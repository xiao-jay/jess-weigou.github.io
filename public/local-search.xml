<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/06/23/k8s/%E5%9C%A8k8s%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85nevida-docker2/"/>
    <url>/2022/06/23/k8s/%E5%9C%A8k8s%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85nevida-docker2/</url>
    
    <content type="html"><![CDATA[<h1 id="在k8s上面安装nevida-docker2"><a href="#在k8s上面安装nevida-docker2" class="headerlink" title="在k8s上面安装nevida-docker2"></a>在k8s上面安装nevida-docker2</h1><pre><code class="hljs awk">sudo yum-config-manager --add-repo=https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>centos/docker-ce.repo</code></pre><pre><code class="hljs awk">curl -s -L https:<span class="hljs-regexp">//</span>nvidia.github.io<span class="hljs-regexp">/nvidia-docker/</span>centos7<span class="hljs-regexp">/x86_64/</span>nvidia-docker.repo | sudo tee <span class="hljs-regexp">/etc/yum</span>.repos.d/nvidia-docker.repo</code></pre><h3 id="0、daemon-json-配置"><a href="#0、daemon-json-配置" class="headerlink" title="0、daemon.json 配置"></a>0、daemon.json 配置</h3><pre><code class="hljs stylus">(base) <span class="hljs-selector-attr">[xinchenTest@master docker]</span>$ cat /etc/docker/daemon<span class="hljs-selector-class">.json</span> &#123;    <span class="hljs-string">&quot;default-runtime&quot;</span>: <span class="hljs-string">&quot;nvidia&quot;</span>,    <span class="hljs-string">&quot;runtimes&quot;</span>: &#123;        <span class="hljs-string">&quot;nvidia&quot;</span>: &#123;            <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;nvidia-container-runtime&quot;</span>,            <span class="hljs-string">&quot;runtimeArgs&quot;</span>: <span class="hljs-selector-attr">[]</span>        &#125;    &#125;,<span class="hljs-string">&quot;exec-opts&quot;</span>: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span>]</span>,<span class="hljs-string">&quot;registry-mirrors&quot;</span>:        <span class="hljs-selector-attr">[<span class="hljs-string">&quot;http://7e61f7f9.m.daocloud.io&quot;</span>]</span>,<span class="hljs-string">&quot;live-restore&quot;</span>: true,<span class="hljs-string">&quot;graph&quot;</span>: <span class="hljs-string">&quot;/data/docker&quot;</span>&#125;</code></pre><p>配置完别忘记</p><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reloadsudo <span class="hljs-params">system</span>ctl restart docker</code></pre><h3 id="1、移除nvidia-docker-1-0"><a href="#1、移除nvidia-docker-1-0" class="headerlink" title="1、移除nvidia-docker 1.0"></a>1、移除nvidia-docker 1.0</h3><pre><code class="hljs powershell">su <span class="hljs-keyword">do</span> docker volume <span class="hljs-built_in">ls</span> <span class="hljs-literal">-q</span> <span class="hljs-operator">-f</span> driver=nvidia<span class="hljs-literal">-docker</span> | xargs <span class="hljs-literal">-r</span> <span class="hljs-literal">-I</span>&#123;&#125; <span class="hljs-literal">-n1</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-q</span> <span class="hljs-literal">-a</span> <span class="hljs-operator">-f</span> volume=&#123;&#125; | xargs <span class="hljs-literal">-r</span> docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span>sudo yum remove nvidia<span class="hljs-literal">-docker</span></code></pre><h3 id="2、安裝nvidia-docker-2-0"><a href="#2、安裝nvidia-docker-2-0" class="headerlink" title="2、安裝nvidia-docker 2.0"></a>2、安裝nvidia-docker 2.0</h3><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> nvidia-docker2</code></pre><h3 id="3、重新載入Docker-daemon的設定"><a href="#3、重新載入Docker-daemon的設定" class="headerlink" title="3、重新載入Docker daemon的設定"></a>3、重新載入Docker daemon的設定</h3><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pkill -SIGHUP dockerd</span></code></pre><h3 id="4、测试是否成功"><a href="#4、测试是否成功" class="headerlink" title="4、测试是否成功"></a>4、测试是否成功</h3><pre><code class="hljs routeros">sudo docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--runtime</span>=nvidia --rm nvidia/cuda:11.1.1-base-centos7 d  nvidia-smi</code></pre><p>5、</p><pre><code class="hljs awk">kubectl create -f https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/NVIDIA/</span>k8s-device-plugin<span class="hljs-regexp">/1.0.0-beta4/</span>nvidia-device-plugin.yml</code></pre><h5 id="Configure-containerd"><a href="#Configure-containerd" class="headerlink" title="Configure containerd"></a>Configure <code>containerd</code></h5><p>When running <code>kubernetes</code> with <code>containerd</code>, edit the config file which is usually present at <code>/etc/containerd/config.toml</code> to set up <code>nvidia-container-runtime</code> as the default low-level runtime:</p><pre><code class="hljs ini"><span class="hljs-attr">version</span> = <span class="hljs-number">2</span><span class="hljs-section">[plugins]</span>  <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</span>      <span class="hljs-attr">default_runtime_name</span> = <span class="hljs-string">&quot;nvidia&quot;</span>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]</span>        <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.nvidia]</span>          <span class="hljs-attr">privileged_without_host_devices</span> = <span class="hljs-literal">false</span>          <span class="hljs-attr">runtime_engine</span> = <span class="hljs-string">&quot;&quot;</span>          <span class="hljs-attr">runtime_root</span> = <span class="hljs-string">&quot;&quot;</span>          <span class="hljs-attr">runtime_type</span> = <span class="hljs-string">&quot;io.containerd.runc.v2&quot;</span>          <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.nvidia.options]</span>            <span class="hljs-attr">BinaryName</span> = <span class="hljs-string">&quot;/usr/bin/nvidia-container-runtime</span></code></pre><p>journalctl -xe</p><pre><code class="hljs go"># 正常来说会输出已经安装过的程序$ rpm -qa | grep nvidia# 正常来说会输出已经安装过的程序$ rpm -qa | grep cuda</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/04/24/k8s/%E5%9C%A8centos%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85k8s/"/>
    <url>/2022/04/24/k8s/%E5%9C%A8centos%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85k8s/</url>
    
    <content type="html"><![CDATA[<h1 id="在centos上面安装k8s"><a href="#在centos上面安装k8s" class="headerlink" title="在centos上面安装k8s"></a>在centos上面安装k8s</h1><p>1、配置镜像源，在centos上面安装k8s</p><p>Kubernetes packages are not available from official CentOS 7 repositories,需要配置yum源</p><pre><code class="hljs awk">cat &lt;&lt;EOF &gt; <span class="hljs-regexp">/etc/yum</span>.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/kubernetes/yum</span><span class="hljs-regexp">/repos/</span>kubernetes-el7-x86_64/enabled=<span class="hljs-number">1</span>gpgcheck=<span class="hljs-number">0</span>EOF<span class="hljs-regexp">//</span> 安装kubeadm，kubectlsudo yum install -y kubelet-<span class="hljs-number">1.21</span>.<span class="hljs-number">0</span>  kubeadm-<span class="hljs-number">1.21</span>.<span class="hljs-number">0</span>  kubectl-<span class="hljs-number">1.21</span>.<span class="hljs-number">0</span>systemctl enable --now kubelet</code></pre><p><strong>ubuntu上面安装</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># 使得 apt 支持 ssl 传输</span>apt-get update &amp;&amp; apt-get install -y apt-transport-https<span class="hljs-comment"># 下载 gpg 密钥   这个需要root用户否则会报错</span>curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - <span class="hljs-comment"># 添加 k8s 镜像源 这个需要root用户否则会报错</span><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><span class="hljs-string">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 更新源列表</span>apt-get update<span class="hljs-comment"># 下载 kubectl，kubeadm以及 kubelet</span>apt-get install -y kubelet kubeadm kubectl</code></pre><p>2、安装docker</p><pre><code class="hljs livescript">sudo yum remove docker <span class="hljs-string">\</span>                  docker-client <span class="hljs-string">\</span>                  docker-client-latest <span class="hljs-string">\</span>                  docker-common <span class="hljs-string">\</span>                  docker-latest <span class="hljs-string">\</span>                  docker-latest-logrotate <span class="hljs-string">\</span>                  docker-logrotate <span class="hljs-string">\</span>                  docker-engine</code></pre><pre><code class="hljs awk">curl -sSL https:<span class="hljs-regexp">//g</span>et.daocloud.io/docker | sh</code></pre><p>配置docker</p><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>docker/daemon.json</code></pre><p>加入：</p><pre><code class="hljs prolog">&#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [    <span class="hljs-string">&quot;https://dockerhub.azk8s.cn&quot;</span>,    <span class="hljs-string">&quot;https://reg-mirror.qiniu.com&quot;</span>,    <span class="hljs-string">&quot;https://quay-mirror.qiniu.com&quot;</span>  ],  <span class="hljs-string">&quot;exec-opts&quot;</span>: [ <span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span> ]&#125;</code></pre><p>然后重启docker</p><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reloadsudo <span class="hljs-params">system</span>ctl restart docker</code></pre><p>3、使用swap会影响性能。kubelet禁用swap</p><pre><code class="hljs awk"> sudo vim <span class="hljs-regexp">/etc/</span>fstab，注释掉swap那一行sudo swapoff -a</code></pre><p>4、下载所需要的镜像</p><pre><code class="hljs awk"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `kubeadm config images list`; <span class="hljs-keyword">do</span>   imageName=<span class="hljs-variable">$&#123;i#k8s.gcr.io/&#125;</span>  docker pull registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span><span class="hljs-variable">$imageName</span>  docker tag registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span><span class="hljs-variable">$imageName</span> k8s.gcr.io/<span class="hljs-variable">$imageName</span>  docker rmi registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span><span class="hljs-variable">$imageName</span>done;</code></pre><p>5、更改kubelet参数(只有centos需要)</p><pre><code class="hljs abnf">sudo vi /etc/sysconfig/kubelet改为如下参数KUBELET_EXTRA_ARGS<span class="hljs-operator">=</span>--cgroup-driver<span class="hljs-operator">=</span>systemd</code></pre><p>6、</p><pre><code class="hljs stylus">sudo kubeadm init <span class="hljs-attr">--image-repository</span>=registry<span class="hljs-selector-class">.aliyuncs</span>.com/google_containers <span class="hljs-attr">--pod-network-cidr</span> <span class="hljs-number">10.244</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span></code></pre><p>如果安装失败，可以使用下面命令重置</p><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo kubeadm reset</span></code></pre><p>然后会得到token 需要保存下来</p><pre><code class="hljs mipsasm">kubeadm <span class="hljs-keyword">join </span><span class="hljs-number">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">203</span>:<span class="hljs-number">6443</span> --token et430p.tuxyjzf2jl8l3nel \        --<span class="hljs-keyword">discovery-token-ca-cert-hash </span><span class="hljs-keyword">sha256:3b6ced67f2eacb0ad575e1dac245a7d0ec9a00bf25e928b722eade805f1e8d18 </span></code></pre><p>安装网络</p><p>kubectl apply -f “<a href="https://docs.projectcalico.org/manifests/calico.yaml&quot;">https://docs.projectcalico.org/manifests/calico.yaml&quot;</a></p><h2 id="Node-节点运行"><a href="#Node-节点运行" class="headerlink" title="Node 节点运行"></a>Node 节点运行</h2><pre><code class="hljs mipsasm">kubeadm <span class="hljs-keyword">join </span><span class="hljs-number">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">203</span>:<span class="hljs-number">6443</span> --token et430p.tuxyjzf2jl8l3nel \        --<span class="hljs-keyword">discovery-token-ca-cert-hash </span><span class="hljs-keyword">sha256:3b6ced67f2eacb0ad575e1dac245a7d0ec9a00bf25e928b722eade805f1e8d18 </span></code></pre><p>这里面有个问题，如果master和node不在一个内网，就访问不到，需要在node节点执行</p><pre><code class="hljs dns">iptables -t nat -<span class="hljs-keyword">A</span> OUTPUT -d <span class="hljs-number">192.168.0.1</span> -j DNAT --to-destination <span class="hljs-number">152.132.125.96</span></code></pre><p>注：第一个ip是master节点的内网ip，后一个ip是外网Ip</p><p>node 节点运行失败怎么卸载</p><pre><code class="hljs awk">rm -rf <span class="hljs-regexp">/etc/</span>kubernetes/</code></pre><h2 id="安装的时候遇到的错误"><a href="#安装的时候遇到的错误" class="headerlink" title="安装的时候遇到的错误"></a>安装的时候遇到的错误</h2><h4 id="1、It-seems-like-the-kubelet-isn‘t-running-or-healthy"><a href="#1、It-seems-like-the-kubelet-isn‘t-running-or-healthy" class="headerlink" title="1、It seems like the kubelet isn‘t running or healthy"></a>1、It seems like the kubelet isn‘t running or healthy</h4><p>查看官网介绍为 docker 和 kubelet 服务中的 cgroup 驱动不一致，有两种方法<br>方式一：驱动向 docker 看齐<br>方式二：驱动为向 kubelet 看齐<br>如果docker 不方便重启则统一向 kubelet看齐，并重启对应的服务即可</p><p><strong>解决方式</strong></p><p>kublete 配置文件<br>grep 截取一下,可以看得出来kubelet默认 cgoup 驱动为systemd</p><pre><code class="hljs gradle">root@controlplane:~# cat <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/kubelet/</span>config.yaml |<span class="hljs-keyword">grep</span> <span class="hljs-keyword">group</span>cgroupDriver: systemd</code></pre><p>重启kubelet （optional）</p><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo systemctl restart kubelet</span></code></pre><h4 id="2、msg-x3D-”getting-status-of-runtime-rpc-error-code-x3D-Unimplemented-desc-x3D-unknown-service-runtime-v1alpha2-RuntimeService”"><a href="#2、msg-x3D-”getting-status-of-runtime-rpc-error-code-x3D-Unimplemented-desc-x3D-unknown-service-runtime-v1alpha2-RuntimeService”" class="headerlink" title="2、msg&#x3D;”getting status of runtime: rpc error: code &#x3D; Unimplemented desc &#x3D; unknown service runtime.v1alpha2.RuntimeService”"></a>2、msg&#x3D;”getting status of runtime: rpc error: code &#x3D; Unimplemented desc &#x3D; unknown service runtime.v1alpha2.RuntimeService”</h4><p>解决方法:</p><pre><code class="hljs awk">rm <span class="hljs-regexp">/etc/</span>containerd/config.tomlsudo systemctl restart containerdrm -fr  <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.kube/</span>config</code></pre><h4 id="3、–apiserver-advertise-address-更改后的地址"><a href="#3、–apiserver-advertise-address-更改后的地址" class="headerlink" title="3、–apiserver-advertise-address  更改后的地址"></a>3、–apiserver-advertise-address  更改后的地址</h4><pre><code class="hljs routeros">sudo kubeadm init \<span class="hljs-attribute">--apiserver-advertise-address</span>=10.0.1.162 \--image-repository registry.aliyuncs.com/google_containers \<span class="hljs-attribute">--kubernetes-version</span>=v1.24.2 \<span class="hljs-attribute">--pod-network-cidr</span>=10.244.0.0/16 \<span class="hljs-attribute">--service-cidr</span>=10.96.0.0/12</code></pre><p>docker 配置</p><pre><code class="hljs prolog">&#123;    <span class="hljs-string">&quot;runtimes&quot;</span>: &#123;        <span class="hljs-string">&quot;nvidia&quot;</span>: &#123;            <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;nvidia-container-runtime&quot;</span>,            <span class="hljs-string">&quot;runtimeArgs&quot;</span>: []        &#125;    &#125;,    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://m3719grz.mirror.aliyuncs.com&quot;</span>]&#125;</code></pre><h4 id="4、kubelet-出现找不到Error-getting-node”-err-x3D-”node-quot-master-quot-not-found"><a href="#4、kubelet-出现找不到Error-getting-node”-err-x3D-”node-quot-master-quot-not-found" class="headerlink" title="4、kubelet 出现找不到Error getting node” err&#x3D;”node &quot;master&quot; not found"></a>4、kubelet 出现找不到Error getting node” err&#x3D;”node &quot;master&quot; not found</h4><p>执行 crictl images 发现 pause 的 TAG 是 3.5 没有 3.2，随即执行重新拉起镜像：</p><pre><code class="hljs gradle">[root@k8s-master ~]# crictl imagesIMAGE                                                             TAG                 IMAGE ID            <span class="hljs-keyword">SIZE</span>registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>coredns                   v1.<span class="hljs-number">8.4</span>              <span class="hljs-number">8</span>d147537fb7d1       <span class="hljs-number">13.7</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>coredns                   latest              <span class="hljs-number">8</span>d147537fb7d1       <span class="hljs-number">13.7</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>etcd                      <span class="hljs-number">3.5</span>.<span class="hljs-number">0</span>-<span class="hljs-number">0</span>             <span class="hljs-number">0048118155842</span>       <span class="hljs-number">99.9</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-apiserver            v1.<span class="hljs-number">22.1</span>             f30469a2491a5       <span class="hljs-number">31.3</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-controller-manager   v1.<span class="hljs-number">22.1</span>             <span class="hljs-number">6</span>e002eb89a881       <span class="hljs-number">29.8</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-proxy                v1.<span class="hljs-number">22.1</span>             <span class="hljs-number">36</span>c4ebbc9d979       <span class="hljs-number">35.9</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-scheduler            v1.<span class="hljs-number">22.1</span>             aca5ededae9c8       <span class="hljs-number">15</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>pause                     <span class="hljs-number">3.5</span>                 ed210e3e4a5ba       <span class="hljs-number">301</span>kB[root@k8s-master ~]# crictl pull registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>pause:<span class="hljs-number">3.2</span>Image is up to date <span class="hljs-keyword">for</span> sha256:<span class="hljs-number">80</span>d28bedfe5dec59da9ebf8e6260224ac9008ab5c11dbbe16ee3ba3e4439ac2c[root@k8s-master ~]# ctr -n k8s.io i tag --force registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>pause:<span class="hljs-number">3.2</span> k8s.gcr.io/pause:<span class="hljs-number">3.2</span>k8s.gcr.io/pause:<span class="hljs-number">3.2</span>[root@k8s-master ~]# crictl imagesIMAGE                                                             TAG                 IMAGE ID            <span class="hljs-keyword">SIZE</span>registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>coredns                   v1.<span class="hljs-number">8.4</span>              <span class="hljs-number">8</span>d147537fb7d1       <span class="hljs-number">13.7</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>coredns                   latest              <span class="hljs-number">8</span>d147537fb7d1       <span class="hljs-number">13.7</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>etcd                      <span class="hljs-number">3.5</span>.<span class="hljs-number">0</span>-<span class="hljs-number">0</span>             <span class="hljs-number">0048118155842</span>       <span class="hljs-number">99.9</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-apiserver            v1.<span class="hljs-number">22.1</span>             f30469a2491a5       <span class="hljs-number">31.3</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-controller-manager   v1.<span class="hljs-number">22.1</span>             <span class="hljs-number">6</span>e002eb89a881       <span class="hljs-number">29.8</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-proxy                v1.<span class="hljs-number">22.1</span>             <span class="hljs-number">36</span>c4ebbc9d979       <span class="hljs-number">35.9</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-scheduler            v1.<span class="hljs-number">22.1</span>             aca5ededae9c8       <span class="hljs-number">15</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>pause                     <span class="hljs-number">3.2</span>                 <span class="hljs-number">80</span>d28bedfe5de       <span class="hljs-number">300</span>kBk8s.gcr.io/pause                                                  <span class="hljs-number">3.2</span>                 <span class="hljs-number">80</span>d28bedfe5de       <span class="hljs-number">300</span>kBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>pause</code></pre><p>执行kubeadm reset和init就好了</p><h4 id="5、在部署时忘记了token密码怎么办？"><a href="#5、在部署时忘记了token密码怎么办？" class="headerlink" title="5、在部署时忘记了token密码怎么办？"></a>5、在部署时忘记了token密码怎么办？</h4><p>首先，在每个节点上 执行 kubeadm reset命令即可，重新获取token（需要重新安装flanner网络组件）<br>关于如何重置k8s集群可以参考：重置kubernetes集群</p><p>1.重新生成新的token<br>默认token的有效期为24小时，当过期之后，该token就不可用了，在master节点上执行 kubeadm token create</p><pre><code class="hljs gauss">$ kubeadm <span class="hljs-built_in">token</span> <span class="hljs-keyword">create</span>c9afga.w3fue0yh3gzxczic</code></pre><p>查看token</p><pre><code class="hljs gauss">$ kubeadm <span class="hljs-built_in">token</span> list<span class="hljs-built_in">TOKEN</span>                     TTL       EXPIRES                     USAGES                   DESCRIPTION   EXTRA GROUPSc9afga.w3fue0yh3gzxczic   <span class="hljs-number">23</span>h       <span class="hljs-number">2019</span><span class="hljs-number">-07</span><span class="hljs-number">-26</span>T14:<span class="hljs-number">30</span>:<span class="hljs-number">54</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>   authentication,signing   &lt;none&gt;        <span class="hljs-keyword">system</span>:bootstrappers:kubeadm:default-node-<span class="hljs-built_in">token</span></code></pre><p>2.获取ca证书sha256编码hash值</p><pre><code class="hljs gradle">$ openssl x509 -pubkey -in <span class="hljs-regexp">/etc/</span>kubernetes<span class="hljs-regexp">/pki/</span>ca.crt | openssl rsa -pubin -outform der <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span> | openssl dgst -sha256 -hex | sed <span class="hljs-string">&#x27;s/^.* //&#x27;</span><span class="hljs-number">8</span>b79b6461e58c07333cb2851fe74fd4374af8bbbe0bf7e040b415b86ad4fb89d</code></pre><p>3.节点加入集群<br>先清理环境，然后再kubeadm join （Node节点上执行）</p><pre><code class="hljs pgsql">sudo kubeadm <span class="hljs-keyword">reset</span>sudo iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -Xsudo sysctl net.bridge.bridge-nf-<span class="hljs-keyword">call</span>-iptables=<span class="hljs-number">1</span>sudo bash -c <span class="hljs-string">&#x27;echo 1 &gt; /proc/sys/net/ipv4/ip_forward&#x27;</span>sudo kubeadm <span class="hljs-keyword">join</span> <span class="hljs-number">10.0</span><span class="hljs-number">.1</span><span class="hljs-number">.162</span>:<span class="hljs-number">6443</span>  <span class="hljs-comment">--token 9kpu6t.e1jf89l5uzminfo2 \</span> <span class="hljs-comment">--discovery-token-ca-cert-hash sha256:3010d593b0b7d699ae53ae7b8939b2dc4169f5ff065650a8da18b4c959ac242a --node-name node1</span></code></pre><h4 id="6、镜像拉不下来怎么办"><a href="#6、镜像拉不下来怎么办" class="headerlink" title="6、镜像拉不下来怎么办"></a>6、镜像拉不下来怎么办</h4><p>先在镜像网站下载下来然后把docker镜像tag修改了</p><h4 id="7、swap没有关闭，防火墙没有关闭"><a href="#7、swap没有关闭，防火墙没有关闭" class="headerlink" title="7、swap没有关闭，防火墙没有关闭"></a>7、swap没有关闭，防火墙没有关闭</h4><p>会导致kubelet会有问题</p><h4 id="8、1-25-0版本的k8s拉不下来网络的镜像，导致node是notready"><a href="#8、1-25-0版本的k8s拉不下来网络的镜像，导致node是notready" class="headerlink" title="8、1.25.0版本的k8s拉不下来网络的镜像，导致node是notready"></a>8、1.25.0版本的k8s拉不下来网络的镜像，导致node是notready</h4><p>docker拉下来改tag也没用，降低版本1.21就好了</p><h4 id="9、pod-状态是evicted"><a href="#9、pod-状态是evicted" class="headerlink" title="9、pod 状态是evicted"></a>9、pod 状态是evicted</h4><p>没有gpu资源然后被驱逐了</p><p>10、k8s calico 插件错误：Number of node(s) with BGP peering established &#x3D; 0 calico&#x2F;node is not ready: BIRD is</p><p><a href="https://blog.csdn.net/baobaoxiannv/article/details/113119528">https://blog.csdn.net/baobaoxiannv/article/details/113119528</a></p><h4 id="10、describe-pod-发现network-error-getting-ClusterInformation-connection-is-unauthorized"><a href="#10、describe-pod-发现network-error-getting-ClusterInformation-connection-is-unauthorized" class="headerlink" title="10、describe pod 发现network: error getting ClusterInformation: connection is unauthorized:"></a>10、describe pod 发现network: error getting ClusterInformation: connection is unauthorized:</h4><p>除了执行这个命令</p><p><code>kubectl delete -f  &lt;yaml&gt;</code></p><p>    还要去&#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;目录下 删掉与calico相关的所有配置文件, 然后重启机器。 不然pod起不来，会报错 network: error getting ClusterInformation: connection is unauthorized: Unauthorized . 在这里发现的解决办法：source</p><h4 id="11、要关闭防火墙，或者开启特定端口，不能防火墙是failed状态"><a href="#11、要关闭防火墙，或者开启特定端口，不能防火墙是failed状态" class="headerlink" title="11、要关闭防火墙，或者开启特定端口，不能防火墙是failed状态"></a>11、要关闭防火墙，或者开启特定端口，不能防火墙是failed状态</h4><h4 id="12、node节点有taint-kubectl-taint-，node-kubernetes-io-x2F-disk-pressure-NoSchedule"><a href="#12、node节点有taint-kubectl-taint-，node-kubernetes-io-x2F-disk-pressure-NoSchedule" class="headerlink" title="12、node节点有taint kubectl taint ，node.kubernetes.io&#x2F;disk-pressure:NoSchedule-"></a>12、node节点有taint kubectl taint ，node.kubernetes.io&#x2F;disk-pressure:NoSchedule-</h4><pre><code class="hljs crmsh">kubectl taint <span class="hljs-keyword">node</span> <span class="hljs-title">node1</span>  node.kubernetes.io/disk-pressure:NoSchedule-</code></pre><p>node节点因为磁盘不够导致有污点上面的任务都被驱逐</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">cuda-vector-add</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>  <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cuda-vector-add</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;k8s.gcr.io/cuda-vector-add:v0.1&quot;</span>      <span class="hljs-attr">resources:</span>        <span class="hljs-attr">limits:</span>          <span class="hljs-attr">nvidia.com/gpu:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># requesting 1 GPU</span></code></pre><p>13、安装docker-compose</p><pre><code class="hljs awk">sudo bash -c <span class="hljs-string">&#x27;curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose&#x27;</span>sudo chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-composesudo ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose <span class="hljs-regexp">/usr/</span>bin/docker-composedocker-compose --version</code></pre><p>14、harbor登陆不上去</p><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/docker.service</code></pre><pre><code class="hljs routeros"><span class="hljs-attribute">ExecStart</span>=/usr/bin/dockerd  <span class="hljs-attribute">--insecure-registry</span>=10.28.0.55:80</code></pre><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reloadsudo <span class="hljs-params">system</span>ctl restart docker</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/04/22/k8s/KubeDL%20%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2022/04/22/k8s/KubeDL%20%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="KubeDL-项目问题"><a href="#KubeDL-项目问题" class="headerlink" title="KubeDL 项目问题"></a>KubeDL 项目问题</h1><p>项目负责人你好，我叫应宇杰，来自杭州电子科技大学，是计科大三，无k8s基础，有一定docker使用经验。想参与2022年开源之夏的KubeDL项目，原因有二：</p><ul><li><p>我想参加开源之夏kubeDL项目，深入参与一次开源社区的开发，提高自己的能力</p></li><li><p>我在一个人工智能小公司实习，公司有一定的机器数量我想使用这个项目来提高公司的机器资源利用率（这个只是我想做的，公司还没和他们商量）。</p></li></ul><p>在尝试看文档使用本机<strong>mac m1</strong>复现quick start，但是遇到了一些困难，提了issue没人理，又不知道该找谁</p><h5 id="1、使用这个项目需要什么前置知识吗，举个例子：需要了解k8s内部service的调度"><a href="#1、使用这个项目需要什么前置知识吗，举个例子：需要了解k8s内部service的调度" class="headerlink" title="1、使用这个项目需要什么前置知识吗，举个例子：需要了解k8s内部service的调度"></a>1、使用这个项目需要什么前置知识吗，举个例子：需要了解k8s内部service的调度</h5><h5 id="2、在quict-start的时候，发现运行"><a href="#2、在quict-start的时候，发现运行" class="headerlink" title="2、在quict start的时候，发现运行"></a>2、在quict start的时候，发现运行</h5><p>（1）、<code>helm install kubedl ./helm/kubedl --create-namespace -n kubedl-system</code></p><p>会报错   <code>Error: INSTALLATION FAILED: path &quot;./helm/kubedl&quot; not found</code></p><p>（2）、运行 <code>kubectl apply -f https://raw.githubusercontent.com/kubedl-io/kubedl/master/example/tf/tf_job_mnist_distributed_simple.yaml</code></p><p>先是开了梯子也拉不下来，我就下载到本地，然后运行会报错</p><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>unable to recognize &quot;tf_job_mnist_distributed_simple.yaml&quot;: no matches for kind &quot;TFJob&quot; in version &quot;training.kubedl.io/v1alpha1&quot;</code></pre><p>发现这个项目无从下手，很难入门写个demo，请问能在快速开始这方面指导一下吗</p><h5 id="3、想请问一下今年开源之夏会有什么题目，想快点入门（有点心急），然后可以参与进来"><a href="#3、想请问一下今年开源之夏会有什么题目，想快点入门（有点心急），然后可以参与进来" class="headerlink" title="3、想请问一下今年开源之夏会有什么题目，想快点入门（有点心急），然后可以参与进来"></a>3、想请问一下今年开源之夏会有什么题目，想快点入门（有点心急），然后可以参与进来</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>美团后台开发工程师一面</title>
    <link href="/2022/03/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%9D%A2%E7%AD%8B/%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/2022/03/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%9D%A2%E7%AD%8B/%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<p>这次面试官语言问的特别少，数据结构操作系统问的特别多，不同面试官有不同偏好吧，面试体验好，第一次说的不好他会引导你说出他想要知道的信息。</p><p><strong>1、自我介绍</strong></p><p><strong>2、为什么想来实习</strong>。 实习是就业的一个适应期，不想考研</p><p><strong>3、项目问题，介绍一下项目的背景，功能，和面向的人群，为什么要做这个项目</strong>（为了改进项目，节省硬件资源，提高用户体验）</p><p><strong>4、讲一下你在项目里面遇到的最大难题</strong>，（Mysql性能调优，项目结构的改良，将一个功能拆分成很多函数，对外提供一个执行的接口，在接口功能里面把一个个函数都写在里面，如果一个函数执行有错误就立马返回，能快速定位错误和符合开放封闭原则）</p><p><strong>5、Java学的多吗</strong>，只有上课学学的java</p><p><strong>6、c语言和golang语言的区别</strong></p><p><strong>7、了解编译型语言和解释型语言吗</strong>，不知道</p><p><strong>8、操作系统中A函数中执行B函数，讲一下这个栈内存中发生的事情</strong></p><p><strong>9、进程和线程的区别</strong></p><p><strong>10、进程间的通信是怎么做到的，线程间的通信是怎么做到的</strong>，进程是共享内存，管道，信号量，线程是共享进程的内存进行通信</p><p><strong>11、讲一下进程并发的概念</strong></p><p><strong>12、时间片的管理和调度算法</strong></p><p><strong>13、讲一下对虚拟内存的理解，作用是什么</strong></p><p><strong>14、讲一下有哪些数据结构</strong></p><p><strong>15、链表，和数组的区别和优点和缺点，增删改查的角度来说</strong></p><p><strong>16、为什么要有二叉树这个数据结构，发明出来是用在哪边的</strong></p><p><strong>17、有了平衡二叉树为什么还要有红黑树</strong></p><p><strong>18、hashmap听说过吗，能讲一下吗，讲一下他有什么用处</strong>，面试官说hash数很大怎么和槽位对应起来，我说如果槽位16是hash数和15&amp;一下 ，面试官说是%16，感觉作用一样</p><p><strong>19、mysql事务介绍一下</strong>，acid和数据库的隔离级别讲了一下，然后随便说了一下面试官就说差不多了，时间差不多了。</p><p>20、反问：问了美团的业务和职业规划之类的，问了面试官是干什么的</p><p>问的东西感觉偏基础而且很广，一部分靠日常积累。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动朝花夕拾服务器后端一面</title>
    <link href="/2022/03/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%9D%A2%E7%AD%8B/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2/"/>
    <url>/2022/03/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%9D%A2%E7%AD%8B/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>估计做服务器端需要c++，问了我c++虚函数是什么，c++11知道吗，c++我屁也没学，只有做算法题需要用，说不会，哎</p><p><strong>1、java的三大特性：继承、封装、多态，解释一下</strong></p><p><strong>2、c++有了解吗</strong> 只用算法的时候做过</p><p><strong>3、c++ 虚函数是什么</strong>，不知道</p><p><strong>4、讲一下对golang 里面interface的理解</strong></p><p><strong>5、c++，java、python、golang里面接口的相同点和不同点</strong></p><p><strong>6、golang里面 defer的是什么，作用是什么</strong>  使open和close代码放在一起防止忘记，捕获异常和崩溃日志。</p><p><strong>7、讲一下进程，线程，协程，和在golang里面的体现</strong></p><p><strong>8、讲一下对c++，python，java，golang的理解，python为什么运行慢？</strong>不知道，呜呜呜</p><p><strong>9、智力题，一个二维平面，在上面两个线段，怎么判断两个线段相不相交</strong></p><p><strong>10、25张红色扑克牌，25张黑色扑克牌，上面取一张，下面取一张，取得两张卡片颜色相等的概率。</strong></p><p><strong>11、项目里面使用amazon的lambda函数是什么东西，能讲一下吗</strong></p><p><strong>12、mysql底层用什么数据结构</strong>， b+树</p><p>算法题：leetcode：150. 逆波兰表达式求值</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/16/swift%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/16/swift%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1、ios模拟器的位置</p><p>&#x2F;Users&#x2F;jie&#x2F;Library&#x2F;Developer&#x2F;CoreSimulator&#x2F;Devices</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mac配置flutter问题合集</title>
    <link href="/2022/02/08/mac%E9%85%8D%E7%BD%AEflutter%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <url>/2022/02/08/mac%E9%85%8D%E7%BD%AEflutter%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h4 id="1、-x2F-Users-x2F-jie-x2F-Desktop-x2F-flutter-x2F-lemon-flutter-app-x2F-ios-x2F-Pods-x2F-Pods-xcodeproj-warning-The-iOS-Simulator-deployment-target-‘IPHONEOS-DEPLOYMENT-TARGET’-is-set-to-8-0-but-the-range-of-supported-deployment-target-versions-is-9-0-to-15-2-99-in-target-‘Toast’-from-project-‘Pods’"><a href="#1、-x2F-Users-x2F-jie-x2F-Desktop-x2F-flutter-x2F-lemon-flutter-app-x2F-ios-x2F-Pods-x2F-Pods-xcodeproj-warning-The-iOS-Simulator-deployment-target-‘IPHONEOS-DEPLOYMENT-TARGET’-is-set-to-8-0-but-the-range-of-supported-deployment-target-versions-is-9-0-to-15-2-99-in-target-‘Toast’-from-project-‘Pods’" class="headerlink" title="1、&#x2F;Users&#x2F;jie&#x2F;Desktop&#x2F;flutter&#x2F;lemon_flutter_app&#x2F;ios&#x2F;Pods&#x2F;Pods.xcodeproj: warning: The iOS Simulator deployment target ‘IPHONEOS_DEPLOYMENT_TARGET’ is set to 8.0, but the range of supported deployment target versions is 9.0 to 15.2.99. (in target ‘Toast’ from project ‘Pods’)"></a>1、&#x2F;Users&#x2F;jie&#x2F;Desktop&#x2F;flutter&#x2F;lemon_flutter_app&#x2F;ios&#x2F;Pods&#x2F;Pods.xcodeproj: warning: The iOS Simulator deployment target ‘IPHONEOS_DEPLOYMENT_TARGET’ is set to 8.0, but the range of supported deployment target versions is 9.0 to 15.2.99. (in target ‘Toast’ from project ‘Pods’)</h4><pre><code class="hljs awk">cd ios sudo rm -rf ~<span class="hljs-regexp">/Library/</span>Caches/CocoaPods   rm -rf Podfile.lock rm -rf Pods      rm -rf ~<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/Xcode/</span>DerivedData/*pod deintegrate  pod setup  pod install</code></pre><p>2、Failed to package &#x2F;Users&#x2F;jie&#x2F;Desktop&#x2F;flutter&#x2F;lemon_flutter_app&#x2F;ios&#x2F;…</p><p>Command PhaseScriptExecution failed with a nonzero exit code</p><pre><code class="hljs bash"><span class="hljs-string">&quot;<span class="hljs-variable">$FLUTTER_ROOT</span>/packages/flutter_tools/bin/xcode_backend.sh&quot;</span> build<span class="hljs-string">&quot;<span class="hljs-variable">$FLUTTER_ROOT</span>/packages/flutter_tools/bin/xcode_backend.sh&quot;</span> embed</code></pre><p>3、zsh: command not found: flatter</p><pre><code class="hljs stylus">vim ~/<span class="hljs-selector-class">.zshrc</span><span class="hljs-comment">// 在最后一行添加</span>source ~/<span class="hljs-selector-class">.zshrc</span><span class="hljs-selector-class">.pre-oh-my-zsh</span>source ~/<span class="hljs-selector-class">.bath_profile</span><span class="hljs-comment">// wq 保存退出重新打开终端即可</span></code></pre><p>4、rsync: link_stat “&#x2F;Users&#x2F;jie&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Runner-bujxbaguzpyukvbumfgytsffnqlc&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;App.framework” failed: No such file or directory (2)</p><p>&#x2F;bin&#x2F;sh “&#x2F;Users&#x2F;jie&#x2F;sdk&#x2F;flutter&#x2F;packages&#x2F;flutter_tools&#x2F;bin&#x2F;xcode_backend.sh” embed_and_thin</p><p>5、ARC Semantic Issue (Xcode): No known class method for selector ‘updatePrivacyShow:privacyInfo:’&#x2F;Users&#x2F;jie&#x2F;sdk&#x2F;flutter&#x2F;.pubcache&#x2F;hosted&#x2F;pub.dartlang.org&#x2F;amap_flutter_location3.0.0&#x2F;ios&#x2F;Classes&#x2F;AMapFlutterLocationPlugin.m:92:29</p><pre><code class="hljs awk">cd ios sudo rm -rf ~<span class="hljs-regexp">/Library/</span>Caches/CocoaPods   rm -rf Podfile.lock rm -rf Pods      rm -rf ~<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/Xcode/</span>DerivedData/*pod deintegrate  pod setup  pod install</code></pre><p>6、Could not find module ‘WebView’ for target ‘x86_64-apple-ios-simulator’; found: arm64, arm64-apple-ios-simulator, at: &#x2F;Users&#x2F;jie&#x2F;Lib</p><p>在execuded archs 加入 x86_64</p><p>7、Error (Xcode): Framework not found tencent_kit</p><p>重新clone 项目</p><p>8、 line 132: ARCHS[@]: unbound variable</p><p>去掉用vscode打开 runner.xcodeproj  里面的EXCLUDED_ARCHS,VALID_ARCHS</p><p>9、Target Integrity (Xcode): The linked framework ‘Pods_Runner.framework’ is missing one or more architectures required by this target: arm64.</p><p>Runner-&gt;target-&gt;EXCLUDED_ARCHS-&gt;any ios simulate add arm64</p><p>10、Parse Issue (Xcode): Module ‘amap_flutter_location’ not found<br>&#x2F;Users&#x2F;jie&#x2F;Desktop&#x2F;flutter&#x2F;lemon_flutter_app&#x2F;ios&#x2F;Runner&#x2F;GeneratedPluginRegistrant.m:11:8</p><p>Encountered error while building for device.</p><p>把Xode 里面的Runner的ios版本改成高版本</p><p>11、TMS-90683: Missing Purpose String in Info.plist. Your app’s code references one or more APIs that access sensitive user data. The app’s Info.plist file should contain a NSCameraUsageDescription key with a user-facing purpose string explaining clearly and completely why your app needs the data. Starting Spring 2019, all apps submitted to the App Store that access user data are required to include a purpose string. If you’re using external libraries or SDKs, they may reference APIs that require a purpose string. While your app might not use these APIs, a purpose string is still required. You can contact the developer of the library or SDK and request they release a version of their code that doesn’t contain the APIs. Learn more (<a href="https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy">https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy</a>).</p><p>在info.plist文件里面加入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>NSCameraUsageDescription<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>照片权限<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>NSPhotoLibraryUsageDescriptionn<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>相机权限<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></code></pre><p>12、ios真机调试无法打开“iproxy”，因为无法验证开发者。</p>]]></content>
    
    
    <categories>
      
      <category>flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万万没想到之聪明的编辑</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E8%81%AA%E6%98%8E%E7%9A%84%E7%BC%96%E8%BE%91/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E8%81%AA%E6%98%8E%E7%9A%84%E7%BC%96%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h3 id="万万没想到之聪明的编辑"><a href="#万万没想到之聪明的编辑" class="headerlink" title="万万没想到之聪明的编辑"></a><font size=6px>万万没想到之聪明的编辑</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径：</p><p>\1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -&gt; hello</p><p>\2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -&gt; hello</p><p>\3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC</p><p>我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！</p><p>……</p><p>万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的……</p><p>请听题：请实现大锤的自动校对程序</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><pre><code class="hljs excel">第一行包括一个数字<span class="hljs-built_in">N</span>，表示本次用例包括多少个待校验的字符串。后面跟随<span class="hljs-built_in">N</span>行，每行为一个待校验的字符串。</code></pre><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><pre><code class="hljs excel"><span class="hljs-built_in">N</span>行，每行包括一个被修复后的字符串。</code></pre><h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><pre><code class="hljs">2helloowooooooow</code></pre><h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><pre><code class="hljs ebnf"><span class="hljs-attribute">hello</span><span class="hljs-attribute">woow</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>简单题，无思路</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span>fmt.Scan(&amp;n)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;fmt.Scan(&amp;str)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(str) &lt; <span class="hljs-number">3</span> &#123;fmt.Println(str)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(check(str))&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;correctStr := []<span class="hljs-type">byte</span>&#123;&#125;correctStr = <span class="hljs-built_in">append</span>(correctStr, <span class="hljs-type">byte</span>(str[<span class="hljs-number">0</span>]), <span class="hljs-type">byte</span>(str[<span class="hljs-number">1</span>]))k := <span class="hljs-number">2</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> || k == <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">if</span> correctStr[k<span class="hljs-number">-1</span>] == str[i] &amp;&amp; correctStr[k<span class="hljs-number">-1</span>] == correctStr[k<span class="hljs-number">-2</span>] &#123;<span class="hljs-keyword">continue</span>&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> correctStr[k<span class="hljs-number">-1</span>] == str[i] &amp;&amp; correctStr[k<span class="hljs-number">-1</span>] == correctStr[k<span class="hljs-number">-2</span>] &#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">if</span> correctStr[k<span class="hljs-number">-3</span>] == correctStr[k<span class="hljs-number">-2</span>] &amp;&amp; correctStr[k<span class="hljs-number">-1</span>] == str[i] &#123;<span class="hljs-keyword">continue</span>&#125;&#125;correctStr = <span class="hljs-built_in">append</span>(correctStr, <span class="hljs-type">byte</span>(str[i]))k++&#125;<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(correctStr)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：5ms, 超过62.59%用Go提交的代码<br>  占用内存：1048KB, 超过21.33%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>头条校招</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%A4%B4%E6%9D%A1%E6%A0%A1%E6%8B%9B/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%A4%B4%E6%9D%A1%E6%A0%A1%E6%8B%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="头条校招"><a href="#头条校招" class="headerlink" title="头条校招"></a><font size=6px>头条校招</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队，每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来，在选题之前，我们对题目进行了盲审，并定出了每道题的难度系统。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件：<br>a&lt;&#x3D;b&lt;&#x3D;c<br>b-a&lt;&#x3D;10<br>c-b&lt;&#x3D;10<br>所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs armasm">输入的第一行包含一个整数n，表示目前已经出好的题目数量。第二行给出每道题目的难度系数<span class="hljs-built_in">d1</span>,<span class="hljs-built_in">d2</span>,...,<span class="hljs-meta">dn</span>。 数据范围对于<span class="hljs-number">30</span>%的数据，<span class="hljs-number">1</span> ≤ n,di ≤ <span class="hljs-number">5</span><span class="hljs-comment">;</span>对于<span class="hljs-number">100</span>%的数据，<span class="hljs-number">1</span> ≤ n ≤ <span class="hljs-number">10</span>^<span class="hljs-number">5</span>,<span class="hljs-number">1</span> ≤ di ≤ <span class="hljs-number">100</span>。在样例中，一种可行的方案是添加<span class="hljs-number">2</span>个难度分别为<span class="hljs-number">20</span>和<span class="hljs-number">50</span>的题目，这样可以组合成两场考试：（<span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">23</span>）和（<span class="hljs-number">35</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>）。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">输出只包括一行，即所求的答案。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span> <span class="hljs-symbol">20 </span><span class="hljs-number">35</span> <span class="hljs-number">23</span> <span class="hljs-number">40</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">2</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先找三个的，再找两个的，最后输出只有单独一个的*2+两个的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sort&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n,a,sum1,sum2  <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    flag := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scan(&amp;a)        num[i] = a    &#125;    sort.Ints(num)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;n;i++&#123;        <span class="hljs-comment">//找到三个数的</span>        <span class="hljs-keyword">if</span> flag[i<span class="hljs-number">-2</span>]==<span class="hljs-number">0</span>&amp;&amp;flag[i<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;flag[i]==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> num[i]-num[i<span class="hljs-number">-1</span>]&lt;=<span class="hljs-number">10</span>&amp;&amp;num[i<span class="hljs-number">-1</span>]-num[i<span class="hljs-number">-2</span>]&lt;=<span class="hljs-number">10</span>&#123;                flag[i],flag[i<span class="hljs-number">-1</span>],flag[i<span class="hljs-number">-2</span>] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>                sum1++            &#125;        &#125;    &#125;    <span class="hljs-comment">//找到两个数的</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> flag[i<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;flag[i]==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> num[i]-num[i<span class="hljs-number">-1</span>]&lt;=<span class="hljs-number">10</span>&#123;                flag[i],flag[i<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span>                sum2++            &#125;        &#125;    &#125;    fmt.Println(sum2+<span class="hljs-number">2</span>*(n<span class="hljs-number">-3</span>*sum1<span class="hljs-number">-2</span>*sum2))    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字母交换</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E6%AF%8D%E4%BA%A4%E6%8D%A2/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E6%AF%8D%E4%BA%A4%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="字母交换"><a href="#字母交换" class="headerlink" title="字母交换"></a><font size=6px>字母交换</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>【编码题】字符串S由小写字母构成，长度为n。定义一种操作，每次都可以挑选字符串中任意的两个相邻字母进行交换。询问在至多交换m次之后，字符串中最多有多少个连续的位置上的字母相同？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs coq">第一行为一个字符串S与一个非负整数m。(<span class="hljs-number">1</span> &lt;= |<span class="hljs-type">S</span>| <span class="hljs-type">&lt;= 1000</span>, <span class="hljs-number">1</span> &lt;= m &lt;= <span class="hljs-number">1000000</span>)</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">一个非负整数，表示操作之后，连续最长的相同字母数量。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs apache"><span class="hljs-attribute">abcbaa</span> <span class="hljs-number">2</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">2</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs css">使<span class="hljs-number">2</span>个字母<span class="hljs-selector-tag">a</span>连续出现，至少需要<span class="hljs-number">3</span>次操作。即把第<span class="hljs-number">1</span>个位w置上的<span class="hljs-selector-tag">a</span>移动到第<span class="hljs-number">4</span>个位置。所以在至多操作<span class="hljs-number">2</span>次的情况下，最多只能使<span class="hljs-number">2</span>个<span class="hljs-selector-tag">b</span>或<span class="hljs-number">2</span>个<span class="hljs-selector-tag">a</span>连续出现。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划递推公式 dp【i】[j]&#x3D;  dp【i+1】【j-1】 + a[j]-a[i] -(j-i);,计算时只算上三角情况，每个字母单独计算，递归公式看懂就会做了。第一轮计算相邻相同字母的相邻距离，第二轮计算相差两个位置的字母靠近需要多少距离</p><p>上三角举例</p><p>0111</p><p>0011</p><p>0001</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;#include&lt;stdlib.h&gt;<span class="hljs-type">int</span> max(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-type">int</span> main()&#123;    char s[<span class="hljs-number">10001</span>];    <span class="hljs-type">int</span> m,max_seq;    scanf(<span class="hljs-string">&quot;%s%d&quot;</span>,s,&amp;m);    <span class="hljs-type">int</span> size_s = strlen(s);    <span class="hljs-keyword">for</span>(char c =<span class="hljs-string">&#x27;a&#x27;</span>;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span> ; c++)&#123;        <span class="hljs-type">int</span> *a = (<span class="hljs-type">int</span> *)malloc(sizeof(<span class="hljs-type">int</span>)*<span class="hljs-number">10002</span>);        <span class="hljs-type">int</span> size =<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size_s;i++)&#123;            <span class="hljs-comment">//把相同字符的位置求出来</span>            <span class="hljs-keyword">if</span>(s[i] ==c) a[size++] = i;        &#125;        <span class="hljs-keyword">if</span>(size)&#123;            <span class="hljs-type">int</span> dp[<span class="hljs-number">1002</span>][<span class="hljs-number">1001</span>];            memset(dp,<span class="hljs-number">0</span>,sizeof(dp));            <span class="hljs-type">int</span> seq = <span class="hljs-number">1</span>;            <span class="hljs-comment">//只计算上三角情况</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>;r&lt;size;r++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size-r;i++)&#123;                    <span class="hljs-type">int</span> j = i+r;                    <span class="hljs-comment">// 在第一轮的情况下</span>                    <span class="hljs-keyword">if</span>(j==i+<span class="hljs-number">1</span>)&#123;                        dp[i][j] = a[j]-a[i]<span class="hljs-number">-1</span>;                    &#125;<span class="hljs-keyword">else</span>&#123;                        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + a[j]-a[i] -(j-i);                    &#125;                    <span class="hljs-keyword">if</span>(dp[i][j]&lt;=m)                        seq = max(seq,j-i+<span class="hljs-number">1</span>);                &#125;            &#125;            max_seq = max(max_seq,seq);        &#125;    &#125;    printf(<span class="hljs-string">&quot;%d\n&quot;</span>,max_seq);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：11ms, 超过57.14%用C提交的代码<br>   占用内存：4348KB, 超过40.00%用C提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可转换最长子串</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%8F%AF%E8%BD%AC%E6%8D%A2%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%8F%AF%E8%BD%AC%E6%8D%A2%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="可转换最长子串"><a href="#可转换最长子串" class="headerlink" title="可转换最长子串"></a><font size=6px>可转换最长子串</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个仅包含’a’和’b’两种字符的字符串s，长度为n，每次操作可以把一个字符做一次转换（把一个’a’设置为’b’，或者把一个’b’置成’a’)；但是操作的次数有上限m，问在有限的操作数范围内，能够得到最大连续的相同字符的子串的长度是多少。.</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行两个整数 <span class="hljs-built_in">n</span> , m (<span class="hljs-number">1</span>&lt;=m&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">50000</span>)，第二行为长度为<span class="hljs-built_in">n</span>且只包含’a’和’b’的字符串s。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs css">输出在操作次数不超过 m 的情况下，能够得到的 最大连续 全’<span class="hljs-selector-tag">a</span>’子串或全’<span class="hljs-selector-tag">b</span>’子串的长度。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs apache"><span class="hljs-attribute">8</span> <span class="hljs-number">1</span><span class="hljs-attribute">aabaabaa</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">5</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs 1c">把第一个 &#x27;b&#x27; 或者第二个 &#x27;b&#x27; 置成 &#x27;a&#x27;，可得到长度为 <span class="hljs-number">5</span> 的全 &#x27;a&#x27; 子串。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用滑动窗口法</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;<span class="hljs-type">int</span> main()&#123;    char c[<span class="hljs-number">500001</span>];    <span class="hljs-type">int</span> n,m;    scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c[i]);    &#125;    <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>,l=<span class="hljs-number">0</span>,maxl=<span class="hljs-number">0</span>,an=<span class="hljs-number">0</span>,bn=<span class="hljs-number">0</span>;    while(r&lt;n)&#123;        <span class="hljs-keyword">if</span>(c[r]==<span class="hljs-string">&#x27;a&#x27;</span>) an++;        <span class="hljs-keyword">else</span> bn++;        <span class="hljs-keyword">if</span>(an&lt;=m||bn&lt;=m)&#123;            r++;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(r-l&gt;maxl) maxl = r-l;            <span class="hljs-keyword">if</span>(c[l]==<span class="hljs-string">&#x27;a&#x27;</span>)&#123;                an--;                l++;            &#125;<span class="hljs-keyword">else</span>&#123;                bn--;                l++;            &#125;            r++;        &#125;    &#125;    <span class="hljs-keyword">if</span>(r-l &gt;maxl) maxl = r-l;    printf(<span class="hljs-string">&quot;%d&quot;</span>,maxl);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：4ms, 超过61.29%用C提交的代码<br>   占用内存：416KB, 超过83.87%用C提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>房间人数</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%88%BF%E9%97%B4%E4%BA%BA%E6%95%B0/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%88%BF%E9%97%B4%E4%BA%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="房间人数"><a href="#房间人数" class="headerlink" title="房间人数"></a><font size=6px>房间人数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有n个房间，现在i号房间里的人需要被重新分配，分配的规则是这样的：先让i号房间里的人全都出来，接下来按照 i+1, i+2, i+3, … 的顺序依此往这些房间里放一个人，n号房间的的下一个房间是1号房间，直到所有的人都被重新分配。</p><p>现在告诉你分配完后每个房间的人数以及最后一个人被分配的房间号x，你需要求出分配前每个房间的人数。数据保证一定有解，若有多解输出任意一个解。</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><pre><code class="hljs excel">第一行两个整数<span class="hljs-built_in">n</span>, x (<span class="hljs-number">2</span>&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">5</span>, <span class="hljs-number">1</span>&lt;=x&lt;=<span class="hljs-built_in">n</span>)，代表房间房间数量以及最后一个人被分配的房间号；第二行<span class="hljs-built_in">n</span>个整数 a_i(<span class="hljs-number">0</span>&lt;=a_i&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">9</span>) ，代表每个房间分配后的人数。</code></pre><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><pre><code class="hljs excel">输出<span class="hljs-built_in">n</span>个整数，代表每个房间分配前的人数。</code></pre><h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><span class="hljs-symbol">6 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span></code></pre><h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>需要考虑的情况是</p><pre><code class="hljs hsp"><span class="hljs-keyword">while</span>(room[<span class="hljs-keyword">pos</span>]!=mn)        <span class="hljs-keyword">pos</span>=<span class="hljs-keyword">pos</span>&gt;<span class="hljs-number">0</span>?<span class="hljs-keyword">pos</span><span class="hljs-number">-1</span>:n<span class="hljs-number">-1</span><span class="hljs-comment">;</span></code></pre><p>最后一个房间的人的前一个最小数才是真正的最小数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;limits.h&gt;#include&lt;algorithm&gt;using namespace std;#define ll long long<span class="hljs-type">int</span> n,x;ll room[<span class="hljs-number">1500005</span>];<span class="hljs-type">int</span> main(void)&#123;    scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);    ll mn=INT_MAX;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;room[i]);        mn=min(mn, room[i]);    &#125;    x-=<span class="hljs-number">1</span>;    <span class="hljs-type">int</span> pos=x;    while(room[pos]!=mn)        pos=pos&gt;<span class="hljs-number">0</span>?pos<span class="hljs-number">-1</span>:n<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        room[i]-=mn;    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i!=pos;i=i&gt;<span class="hljs-number">0</span>?i<span class="hljs-number">-1</span>:n<span class="hljs-number">-1</span>)&#123;        room[i]-=<span class="hljs-number">1</span>;        count+=<span class="hljs-number">1</span>;    &#125;    room[pos]+=count+n*mn;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        printf(<span class="hljs-string">&quot;%lld &quot;</span>,room[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动附加题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%99%84%E5%8A%A0%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%99%84%E5%8A%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="字节跳动附加题"><a href="#字节跳动附加题" class="headerlink" title="字节跳动附加题"></a><font size=6px>字节跳动附加题</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>存在n+1个房间，每个房间依次为房间1 2 3…i，每个房间都存在一个传送门，i房间的传送门可以把人传送到房间pi(1&lt;&#x3D;pi&lt;&#x3D;i),现在路人甲从房间1开始出发(当前房间1即第一次访问)，每次移动他有两种移动策略：<br>  A. 如果访问过当前房间 i 偶数次，那么下一次移动到房间i+1；<br>  B. 如果访问过当前房间 i 奇数次，那么移动到房间pi；<br>现在路人甲想知道移动到房间n+1一共需要多少次移动；</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行包括一个数字<span class="hljs-built_in">n</span>(<span class="hljs-comment">30%数据1&lt;=n&lt;=100，100%数据 1&lt;=n&lt;=1000</span>)，表示房间的数量，接下来一行存在<span class="hljs-built_in">n</span>个数字 <span class="hljs-built_in">pi</span>(<span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">pi</span>&lt;=i), <span class="hljs-built_in">pi</span>表示从房间i可以传送到房间<span class="hljs-built_in">pi</span>。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs dns">输出一行数字，表示最终移动的次数，最终结果需要对<span class="hljs-number">1000000007</span> (<span class="hljs-number">10</span>e9 + <span class="hljs-number">7</span>) 取模。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs css">开始从房间<span class="hljs-number">1</span> 只访问一次所以只能跳到p1即 房间<span class="hljs-number">1</span>， 之后采用策略<span class="hljs-selector-tag">A</span>跳到房间<span class="hljs-number">2</span>，房间<span class="hljs-number">2</span>这时访问了一次因此采用策略<span class="hljs-selector-tag">B</span>跳到房间<span class="hljs-number">2</span>，之后采用策略<span class="hljs-selector-tag">A</span>跳到房间<span class="hljs-number">3</span>，因此到达房间<span class="hljs-number">3</span>需要 <span class="hljs-number">4</span> 步操作。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一道递推题，dp【i】需要一次奇数和偶数移动，偶数移动 &#x3D; dp【i-1】+1,奇数移动是dp【i】&#x3D; dp【i-1】-dp【jump【i-1】】+1。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">2</span>)    jump := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)    mod := <span class="hljs-number">1000000007</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        fmt.Scan(&amp;jump[i])    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++&#123;        count[i] = (<span class="hljs-number">2</span>*count[i<span class="hljs-number">-1</span>]%mod-count[jump[i<span class="hljs-number">-1</span>]]+<span class="hljs-number">2</span>)%mod    &#125;    fmt.Println(count[n+<span class="hljs-number">1</span>])&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：2 ms, 在所有 Go 提交中击败了100.00%的用户<br>   占用内存：988KB, 超过13.64%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大点集</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%80%E5%A4%A7%E7%82%B9%E9%9B%86/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%80%E5%A4%A7%E7%82%B9%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="最大点集"><a href="#最大点集" class="headerlink" title="最大点集"></a><font size=6px>最大点集</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>P为给定的二维平面整数点集。定义P中某点x，如果x满足P中任意点都不在x的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复,坐标轴范围在[0, 1e9]内）</p><p>如下图：实心点为满足条件的点的集合。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180711/305700_1531276401135_0787E0E2ECD199446DCB82BEAE571BDF" alt="img"></p><p>请实现代码找到集合P中的所有”最大“点的集合并输出。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行输入点集的个数<span class="hljs-built_in">N</span>， 接下来<span class="hljs-built_in">N</span>行，每行两个数字代表点的X轴和Y轴。<span class="hljs-number">1</span> ≤ <span class="hljs-built_in">n</span> ≤ <span class="hljs-number">500000</span></code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs tp">输出“最大的”点集合， 按照<span class="hljs-keyword">X</span>轴从小到大的方式输出，每行两个数字分别代表点的<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先按照x升序和y升序排序，然后从后到前判断</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;<span class="hljs-keyword">struct</span> num &#123;    <span class="hljs-type">int</span> a,b;&#125;;<span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">struct</span> num num1,<span class="hljs-keyword">struct</span> num num2)&#123;    <span class="hljs-keyword">if</span> (num1.a &gt; num2.a)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num1.a &lt; num2.a)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span> (num1.b&lt;num2.b)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">struct</span> num nums[n];    <span class="hljs-keyword">struct</span> num res[n];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums[i].a);        scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums[i].b);    &#125;    sort(nums,nums+n,cmp);    <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;    <span class="hljs-type">int</span> max = nums[n<span class="hljs-number">-1</span>].b;    res[<span class="hljs-number">0</span>].a = nums[n<span class="hljs-number">-1</span>].a;    res[<span class="hljs-number">0</span>].b = nums[n<span class="hljs-number">-1</span>].b;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-keyword">if</span>(nums[i].b &gt;max)&#123;            max = nums[i].b;            res[k].a = nums[i].a;            res[k++].b = nums[i].b;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,res[i].a,res[i].b);    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：173ms, 超过80.50%用C++提交的代码<br>   占用内存：12684KB, 超过44.93%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人跳跃问题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="机器人跳跃问题"><a href="#机器人跳跃问题" class="headerlink" title="机器人跳跃问题"></a><font size=6px>机器人跳跃问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。 </p><p>起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第个k+1建筑。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果 H(k+1) &gt; E 那么机器人就失去 H(k+1) - E 的能量值，否则它将得到 E - H(k+1) 的能量值。</p><p>游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs css">第一行输入，表示一共有 N 组数据.第二个是 N 个空格分隔的整数，<span class="hljs-selector-tag">H1</span>, <span class="hljs-selector-tag">H2</span>, <span class="hljs-selector-tag">H3</span>, ..., Hn 代表建筑物的高度</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">输出一个单独的数表示完成游戏所需的最少单位的初始能量</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><p>示例2</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span></code></pre><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><p>示例3</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span></code></pre><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">3</code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h2><pre><code class="hljs parser3"><span class="language-xml">数据约束：</span><span class="language-xml"></span><span class="hljs-number">1</span><span class="language-xml"> &lt;= N &lt;= </span><span class="hljs-number">10</span><span class="hljs-keyword">^5</span><span class="language-xml"></span><span class="language-xml"></span><span class="hljs-number">1</span><span class="language-xml"> &lt;= H(i) &lt;= </span><span class="hljs-number">10</span><span class="hljs-keyword">^5</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用动态规划,令 f(n)&#x3D;E(n)，</p><p>则 f(n+1)&#x3D;2f(n)–H(n+1)≥0，所以 f(n)&#x3D;⌈(f(n+1)+H(n+1))&#x2F;2⌉</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n,a <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scan(&amp;a)        num[i] = a    &#125;    <span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(num)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        ans = ceil(ans , num[i])    &#125;    fmt.Println(ans)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ceil</span><span class="hljs-params">( a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> (a+b) %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> (a+b)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> (a+b)/<span class="hljs-number">2</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：15ms, 超过9.84%用Go提交的代码<br>   占用内存：1036KB, 超过37.70%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业旅行问题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%AF%95%E4%B8%9A%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%AF%95%E4%B8%9A%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="毕业旅行问题"><a href="#毕业旅行问题" class="headerlink" title="毕业旅行问题"></a><font size=6px>毕业旅行问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">城市个数<span class="hljs-built_in">n</span>（<span class="hljs-number">1</span>&lt;<span class="hljs-built_in">n</span>≤<span class="hljs-number">20</span>，包括北京）城市间的车票价钱 <span class="hljs-built_in">n</span>行<span class="hljs-built_in">n</span>列的矩阵 m[<span class="hljs-built_in">n</span>][<span class="hljs-built_in">n</span>]</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">最小车费花销 s</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">4</span><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><span class="hljs-symbol">6 </span><span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">13</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs tap">共<span class="hljs-number"> 4 </span>个城市，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 1 </span>的车费为0，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 2 </span>之间的车费为 2，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 3 </span>之间的车费为 6，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 4 </span>之间的车费为 5，依次类推。假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用状态压缩动态规划来写，1代表已经走过这个地方了，解释一下代码</p><p>第一层循环代表所有情况，第二层代表下一个要去的城市是第几个城市，第三层循环代表中间结点城市。</p><pre><code class="hljs 1c">i&gt;&gt;j <span class="hljs-meta">&amp;1 <span class="hljs-comment">//判断i的第j位是不是1</span></span></code></pre><p>i^(1&lt;&lt;j) &#x2F;&#x2F;把i的第j位置为1</p><pre><code class="hljs cpp">#### 代码:```golang<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;    <span class="hljs-keyword">if</span>(a &gt; b)&#123;        <span class="hljs-keyword">return</span> b;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-type">int</span> dp[<span class="hljs-number">1</span>&lt;&lt;n][n];        <span class="hljs-type">int</span> num[n][n];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num[i][j]);    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dp));    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i+=<span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;            <span class="hljs-keyword">if</span>((i&gt;&gt;j &amp;<span class="hljs-number">1</span>==<span class="hljs-number">0</span>)) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;                <span class="hljs-keyword">if</span>(j==k) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>((i&gt;&gt;k)&amp;<span class="hljs-number">1</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)][k]+num[k][j]);            &#125;        &#125;    &#125;    <span class="hljs-type">int</span> res =<span class="hljs-number">9999</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        res = <span class="hljs-built_in">min</span>(res,dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i]+num[i][<span class="hljs-number">0</span>]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：78ms, 超过33.33%用C提交的代码<br>   占用内存：18732KB, 超过15.69%用C提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点排序</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%82%B9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%82%B9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="点排序"><a href="#点排序" class="headerlink" title="点排序"></a><font size=6px>点排序</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>P为给定的二维平面整数点集。定义 P 中某点x，如果x满足 P 中任意点都不在 x 的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复, 坐标轴范围在[0, 1e9) 内）</p><p>如下图：实心点为满足条件的点的集合。请实现代码找到集合 P 中的所有 ”最大“ 点的集合并输出。</p><p><img src="https://uploadfiles.nowcoder.com/images/20170817/300557_1502940399706_1329AFEA3FC7961DEA219781A71B3B5B" alt="img"></p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行输入点集的个数 <span class="hljs-built_in">N</span>， 接下来 <span class="hljs-built_in">N</span> 行，每行两个数字代表点的 X 轴和 Y 轴。对于 <span class="hljs-number">50%</span>的数据,  <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">N</span> &lt;= <span class="hljs-number">10000</span>;对于 <span class="hljs-number">100%</span>的数据, <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">N</span> &lt;= <span class="hljs-number">500000</span>;</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs tp">输出“最大的” 点集合， 按照 <span class="hljs-keyword">X</span> 轴从小到大的方式输出，每行两个数字分别代表点的 <span class="hljs-keyword">X</span> 轴和 <span class="hljs-keyword">Y</span>轴。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;using namespace std;<span class="hljs-keyword">struct</span> node&#123;    <span class="hljs-type">int</span> x;    <span class="hljs-type">int</span> y;&#125;;<span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">struct</span> node a,<span class="hljs-keyword">struct</span> node b)&#123;    <span class="hljs-keyword">if</span>(a.x&lt;b.x)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-type">int</span> max(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-keyword">if</span>(a&gt;b)&#123;        <span class="hljs-keyword">return</span> a;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b;    &#125;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">struct</span> node node1[n];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;node1[i].x,&amp;node1[i].y);    &#125;    sort(node1,node1+n,cmp);    <span class="hljs-type">int</span> maxNum[n];    memset(maxNum,<span class="hljs-number">0</span>,sizeof(maxNum));    maxNum[n<span class="hljs-number">-1</span>] = node1[n<span class="hljs-number">-1</span>].y;    <span class="hljs-comment">//找出这个点到最后的数中最大数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        maxNum[i] = max(maxNum[i+<span class="hljs-number">1</span>],node1[i].y);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(node1[i].y==maxNum[i])&#123;            printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,node1[i].x,node1[i].y);        &#125;    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：207ms, 超过89.17%用C++提交的代码<br>   占用内存：19556KB, 超过27.91%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程题2</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%BC%96%E7%A8%8B%E9%A2%982/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%BC%96%E7%A8%8B%E9%A2%982/</url>
    
    <content type="html"><![CDATA[<h3 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a><font size=6px>编程题2</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有n个房间，现在i号房间里的人需要被重新分配，分配的规则是这样的：先让i号房间里的人全都出来，接下来按照 i+1, i+2, i+3, … 的顺序依此往这些房间里放一个人，n号房间的的下一个房间是1号房间，直到所有的人都被重新分配。</p><p>现在告诉你分配完后每个房间的人数以及最后一个人被分配的房间号x，你需要求出分配前每个房间的人数。数据保证一定有解，若有多解输出任意一个解。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行两个整数<span class="hljs-built_in">n</span>, x (<span class="hljs-number">2</span>&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">5</span>, <span class="hljs-number">1</span>&lt;=x&lt;=<span class="hljs-built_in">n</span>)，代表房间房间数量以及最后一个人被分配的房间号；第二行<span class="hljs-built_in">n</span>个整数 a_i(<span class="hljs-number">0</span>&lt;=a_i&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">9</span>) ，代表每个房间分配后的人数。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs excel">输出<span class="hljs-built_in">n</span>个整数，代表每个房间分配前的人数。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><span class="hljs-symbol">6 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找出last左右边最小的数，如果左右边最小的数相等，就选last左边的最小数，写的像屎一样的代码，不想写思路了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n,last,min,min1 <span class="hljs-type">int</span>        fmt.Scan(&amp;n,&amp;last)    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-comment">//找出last左右边最小的数，如果左右边最小的数相等，就选last左边的最小数</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;last;i++&#123;        fmt.Scan(&amp;num[i])        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>&#123;            min = i        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> num[min] &gt;=num[i]&#123;                min = i            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=last;i&lt;n;i++&#123;        fmt.Scan(&amp;num[i])        <span class="hljs-keyword">if</span> i==last&#123;            min1 = i        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> num[min1] &gt;=num[i]&#123;                min1 = i            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> num[min]&gt;num[min1]&#123;        min = min1    &#125;    sum :=<span class="hljs-number">0</span>    minNum :=num[min]    <span class="hljs-keyword">if</span> last &lt; min+<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">for</span> i:=min+<span class="hljs-number">1</span>;i&lt;n;i++&#123;            num[i] -=minNum+<span class="hljs-number">1</span>           &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;last;i++&#123;            num[i] -=minNum+<span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">for</span> i:=last;i&lt;=min;i++&#123;            num[i] -=minNum        &#125;        sum = (last+n-(min+<span class="hljs-number">1</span>))*(minNum+<span class="hljs-number">1</span>)+(n-last-(n-(min+<span class="hljs-number">1</span>)))*minNum    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> last&gt;min+<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=min;i++&#123;            num[i] -=minNum        &#125;         <span class="hljs-keyword">for</span> i:=last;i&lt;n;i++&#123;            num[i] -=minNum        &#125;        <span class="hljs-keyword">for</span> i:=min+<span class="hljs-number">1</span>;i&lt;last;i++&#123;            num[i] -=minNum+<span class="hljs-number">1</span>        &#125;        sum = (last-min<span class="hljs-number">-1</span>) *(minNum+<span class="hljs-number">1</span>)+(n-(last-min)+<span class="hljs-number">1</span>)*minNum    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;            num[i]-=minNum        &#125;        sum = n*minNum    &#125;    num[min] = sum    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,num[i])        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Printf(<span class="hljs-string">&quot; %d&quot;</span>,num[i])        &#125;    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：686ms, 超过66.67%用Go提交的代码<br>   占用内存：6812KB, 超过83.33%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选区间</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E9%80%89%E5%8C%BA%E9%97%B4/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E9%80%89%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="选区间"><a href="#选区间" class="headerlink" title="选区间"></a><font size=6px>选区间</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组序列,需要求选出一个区间,使得该区间是所有区间中经过如下计算的值最大的一个：</p><p>区间中的最小数*区间所有数的和</p><p>最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列 [6 2 1]则根据上述公式,可得到所有可以选定各个区间的计算值:</p><p>[6] &#x3D; 6 * 6 &#x3D; 36;</p><p>[2] &#x3D; 2 * 2 &#x3D; 4;</p><p>[1] &#x3D; 1 * 1 &#x3D; 1;</p><p>[6,2] &#x3D; 2 * 8 &#x3D; 16;</p><p>[2,1] &#x3D; 1 * 3 &#x3D; 3;</p><p>[6, 2, 1] &#x3D; 1 * 9 &#x3D; 9;</p><p>从上述计算可见选定区间[6]，计算值为36， 则程序输出为36。</p><p>区间内的所有数字都在[0, 100]的范围内;</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs">第一行输入数组序列个数，第二行输入数组序列。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">输出数组经过计算后的最大值。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">6 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">36</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把每个数当成最小数，从左到右遍历</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n,max=<span class="hljs-number">-1</span>,sum,res;    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-type">int</span> num[n+<span class="hljs-number">1</span>];    <span class="hljs-type">int</span> numSum[n+<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num[i]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;=<span class="hljs-number">1</span>;j--)&#123;            <span class="hljs-keyword">if</span> (num[j]&gt;=num[i])&#123;                sum +=num[j];            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            <span class="hljs-keyword">if</span> (num[j]&gt;=num[i])&#123;                sum +=num[j];            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        res = num[i]*sum;        sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (max &lt;res)&#123;            max = res;        &#125;    &#125;    printf(<span class="hljs-string">&quot;%d&quot;</span>,max);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：1038ms, 超过19.45%用C++提交的代码<br>   占用内存：3472KB, 超过39.60%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝绿部署、金丝雀部署的含义和区别</title>
    <link href="/2022/01/21/%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2%E3%80%81%E9%87%91%E4%B8%9D%E9%9B%80%E9%83%A8%E7%BD%B2%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2%E3%80%81%E9%87%91%E4%B8%9D%E9%9B%80%E9%83%A8%E7%BD%B2%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="蓝绿部署、金丝雀部署的含义和区别"><a href="#蓝绿部署、金丝雀部署的含义和区别" class="headerlink" title="蓝绿部署、金丝雀部署的含义和区别"></a>蓝绿部署、金丝雀部署的含义和区别</h2><p>在一般情况下，升级服务器端应用，需要将应用源码或程序包上传到服务器，然后停止掉老版本服务，再启动新版本。但是这种简单的发布方式存在两个问题，一方面，在新版本升级过程中，服务是暂时中断的，另一方面，如果新版本有BUG，升级失败，回滚起来也非常麻烦，容易造成更长时间的服务不可用。<strong>为了解决这些（服务中断、失败回滚、……）问题，人们研究出了多种发布策略。</strong></p><h5 id="1、蓝绿部署-–-BlueGreenDeployment"><a href="#1、蓝绿部署-–-BlueGreenDeployment" class="headerlink" title="1、蓝绿部署 – BlueGreenDeployment"></a>1、蓝绿部署 – BlueGreenDeployment</h5><blockquote><p>It’s basically a technique for <em>releasing your application in a predictable</em> manner with an goal of <em>reducing any downtime associated with a release</em>. It’s a quick way to prime your app before releasing, and also quickly roll back if you find issues.</p></blockquote><p><strong>蓝绿部署的目的是——减少因发布导致的服务中断时间</strong>，同时它也支持发布失败时的快速回滚。</p><p><img src="https://ixyzero.com/blog/wp-content/uploads/2020/01/blue_green_deployments.png" alt="img"></p><p>蓝绿部署需要在发布过程中，同时运行两套程序。对硬件的要求也是当前所需的2倍，比如当前运行时，需要10台服务器支撑业务，那么使用蓝绿部署，你就需要购置20台服务器。</p><h5 id="2、滚动发布-x2F-更新"><a href="#2、滚动发布-x2F-更新" class="headerlink" title="2、滚动发布&#x2F;更新"></a>2、滚动发布&#x2F;更新</h5><p>所谓滚动发布，就是在发布过程中，并不一下子启动所有新版本，而是先启动一台新版本，再停止一台老版本，然后再启动一台新版本，再停止一台老版本，直到全部发布完成，这样的话，如果当前需要10台服务器支撑服务，那么升级过程中一共只需要11台就行了。</p><p><strong>滚动发布能够解决掉蓝绿部署时对硬件要求增倍的问题。</strong></p><p>但是滚动发布有一个问题，在开始滚动发布后，流量会直接流向已经启动起来的新版本，但是这个时候，新版本是不一定稳定&#x2F;符合预期的，可能需要进一步的测试才能确认。那么在滚动发布期间，整个系统就处于较为不稳定的状态，如果发现了问题，也比较难以确定是新版本还是老版本造成的问题。<br>为了解决这个问题，我们需要为滚动发布实现流量控制能力。也就是下面的金丝雀发布&#x2F;灰度发布。</p><h5 id="2-1、金丝雀发布-–-也叫灰度发布"><a href="#2-1、金丝雀发布-–-也叫灰度发布" class="headerlink" title="2.1、金丝雀发布 –  (也叫灰度发布)"></a>2.1、金丝雀发布 –  (也叫灰度发布)</h5><blockquote><p>17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离。</p><p>金丝雀发布(Canary Releases)名称的由来</p></blockquote><p>金丝雀发布指的是在生产环境中分阶段逐步更新后端应用的版本（需要具备流量控制能力），在小范围验证符合预期之后，再推广至整个生产环境。</p><p><img src="https://ixyzero.com/blog/wp-content/uploads/2020/01/canary-release-2.png" alt="img"></p><p><strong>金丝雀发布的好处在于可以用真实环境测试新版本</strong>，当新版本存在问题时最多只影响部分用户，且支持安全快速的回滚策略（将路由到新版本上的流量切换到其它的老版本机器上即可）。</p><p>但金丝雀发布并不是完美的，如果新版本有问题，那么路由到新版本的小部分流量会有问题，就跟矿井中毒发身亡的金丝雀一样。这种做法在非常敏感的业务中几乎无法接受，但是当系统复杂的到一定程度，错误无法完全避免的时候，为了避免出现更大的问题，牺牲一小部分流量，就可以将大部分错误的影响控制在一定范围内。</p><hr><h5 id="A-x2F-B测试-–-A-x2F-B-Testing"><a href="#A-x2F-B测试-–-A-x2F-B-Testing" class="headerlink" title="A&#x2F;B测试 – A&#x2F;B Testing"></a>A&#x2F;B测试 – A&#x2F;B Testing</h5><p><strong>首先需要明确的是，A&#x2F;B测试和蓝绿部署以及金丝雀发布，完全是不同类型的概念。</strong></p><p>蓝绿部署和金丝雀发布是发布策略，目标是确保新上线的系统稳定，关注的是新系统的BUG、隐患。</p><p><strong>A&#x2F;B测试是效果测试（一般用来验证某个想法是否符合预期）</strong>，同一时间有多个版本的服务对外服务，这些服务都是经过足够测试，达到了上线标准的服务，有差异但是没有新旧之分。它关注的是不同版本的服务的实际效果，譬如说转化率、订单情况等。</p><p>A&#x2F;B测试时，线上同时运行多个版本的服务，这些服务通常会有一些体验上的差异，譬如说页面样式、颜色、操作流程不同。相关人员通过分析各个版本服务的实际效果，以选出效果最好的版本。</p><p><img src="https://ixyzero.com/blog/wp-content/uploads/2020/01/abtesting.png" alt="img"></p><p>参考文章：<a href="https://ixyzero.com/blog/archives/4722.html">https://ixyzero.com/blog/archives/4722.html</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>情侣间的日常琐事记录</title>
    <link href="/2022/01/21/%E6%83%85%E4%BE%A3%E7%94%9C%E8%9C%9C%E5%B0%8F%E6%97%A5%E5%B8%B8/"/>
    <url>/2022/01/21/%E6%83%85%E4%BE%A3%E7%94%9C%E8%9C%9C%E5%B0%8F%E6%97%A5%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="情侣间的日常琐事记录"><a href="#情侣间的日常琐事记录" class="headerlink" title="情侣间的日常琐事记录"></a>情侣间的日常琐事记录</h1><p class="label label-warning"style= "font-size:24px" >记录了一部分成为情侣之后的日常，超甜勿看</p><hr><h3 id="2020-7-10第一次约会去撸猫"><a href="#2020-7-10第一次约会去撸猫" class="headerlink" title="2020.7.10第一次约会去撸猫"></a>2020.7.10第一次约会去撸猫</h3><h3 id="2020-7-12-yyj生日、第一次一起去逛西湖"><a href="#2020-7-12-yyj生日、第一次一起去逛西湖" class="headerlink" title="2020.7.12 yyj生日、第一次一起去逛西湖"></a>2020.7.12 yyj生日、第一次一起去逛西湖</h3><h3 id="2020-7-19-答辩结束-yyj到家啦-虽然结果不咋地-但是收获了一个npy-不错"><a href="#2020-7-19-答辩结束-yyj到家啦-虽然结果不咋地-但是收获了一个npy-不错" class="headerlink" title="2020.7.19 答辩结束:yyj到家啦,虽然结果不咋地,但是收获了一个npy,不错~"></a>2020.7.19 答辩结束:yyj到家啦,虽然结果不咋地,但是收获了一个npy,不错~</h3><h3 id="2020-8-25第一个情人节-看了第一场电影、收获第一支玫瑰🌹"><a href="#2020-8-25第一个情人节-看了第一场电影、收获第一支玫瑰🌹" class="headerlink" title="2020.8.25第一个情人节,看了第一场电影、收获第一支玫瑰🌹"></a>2020.8.25第一个情人节,看了第一场电影、收获第一支玫瑰🌹</h3><h3 id="2020-9-6他来抗州找我玩，第一出去逛了宜家"><a href="#2020-9-6他来抗州找我玩，第一出去逛了宜家" class="headerlink" title="2020.9.6他来抗州找我玩，第一出去逛了宜家"></a>2020.9.6他来抗州找我玩，第一出去逛了宜家</h3><h3 id="2020-10-2获得了秋天第一个柚子"><a href="#2020-10-2获得了秋天第一个柚子" class="headerlink" title="2020.10.2获得了秋天第一个柚子"></a>2020.10.2获得了秋天第一个柚子</h3><hr>]]></content>
    
    
    <categories>
      
      <category>生活杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从前端到后端到数据库有什么优化办法</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%90%8E%E7%AB%AF%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E5%8A%9E%E6%B3%95/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%90%8E%E7%AB%AF%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>1、减少网络传输时间</p><ul><li>传输协议：使用rpc协议而不是http来进行传输。</li><li>多地部署服务，使用CDN把请求导引到最近的服务减少在网络传输的时间 。</li></ul><p>2、使用 k8s service的或者 nginx 反向代理负载均衡减少每个请求处理的时间。</p><p>3、数据库层面进行索引优化</p><ul><li>mysql表结构和索引进行优化，减少mysql查找时间。</li><li>使用redis等内存数据库作为缓存，使用先更新数据库再删redis来做到最终一致性。</li><li>数据库进行读写分离操作，提高查询效率。</li></ul><p>4、代码层面优化</p><ul><li><p>使用多个协程配合 channal 同步信息来做到充分利用多核cpu，减少代码运行时间</p></li><li><p>限制goroutine数量，防止太多导致cpu的时候都在goroutine上下文切换中</p></li></ul><p>5、增加硬件配置</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>encoder/json为什么慢</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/encoder:json%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%A2/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/encoder:json%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="encoder-x2F-json为什么慢"><a href="#encoder-x2F-json为什么慢" class="headerlink" title="encoder&#x2F;json为什么慢"></a>encoder&#x2F;json为什么慢</h3><p>因为使用了较多的反射，会导致时间变慢</p><h3 id="为什么jsoniter快"><a href="#为什么jsoniter快" class="headerlink" title="为什么jsoniter快"></a>为什么jsoniter快</h3><ul><li>减少不必要的内存复制。</li><li>减少 反射(<code>reflect</code>） 的使用，对同一类型的对象，<code>jsoniter </code>只反射一次之后即缓存下来。</li><li>获取部分内容的时候尽可能解析少的东西，按需解析</li></ul><p>和 encoding&#x2F;json 的区别是，标准库使用的是 reflect.ValueOf ，然后根据 json 的输入情况去找对应的 field 和 element 。而 jsoniter 的实现是反过来的，用 reflect.TypeOf 确定一个 json 的 schema ，然后根据 schema 产生对应的 decoder 。如果 json 输入不符合这个 decoder 则报错。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka和redis作为消息队列的差别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka%E5%92%8Credis%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%AE%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka%E5%92%8Credis%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%AE%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="kafka和redis作为消息队列的差别"><a href="#kafka和redis作为消息队列的差别" class="headerlink" title="kafka和redis作为消息队列的差别"></a>kafka和redis作为消息队列的差别</h2><p>1、需要使用多消费组情况的时候redis做不了，redis的list只能支持一个消费者pop，kafka可以使用多个group重复消费一个数据。</p><p>2、当订阅者断开重连会丢失断开期间发布者发布的消息，而kafka中会记录每个消费者消费的topic的offset，因此kafka可以从断开的offset继续消费。</p><p>3、高并发情况的下的list无法通过扩容解决问题，kafka可以扩partition。</p><p>4、没有确认机制，每当pop了之后消息就永远从list删除，消费者如果消费失败就永远不能找回这条消息了</p><p>5、redis断电无法保证数据完全不丢，kakfa不会，kafka可靠</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脑裂</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98-%E8%84%91%E8%A3%82/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98-%E8%84%91%E8%A3%82/</url>
    
    <content type="html"><![CDATA[<h1 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>集群中的Master或Leader节点往往是通过选举产生的。在网络正常的情况下，可以顺利的选举出Leader（后续以Zookeeper命名为例）。但当两个机房之间的网络通信出现故障时，选举机制就有可能在不同的网络分区中选出两个Leader。当网络恢复时，这两个Leader该如何处理数据同步？又该听谁的？这也就出现了“脑裂”现象。</p><h3 id="Zookeeper的解决方案-过半原则"><a href="#Zookeeper的解决方案-过半原则" class="headerlink" title="Zookeeper的解决方案-过半原则"></a>Zookeeper的解决方案-过半原则</h3><p>所谓的过半原则就是：在Leader选举的过程中，如果某台zkServer获得了超过半数的选票，则此zkServer就可以成为Leader了。</p><p>Zookeeper集群通过过半机制，达到了要么没有Leader，要没只有1个Leader，这样就避免了脑裂问题。</p><p>对于过半机制除了能够防止脑裂，还可以实现快速的选举。因为过半机制不需要等待所有zkServer都投了同一个zkServer就可以选举出一个Leader，所以也叫快速领导者选举算法。</p><p>假设某个Leader假死，其余的followers选举出了一个新的Leader。这时，旧的Leader复活并且仍然认为自己是Leader，向其他followers发出写请求也是会被拒绝的。</p><p>因为ZooKeeper维护了一个叫epoch的变量，每当新Leader产生时，会生成一个epoch标号（标识当前属于那个Leader的统治时期），epoch是递增的，followers如果确认了新的Leader存在，知道其epoch，就会拒绝epoch小于现任leader epoch的所有请求。</p><p>那有没有follower不知道新的Leader存在呢，有可能，但肯定不是大多数，否则新Leader无法产生。ZooKeeper的写也遵循quorum机制，因此，得不到大多数支持的写是无效的，旧leader即使各种认为自己是Leader，依然没有什么作用。</p><p>并且Zookeeper一般是奇数个数</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幂等性</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>幂等，这个词来源自数学领域。幂等性衍生到软件工程中，它的语义是指：函数&#x2F;接口可以使用相同的参数重复执行, 不应该影响系统状态，也不会对系统造成改变。</p><p>举一个简单的例子：正常设计的查询接口，不管调用多少次，都不会破坏当前的系统或数据，这就是一个幂等操作。</p><p>由于分布式天然特性的时序问题以及网络的不可靠性(机器、机架、机房故障、电缆被挖断等等)， 重复请求很常见，接口幂等性设计就显得尤为重要。</p><p>幂等需要考虑的场景有很多，例如系统A是处理用户客户端发送过来的请求，无论是前端bug、脚本恶意发包、用户重复点击又或是网络超时导致的网络重发，都会造成系统A收到相同参数的网络请求。</p><h3 id="保障幂等性的原理"><a href="#保障幂等性的原理" class="headerlink" title="保障幂等性的原理"></a>保障幂等性的原理</h3><p>对于分布式系统来说，在JVM层面的锁已经失去作用，所以保证系统幂等性需要满足3个条件:</p><ol><li>请求唯一标识：每一个请求必须有一个唯一标识。</li><li>处理唯一标识：每次处理完请求之后，必须有一个记录标识这个请求处理过了。</li><li>逻辑判断处理：每次接收请求需要进行判断之前是否处理过的逻辑处理。根据请求唯一标识查询是否存在处理唯一标识。</li></ol><h2 id="幂等性实现方案"><a href="#幂等性实现方案" class="headerlink" title="幂等性实现方案"></a>幂等性实现方案</h2><h3 id="1-token机制"><a href="#1-token机制" class="headerlink" title="1. token机制"></a>1. token机制</h3><p>针对客户端重复连续多次点击的情况，例如用户购物提交订单，提交订单的接口就可以通过token机制实现防止重复提交。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/41ebd6f037094556b29d7cdb6b607a78.png?imageView2/2/w/1620" alt="img"></p><p>主要流程就是：</p><ol><li>服务端提供生成请求token的接口。在存在幂等问题的业务执行前，向<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>获取请求token，服务器会把token保存到<a href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>中。</li><li>然后调用业务接口请求时，把请求token携带过去，一般放在请求头部。</li><li>服务器判断请求token是否存在redis中：存在则表示第一次请求，这时把Redis中的token删除，继续执行业务；如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</li></ol><blockquote><p>这里要结合业务考虑这种场景：如果请求处理失败，前端是否需要重新申请token进行重试（因为此时token在服务端已经被删除）。</p></blockquote><h3 id="2-数据库唯一索引"><a href="#2-数据库唯一索引" class="headerlink" title="2. 数据库唯一索引"></a>2. <a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>唯一索引</h3><p>往数据库表里插入数据的时候，利用数据库的唯一索引特性，保证唯一的逻辑。唯一序列号可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合。</p><blockquote><p>事务中包含多表数据的更新，业务要考虑处理事务回滚的问题。</p></blockquote><h3 id="3-Redis实现"><a href="#3-Redis实现" class="headerlink" title="3. Redis实现"></a>3. Redis实现</h3><p>Redis实现的方式就是将唯一序列号作为Key存入Redis，在请求处理之前，先查看Key是否存在。唯一序列号可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合。当然这里需要设置一个key的过期时间，否则Redis中会存在过多的key。具体校验流程如下图所示：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/f0fcf4c410824d93a2be939cadf0bd5a.png?imageView2/2/w/1620" alt="img"></p><p>如果想要基于Redis实现幂等性防重框架，需要考虑如下两个问题：</p><ol><li>如果第一次请求失败了，客户端重试，是否需要放行？</li><li>网络请求可能是get或者post（内部rpc协议除外），唯一序列号参数可能在url或是在body体里。则使用防重框架的新接口以及之前老业务接口能否做到版本兼容性？</li></ol><blockquote><p>建议业务使用方最好针对指定业务进行Redis的幂等方案。</p></blockquote><p>Zookeeper同样也能实现上述功能，但由于Zookeeper是CP模型，性能不如Redis，另外针对防重场景，也并不需要Zookeeper高可靠性，所以优先推荐Redis。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解释型语言和编译型语言的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="解释型语言和编译型语言的区别"><a href="#解释型语言和编译型语言的区别" class="headerlink" title="解释型语言和编译型语言的区别"></a>解释型语言和编译型语言的区别</h2><h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h3><p>定于：编译型语言是需通过编译器(compiler)将源代码编译成机器码之后才能执行的语言。一般需经过编译(compile)、链接(linker)这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。</p><p>执行过程：源代码-&gt;汇编代码-&gt;机器码-&gt;CPU执行</p><p>特点：执行效率高：只须编译一次就可以把源代码编译成机器码，后面的执行无须重新编译，直接使用之前的编译结果，可以脱离语言环境独立运行(不需要虚拟机)</p><p>适用范围：编译型语言由于程序执行速度快，同等条件下对系统的要求比较低，因此像开发操作系统、大型应用程序、数据库系统等软件时一般采用它</p><p>跨平台性差：依赖于编译器，编译之后如果需要修改就要将整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件</p><h3 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h3><p>解释型语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。</p><p>执行过程：源代码-&gt;字节码-&gt;解释器-&gt;机器码-&gt;CPU执行</p><p>解释型语言能跨平台，是指源代码跨平台，而不是解释器跨平台。解释器用来将源代码转换成字节码，它就是一个可执行程序，是绝对不能跨平台的。在不同的平台下，解释器会将相同的源代码转换成不同的机器码，解释器帮助我们屏蔽了不同平台之间的差异</p><p>参考文章：<a href="https://blog.csdn.net/weixin_34025386/article/details/116487152?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-116487152.pc_agg_new_rank&amp;utm_term=go%E8%AF%AD%E8%A8%80%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%BF%98%E6%98%AF%E8%A7%A3%E9%87%8A%E5%9E%8B&amp;spm=1000.2123.3001.4430">https://blog.csdn.net/weixin_34025386/article/details/116487152?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-116487152.pc_agg_new_rank&amp;utm_term=go%E8%AF%AD%E8%A8%80%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%BF%98%E6%98%AF%E8%A7%A3%E9%87%8A%E5%9E%8B&amp;spm=1000.2123.3001.4430</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口限流方式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="接口限流算法"><a href="#接口限流算法" class="headerlink" title="接口限流算法"></a>接口限流算法</h2><p>常用的限流算法有<strong>令牌桶和和漏桶</strong>，而Google开源项目Guava中的RateLimiter使用的就是令牌桶控制算法。</p><h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。</p><p><img src="https://segmentfault.com/img/remote/1460000015967925?w=443&h=299" alt="img"></p><p>漏斗有一个进水口 和 一个出水口，出水口以一定速率出水，并且有一个最大出水速率：</p><p>在漏斗中没有水的时候，</p><ul><li>如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，此时，不会积水</li><li>如果进水速率大于最大出水速率，那么，漏斗以最大速率出水，此时，多余的水会积在漏斗中</li></ul><p>在漏斗中有水的时候</p><ul><li>出水口以最大速率出水</li><li>如果漏斗未满，且有进水的话，那么这些水会积在漏斗中</li><li>如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外</li></ul><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。</p><p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p><p><img src="https://segmentfault.com/img/remote/1460000015967926?w=363&h=215" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大二上半学期学期总结</title>
    <link href="/2022/01/21/%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%8D%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/21/%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%8D%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>​    </p><p>​    很快半年就过去了，都懒得写半年总结，每天都在催自己写，每天都说明天一定写，真的人人都笑贝塔，人人都是贝塔，贝塔最经典的语录就是，在寝室晚上的时候“明天一定学习，阿健明天带我去图书馆学习”，然后在寝室玩了一天电脑，其实我也差不多，寒假在家当个废物，不想写算法题不想起床，在家写了一会就不想写了，就叫女朋友打游戏去了。最近有点丧，想个办法改变一下，越玩愧疚感越大。</p><p>​    总的来说，大二上这半年是失败的，考试考试没考好，方法没用对，平时也不怎么努力学，平时都在写acm布置的作业（ps：这作业每周要花好久写），因为想早点去公司实习，要早点开始准备企业的面试，就好好写这个作业，然后其他作业很多都是很草率，什么工程经济学项目管理课都是乱来的，想不去就不去，因为每天差不多一点睡，早上8点起，感觉有报复性迟到的心理，只要是早八课就必迟到。</p><p>​    先说说班级的事情吧，大二转专业来到一个新班级，真就个个是学霸，确实班级里面就有很多大佬，跟他们相处之后发现大一一年一点计算机没学确实落后很多，会比你更早进入实验室、老师的项目、新苗之类的，哦对了，还是选择当班长，班长很水，事情没多少，听着还威风呢，然后还有李子睿同学全程安排了一次班会，班级水果捞，水果吃的很开心，还有班级小游戏玩的很开心。</p><p>​    再说说学业上面做了什么，参加了数学建模认证杯，成功拿了一个参赛奖，还干了啥，上课睡觉，早课迟到，这学期过的很水，感觉有些课真的不太听得懂，比如数据结构，都是好多都是课后自学的。哦对，还有创新实践，我承认这个创新实践是乱选的（听学长推荐的），选了嵌入式，不过老师真的很不错，很和善，教的还好，她带的研究生教的也好，很热心回答问题，我导师她还帮我找了服务外包大赛的队员，谢谢张桦老师。</p><p>  说说我学到了什么，这个确实还是挺多的，加入了杭电助手的后台部，跟着社团接触到了golang语言和它的gorm和gin框架，最近就用goalng写力扣，上acm课系统的学了一遍算法，上数据结构课基础的数据结构都能掌握，上创新实践也了解了一点硬件的知识，硬件和电脑用串口和wifi的两种通信方式，还有学了sql serve，了解了关系型数据库基本的构建过程，就是先画er图之后在建表这些，我还用hexo弄了个静态的博客，现在我打算把它部署到服务器上面，每天更换一张好看的图片到首页，让他变成动态。</p><p>​    说说爱情方面，想想我们这半年都去过什么地方，去过杭州动物园，去良渚看风景，和一起做了一顿饺子（皮厚馅少，面包蟹好吃），一起做了一度饭（好家伙忘记买米了，还没了一把雨伞和忘记拿充电头），一起吃了炸鸡，自助烤肉，牛排，奶酸菜鱼，肯德基，吴山烤禽，一起去点了痣。。。。。</p><p>​    总的来说，是失败的，失败中藏着胜利，这个寒假要做的事情还是很多的，准备浙大的pat考试乙级，学习js，在寒假也开始做服务外包大赛的前期准备，还问了学长接下来go该怎么做，他教我让我自己包装一个阿里dns接口，然后把我的博客用nginx弄成动态再acme部署https证书，还是有很多事情做（自己还这么懒，打自己两巴掌）想好了之后大方向是想做后端&#x2F;算法岗位，不过阿里和字节都举办了前端练习生活动，大公司前端岗位缺失，也会考虑一下前端吧，再说。</p>]]></content>
    
    
    <categories>
      
      <category>生活杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大一生活的总结</title>
    <link href="/2022/01/21/%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%A4%A7%E5%AD%A6%E4%B8%80%E5%B9%B4%E7%94%9F%E6%B4%BB%E7%9A%84%E6%84%9F%E6%82%9F/"/>
    <url>/2022/01/21/%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%A4%A7%E5%AD%A6%E4%B8%80%E5%B9%B4%E7%94%9F%E6%B4%BB%E7%9A%84%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<p>​      </p><p>大一生活最大的收获就是从经济转去了计算机，顺便在转去的时候拿了个一等奖学金。</p><p>​      大一的时候把全部精力都投入怎么提高绩点的路上了，其实现在想起来哦，好多东西都学的太迟了，在大一下的时候才从学长学姐那边了解到以后就业分前后端两个大方向，前端是做页面，在vue，react等主流框架下写代码，后端与数据库打交道，写完后写api接口给前端用，其实我最开始选择后端是因为赚钱多，毕竟后端的任务比较难，前端好上手，一写代码就能看到成果，但是好像以后就业活会比较枯燥比较机械，现在开始加入杭助后端，开始学golang和数据库，和大佬比学的太迟了。</p>  <h2>学习篇：</h2><p>​    在大一下疫情在家的时间，自学了c，学习了指针，链表，结构体，数据结构也学了栈，队列，还有到现在都没理解的分治算法（递归的方式看不懂），二叉树，还有自学了python，但是只能写写基础语法，然后在大一下学了前端的html和css语言（确实很好上手，没有什么逻辑关系，就是没有if语句这些判断），最后还有大一下买的吉他，谈了几天到学校就没时间谈学（现在已经积灰了）。</p> <h2>竞赛篇：</h2> <p>大一下参加证卷投资大赛，发现选导师真的很重要，如果他是你的评委老师你做的东西对他口味分数就会高，其实这个比赛策略组根本就不需要基础，导师会给你题目，给你模板和大概方向，你只需要一定时间把word写长和ppt做漂亮，然后给导师改一下，就能得奖。感觉统调，金融创新应该都差不多，含金量不高，还是大创含金量相对高一点，不过最后还是要花大量时间写word和ppt，一般比赛的时候熬夜是常态，推荐竞赛的话血推数模，acm（这比赛大一就要训练，一般人还参加不了），真的挺硬核。你说大一没人带不敢参加竞赛，其实感兴趣大胆参加，你说没想法，你可以只找一个最粗略的想法，然后找导师问问，如果最粗略也没有，只要你脸皮够厚，直接找导师要，毕竟你拿奖了对导师也有好处，最好早点找导师，迟了可能导师人太多不要你，这是我个人意见，看看就好了。（竞赛真的要多参加哦，说不定有意外惊喜，我女朋友就是竞赛认识的）</p>  <h2>社团篇：</h2><p>社团粗略分为三类，学生会杭助非技术部这种干活交朋友写策划社团，滑轮滑板等兴趣社团，红家、杭电助手技术部这种技术社团，当然还有这种特点都有的社团，我大一参加了经济学院学生会，说一下体验吧，几乎学院一半的人都加入了学生会，你可以在里面交到各种各样的人，还有部门联谊，部长也很亲切，不过一般最亲切的还是同部门的人，举办活动还有东西吃圣诞节还会给你送糖果吃，如果你加入了也最好别退，因为你退了的话本来属于你的活就要平均分配到其他小干事身上和部长身上。其实本质来说哦，就是招你去干活的，事情会挺多，真的贼多，好多活动会轮到你们部门出策划，大家就想想法，出策划，不过等你们部门想的活动节目顺利办完了的时候还是有点小成就感的。我感觉我不适合这种部门，而且竞赛和学业这两个事情有可能会和社团的事情重合，那就有你的爽了。兴趣社团我也去，杭助也才刚刚二面，等体验过了以后再说。</p><hr><p>  最后说说我最近的状态吧，等转到计算机，我熬夜已经成为常态，天天1点睡，4天有早课，然后水课补课，主要选了acm（这课很值），数据结构这种课，要花好长时间写作业，还有报了社团，得花很多时间学东西，还有勤工俭学，帮老师改作业，事情太多了，感觉最近人有点累和迷茫了，得找个时间出去散散心。<br>    1、不是特别清楚下一步怎么走，不知道怎么找老师怎么找项目做，2、不知道从学校到实习这一步改怎么走（打算问问已经工作学长学姐），3、不知道怎么去规划自己的后端学习路线（打算问问部长），好迷茫压，感觉最近学习效率也不高，学了一会不想学了。算了，其实也没关系，都是有办法解决的，跨过这座山，他们就会听见你的故事，先写到这里吧，等我 把这3个问题都解决了就更我的未来学习打算，恋爱部分这边不提了，我整一个完整的板块写。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分模块刷力扣题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/1%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E7%89%9B%E5%AE%A2%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/1%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E7%89%9B%E5%AE%A2%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><style>table th:first-of-type {    width: 20%;}table th:nth-of-type(2) {    width: 50%;}table th:nth-of-type(3) {    width: 20%;} table th:nth-of-type(4) {    width: 30%;}</style><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">题目</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">万万没想到之抓捕孔连顺</td><td align="center"></td><td align="center">golang</td><td align="center">普通</td></tr><tr><td align="center">机器人跳跃问题</td><td align="center">认真读题目</td><td align="center">golang</td><td align="center">普通</td></tr><tr><td align="center">选区间</td><td align="center"></td><td align="center">c</td><td align="center">中等</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">万万没想到之聪明的编辑</td><td align="center"></td><td align="center">go</td><td align="center">入门</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">字节跳动附加题</td><td align="center">熟悉了递推式</td><td align="center">go</td><td align="center">普通</td></tr><tr><td align="center">编程题2</td><td align="center"></td><td align="center">go</td><td align="center">中等</td></tr><tr><td align="center">字母交换</td><td align="center">看懂递推式</td><td align="center">c</td><td align="center">普通</td></tr><tr><td align="center">毕业旅行问题</td><td align="center">学会压缩状态动态规划</td><td align="center">c</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">头条校招</td><td align="center"></td><td align="center">go</td><td align="center">普通</td></tr><tr><td align="center">最大点集</td><td align="center"></td><td align="center">c</td><td align="center">普通</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MT4 直方图内最大矩形</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/MT4%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%86%85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/MT4%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%86%85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="直方图内最大矩形"><a href="#直方图内最大矩形" class="headerlink" title="直方图内最大矩形"></a><font size=6px>直方图内最大矩形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组heights，长度为n，height[i]是在第i点的高度，那么height[i]表示的直方图，能够形成的最大矩形是多少?</p><p>1.每个直方图宽度都为1</p><p>2.直方图都是相邻的</p><p>3.如果不能形成矩形，返回0即可</p><p>4.保证返回的结果不会超过231-1</p><p>数据范围:</p><p>0 &lt;&#x3D; heights[i] &lt;&#x3D; 10^40&lt;&#x3D;<em>h<strong>e</strong>i<strong>g</strong>h<strong>t</strong>s</em>[<em>i</em>]&lt;&#x3D;104</p><p>0 &lt;&#x3D; heights.length &lt;&#x3D;10^50&lt;&#x3D;<em>h<strong>e</strong>i<strong>g</strong>h<strong>t</strong>s</em>.<em>l<strong>e</strong>n<strong>g</strong>t**h</em>&lt;&#x3D;105</p><p>如输入[3,4,7,8,1,2]，那么如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20211106/301499_1636186669482/D4212B8149018E3A3A42996A461EA3FC" alt="img"></p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><pre><code class="hljs accesslog"><span class="hljs-string">[3,4,7,8,1,2]</span></code></pre><p>复制</p><p>返回值：</p><pre><code class="hljs">14</code></pre><p>复制</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><pre><code class="hljs dns">[<span class="hljs-number">1,7,3,2</span>,<span class="hljs-number">4,5,8,2</span>,<span class="hljs-number">7</span>]</code></pre><p>返回值：</p><pre><code class="hljs">16</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>单调栈思路做，如果一个数比之前的大就入栈，确保栈里面的数据是有序的，然后遇到比自己小的就出栈直到栈有序，这里有个技巧是加入哨兵就可以简化判断边界情况的复杂度。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">( heights []<span class="hljs-type">int</span> )</span></span> <span class="hljs-type">int</span> &#123;        <span class="hljs-keyword">var</span>  stack []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> heights == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-comment">// 插入一个数防止栈空</span>    stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-number">0</span>)    heights = <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;, heights...)    maxNum := heights[<span class="hljs-number">1</span>]    heights = <span class="hljs-built_in">append</span>(heights, <span class="hljs-number">-1</span>)    n := <span class="hljs-built_in">len</span>(heights)    secondTop := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        top := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack )&gt;<span class="hljs-number">1</span>&#123;            secondTop = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-2</span>]        &#125;<span class="hljs-keyword">else</span>&#123;            secondTop = top        &#125;            <span class="hljs-keyword">for</span> heights[top]&gt;heights[i]&#123;                maxNum = max((i - secondTop<span class="hljs-number">-1</span>) * heights[top], maxNum)                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]                top = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">1</span>&#123;                    secondTop = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-2</span>]                &#125;<span class="hljs-keyword">else</span>&#123;                    secondTop = top                &#125;            &#125;        stack = <span class="hljs-built_in">append</span>(stack, i)    &#125;    <span class="hljs-keyword">return</span> maxNum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：35ms超过56.52% 用Go提交的代码<br>   占用内存：10292KB超过39.13%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MT1 最大差值</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/MT1%20%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/MT1%20%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="最大差值"><a href="#最大差值" class="headerlink" title="最大差值"></a><font size=6px>最大差值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有一个长为 n 的数组 A ，求满足 0 ≤ a ≤ b &lt; n 的 A[b] - A[a] 的最大值。</p><p>给定数组 A 及它的大小 n ，请返回最大差值。</p><p>数据范围： 2 &lt; n \le 2<em>10^5\2&lt;<em>n</em>≤2∗105 ，数组中的值满足 0 \le |val| \le 5</em>10^8 \0≤∣<em>v<strong>a</strong>l</em>∣≤5∗108 </p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><pre><code class="hljs angelscript"><span class="hljs-string">[5,1]</span>,<span class="hljs-number">2</span></code></pre><p>复制</p><p>返回值：</p><pre><code class="hljs">0</code></pre><p>复制</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><pre><code class="hljs angelscript"><span class="hljs-string">[5,6]</span>,<span class="hljs-number">2</span></code></pre><p>复制</p><p>返回值：</p><pre><code class="hljs">1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>模拟即可</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">class Solution &#123;public:    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * @param A int整型vector </span><span class="hljs-comment">     * @param n int整型 </span><span class="hljs-comment">     * @return int整型</span><span class="hljs-comment">     */</span>    <span class="hljs-type">int</span> getDis(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> n) &#123;        <span class="hljs-comment">// write code here</span>        <span class="hljs-keyword">if</span> (A.size() &lt;n)&#123;            n = A.size();        &#125;        <span class="hljs-type">int</span> min = A[<span class="hljs-number">0</span>];        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n;i++)&#123;            <span class="hljs-keyword">if</span>(min &gt; A[i])&#123;                min = A[i];            &#125;            res = max(res, A[i]-min);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：55ms,超过64.24% 用C++提交的代码<br>   占用内存：8060KB ,超过33.24%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万万没想到之抓捕孔连顺</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E6%8A%93%E6%8D%95%E5%AD%94%E8%BF%9E%E9%A1%BA/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E6%8A%93%E6%8D%95%E5%AD%94%E8%BF%9E%E9%A1%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="万万没想到之抓捕孔连顺"><a href="#万万没想到之抓捕孔连顺" class="headerlink" title="万万没想到之抓捕孔连顺"></a><font size=6px>万万没想到之抓捕孔连顺</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议</p><ol><li><p>我们在字节跳动大街的N个建筑中选定3个埋伏地点。</p></li><li><p>为了相互照应，我们决定相距最远的两名特工间的距离不超过D。</p></li></ol><p>我特喵是个天才! 经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！</p><p>……</p><p>万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！</p><p>请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。</p><p>注意：</p><ol><li><p>两个特工不能埋伏在同一地点</p></li><li><p>三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用</p></li></ol><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs mathematica">第一行包含空格分隔的两个数字 <span class="hljs-built_in">N</span>和<span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span> ≤ <span class="hljs-built_in">N</span> ≤ <span class="hljs-number">1000000</span><span class="hljs-operator">;</span> <span class="hljs-number">1</span> ≤ <span class="hljs-built_in">D</span> ≤ <span class="hljs-number">1000000</span><span class="hljs-punctuation">)</span>第二行包含<span class="hljs-built_in">N</span>个建筑物的的位置，每个位置用一个整数（取值区间为<span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-number">1000000</span><span class="hljs-punctuation">]</span>）表示，从小到大排列（将字节跳动大街看做一条数轴）</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs dns">一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 <span class="hljs-number">99997867</span> 取模</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs gcode">可选方案 <span class="hljs-comment">(1, 2, 3)</span>, <span class="hljs-comment">(1, 2, 4)</span>, <span class="hljs-comment">(1, 3, 4)</span>, <span class="hljs-comment">(2, 3, 4)</span></code></pre><p>示例2</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">19</span><span class="hljs-symbol">1 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">50</span></code></pre><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">1</code></pre><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs gcode">可选方案 <span class="hljs-comment">(1, 10, 20)</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先选一个数，然后从后开始遍历找到符合条件（num【j】-num【i】&lt;&#x3D;distance）的第一个数，然后从i+1到j里面选2个数字出来就可以，排列组合问题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a, n, dis,i,j,sum <span class="hljs-type">int</span>mod := <span class="hljs-number">99997867</span>fmt.Scan(&amp;n, &amp;dis)<span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span> &#123;fmt.Println(<span class="hljs-number">0</span>)&#125; <span class="hljs-keyword">else</span> &#123;num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;fmt.Scan(&amp;a)num[i] = a&#125;<span class="hljs-keyword">for</span> i ,j= <span class="hljs-number">0</span>, <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<span class="hljs-keyword">for</span> ;i&gt;=<span class="hljs-number">2</span>&amp;&amp;num[i]-num[j]&gt;dis;&#123;j++&#125;sum += ((i-j)*(i-j<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)&#125;&#125;sum %= modfmt.Println(sum)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：510ms, 超过77.73%用Go提交的代码<br>   占用内存：5636KB, 超过75.78%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为2016校园招聘上机笔试题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%8D%8E%E4%B8%BA2016%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E4%B8%8A%E6%9C%BA%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%8D%8E%E4%B8%BA2016%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E4%B8%8A%E6%9C%BA%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs gcode">时间复杂度：<span class="hljs-comment">()</span>,空间复杂度：<span class="hljs-comment">()</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019-8-19字节校招笔试</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/2019-8-19%E5%AD%97%E8%8A%82%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/2019-8-19%E5%AD%97%E8%8A%82%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1、上学闹钟"><a href="#1、上学闹钟" class="headerlink" title="1、上学闹钟"></a>1、<font size=6px>上学闹钟</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p> 题目从牛客网上找</p><p>小明定了n个闹钟，他只能在闹钟响起时出发去学校，每个闹钟时间分别为hi点mi分，小明家到学校要x分钟，学校上课时间a点b分 （0-24 小时，0-59分钟），求他最晚几点起 </p><blockquote><p>   输入：  </p><p>   3 &#x2F;&#x2F;定了几个闹钟<br> 5 0 &#x2F;&#x2F;第1个闹钟的小时数和分钟数<br> 6 0   &#x2F;&#x2F;第2个闹钟的小时数和分钟数<br> 7 0   &#x2F;&#x2F;第3个闹钟的小时数和分钟数<br> 59 &#x2F;&#x2F;到学校要多少分钟<br> 6 59   &#x2F;&#x2F;上课的小时数和分钟数  </p><p>   输出：  </p><p>   6 0 &#x2F;&#x2F;最晚的起床时间</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以把时间都换成分钟，然后从大到小排序，找到第一个能够到达的闹钟从而找到起床时间。</p><pre><code class="hljs pgsql">// 这是别的人ac代码struct <span class="hljs-type">Time</span>&#123;    <span class="hljs-type">int</span> h;    <span class="hljs-type">int</span> m;    friend <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">Time</span> a, <span class="hljs-type">TIme</span> b)&#123;        <span class="hljs-keyword">if</span>(a.h == b.h)&#123;            <span class="hljs-keyword">return</span> a.m &gt; b.m;        &#125;        <span class="hljs-keyword">return</span> a.h &gt; b.h;    &#125;&#125;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n, x, a, b, rest;cin &gt;&gt; n;<span class="hljs-type">Time</span>* <span class="hljs-type">time</span> = (<span class="hljs-type">Time</span>*)malloc(n * sizeof(<span class="hljs-type">Time</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;cin &gt;&gt; <span class="hljs-type">time</span>[i].h &gt;&gt; <span class="hljs-type">time</span>[i].m;&#125;sort(<span class="hljs-type">time</span>, <span class="hljs-type">time</span> + n);cin &gt;&gt; x;cin &gt;&gt; a &gt;&gt; b;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;rest = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (<span class="hljs-type">time</span>[i].h &lt; a || <span class="hljs-type">time</span>[i].h == a &amp;&amp; <span class="hljs-type">time</span>[i].m &lt; b)&#123;rest = (a - <span class="hljs-type">time</span>[i].h) * <span class="hljs-number">60</span> + b - <span class="hljs-type">time</span>[i].m;<span class="hljs-keyword">if</span> (rest &gt;= x)&#123;cout &lt;&lt; <span class="hljs-type">time</span>[i].h &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-type">time</span>[i].m &lt;&lt; endl;break;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="2-加密通信-O-n"><a href="#2-加密通信-O-n" class="headerlink" title="2. 加密通信 O(n)"></a>2. 加密通信 O(n)</h2><p>小明和小红采用密码加密通信，每次通信有固定的明文长度n和加密次数k。 </p><p>  比如：密码二进制明文是1001010，加密次数是4，则每次将密文右移1位与明文做异或操作 ，总共位移3次（k&#x3D;4, 所以 k - 1 &#x3D; 3） </p><blockquote><p>   输入：  </p><p>   7 4 &#x2F;&#x2F; n k<br>   1110100110 &#x2F;&#x2F;密文  </p><p>   输出：<br>   1001010 &#x2F;&#x2F;明文  </p><p>   解释：  </p><p>   1001010—<br>   -1001010–<br>   –1001010-<br>   —1001010<br>   加密次数为4，故对于明文右移4-1&#x3D;3轮，每轮与当前密文进行一次异或，故  1001010对应密文为  1110100110</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>前置知识：异或的数字异或一次就会变成原数字，举例，101 和011 异或成110，110和011 异或之后变成原来数字101。</p><p>首先密文和明文 <strong>第1位是一样的</strong>，看一下上方样例里的解释就懂了。 </p><p>  然后考虑 <strong>第2到k-1位</strong>，可以发现这一段的每一位都是由 <strong>前一位密文的</strong> <strong>异或</strong> <strong>结果</strong> <strong>再</strong> <strong>与当前位明文异或</strong>得到的。 </p><p>  接下来考虑 <strong>第k到n-1位</strong>，观察规律可以发现这一段的每一位都是由 <strong>前一位密文与第i-k位明文异或得到的结果再与当前位明文异或</strong>得到的。 </p><p>  如何消除异或影响大家应该都能理解，因此只要把参与异或的部分再与密文异或一下即可得到明文。</p><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<span class="hljs-built_in">int</span> n, k, tmp;<span class="hljs-built_in">string</span> s,ans=<span class="hljs-string">&quot;&quot;</span>;cin &gt;&gt; n &gt;&gt; k;cin &gt;&gt; s;ans += s[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; k; i++)&#123;tmp = (<span class="hljs-built_in">int</span>)(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) ^ (<span class="hljs-built_in">int</span>)(s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>);ans += tmp + <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = k; i &lt; n; i++)&#123;ans += (<span class="hljs-built_in">int</span>)(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) ^ (<span class="hljs-built_in">int</span>)(s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) ^ (<span class="hljs-built_in">int</span>)(ans[i - k] - <span class="hljs-string">&#x27;0&#x27;</span>) + <span class="hljs-string">&#x27;0&#x27;</span>;&#125;cout &lt;&lt; ans;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="3-发工资O-n-x2F-O-nlogn"><a href="#3-发工资O-n-x2F-O-nlogn" class="headerlink" title="3.发工资O(n)&#x2F;O(nlogn)"></a>3.发工资O(n)&#x2F;O(nlogn)</h2><p>王大锤要给员工发工资，员工从左到右坐成一排，每个员工知道彼此的资历，每个员工只知道自己左右员工的工资，如果某员工比左边或右边的人资历老，那他一定比这个人工资高100元，每个人最低工资100元，求王大锤最低给多少工资。 </p><blockquote><p>   样例  </p><p>   输入：  </p><p>   4 &#x2F;&#x2F;几个员工<br> 3 9 2 7 &#x2F;&#x2F;员工顺序以及对应的资历  </p><p>   输出：<br> 600 &#x2F;&#x2F;100  元，20  0元，100元，200元</p><p> 6<br> 1 2 3 4 5 6<br> 2100 &#x2F;&#x2F;100，200，300，400，500，600</p><p> 5<br> 1 1 1 1 1  </p><p>   500 &#x2F;&#x2F;100，100，100，100，100  </p><p> 8<br> 1 2 3 4 3 2 3 4  </p><p>   1800 &#x2F;&#x2F;100 200 300 400 200 100 200 300<br> 8<br> 3 4 3 4 3 4 3 4  </p><p>   1200 &#x2F;&#x2F;100 200 100 200 100 200 100 200<br> 5<br> 1 2 3 4 1   </p><p>   1100 &#x2F;&#x2F;100 200 300 400 500</p></blockquote><h4 id="思路1-（时间复杂度为o（n））"><a href="#思路1-（时间复杂度为o（n））" class="headerlink" title="思路1 （时间复杂度为o（n））"></a>思路1 （时间复杂度为o（n））</h4><p><strong>广度优先搜索</strong>，可以把员工序列看作一棵 <strong>多根树</strong>，每个 <strong>工资最低的员工就是根节点</strong>，一个员工的工资其实就是他在 <strong>多根树里的深度</strong>， </p><p>  首先在输入的时候找到比左右资历都年轻的员工入队，每次从队列pop一个员工，然后判断该员工的最小工资，然后判断左右员工是否可以入队，直到所有员工出队</p><pre><code class="hljs excel"><span class="hljs-built_in">int</span> main() &#123;<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">now</span>;long long ans = <span class="hljs-number">0</span>;cin &gt;&gt; <span class="hljs-built_in">n</span>;<span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> == <span class="hljs-number">0</span>)&#123;cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;return <span class="hljs-number">0</span>;&#125;vector&lt;<span class="hljs-built_in">int</span>&gt; epy(<span class="hljs-built_in">n</span>, <span class="hljs-number">0</span>), depth(<span class="hljs-built_in">n</span>, <span class="hljs-number">0</span>);queue&lt;<span class="hljs-built_in">int</span>&gt; sal;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++)&#123;cin &gt;&gt; epy[i];<span class="hljs-built_in">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; epy[i - <span class="hljs-number">1</span>] &lt;= epy[i - <span class="hljs-number">2</span>] &amp;&amp; epy[i - <span class="hljs-number">1</span>] &lt;= epy[i])&#123;depth[i - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;sal.push(i - <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-built_in">if</span> (epy[<span class="hljs-number">0</span>] &lt;= epy[<span class="hljs-number">1</span>])&#123;depth[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;sal.push(<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">if</span> (epy[<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>] &lt;= epy[<span class="hljs-built_in">n</span> - <span class="hljs-number">2</span>])&#123;depth[<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;sal.push(<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>);&#125;while (!sal.empty())&#123;<span class="hljs-built_in">now</span> = sal.front();<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = (<span class="hljs-built_in">now</span> &gt; <span class="hljs-number">0</span> &amp;&amp; epy[<span class="hljs-built_in">now</span>-<span class="hljs-number">1</span>] &lt; epy[<span class="hljs-built_in">now</span>]) ? depth[<span class="hljs-built_in">now</span> - <span class="hljs-number">1</span>] <span class="hljs-symbol">:</span> <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = (<span class="hljs-built_in">now</span> &lt; <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span> &amp;&amp; epy[<span class="hljs-built_in">now</span> + <span class="hljs-number">1</span>] &lt; epy[<span class="hljs-built_in">now</span>]) ? depth[<span class="hljs-built_in">now</span> + <span class="hljs-number">1</span>] <span class="hljs-symbol">:</span> <span class="hljs-number">0</span>;sal.pop();<span class="hljs-built_in">if</span> (depth[<span class="hljs-built_in">now</span>] == <span class="hljs-number">0</span>)&#123;depth[<span class="hljs-built_in">now</span>] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>) + <span class="hljs-number">1</span>;&#125;//<span class="hljs-built_in">left</span><span class="hljs-built_in">if</span> (<span class="hljs-built_in">now</span> &gt; <span class="hljs-number">0</span> &amp;&amp; depth[<span class="hljs-built_in">now</span> - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; (<span class="hljs-built_in">now</span> == <span class="hljs-number">1</span> || epy[<span class="hljs-built_in">now</span> - <span class="hljs-number">2</span>] &gt; epy[<span class="hljs-built_in">now</span> - <span class="hljs-number">1</span>] || depth[<span class="hljs-built_in">now</span> - <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>))&#123;sal.push(<span class="hljs-built_in">now</span> - <span class="hljs-number">1</span>);&#125;//<span class="hljs-built_in">right</span><span class="hljs-built_in">if</span> (<span class="hljs-built_in">now</span> &lt; <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span> &amp;&amp; (depth[<span class="hljs-built_in">now</span> + <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">now</span> == <span class="hljs-built_in">n</span> - <span class="hljs-number">2</span> || epy[<span class="hljs-built_in">now</span> + <span class="hljs-number">2</span>] &gt; epy[<span class="hljs-built_in">now</span> + <span class="hljs-number">1</span>] || depth[<span class="hljs-built_in">now</span> + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>))&#123;sal.push(<span class="hljs-built_in">now</span> + <span class="hljs-number">1</span>);&#125;&#125;for (auto salary <span class="hljs-symbol">:</span> depth) &#123;ans += salary;&#125;cout &lt;&lt; ans * <span class="hljs-number">100</span> &lt;&lt; endl;&#125;</code></pre><h4 id="思考2-（时间复杂度olog（n））"><a href="#思考2-（时间复杂度olog（n））" class="headerlink" title="思考2 （时间复杂度olog（n））"></a>思考2 （时间复杂度olog（n））</h4><p>用贪心思路，先全部输入结构体内，然后按照分数大小排序，从最小的开始如果旁边有没有分数那就是100，如果有就比有分数最高的多100.</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CI/CD介绍</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/CI:CD%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/CI:CD%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>持续集成，持续交付和持续部署是人们谈论现代开发实践时常提到的几个概念，三者究竟是什么，又有何联系和区别呢？我们翻译了以下这篇文章来探讨这些问题。</p><p>第一次开始学习持续集成和持续交付的时候，想必很多人都多多少少有一些疑惑。别着急，在理解这些术语之前，我们首先需要知道一个概念———<strong>流水线</strong>（pipeline）。</p><blockquote><p>在软件开发领域，流水线就是一系列流程的序列，例如按照顺序一个接着一个执行的过程或者指令。有的时候，上一步的输出即是下一步的输入。</p></blockquote><p>在详述每个连续性流程的细节之前，我们可以先来看一看组成流水线的步骤：</p><p>首先，将在本地进行的代码更改提交并推送到中央仓库中；接下来，通过一个自动系统将其检出，该系统将项目构建为我们的浏览器可以理解的代码段；然后针对代码进行测试以确保我们的更改没有任何中断，最后部署到用户可以使用的最终环境。</p><p>这些步骤实质上构成了持续集成&#x2F;持续部署的核心，并且一起构成了软件开发的流程。既然已经知道了流水线是什么，我们接下来谈谈本文的重点。</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a><strong>持续集成</strong></h2><p>顾名思义，<strong>持续集成</strong>（Continuous integration，简称 CI）是指每次对代码库进行更改时都运行集成测试。每当提交更改并将其推送到代码仓库时，持续集成系统都会重建分支，并运行所有相关的测试用例，以验证新更改不会破坏现有应用程序的运行。然而要实施持续集成，必须满足一些先决条件。</p><p><strong>条件是什么</strong></p><p>为了使应用程序做好持续集成的准备，需要事先采取一些措施。最显而易见的是如果没有构建系统或测试要运行，则无法构建和测试应用程序。尽管看起来可能要花费额外的精力（特别是在代码没有进行过任何测试的情况下），持续集成可以带来很多好处。例如，自动化单元和集成测试能够在 bug 进入生产环境之前就捕获它们，这样一来更少的 bug 会被交付到生产中。事实上，防止一个潜在 bug 进入生产阶段的有效措施就是用一个测试用例覆盖它们，以确保它们不会导致产品回滚。除此之外，由于持续集成可以在短短几分钟内运行数百个测试用例，花费在手动测试上的时间也将大大减少，这意味着测试人员可以专注于更重要的改进而不是耗费大量精力在反复测试现有功能上。</p><p>为了进一步开发和拓展持续集成机制以实现更高的自动化程度，我们引进了持续交付这一理念。</p><h2 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h2><p><strong>持续交付</strong>（Continuous delivery，简称 CD）是持续集成的扩展。从本质上讲，这意味着每次代码更改通过测试时都要对其进行重新部署。这不仅自动化了构建和测试阶段，而且还自动化了大部分发布过程，运维人员只要点一下按钮就可以部署应用程序。</p><p>和持续集成相比，持续交付的好处是什么？</p><p>有了持续交付，由于在构建和测试应用程序后大部分步骤已经自动化，部署的复杂性得以降低。开发团队可以加快迭代速度并部署更小的更改，从而减少引入生产 bug 的可能性。通过持续交付，我们可以更轻松地定位 bug并将其修复。</p><h2 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h2><p>持续交付是持续集成的扩展，而部署则建立在交付之上。与持续交付相比，<strong>持续部署</strong>（Continuous deployment，简称 CD）更进一步，因为它可以自动将代码更改部署到生产中而无需人工干预。这也意味着为了避免出现回滚和其他问题，您的测试包必须是一流的，因为它决定了您的发布过程。</p><p>在持续交付的基础上，项目团队将获取更快的部署速度，因为每项更改都可以进行自动处理，代码合并后几分钟就能够在生产环境中看到本地开发的功能；另一方面，代码发布的风险也能够进一步降低，因为您应该尽可能进行小批量部署，这样的话在出现任何问题时更容易排除故障。通过所有这些连续性环节，最终用户将体验到应用程序中的持续改进，而不是时不时看到重大版本的变化。</p><p>最后，为了可视化整个过程以及这三个概念之间的核心区别，以下这张流程图可以加深您的印象。</p><p><img src="https://pic4.zhimg.com/80/v2-cf2cd577a31d628709abcd4b9d5376c3_1440w.jpg" alt="img"></p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/103554905">https://zhuanlan.zhihu.com/p/103554905</a></p>]]></content>
    
    
    <categories>
      
      <category>自动化博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac自动push</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/mac%E8%87%AA%E5%8A%A8push/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/mac%E8%87%AA%E5%8A%A8push/</url>
    
    <content type="html"><![CDATA[<h3 id="1、编写脚本"><a href="#1、编写脚本" class="headerlink" title="1、编写脚本"></a>1、编写脚本</h3><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> upload.<span class="hljs-keyword">sh</span></code></pre><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">plist</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="hljs-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>upload.github.code.plist<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>ProgramArguments<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/Users/jie/Desktop/myblog/upload.sh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span> //脚本位置<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>StartCalendarInterval<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Minute<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">integer</span>&gt;</span>   //每天18点执行一次        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Hour<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-name">integer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>KeepAlive<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">false</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>RunAtLoad<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span></code></pre><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">cd</span> /Users/jie/Desktop/mybloggit add .git commit -m <span class="hljs-string">&quot;update&quot;</span>git push</code></pre><p>给权限</p><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">755</span> upload.sh</code></pre><h3 id="2、建立plist"><a href="#2、建立plist" class="headerlink" title="2、建立plist"></a>2、建立plist</h3><pre><code class="hljs awk">cd <span class="hljs-regexp">/Library/</span>LaunchDaemons/sudo vim upload.github.code.plist</code></pre><pre><code class="hljs stylus">plutil -lint upload<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.plist</span> 检查是否编写错误chmod <span class="hljs-number">600</span> upload<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.plist</span>  给权限sudo launchctl load upload<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.plist</span> 加载脚本sudo launchctl start upload<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.plist</span> 开始脚本</code></pre>]]></content>
    
    
    <categories>
      
      <category>自动化博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动2017客户端工程师实习生笔试题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82017%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82017%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="4、或与加"><a href="#4、或与加" class="headerlink" title="4、或与加"></a><font size=6px>4、或与加</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定 x, k ，求满足 x + y &#x3D; x | y 的第 k 小的正整数 y 。 | 是二进制的或(or)运算，例如 3 | 5 &#x3D; 7。</p><p>比如当 x&#x3D;5，k&#x3D;1时返回 2，因为5+1&#x3D;6 不等于 5|1&#x3D;5，而 5+2&#x3D;7 等于 5 | 2 &#x3D; 7。</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><pre><code class="hljs llvm">每组测试用例仅包含一组数据，每组数据为两个正整数 <span class="hljs-keyword">x</span> <span class="hljs-punctuation">,</span> k。 满足 <span class="hljs-number">0</span> &lt; <span class="hljs-keyword">x</span> <span class="hljs-punctuation">,</span> k ≤ <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">000</span><span class="hljs-punctuation">,</span><span class="hljs-number">000</span><span class="hljs-punctuation">,</span><span class="hljs-number">000</span>。</code></pre><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><pre><code class="hljs">输出一个数y。</code></pre><h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">1</span></code></pre><h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><pre><code class="hljs">2</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>x+y&#x3D;x|y </p><p>  这里可以推出一个结论，x&amp;y&#x3D;0。也就是说，在二进制上看，x取1的地方，y必定不能取1。从最低位考虑，若x与y在某一位上同时取1，则x+y在该位上为0，x|y在该位上为1，前面说这是最低一位x  y同时取1，也就是说没有更低位加法的进位，所以这里两个结果不相等，出现了矛盾。 </p><p>  例子： </p><p>  x &#x3D; 001010 </p><p>  y &#x3D; 110110 </p><p>  x + y &#x3D;  1000000 </p><p>  x | y &#x3D; 111110 </p><p>  偏差产生的原因是倒数第二位，x+y&#x3D;0 x|y&#x3D;1 且倒数第一位加法没有进位 </p><p>  结论：<strong>x在二进制取1的位上，y不能做出改变，只能取0</strong></p><p>  —-方法—-</p><p>  有了上述结论，可以进一步推出只要在x取0的地方，y可以做出改变</p><p>  例如</p><p>  x &#x3D; 10010010011</p><p>  y &#x3D; 00000000(0)00  k &#x3D; 0</p><p>  y &#x3D; 00000000(1)00  k &#x3D; 1</p><p>  y &#x3D; 0000000(1)(0)00 k &#x3D; 2</p><p>  y &#x3D; 0000000(1)(1)00 k &#x3D; 3</p><p>  y &#x3D; 00000(1)0(0)(0)00 k &#x3D; 4</p><p>  y &#x3D; 00000(1)0(0)(1)00 k &#x3D; 5</p><p>  …</p><p>  注意观察括号里的数，为x取0的比特位，而如果把括号里的数连起来看，正好等于k。</p><p>  得出结论，<strong>把k表示成二进制数，填入x取0的比特位，x取1的比特位保持为0，得到y</strong>。 </p><p>  —代码说明—</p><p>  思路有了，接着就是代码，显然用位操作是最合适的方式。 </p><p>  循环的思想是每次取得k的最低一位，填入到低位开始，x中比特位为0的位置上。 </p><p>  所以用while来判断k是否大于0，若是，说明k还未完全填完 </p><p>  循环体内，需要找到x当前可以填的位置，我们用bitNum来从右往左扫描x的每一位 </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈git的使用</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%B5%85%E8%B0%88git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%B5%85%E8%B0%88git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="观前提醒：我写这个主要是来巩固我学的git操作"><a href="#观前提醒：我写这个主要是来巩固我学的git操作" class="headerlink" title="观前提醒：我写这个主要是来巩固我学的git操作"></a><p class="note note-primary">观前提醒：我写这个主要是来巩固我学的git操作</p></h2><p>在程序中#这个符号后面代表我的注释</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h4 id="0、先安装git，这里我引用别人的文章git安装"><a href="#0、先安装git，这里我引用别人的文章git安装" class="headerlink" title="0、先安装git，这里我引用别人的文章git安装"></a>0、先安装git，这里我引用别人的文章<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">git安装</a></h4><h4 id="1、创建一个文件夹，创建一个readme-txt文件，里面写入hello-git文字（这个之后会用到）"><a href="#1、创建一个文件夹，创建一个readme-txt文件，里面写入hello-git文字（这个之后会用到）" class="headerlink" title="1、创建一个文件夹，创建一个readme.txt文件，里面写入hello git文字（这个之后会用到）"></a>1、创建一个文件夹，创建一个readme.txt文件，里面写入hello git文字（这个之后会用到）</h4><h4 id="2、在文件夹中右键，会有一个Git-Bosh-Here，点这个"><a href="#2、在文件夹中右键，会有一个Git-Bosh-Here，点这个" class="headerlink" title="2、在文件夹中右键，会有一个Git Bosh Here，点这个"></a>2、在文件夹中右键，会有一个Git Bosh Here，点这个</h4><p><img src="/img/gitbosh.png"></p><h4 id="3、配置环境，输入提交人的名字和邮箱"><a href="#3、配置环境，输入提交人的名字和邮箱" class="headerlink" title="3、配置环境，输入提交人的名字和邮箱"></a>3、配置环境，输入提交人的名字和邮箱</h4><pre><code class="hljs stylus"><span class="hljs-variable">$git</span> config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;输入你的名字&quot;</span><span class="hljs-variable">$git</span> config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;输入你的邮箱&quot;</span><span class="hljs-variable">$git</span> config <span class="hljs-attr">--global</span> -l  #查看仓库配置，用来查看你是否配置成功</code></pre><h4 id="4-建立仓库"><a href="#4-建立仓库" class="headerlink" title="4.建立仓库"></a>4.建立仓库</h4><pre><code class="hljs autoit">$git init     <span class="hljs-meta">#会给你创建一个.git隐藏文件，用来存放你的操作记录，注意在你的路径里面最好不要有中文</span></code></pre><h2 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h2><p>创建好文件夹和txt文件之后，在git里面输入</p><pre><code class="hljs autoit">$git status <span class="hljs-meta">#查看现在的仓库状态</span></code></pre><p>会出现这样的语句</p><pre><code class="hljs smali">Untracked files:  <span class="hljs-comment">#有个未被跟踪的readme.txt文件</span>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include in what will be committed)        readme .txtno changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span><span class="hljs-built_in"> and/or </span><span class="hljs-string">&quot;git commit -a&quot;</span>)</code></pre><p>然后添加文件</p><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> readme.txt</code></pre><p>如果提交了没提示那就是提交正确了，输入了命令什么都没提示就是最好的提示。</p><p>最后提交文件</p><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m&quot;写你提交了什么东西，方便回溯的时候看回溯到哪个版本&quot;  #可以<span class="hljs-keyword">add</span>多个文件一起<span class="hljs-keyword">commit</span></code></pre><p>现在再输入git status会显示</p><pre><code class="hljs pgsql">$ git status<span class="hljs-keyword">On</span> branch dev<span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean #没有东西可以提交</code></pre><p>用 git log命令能知道提交人的id和提交日期</p><pre><code class="hljs llvm">$ git logcommit <span class="hljs-number">507671</span>f<span class="hljs-number">473</span>bbbfa<span class="hljs-number">18</span>ec<span class="hljs-number">0</span><span class="hljs-keyword">c</span><span class="hljs-number">2</span>de<span class="hljs-number">9</span>ed<span class="hljs-number">80</span><span class="hljs-keyword">c</span><span class="hljs-number">27</span><span class="hljs-keyword">cc</span><span class="hljs-number">483</span>b<span class="hljs-number">53</span>Author: jess-weigou &lt;<span class="hljs-number">895006375</span><span class="hljs-title">@qq.com</span>&gt;Date:   Fri Nov <span class="hljs-number">13</span> <span class="hljs-number">00</span>:<span class="hljs-number">10</span>:<span class="hljs-number">45</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span>wrote a readme.file</code></pre><p>用 git show命令能知道最近一个人的提交id，id后面回溯的时候要用到</p><pre><code class="hljs sql">$ git <span class="hljs-keyword">show</span><span class="hljs-keyword">commit</span> <span class="hljs-number">20</span>b009be6781d2fe5df568f8bf859bdf7e489408 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> dev) #这一串字母就是                                                                    #<span class="hljs-keyword">commit</span> idAuthor: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Thu Nov <span class="hljs-number">26</span> <span class="hljs-number">09</span>:<span class="hljs-number">44</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    write a readme.txt</code></pre><p>我们再在readme.txt文件中“hello git。”的基础上再添加“hello world”文字，并保存。</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>  我们来讲git最有趣的回溯功能,先用git log功能看提交的记录和提交人的id,这里我提交了多次。</p><pre><code class="hljs sql">$ git log<span class="hljs-keyword">commit</span> <span class="hljs-number">80</span>ee417c0d4eb1803202b762dbabe747fa38d1f6 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> dev)Author: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Mon Nov <span class="hljs-number">30</span> <span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    <span class="hljs-keyword">add</span> hello world<span class="hljs-keyword">commit</span> <span class="hljs-number">3</span>bb0b8bfb6f2f9178d31a4d0cb372b3d87b461aeAuthor: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Sun Nov <span class="hljs-number">29</span> <span class="hljs-number">09</span>:<span class="hljs-number">46</span>:<span class="hljs-number">26</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    <span class="hljs-keyword">add</span> hello world<span class="hljs-keyword">commit</span> <span class="hljs-number">20</span>b009be6781d2fe5df568f8bf859bdf7e489408Author: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Thu Nov <span class="hljs-number">26</span> <span class="hljs-number">09</span>:<span class="hljs-number">44</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    write a readme.txt<span class="hljs-keyword">commit</span> <span class="hljs-number">268</span>d66e08b1ebf50d9ddbf20096504592463051dAuthor: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Thu Nov <span class="hljs-number">26</span> <span class="hljs-number">09</span>:<span class="hljs-number">34</span>:<span class="hljs-number">36</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    write a readme.txt</code></pre><p>用git reset –hard “写提交的id”</p><pre><code class="hljs maxima">$ git <span class="hljs-built_in">reset</span> --hard <span class="hljs-number">20b009</span> #只要前几个字母id就可以匹配到你的提交idHEAD <span class="hljs-built_in">is</span> now <span class="hljs-built_in">at</span> 20b009b write a readme.txt</code></pre><p>这里说head指针已经指向20b009b,我们打开readme.txt，会发现写的“hello world”已经不见了。</p><p><strong>如果回退到以前的版本了还想回会到最新的版本，那咋办？</strong></p><p>找到之前git log的界面，就像我之前git log，那一条最新的日志记录</p><pre><code class="hljs sql">$ git log<span class="hljs-keyword">commit</span> <span class="hljs-number">80</span>ee417c0d4eb1803202b762dbabe747fa38d1f6 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> dev)Author: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Mon Nov <span class="hljs-number">30</span> <span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    <span class="hljs-keyword">add</span> hello world</code></pre><p>输入 git reset –hard “80ee417”就可以回退到之前的最新版本</p><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 80ee417c0</span>HEAD <span class="hljs-keyword">is</span> now at <span class="hljs-number">80</span>ee417 <span class="hljs-keyword">add</span> hello world</code></pre><p>你会发现hello world又出现了，所以别轻易清屏，清屏了也没关系，用git reflog查看历史命令</p><pre><code class="hljs pgsql">$ git reflog<span class="hljs-number">80</span>ee417 (HEAD -&gt; dev) HEAD@&#123;<span class="hljs-number">0</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">80</span>ee417c0<span class="hljs-number">20</span>b009b HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">20</span>b009<span class="hljs-number">80</span>ee417 (HEAD -&gt; dev) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> hello world<span class="hljs-number">3</span>bb0b8b HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> hello world<span class="hljs-number">20</span>b009b HEAD@&#123;<span class="hljs-number">4</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">write</span> a readme.txt<span class="hljs-number">268</span>d66e HEAD@&#123;<span class="hljs-number">5</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">write</span> a readme.txte845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">6</span>&#125;: checkout: moving <span class="hljs-keyword">from</span> master <span class="hljs-keyword">to</span> deve845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">7</span>&#125;: checkout: moving <span class="hljs-keyword">from</span> dev <span class="hljs-keyword">to</span> mastere845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">8</span>&#125;: checkout: moving <span class="hljs-keyword">from</span> master <span class="hljs-keyword">to</span> deve845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">9</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> e845<span class="hljs-number">507671</span>f HEAD@&#123;<span class="hljs-number">10</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">50767</span>e845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">11</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> <span class="hljs-keyword">some</span> words<span class="hljs-number">507671</span>f HEAD@&#123;<span class="hljs-number">12</span>&#125;: <span class="hljs-keyword">commit</span> (initial): wrote a readme.file</code></pre>]]></content>
    
    
    <categories>
      
      <category>自动化博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器自动拉取push到github上面的代码</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96push%E5%88%B0github%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96push%E5%88%B0github%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>d </p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>把hexo博客部署到windows服务器中</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%8A%8A%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%8A%8A%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary"; style="font-size:22px">   前提需要：一个三个月以上时间的windows服务器，一个已经备案好的域名，已经会熟悉使用hexo，为了把hexo从github中部署到自己的服务器中。</p><h4 id="1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码"><a href="#1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码" class="headerlink" title="1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码"></a>1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0geh1147mj20d808y0te.jpg"></p><h4 id="2、把IE增强的安全配置给关了（安全就代表麻烦），win-gt-服务器管理器-gt-IE增强的安全配置：启动点进去然后关闭"><a href="#2、把IE增强的安全配置给关了（安全就代表麻烦），win-gt-服务器管理器-gt-IE增强的安全配置：启动点进去然后关闭" class="headerlink" title="2、把IE增强的安全配置给关了（安全就代表麻烦），win-&gt;服务器管理器-&gt;IE增强的安全配置：启动点进去然后关闭"></a>2、把IE增强的安全配置给关了（安全就代表麻烦），win-&gt;服务器管理器-&gt;IE增强的安全配置：启动点进去然后关闭</h4><h4 id="3、下载宝塔-选windows版本，点下载，用来集成配置服务器的好工具"><a href="#3、下载宝塔-选windows版本，点下载，用来集成配置服务器的好工具" class="headerlink" title="3、下载宝塔,选windows版本，点下载，用来集成配置服务器的好工具"></a>3、下载<a href="https://www.bt.cn/">宝塔</a>,选windows版本，点下载，用来集成配置服务器的好工具</h4><p>、<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0geo2ismyj20is0eiabx.jpg"></p><h4 id="4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以"><a href="#4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以" class="headerlink" title="4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以"></a>4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以</h4><h4 id="5、宝塔先放放，等下再绑定域名，现在先下载-git和node-（点击可获得安装包，可能不是最新版的也可以去官网下载"><a href="#5、宝塔先放放，等下再绑定域名，现在先下载-git和node-（点击可获得安装包，可能不是最新版的也可以去官网下载" class="headerlink" title="5、宝塔先放放，等下再绑定域名，现在先下载**git和node **（点击可获得安装包，可能不是最新版的也可以去官网下载"></a>5、宝塔先放放，等下再绑定域名，现在先下载**<a href="http://hkctfsys.com/Git-2.30.0.2-64-bit.exe">git</a><strong>和</strong><a href="http://hkctfsys.com/node-v15.10.0-x64.msi">node</a> **（点击可获得安装包，可能不是最新版的也可以去官网下载</h4><p>下载完之后安装，一直点next就行）</p><p>node下载安装有一个注意点是,到这一步要选Add To Path</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gelil50mj20dz0b1dh7.jpg"></p><h4 id="6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git-bosh"><a href="#6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git-bosh" class="headerlink" title="6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git bosh"></a>6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git bosh</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gela2e7oj208a0a7mxd.jpg"></p><pre><code class="hljs undefined">npm install -g hexo-cli //如果没反应可以到cmd运行这个代码</code></pre><p>初始化hexo程序，如果有hexo 的人可以直接把hexo文件复制进去就可</p><pre><code class="hljs kotlin">hexo <span class="hljs-keyword">init</span></code></pre><p>然后输入</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span></code></pre><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span></code></pre><p>打开网页，输入<a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到hexo界面了，说明成功一大半了</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0geojqhh7j21800ouad9.jpg"></p><h4 id="7、下载和配置Nginx"><a href="#7、下载和配置Nginx" class="headerlink" title="7、下载和配置Nginx"></a>7、下载和配置Nginx</h4><p><a href="http://hkctfsys.com/nginx-1.16.1.zip">Nginx安装包</a>，下载了之后点击nginx-1.16.1-&gt;conf-&gt;nginx,这个文件用txt打开，然后把下放的root改成你hexo的public地方，其他不用改</p><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span> &#123;        <span class="hljs-keyword">listen</span>       <span class="hljs-number">80</span>;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.<span class="hljs-keyword">access</span>.<span class="hljs-keyword">log</span>  main;        <span class="hljs-keyword">location</span> / &#123;            root   C:\Users\Administrator\Desktop\hexo\<span class="hljs-built_in">public</span>;            <span class="hljs-keyword">index</span>  <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;        &#125;</code></pre><p>下面介绍为什么要下载nignx和为什么要把root 地址改成hexo的public文件夹，因为source文件夹中makedown文件执行hexo g被编译成html文件放在public文件夹中，并且把网站的根目录指向public文件夹，用Nginx反向代理使得人们可以访问我这个网站。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gene2lewj20m80dcjro.jpg"></p><h4 id="8、接下来让网站根目录指向public文件夹，打开宝塔软件-信息输入密码之后点保存，然后通过面板地址，http-f-x2F-hkctfsys-com-8990-x2F-OEsp376s（这是我的面板地址，在面板最上面找）"><a href="#8、接下来让网站根目录指向public文件夹，打开宝塔软件-信息输入密码之后点保存，然后通过面板地址，http-f-x2F-hkctfsys-com-8990-x2F-OEsp376s（这是我的面板地址，在面板最上面找）" class="headerlink" title="8、接下来让网站根目录指向public文件夹，打开宝塔软件,信息输入密码之后点保存，然后通过面板地址，http: f&#x2F;hkctfsys. com: 8990&#x2F;OEsp376s（这是我的面板地址，在面板最上面找）"></a>8、接下来让网站根目录指向public文件夹，打开宝塔软件,信息输入密码之后点保存，然后通过面板地址，http: f&#x2F;hkctfsys. com: 8990&#x2F;OEsp376s（这是我的面板地址，在面板最上面找）</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gekb9somj20jh0gmq4t.jpg"></p><p>然后点开网站-&gt;添加站点,把根目录指向hexo的public文件夹，大功告成啦</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gek24os0j216z0mxjth.jpg"></p><p>现在在浏览器里面输入你的域名，可以正常显示了</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gekr3d8lj21hc0szgt0.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>自动化博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>channel</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/channal/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/channal/</url>
    
    <content type="html"><![CDATA[<h4 id="往一个关闭的channal里面接收数据能够接收到吗"><a href="#往一个关闭的channal里面接收数据能够接收到吗" class="headerlink" title="往一个关闭的channal里面接收数据能够接收到吗"></a>往一个关闭的channal里面接收数据能够接收到吗</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)ch &lt;- <span class="hljs-number">1</span><span class="hljs-built_in">close</span>(ch)fmt.Println(&lt;-ch)fmt.Println(&lt;-ch)ch &lt;- <span class="hljs-number">1</span>&#125;</code></pre><p>可以，但是从channal里面拿就会panic</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1、能使用无缓存的channal做mutex吗"><a href="#1、能使用无缓存的channal做mutex吗" class="headerlink" title="1、能使用无缓存的channal做mutex吗"></a>1、能使用无缓存的channal做mutex吗</h3><p>虽然没有缓存，但是可以有一个放入，多个放出，放出可以抽象成争抢锁</p><p>1、设置一个goroutine，专门来放入，因为没有拿就阻塞了，如果有人拿就退出</p><p>2、有人拿了，没有被阻塞，说明拿到锁了，开始执行任务，然后执行完的时候重新启动一个goroutine来放入锁，等待下一个拿到锁的人。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Context</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/context/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/context/</url>
    
    <content type="html"><![CDATA[<h4 id="Context有什么作用"><a href="#Context有什么作用" class="headerlink" title="Context有什么作用"></a>Context有什么作用</h4><p>其主要的作用是在 goroutine 中进行上下文的传递，而在传递信息中又包含了 goroutine 的运行控制、上下文信息传递等功能。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57e9igvnkj21lc0cqwga.jpg"></p><p>例如在业务的高峰期，某个下游服务的响应变慢，而当前系统的请求又没有超时控制，或者超时时间设置地过大，那么等待下游服务返回数据的协程就会越来越多。而我们知道，协程是要消耗系统资源的，后果就是协程数激增，内存占用飙涨，甚至导致服务不可用。更严重的会导致雪崩效应，整个服务对外表现为不可用，这肯定是 P0 级别的事故。</p><p>但是在某些场景下，例如处理一个请求衍生了很多协程，这些协程之间是相互关联的：需要共享一些全局变量、有共同的 deadline 等，而且可以同时被关闭。再用 <code>channel+select</code> 就会比较麻烦，这时就可以通过 context 来实现。</p><p>一句话：context 用来解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能。</p><h3 id="context获取key的方式"><a href="#context获取key的方式" class="headerlink" title="context获取key的方式"></a>context获取key的方式</h3><ul><li>上面的例子我们获取<code>trace_id</code>是直接从当前<code>ctx</code>获取的，实际我们也可以获取父<code>context</code>中的<code>value</code>，在获取键值对是，我们先从当前<code>context</code>中查找，没有找到会在从父<code>context</code>中查找该键对应的值直到在某个父<code>context</code>中返回 <code>nil</code> 或者查找到对应的值。</li><li><code>context</code>传递的数据中<code>key</code>、<code>value</code>都是<code>interface</code>类型，这种类型编译期无法确定类型，所以不是很安全，所以在类型断言时别忘了保证程序的健壮性。</li></ul><h3 id="使用Context来控制协程"><a href="#使用Context来控制协程" class="headerlink" title="使用Context来控制协程"></a>使用Context来控制协程</h3><p>1、控制单个协程，context.WithCancel</p><pre><code class="hljs sqf">func reqTask(ctx context.Context, <span class="hljs-built_in">name</span> string) &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-built_in">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ctx.Done():fmt.Println(<span class="hljs-string">&quot;stop&quot;</span>, <span class="hljs-built_in">name</span>)return<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-built_in">name</span>, <span class="hljs-string">&quot;send request&quot;</span>)<span class="hljs-built_in">time</span>.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1</span> * <span class="hljs-built_in">time</span>.Second)&#125;&#125;&#125;func main() &#123;ctx, cancel := context.WithCancel(context.Background())go reqTask(ctx, <span class="hljs-string">&quot;worker1&quot;</span>)<span class="hljs-built_in">time</span>.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * <span class="hljs-built_in">time</span>.Second)cancel()<span class="hljs-built_in">time</span>.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * <span class="hljs-built_in">time</span>.Second)&#125;</code></pre><p>2、控制多个协程（多个协程间的同步）</p><pre><code class="hljs css">func <span class="hljs-selector-tag">main</span>() &#123;ctx, cancel := context.<span class="hljs-built_in">WithCancel</span>(context.<span class="hljs-built_in">Background</span>())go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker1&quot;</span>)go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker2&quot;</span>)time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)<span class="hljs-built_in">cancel</span>()time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)&#125;</code></pre><p>3、ctx 传递值，context.WithValue</p><pre><code class="hljs maxima">type Options struct&#123; Interval <span class="hljs-built_in">time</span>.Duration &#125;func reqTask(ctx <span class="hljs-built_in">context</span>.Context, name <span class="hljs-built_in">string</span>) &#123;<span class="hljs-keyword">for</span> &#123;select &#123;case &lt;-ctx.Done():fmt.Println(<span class="hljs-string">&quot;stop&quot;</span>, name)<span class="hljs-built_in">return</span>default:fmt.Println(name, <span class="hljs-string">&quot;send request&quot;</span>)<span class="hljs-built_in">op</span> := ctx.Value(<span class="hljs-string">&quot;options&quot;</span>).(*Options)<span class="hljs-built_in">time</span>.Sleep(<span class="hljs-built_in">op</span>.Interval * <span class="hljs-built_in">time</span>.Second)&#125;&#125;&#125;func main() &#123;ctx, cancel := <span class="hljs-built_in">context</span>.WithCancel(<span class="hljs-built_in">context</span>.Background())vCtx := <span class="hljs-built_in">context</span>.WithValue(ctx, <span class="hljs-string">&quot;options&quot;</span>, &amp;Options&#123;<span class="hljs-number">1</span>&#125;)<span class="hljs-built_in">go</span> reqTask(vCtx, <span class="hljs-string">&quot;worker1&quot;</span>)<span class="hljs-built_in">go</span> reqTask(vCtx, <span class="hljs-string">&quot;worker2&quot;</span>)<span class="hljs-built_in">time</span>.Sleep(<span class="hljs-number">3</span> * <span class="hljs-built_in">time</span>.Second)cancel()<span class="hljs-built_in">time</span>.Sleep(<span class="hljs-number">3</span> * <span class="hljs-built_in">time</span>.Second)&#125;</code></pre><p>4、控制执行时间，context.WithTimeout</p><pre><code class="hljs css">func <span class="hljs-selector-tag">main</span>() &#123;ctx, cancel := context.<span class="hljs-built_in">WithTimeout</span>(context.<span class="hljs-built_in">Background</span>(), <span class="hljs-number">2</span>*time.Second)go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker1&quot;</span>)go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker2&quot;</span>)time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;before cancel&quot;</span>)<span class="hljs-built_in">cancel</span>()time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)&#125;</code></pre><p>5、根据时间点来决定退出，context.WithDeadline</p><pre><code class="hljs css">func reqTask(ctx context<span class="hljs-selector-class">.Context</span>, name string) &#123;for &#123;select &#123;case &lt;-ctx<span class="hljs-selector-class">.Done</span>():fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;stop&quot;</span>, name, ctx.<span class="hljs-built_in">Err</span>())returndefault:fmt.<span class="hljs-built_in">Println</span>(name, <span class="hljs-string">&quot;send request&quot;</span>)time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1</span> * time.Second)&#125;&#125;&#125;func <span class="hljs-selector-tag">main</span>() &#123;ctx, cancel := context.<span class="hljs-built_in">WithDeadline</span>(context.<span class="hljs-built_in">Background</span>(), time.<span class="hljs-built_in">Now</span>().<span class="hljs-built_in">Add</span>(<span class="hljs-number">1</span>*time.Second))go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker1&quot;</span>)go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker2&quot;</span>)time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;before cancel&quot;</span>)<span class="hljs-built_in">cancel</span>()time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)&#125;</code></pre><p><code>WithTimeout</code>，带有超时时间的cancelCtx的Context，它是WithDeadline的封装，只不过WithTimeout为时间间隔，Deadline为时间点。</p><p>参考文章：<a href="https://geektutu.com/post/quick-go-context.html">https://geektutu.com/post/quick-go-context.html</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang GC</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%20GC/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%20GC/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-的垃圾回收"><a href="#Golang-的垃圾回收" class="headerlink" title="Golang 的垃圾回收"></a>Golang 的垃圾回收</h1><h2 id="Golang1-0-标记清除算法"><a href="#Golang1-0-标记清除算法" class="headerlink" title="Golang1.0 标记清除算法"></a>Golang1.0 标记清除算法</h2><p>串行的标记清除算法，会导致长时间stw（stop the world）时间，造成资源浪费。</p><h2 id="Golang-1-5三色标记法"><a href="#Golang-1-5三色标记法" class="headerlink" title="Golang 1.5三色标记法"></a>Golang 1.5三色标记法</h2><p>Go的垃圾收集的整个过程可以分成标记准备、标记、标记终止和清除四个不同阶段</p><p>​    Golang 使用三色标记法，开始每个事件都是白色，扫描到一个进程，标记为灰色，就把他丢入队列，每次从队列取出来一个，从这个事件的开始遍历这个事件引出的其他事件，然后把这个事件标记成黑色，有bfs那味，不会重新遍历黑色的事件，直到灰色事件队列没事件了，清除白色事件。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>因为程序与标记是并发运行的，可能这个事件已经是黑色的还会引出事件，这个时候新事件还是白色，会被清除，这个时候加入写屏障，约定在清扫开始前黑色事件不引出其他事件</p><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p><ul><li>强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li><li>弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</li></ul><h4 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h4><p>Dijkstra 在 1978 年提出了插入写屏障，通过如下所示的写屏障，用户程序和垃圾收集器可以在交替工作的情况下保证程序执行的正确性：</p><pre><code class="hljs go">writePointer(slot, ptr):    shade(ptr)    *slot = ptr</code></pre><p>上述插入写屏障的伪代码非常好理解，每当执行类似 <code>*slot = ptr</code> 的表达式时，我们会执行上述写屏障通过 <code>shade</code> 函数尝试改变指针的颜色。如果 <code>ptr</code> 指针是白色的，那么该函数会将该对象设置成灰色，其他情况则保持不变。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141840-dijkstra-insert-write-barrier.png" alt="dijkstra-insert-write-barrier"></p><p><strong>图 7-29 Dijkstra 插入写屏障</strong></p><p>假设我们在应用程序中使用 Dijkstra 提出的插入写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p><ol><li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li><li>用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色；</li><li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；</li></ol><p>Dijkstra 的插入写屏障是一种相对保守的屏障技术，它会将<strong>有存活可能的对象都标记成灰色</strong>以满足强三色不变性。在如上所示的垃圾收集过程中，实际上不再存活的 B 对象最后没有被回收；而如果我们在第二和第三步之间将指向 C 对象的指针改回指向 B，垃圾收集器仍然认为 C 对象是存活的，这些被错误标记的垃圾对象只有在下一个循环才会被回收。</p><p>插入式的 Dijkstra 写屏障虽然实现非常简单并且也能保证强三色不变性，但是它也有明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之间做出权衡。</p><h4 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h4><p>Yuasa 在 1990 年的论文 Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它会保证开启写屏障时堆上所有对象的可达，所以也被称作快照垃圾收集（Snapshot GC）<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:10">10</a>：</p><blockquote><p>This guarantees that no objects will become unreachable to the garbage collector traversal all objects which are live at the beginning of garbage collection will be reached even if the pointers to them are overwritten.</p></blockquote><p>该算法会使用如下所示的写屏障保证增量或者并发执行垃圾收集时程序的正确性：</p><pre><code class="hljs go">writePointer(slot, ptr)    shade(*slot)    *slot = ptr</code></pre><p>上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p><p><img src="https://img.draveness.me/2021-01-02-16095599123266-yuasa-delete-write-barrier.png" alt="yuasa-delete-write-barrier"></p><p><strong>图 7-29 Yuasa 删除写屏障</strong></p><p>假设我们在应用程序中使用 Yuasa 提出的删除写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p><ol><li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li><li>用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；</li><li><strong>用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色</strong>；</li><li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；</li></ol><p>GC触发条件：</p><p>1、长时间（2分钟）没GC，就GC一次</p><p>2、内存分配到一定比例，或者堆内存占用比上次增加了100%</p><p>3、手动</p><h4 id="标记好之后是怎么回收内存的"><a href="#标记好之后是怎么回收内存的" class="headerlink" title="标记好之后是怎么回收内存的"></a>标记好之后是怎么回收内存的</h4><p>​    标记完之后会扫描堆栈中每一个对象，如果不是黑色就把对象清空，并且用链表把每一个空闲空间链接起来。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go为什么不支持可重入锁</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="可重入锁是什么"><a href="#可重入锁是什么" class="headerlink" title="可重入锁是什么"></a>可重入锁是什么</h2><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&#123;     Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> Lock();     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span>()</span>&#123;         <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();         ...........;         methodB();         ...........;         <span class="hljs-keyword">lock</span>.unlock();     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span>()</span>&#123;         <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();         ...........;         <span class="hljs-keyword">lock</span>.unlock();     &#125;&#125;</code></pre><p>当A方法获取lock锁去锁住一段需要做原子性操作的B方法时，如果这段B方法又需要锁去做原子性操作，那么A方法就必定要与B方法出现死锁。这种会出现问题的重入一把锁的情况，叫不可重入锁。</p><p>A方法需要等B方法执行完才能解锁，但是B方法想执行完代码又必须要lock锁来加锁。A的锁未解锁前，其他代码块无法使用此锁来加锁。这是由这个不可重入锁决定的。</p><h2 id="为什么Go没有可重入锁"><a href="#为什么Go没有可重入锁" class="headerlink" title="为什么Go没有可重入锁"></a>为什么Go没有可重入锁</h2><p>如果当你的代码需要重入锁时，那就说明你的代码有问题了，我们正常写代码时，从入口函数开始，执行的层次都是一层层往下的，如果有一个锁需要共享给几个函数，那么就在调用这几个函数的上面，直接加上互斥锁就好了，不需要在每一个函数里面都添加锁，再去释放锁。</p><pre><code class="hljs scss">func <span class="hljs-built_in">call</span>()&#123;  <span class="hljs-built_in">F</span>()  <span class="hljs-built_in">G</span>()&#125;func <span class="hljs-built_in">F</span>() &#123;      mu<span class="hljs-selector-class">.Lock</span>()      ... do some stuff      mu<span class="hljs-selector-class">.Unlock</span>()&#125;func <span class="hljs-built_in">g</span>() &#123;     ... do some stuff ...&#125;func <span class="hljs-built_in">G</span>() &#123;     mu<span class="hljs-selector-class">.Lock</span>()     <span class="hljs-built_in">g</span>()     mu<span class="hljs-selector-class">.Unlock</span>()&#125;</code></pre><p>这样不仅避免了死锁，而且还对代码进行了解耦。这样的代码按照作用范围进行了分层，就像金字塔一样，上层调用下层的函数，越往上作用范围越大；各层有自己的锁。</p><p>总结：<code>Go</code>语言中完全没有必要使用可重入锁，如果我们发现我们的代码要使用到可重入锁了，那一定是我们写的代码有问题了，请检查代码结构，修改他！！！</p><p>在单线程的测试中，无法发现bug。可重入锁无法保护invariant，是可能导致大问题的。</p><p><strong>使用可重入锁是一种彻彻底底的错误，它是bug的温床</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要使用通信的方式来实现共享内存</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用通信的方式来实现共享内存"><a href="#为什么要使用通信的方式来实现共享内存" class="headerlink" title="为什么要使用通信的方式来实现共享内存"></a>为什么要使用通信的方式来实现共享内存</h2><p>GO 的 channal 底层还是使用共享内存的方式进行通信，抽象层面上在共享内存上面一层，在内部处理了线程竞争（CAS指令）、内存管理等内容，适用于更多场景。</p><p><strong>总结：</strong></p><ol><li>首先，使用发送消息来同步信息相比于直接使用共享内存和互斥锁是一种更高级的抽象，使用更高级的抽象能够为我们在程序设计上提供更好的封装，让程序的逻辑更加清晰；</li><li>其次，消息发送在解耦方面与共享内存相比也有一定优势，我们可以将线程的职责分成生产者和消费者，并通过消息传递的方式将它们解耦，不需要再依赖共享内存；</li><li>最后，Go 语言选择消息发送的方式，通过保证同一时间只有一个活跃的线程能够访问数据，能够从设计上天然地避免线程竞争和数据冲突的问题；</li></ol><p>说明在chanel维护所有被该chanel阻塞的协程（读，写各一双向链表）来保证有资源的时候只唤醒一个协程来避免竞争之类的</p><p>从架构上来讲，降低共享内存的使用，本来就是解耦和的重要手段之一，举几个例子</p><p>golang建议使用channel来共享信息而不是使用共享内存，这是一种优雅的方式，避免了数据同步带来的繁琐和低效。</p><p>往大了说，本质上还是让资源去调度请求，而不是让请求去调度资源。</p><p>资源就那么多，所有请求有序使用资源的方式就是通信的方式，反过来，为每个请求虚拟出它独占资源的假象，那就是共享的方式。两种截然不同的方式，差异体现在仲裁成本，这个成本决定了它们承载并发的能力。</p><p>参考文章：<a href="https://draveness.me/whys-the-design-communication-shared-memory/">https://draveness.me/whys-the-design-communication-shared-memory/</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang Mutex</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E9%94%81/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p><strong>我们先来看怎么实现一个最简单的互斥锁，在开始之前可以先想一想，如果是你，你会怎么设计呢？</strong></p><p><strong>你可能会想到，可以通过一个 flag 变量，标记当前的锁是否被某个 goroutine 持有。如果这个 flag 的值是 1，就代表锁已经被持有，那么其它竞争的 goroutine 只能等待；如果这个 flag 的值是 0，就可以通过 CAS（compare-and-swap，或者 compare-and-set）将这个 flag 设置为 1，标识锁被当前的这个 goroutine 持有了。</strong></p><p><strong>整个逻辑很简单，但事实上早期的 Mutex 就是这么设计的，不过在看源码之前我们需要先了解一下什么是 CAS，它非常重要。</strong></p><h4 id="CAS-是什么"><a href="#CAS-是什么" class="headerlink" title="CAS 是什么"></a>CAS 是什么</h4><p><strong>假设有一个块内存，里面存储的值是 a，但是现在想将其变成 a + b，这个时候需要经历哪几步呢？</strong></p><ul><li><code>将存储的值读取出来，得到 a</code></li><li><code>将 a 和 b 进行加法运算，得到 a + b</code></li><li><code>再将计算后的新值 a + b 写回到原来的内存中，也就是将原来的值 a 给更新掉</code></li></ul><p><strong>单线程的话是没有任何问题的，但如果是多个线程同时操作这块内存呢？显然可能会出问题。因此需要通过 CAS 解决这一点，首先它会将内存中原本的值备份一份，运算之后会比较此时内存的值和备份的值，如果一致才进行更新，如果不一致则什么也不做。比如一开始内存的值是 a，备份一份，然后计算完毕之后发现内存的值变成了 a1，前后不一致，说明其它线程已经将这块内存的值给修改了，那么此时就不会再更新了；如果一致，说明没有别的线程修改这个内存的数据，那么此时才会更新。</strong></p><blockquote><p><strong>所以 CAS 的名字很直观，就是先比较、然后再决定是否更新（设置），并且整体是原子性的。</strong></p></blockquote><p><strong>CAS 是实现互斥锁和并发原语的基础，我们有必要掌握它。</strong></p><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p>这是sync包的互斥锁，加了之后不需要其他goroutine读取，只允许这个读取</p><p>加锁是原语操作</p><p>当goutine超过1ms因为锁请求不到资源的时候，会变成饥饿模式，下次允许优先获得锁。</p><h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><p>这个sync包的读写锁，加了之后运行其他goroutine读，不允许其他进程写</p><p>参考文档：<a href="https://www.cnblogs.com/traditional/p/11894550.html">https://www.cnblogs.com/traditional/p/11894550.html</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka内部积压</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka/kafka%E5%86%85%E9%83%A8%E7%A7%AF%E5%8E%8B%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka/kafka%E5%86%85%E9%83%A8%E7%A7%AF%E5%8E%8B%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    
    <content type="html"><![CDATA[<p>1、kafka内部速度比较慢，rebalance（比较少）</p><p>排查分区数据发生倾斜</p><p>2、业务数据量增多</p><p>增大分区，增大并行度，排查消费者速率是否出现问题</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka如何保证消息的顺序性</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我举个例子，我们以前做过一个 mysql <code>binlog</code> 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如<a href="https://cloud.tencent.com/solution/bigdata?from=10680">大数据</a> team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p><p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 <code>binlog</code> 日志，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</p><p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p><p>先看看顺序会错乱的俩场景：</p><ul><li>RabbitMQ：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1&#x2F;data2&#x2F;data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>，然后是 data1&#x2F;data3。这不明显乱了。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/1692602/3iq10gkba3.png?imageView2/2/w/1620" alt="img"></p><ul><li>Kafka：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。 消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞多个线程来并发处理消息。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/1692602/ej36p1xzs7.png?imageView2/2/w/1620" alt="img"></p><p>解决方案</p><p>RabbitMQ</p><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 </p><p><img src="https://ask.qcloudimg.com/http-save/1692602/51b3nl839e.png?imageView2/2/w/1620" alt="img"></p><p>Kafka</p><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/1692602/5k5yv4ef95.png?imageView2/2/w/1620" alt="img"></p><p>参考文章：<a href="https://cloud.tencent.com/developer/article/1543005?from=article.detail.1839597">https://cloud.tencent.com/developer/article/1543005?from=article.detail.1839597</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/HashMap/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/HashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>定义：HashMap是我们常见的一种数据结构，实现Map接口，用来存储键值对,允许null键&#x2F;值、非同步、不保证有序(比如插入的顺序)。那HashMap中最核心的部分就是哈希函数，又称散列函数。也就是说，哈希函数是通过把key的hash值映射到数组中的一个位置来进行访问。</p><h4 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h4><p> static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1&lt;&lt;4;</p><h4 id="最大容量"><a href="#最大容量" class="headerlink" title="最大容量"></a>最大容量</h4><p> MAXIMUM_CAPACITY &#x3D; 1&lt;&lt;30;</p><h4 id="扩容条件"><a href="#扩容条件" class="headerlink" title="扩容条件"></a>扩容条件</h4><p>DEFAULT_LOAD_FACTOR &#x3D; 0.75f;  在容量3&#x2F;4时扩容</p><h3 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h3><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;        <span class="hljs-type">int</span> h;        <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/16390890-8018e0b694b486d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/586/format/webp"></p><p>一个hashCode的前16位和他的后16为进行异或，将算出来的值和（n-1）&amp;一下就是要插入的槽位。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synchronize</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/Synchronize/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/Synchronize/</url>
    
    <content type="html"><![CDATA[<p>悲观锁（Pessimistic Lock）：<br>每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。</p><p>乐观锁（Optimistic Lock）：<br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。<br>由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。</p><p>悲观锁比较适合强一致性的场景，但效率比较低，特别是读的并发低。<br>乐观锁则适用于读多写少，并发冲突少的场景。</p><p>Synchronized：<br>Java在JDK1.5之前都是靠 synchronized关键字保证同步的。这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。这就是一种独占锁，独占锁其实就是一种悲观锁。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile怎么样才能最小</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/Dockerfile%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E8%83%BD%E6%9C%80%E5%B0%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/Dockerfile%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E8%83%BD%E6%9C%80%E5%B0%8F/</url>
    
    <content type="html"><![CDATA[<p>Dockerfile怎么样才能最小</p><p>1、每一层尽可能的多做事情，只有一层layer能够做到尽可能少的打包内容，但是管理成本很大，无法复用和使用本地cache</p><p>2、选择基础镜像的时候选的小一点</p><p>3、编译和运行分开，使用from来传输编译好的数据，使用rebuild</p><p>Dockerfile最下面那层添加代码，倒数第二层删除代码，有什么不好</p><p>1、每次打包docker时,都会使用资源打包无意义的东西</p><p>2、打包会导致源代码泄漏，造成很严重的安全事故</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>daemonset适用场景</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/daemonset%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/daemonset%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<ol><li>在集群的每个节点上运行存储 Daemon，比如 glusterd 或 ceph。</li><li>在每个节点上运行日志收集 Daemon，比如 flunentd 或 logstash。</li><li>在每个节点上运行监控 Daemon，比如 Prometheus Node Exporter 或 collectd。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker组成</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/docker%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/docker%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h2 id="docker基础组成"><a href="#docker基础组成" class="headerlink" title="docker基础组成"></a>docker基础组成</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59qurl3dsj21ao0p3gpe.jpg"></p><p>命名空间（Namespaces） 、控制组（Control Groups）和联合文件系统（Union File System）为底层提供的实现，Docker将其封装，开发者并不直接操作。在Docker中，另外提供出了一些软件层面的概念，是操作Docker所针对的对象。</p><p>它们分别是：<strong>镜像（Image</strong>）、<strong>容器</strong>（<strong>Container</strong>）、<strong>网络</strong>（<strong>Network</strong>）、<strong>数据卷</strong>（<strong>Volume</strong>）。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59qwhlezwj20zk0dm74h.jpg"></p><h3 id="docker和vm的区别"><a href="#docker和vm的区别" class="headerlink" title="docker和vm的区别"></a>docker和vm的区别</h3><p>VM是一个运行在宿主机之上的完整的操作系统，VM运行自身操作系统会占用较多的CPU、内存、硬盘资源。Docker不同于VM，只包含应用程序以及依赖库，基于libcontainer运行在宿主机上，并处于一个隔离的环境中，这使得Docker更加轻量高效，启动容器只需几秒钟之内完成。由于Docker轻量、资源占用少，使得Docker可以轻易的应用到构建标准化的应用中。但Docker目前还不够完善，比如隔离效果不如VM，共享宿主机操作系统的一些基础库等；网络配置功能相对简单，主要以桥接方式为主；查看日志也不够方便灵活。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59quy8wlvj21c80u0afi.jpg"></p><h3 id="Docker-容器有几种在状态？"><a href="#Docker-容器有几种在状态？" class="headerlink" title="Docker 容器有几种在状态？"></a>Docker 容器有几种在状态？</h3><ul><li>starting 运行状态</li><li>Exited 退出状态</li><li>Paused 暂停状态</li><li>healthy 健康状态</li><li>unhealthy 非健康状态</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s service</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20service/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20service/</url>
    
    <content type="html"><![CDATA[<h3 id="service的负载均衡机制"><a href="#service的负载均衡机制" class="headerlink" title="service的负载均衡机制"></a>service的负载均衡机制</h3><p>从服务ip到后端pod的负载均衡机制，是由每个node上面的kube-proxy实现的</p><h4 id="kube-proxy-代理模式"><a href="#kube-proxy-代理模式" class="headerlink" title="kube-proxy 代理模式"></a>kube-proxy 代理模式</h4><h5 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h5><p>这种模式，<code>kube-proxy</code> 会监视 Kubernetes 控制节点对 Service 对象和 Endpoints 对象的添加和移除。 对每个 Service，它会配置 iptables 规则，从而捕获到达该 Service 的 <code>clusterIP</code> 和端口的请求，进而将请求重定向到 Service 的一组后端中的某个 Pod 上面。 对于每个 Endpoints 对象，它也会配置 iptables 规则，这个规则会选择一个后端组合。</p><p>默认的策略是，kube-proxy 在 iptables 模式下随机选择一个后端。</p><p>使用 iptables 处理流量具有较低的系统开销，因为流量由 Linux netfilter 处理， 而无需在用户空间和内核空间之间切换。 这种方法也可能更可靠。</p><p>如果 kube-proxy 在 iptables 模式下运行，并且所选的第一个 Pod 没有响应，则连接失败。 这与用户空间模式不同：在这种情况下，kube-proxy 将检测到与第一个 Pod 的连接已失败， 并会自动使用其他后端 Pod 重试。</p><p>你可以使用 Pod <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">就绪探测器</a> 验证后端 Pod 可以正常工作，以便 iptables 模式下的 kube-proxy 仅看到测试正常的后端。 这样做意味着你避免将流量通过 kube-proxy 发送到已知已失败的 Pod。</p><p><img src="https://d33wubrfki0l68.cloudfront.net/27b2978647a8d7bdc2a96b213f0c0d3242ef9ce0/e8c9b/images/docs/services-iptables-overview.svg" alt="iptables 代理模式下 Service 概览图"></p><h3 id="IPVS-代理模式"><a href="#IPVS-代理模式" class="headerlink" title="IPVS 代理模式"></a>IPVS 代理模式</h3><p><strong>特性状态：</strong> <code>Kubernetes v1.11 [stable]</code></p><p>在 <code>ipvs</code> 模式下，kube-proxy 监视 Kubernetes 服务和端点，调用 <code>netlink</code> 接口相应地创建 IPVS 规则， 并定期将 IPVS 规则与 Kubernetes 服务和端点同步。该控制循环可确保 IPVS 状态与所需状态匹配。访问服务时，IPVS 将流量定向到后端 Pod 之一。</p><p>IPVS 代理模式基于类似于 iptables 模式的 netfilter 挂钩函数， 但是使用哈希表作为基础数据结构，并且在内核空间中工作。 这意味着，与 iptables 模式下的 kube-proxy 相比，IPVS 模式下的 kube-proxy 重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。 与其他代理模式相比，IPVS 模式还支持更高的网络流量吞吐量。</p><p>IPVS 提供了更多选项来平衡后端 Pod 的流量。这些是：</p><ul><li><code>rr</code>：轮替（Round-Robin）</li><li><code>lc</code>：最少链接（Least Connection），即打开链接数量最少者优先</li><li><code>dh</code>：目标地址哈希（Destination Hashing）</li><li><code>sh</code>：源地址哈希（Source Hashing）</li><li><code>sed</code>：最短预期延迟（Shortest Expected Delay）</li><li><code>nq</code>：从不排队（Never Queue）</li></ul><h5 id="ipvs"><a href="#ipvs" class="headerlink" title="ipvs"></a>ipvs</h5><p>服务发现：</p><p>通过DNS来做</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>taint 和 Toleration</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20taint/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20taint/</url>
    
    <content type="html"><![CDATA[<h3 id="taint类型"><a href="#taint类型" class="headerlink" title="taint类型"></a>taint类型</h3><ul><li>NoSchedule：不能容忍此污点的 Pod 不会被调度到节点上；现有 Pod 不会从节点中逐出。</li><li>PreferNoSchedule：Kubernetes 会避免将不能容忍此污点的 Pod 安排到节点上。</li><li>NoExecute：如果 Pod 已在节点上运行，则会将该 Pod 从节点中逐出；如果尚未在节点上运行，则不会将其安排到节点上。</li></ul><h4 id="容忍度（Toleration）"><a href="#容忍度（Toleration）" class="headerlink" title="容忍度（Toleration）"></a>容忍度（Toleration）</h4><pre><code class="hljs dts"><span class="hljs-symbol">tolerations:</span>- key: <span class="hljs-string">&quot;key1&quot;</span><span class="hljs-symbol">  operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><span class="hljs-symbol">  value:</span> <span class="hljs-string">&quot;value1&quot;</span><span class="hljs-symbol">  effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s 探针</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20%E6%8E%A2%E6%B4%BB%E6%8C%87%E9%92%88/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20%E6%8E%A2%E6%B4%BB%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="探针的三种机制"><a href="#探针的三种机制" class="headerlink" title="探针的三种机制"></a>探针的三种机制</h3><p>HTTP GET：该类型的探针对容器的ip地址和执行HTTP GET请求，如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。<br>TCP套接字：该类型的探针尝试与容器指定端口建立TCP连接，如果端口打开，则诊断被认为是成功的。<br>Exec：该类型的探针在容器内执行任意的命令，如果命令退出时返回码为 0 则认为诊断成功<br>每次探测都将获得以下三种结果之一：</p><p>Success（成功）：容器通过了诊断。<br>Failure（失败）：容器未通过诊断。<br>Unknown（未知）：诊断失败，因此不会采取任何行动。</p><h3 id="探针的三种类型"><a href="#探针的三种类型" class="headerlink" title="探针的三种类型"></a>探针的三种类型</h3><p>存活指针，就绪指针，启动指针</p><h3 id="liveness（存活指针）"><a href="#liveness（存活指针）" class="headerlink" title="liveness（存活指针）"></a>liveness（存活指针）</h3><p>存活指针,该指针用来指示容器是否正在运行。kubernetes根据存活指针来检查容器是否正常运行，若探测失败，则 kubelet 会杀死容器， 并且容器将根据其重启策略去处理。</p><h3 id="Readiness（就绪指针）"><a href="#Readiness（就绪指针）" class="headerlink" title="Readiness（就绪指针）"></a>Readiness（就绪指针）</h3><p>该指针用来指示容器是否准备好为请求提供服务。如果就绪态探测失败，kubelet将该Pod提供的所有服务的endpoint列表中删除该Pod的 IP地址。<br>Kubernetes根据就绪指针来检测pod中的容器是否已经就绪，在发布应用时很有必要在pod中添加该指针，K8s会根据pod是否就绪决定是否将该pod放入该服务中，从而保证服务集群中的pod都是可以提供服务的。</p><p>与存活指针的区别在于，若容器未通过检查准备，则不会被终止或重新启动。存活探针通过杀死异常的容器并用新的容器去替代他们的工作，而就绪探针确保只有准备好处理请求的pod才能在服务集群中。</p><h3 id="启动指针"><a href="#启动指针" class="headerlink" title="启动指针"></a>启动指针</h3><p>该指针用来指示容器中的应用是否已经启动，如果使用了启动探针，则所有其他探针都会被禁用，直到此探针成功为止。如果启动探测失败，kubelet将杀死容器，而容器依其重启策略进行重启。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s网络</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h50depznptj20s50e13zh.jpg"></p><p>docker使用网桥模式，通过虚拟化出网卡来，不同容器之间通信是通过docker0网桥转发。</p><p>每个容器里面都有个etho，然后docker0有个对应的veth。</p><h4 id="k8s不同node是怎么进行通信的"><a href="#k8s不同node是怎么进行通信的" class="headerlink" title="k8s不同node是怎么进行通信的"></a>k8s不同node是怎么进行通信的</h4><p>k8s不同node通信也是和</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sidecar</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/sidecar/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/sidecar/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Sidecar模式？"><a href="#什么是Sidecar模式？" class="headerlink" title="什么是Sidecar模式？"></a>什么是Sidecar模式？</h2><p>Sidecar模式是一种将应用功能从应用本身剥离出来作为单独进程的方式。该模式允许我们向应用无侵入添加多种功能，避免了为满足第三方组件需求而向应用添加额外的配置代码。</p><p>就像边车加装在摩托车上一样，在软件架构中，sidecar附加到主应用，或者叫父应用上，以扩展&#x2F;增强功能特性，同时Sidecar与主应用是松耦合的。</p><p>举个例子，假设现在有6个相互通信的微服务，每个微服务都需要具有可观察性、监控、日志记录、配置、断路器等功能，而所有这些功能都是在微服务中使用一些第三方库实现的。</p><p>这样一组服务的实际情况可能会非常复杂，增加了应用的整体复杂性，尤其是当每个微服务用不同的语言编写、使用不同的基于.net、Java、Python等语言的第三方库……</p><h2 id="Sidecar模式的好处"><a href="#Sidecar模式的好处" class="headerlink" title="Sidecar模式的好处"></a>Sidecar模式的好处</h2><ul><li>通过将公用基础设施相关功能抽象到不同的层来降低微服务的代码复杂性</li><li>由于我们不需要在每个微服务中编写配置代码，因此减少了微服务架构中的代码重复</li><li>P应用和底层平台之间实现了松耦合</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>master节点有什么组件</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/master%E8%8A%82%E7%82%B9%E6%9C%89%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/master%E8%8A%82%E7%82%B9%E6%9C%89%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="master节点有什么组件"><a href="#master节点有什么组件" class="headerlink" title="master节点有什么组件"></a>master节点有什么组件</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4s6dbhvbgj20ru0k7myt.jpg"></p><p><strong>api server：</strong>负责对外提供restful的Kubernetes API服务，提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制。我们操作kubectl 和其他Master组件都通过调用api server提供的rest接口实现各自的功能，如controller就是通过api server来实时监控各个资源的状态的。</p><p><strong>etcd：</strong>是 Kubernetes 提供的一个高可用的键值数据库，用于保存集群所有的网络配置和资源对象的状态信息，也就是保存了整个集群的状态。数据变更都是通过api server进行的。整个kubernetes系统中一共有两个服务需要用到etcd用来协同和存储配置，分别是：<br>1）网络插件flannel，其它网络插件也需要用到etcd存储网络的配置信息；<br>2）kubernetes本身，包括各种资源对象的状态和元信息配置。</p><p><strong>scheduler：</strong>监听新建pod副本信息，并通过调度算法为该pod选择一个最合适的Node节点。会检索到所有符合该pod要求的Node节点，执行pod调度逻辑。调度成功之后，会将pod信息绑定到目标节点上，同时将信息写入到etcd中。一旦绑定，就由Node上的kubelet接手pod的接下来的生命周期管理。Kubernetes目前提供了调度算法，但是同样也保留了接口，用户可以根据自己的需求定义自己的调度算法。</p><p><strong>controller manager：</strong>负责维护集群的状态，比如故障检测、自动扩展、滚动更新等。每个资源一般都对应有一个控制器，这些controller通过api server实时监控各个资源的状态，controller manager就是负责管理这些控制器的。当有资源因为故障导致状态变化，controller就会尝试将系统由“现有状态”恢复到“期待状态”，保证其下每一个controller所对应的资源始终处于期望状态。比如我们通过api server创建一个pod，当这个pod创建成功后，api server的任务就算完成了。其中一个pod出现问题，controller会自动恢复创建新的pod。</p><h3 id="Node节点有什么组件"><a href="#Node节点有什么组件" class="headerlink" title="Node节点有什么组件"></a>Node节点有什么组件</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4s6ogvdamj20rp0k276g.jpg"></p><p>kubelet: 会监视已分配给节点的pod，负责pod的生命周期管理，同时与Master密切协作，维护和管理该Node上面的所有容器，实现集群管理的基本功能。即Node节点通过kubelet与master组件交互，可以理解为kubelet是Master在每个Node节点上面的agent。本质上，它负责使Pod的运行状态与期望的状态一致。</p><p>kube-proxy: 是实现service的通信与负载均衡机制的重要组件，将到service的请求转发到后端的pod上。</p><p>docker-engine(docker): 是负责容器的创建和管理工作。</p><p>Pod: 最小部署单元，一个Pod 有一个或多个容器组成，容器中共享存储和网络，在同一台docker主机上运行。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARP协议</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/ARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/ARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP解决了同一个局域网上的主机和路由器IP和MAC地址的解析。</p><ul><li>每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。 </li><li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。 </li><li>网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。 </li><li>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。 </li><li>如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP1.0和2.0的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP1.0%E5%92%8C2.0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP1.0%E5%92%8C2.0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>虽然 HTTP&#x2F;1.1 已经做了大量的优化，但是依然存在很多性能瓶颈，依然不能满足我们日益变化的新需求，所以就有了我们今天要聊的 HTTP&#x2F;2。</p><p>本文我们依然从需求的层面来谈，先分析 HTTP&#x2F;1.1 存在哪些问题，然后再来分析 HTTP&#x2F;2 是如何解决这些问题的。</p><p>我们知道 HTTP&#x2F;1.1 为网络效率做了大量的优化，最核心的有如下三种方式：</p><ul><li>增加了持久连接；</li><li>浏览器为每个域名最多同时维护 6 个 TCP 持久连接；</li><li>使用 CDN 的实现域名分片机制。</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gse5yu77j20vo0u0dha.jpg"></p><p>在该图中，引入了 CDN，并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间。这里我们可以简单计算下：如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 100 * n * RTT；若通过上面的技术，就可以把整个时间缩短为 100 * n * RTT&#x2F;(6 * CDN 个数)。从这个计算结果来看，我们的页面加载速度变快了不少。</p><h3 id="HTTP1-1主要问题"><a href="#HTTP1-1主要问题" class="headerlink" title="HTTP1.1主要问题"></a>HTTP1.1主要问题</h3><p>主要问题是Http1.1对带宽的利用率不高</p><h5 id="1、TCP的慢启动"><a href="#1、TCP的慢启动" class="headerlink" title="1、TCP的慢启动"></a>1、TCP的慢启动</h5><p>因为有一些关键数据他本来就不大，慢启动了之后更加显得慢了，推迟了首次渲染的速度。</p><h5 id="2、同时开启了多条-TCP-连接，那么这些连接会竞争固定的带宽。"><a href="#2、同时开启了多条-TCP-连接，那么这些连接会竞争固定的带宽。" class="headerlink" title="2、同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。"></a>2、<strong>同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。</strong></h5><p>你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p><p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p><h5 id="3、队头阻塞问题"><a href="#3、队头阻塞问题" class="headerlink" title="3、队头阻塞问题"></a>3、队头阻塞问题</h5><p>我们知道在 HTTP&#x2F;1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p><p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。</p><p>在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。</p><p>但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。</p><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p><strong>HTTP2.0使用多路复用来解决这个问题</strong></p><p>基于此，HTTP&#x2F;2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p><p>另外，就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP&#x2F;2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</p><p>所以，HTTP&#x2F;2 的解决方案可以总结为：一个域名只使用一个 TCP 长连接和消除队头阻塞问题。可以参考下图</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gt484gycj214o0j8acm.jpg"></p><h3 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gt6kaqb9j20u00udjts.jpg"></p><p>从图中可以看出，HTTP&#x2F;2 添加了一个二进制分帧层，那我们就结合图来分析下 HTTP&#x2F;2 的请求和接收过程。</p><ul><li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li><li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li><li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li><li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li><li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li><li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求</li></ul><p>从上面的流程可以看出，通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。</p><p>上一篇文章我们介绍过，HTTP 是浏览器和服务器通信的语言，在这里虽然 HTTP&#x2F;2 引入了二进制分帧层，不过 HTTP&#x2F;2 的语义和 HTTP&#x2F;1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，依然可以使用 Cookie 来保持登录状态，依然可以使用 Cache 来缓存本地文件，这些都没有变，发生改变的只是传输方式。这一点对开发者来说尤为重要，这意味着我们不需要为 HTTP&#x2F;2 去重建生态，并且 HTTP&#x2F;2 推广起来会也相对更轻松了</p><h2 id="HTTP-x2F-2其他特性"><a href="#HTTP-x2F-2其他特性" class="headerlink" title="HTTP&#x2F;2其他特性"></a>HTTP&#x2F;2其他特性</h2><p>通过上面的分析，我们知道了多路复用是 HTTP&#x2F;2 的最核心功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上。其实基于二进制分帧层，HTTP&#x2F;2 还附带实现了很多其他功能，下面我们就来简要了解下。</p><h4 id="1-可以设置请求的优先级"><a href="#1-可以设置请求的优先级" class="headerlink" title="1. 可以设置请求的优先级"></a>1. 可以设置请求的优先级</h4><p>我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。</p><p>为了解决这个问题，HTTP&#x2F;2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p><h4 id="2-服务器推送"><a href="#2-服务器推送" class="headerlink" title="2. 服务器推送"></a>2. 服务器推送</h4><p>除了设置请求的优先级外，HTTP&#x2F;2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p><h4 id="3-头部压缩"><a href="#3-头部压缩" class="headerlink" title="3. 头部压缩"></a>3. 头部压缩</h4><p>无论是 HTTP&#x2F;1.1 还是 HTTP&#x2F;2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP&#x2F;2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</p><p>参考资料：<a href="https://blog.poetries.top/browser-working-principle/guide/part6/lesson30.html#_2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">https://blog.poetries.top/browser-working-principle/guide/part6/lesson30.html#_2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC和HTTP接口的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/RPC%E5%92%8CHTTP%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/RPC%E5%92%8CHTTP%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是RPC协议？"><a href="#什么是RPC协议？" class="headerlink" title="什么是RPC协议？"></a>什么是RPC协议？</h2><p>RPC是一种远程过程调用的协议，使用这种协议向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。<br>在 RPC 中，发出请求的程序是客户程序，而提供服务的程序是服务器。<br>HTTP是一种超文本传输协议。是WWW浏览器和WWW服务器之间的应用层通讯协议。</p><h2 id="RPC协议与HTTP协议的区别"><a href="#RPC协议与HTTP协议的区别" class="headerlink" title="RPC协议与HTTP协议的区别"></a>RPC协议与HTTP协议的区别</h2><p>RPC是一种API，HTTP是一种无状态的网络协议。RPC可以基于HTTP协议实现，也可以直接在TCP协议上实现。<br>RPC主要是用在大型网站里面，因为大型网站里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。<br>HTTP主要是用在中小型企业里面，业务线没那么繁多的情况下。 3、HTTP开发方便简单、直接。开发一个完善的RPC框架难度比较大。<br>HTTP发明的初衷是为了传送超文本的资源，协议设计的比较复杂，参数传递的方式效率也不高。开源的RPC框架针对远程调用协议上的效率会比HTTP快很多。<br>HTTP需要事先通知，修改Nginx&#x2F;HAProxy配置。RPC能做到自动通知，不影响上游。<br>HTTP大部分是通过Json来实现的，字节大小和序列化耗时都比Thrift要更消耗性能。RPC，可以基于Thrift实现高效的二进制传输。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>粘包与拆包</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="粘包与拆包"><a href="#粘包与拆包" class="headerlink" title="粘包与拆包"></a>粘包与拆包</h2><h3 id="粘包发生场景"><a href="#粘包发生场景" class="headerlink" title="粘包发生场景"></a>粘包发生场景</h3><p>因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。</p><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nb933r31j213t0u0ac6.jpg"></p><p>上图中演示了以下几种情况：</p><ul><li>正常的理想情况，两个包恰好满足TCP缓冲区的大小或达到TCP等待时长，分别发送两个包；</li><li>粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送；</li><li>拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送；</li><li>拆包和粘包：Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理。</li></ul><h3 id="粘包拆包解决办法"><a href="#粘包拆包解决办法" class="headerlink" title="粘包拆包解决办法"></a>粘包拆包解决办法</h3><p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p><p>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p><p>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。（FTP协议）</p><h4 id="为什么UDP没有粘包"><a href="#为什么UDP没有粘包" class="headerlink" title="为什么UDP没有粘包"></a>为什么UDP没有粘包</h4><p>​    由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL有哪些数据类型</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Mysql-有哪些数据类型，使用的时候有没有什么注意点"><a href="#Mysql-有哪些数据类型，使用的时候有没有什么注意点" class="headerlink" title="Mysql 有哪些数据类型，使用的时候有没有什么注意点"></a>Mysql 有哪些数据类型，使用的时候有没有什么注意点</h3><p><strong>整数类型</strong>：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、INT、BIG INT<br><strong>浮点数类型：</strong>FLOAT、DOUBLE、DECIMAL<br><strong>字符串类型：</strong>CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、MEDIUM BLOB、LONG BLOB<br><strong>日期类型：</strong>Date、DateTime、TIMESTAMP、TIME、YEAR<br>使用的时候建议遵循从小原则。</p><p>使用char和vahrchar的时候，注意char会去掉字符串末尾的空格<br>使用text和blob的时候，注意定期清理碎片空间，使用OPTIMIZE TABLE命令<br>浮点数会造成精度丢失，尽量使用定点数DECIMAL</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http3</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/http3/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/http3/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h1><p>网络迁移需要重新连接<br>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WIFI。</p><p>这些问题都是 TCP 协议固有的问题，无论应用层的 HTTP&#x2F;2 在怎么设计都无法逃脱。要解决这个问题，就必须把传输层协议替换成 UDP，这个大胆的决定，HTTP&#x2F;3 做了！</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h36nocclm9j21bw0u077j.jpg"></p><h4 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3j4fhk5v3j20jg0e0gn5.jpg"></p><p>QUIC引入了连接上的多路流复用的概念。QUIC通过设计实现了单独的、针对每个流的流控，解决了整个连接的行头阻塞问题。</p><p>QUIC使用增强的丢失恢复机制和转发纠错功能，以更好地处理错误数据包。该功能对于那些只能通过缓慢的无线网络访问互联网的用户来说是一个福音，因为这些网络用户在传输过程中经常出现高错误率。</p><p>更快的握手。QUIC使用相同的TLS模块进行安全连接。然而，与TCP不同的是，QUIC的握手机制经过优化，避免了每次两个已知的对等者之间建立通信时的冗余协议交换</p><h3 id="更快的连接建立"><a href="#更快的连接建立" class="headerlink" title="更快的连接建立"></a>更快的连接建立</h3><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><p>如下图右边部分，HTTP&#x2F;3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT：</p><h3 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h3><p>在前面我们提到，基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接，而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。</p><p><img src="https://pic1.zhimg.com/v2-c13b3c2513e7b9edc98c28f5232ccb88_b.webp"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bf399e5cb48cadacb7008d47f7dc39c5.gif"></p><p>TCP从来就不适合处理有损无线环境中的数据传输。在互联网的早期，有线网络将网络中的每一台计算机连接起来。</p><p>现在，随着智能手机和便携式设备的数量超过台式机和笔记本电脑的数量，超过50%的互联网流量已经通过无线传输。这种趋势给整体的网络浏览体验带来了问题，其中最重要的是在无线覆盖率不足的情况下，TCP中的行头阻塞。</p><p>QUIC 协议的特点：</p><p>无队头阻塞，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，某个流发生丢包了，只会影响该流，其他流不受影响；<br>建立连接速度快，因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。<br>连接迁移，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；</p><h3 id="HTTP-x2F-3-协议"><a href="#HTTP-x2F-3-协议" class="headerlink" title="HTTP&#x2F;3 协议"></a>HTTP&#x2F;3 协议</h3><p>了解完 QUIC 协议的特点后，我们再来看看 HTTP&#x2F;3 协议在 HTTP 这一层做了什么变化。</p><p>HTTP&#x2F;3 同 HTTP&#x2F;2 一样采用二进制帧的结构，不同的地方在于 HTTP&#x2F;2 的二进制帧里需要定义 Stream，而 HTTP&#x2F;3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream，于是 HTTP&#x2F;3 的帧的结构也变简单了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3j4x5m374j21bz0geju3.jpg"></p><p>从上图可以看到，HTTP&#x2F;3 帧头只有两个字段：类型和长度。</p><p>根据帧类型的不同，大体上分为数据帧和控制帧两大类，HEADERS 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</p><p>HTTP&#x2F;3 在头部压缩算法这一方便也做了升级，升级成了 QPACK。与 HTTP&#x2F;2 中的 HPACK 编码方式相似，HTTP&#x2F;3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。</p><p>对于静态表的变化，HTTP&#x2F;2 中的 HPACK 的静态表只有 61 项，而 HTTP&#x2F;3 中的 QPACK 的静态表扩大到 91 项。</p><p>HTTP&#x2F;2 和 HTTP&#x2F;3 的 Huffman 编码并没有多大不同，但是动态表编解码方式不同。</p><p>所谓的动态表，在首次请求-响应后，双方会将未包含在静态表中的 Header 项更新各自的动态表，接着后续传输时仅用 1 个数字表示，然后对方可以根据这 1 个数字从动态表查到对应的数据，就不必每次都传输长长的数据，大大提升了编码效率。</p><p>可以看到，动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来。</p><p>HTTP&#x2F;3 的 QPACK 解决了这一问题，那它是如何解决的呢？</p><p>QUIC 会有两个特殊的单向流，所谓的单项流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：</p><p>一个叫 QPACK Encoder Stream， 用于将一个字典（key-value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；<br>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。<br>这两个特殊的单向流是用来同步双方的动态表，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU和LFU等淘汰算法</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/LRU%E5%92%8CLFU%E7%AD%89%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/LRU%E5%92%8CLFU%E7%AD%89%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>算法介绍：一个双向链表，一个map记录链表中的节点，访问一个节点，如果在链表里面，就把这个节点从原来的地方删除并且插入到链表头部。</p><p>优点：考虑了时间的因素</p><p>缺点：没有考虑频率的原因，容易因为扫库把热点数据扫出去</p><h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><p>算法介绍： 在最前面的是访问频率最多的数据，访问一次就把这个数据的访问次数加一并且排序把序列有序，如果满了就把频率最低的节点淘汰</p><p><strong>可以使用最小堆或者优先队列实现，时间复杂度O（logn）</strong></p><p>优点：考虑了频率的因素</p><p>缺点：没有考虑时间的原因，容易收到历史数据的影响。</p><h2 id="冷热LRU（mysql的缓存池做法）"><a href="#冷热LRU（mysql的缓存池做法）" class="headerlink" title="冷热LRU（mysql的缓存池做法）"></a>冷热LRU（mysql的缓存池做法）</h2><p>把一个LRU链表中的5&#x2F;8作为热点数据链表，3&#x2F;8作为冷LRU链表</p><p>插入：节点不在链表时就先插入到冷链表，第二次在遇到这个节点就插入到热链表中，也像lru链表一样，每次遇到就会插入到前面，热链表再次遇到就插入到最前面，冷链表中再次遇到就插入到热链表的最前面，</p><p>淘汰：每次都淘汰冷链表中最后几个数据页。</p><p>优点：防止扫库把热点数据淘汰了，既考虑了时间，也考虑了频率。</p><h4 id="什么时候将LRU链表中的冷热数据中的缓存页刷盘"><a href="#什么时候将LRU链表中的冷热数据中的缓存页刷盘" class="headerlink" title="什么时候将LRU链表中的冷热数据中的缓存页刷盘"></a>什么时候将LRU链表中的冷热数据中的缓存页刷盘</h4><p>定时刷盘，MySQL会起一个后台线程，运行定时任务，每隔一定的时间就将LRU链表的冷数据区域尾部的一些缓存页刷盘，然后清空这些缓存页，并放入<code>free链表</code>，从<code>LRU链表</code>删除，从<code>Flush链表</code>删除</p><h2 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h2><p>​    LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法”缓存污染”的问题，其核心思想是将”最近使用过1次”的判断标准扩展为”最近使用过K次”</p><p>常用实现如下</p><p>数据第一次被访问，加入到访问历史列表；如果数据在访问历史列表里后没有达到K次访问，则按照LRU淘汰；当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；缓存数据队列中被再次访问后，重新排序；需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即淘汰”倒数第K次访问离现在最久”的数据。</p><p>命中率分析</p><p>LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。LRU-K降低了”缓存污染”带来的问题，命中率比LRU要高。</p><p>2Q与LRU-2类似，不同点在于将LRU-2算法中的访问历史队列改成了一个FIFO队列</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua脚本为什么支持原子性</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/lua%E8%84%9A%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/lua%E8%84%9A%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="Redis事务满足原子性吗"><a href="#Redis事务满足原子性吗" class="headerlink" title="Redis事务满足原子性吗"></a>Redis事务满足原子性吗</h4><p>有两种错误：语法错误和运行错误</p><p>语法错误可以保障原子性，但是运行错误无法保障原子性，正常语句还是能够正常执行</p><h4 id="为什么redis不支持回滚"><a href="#为什么redis不支持回滚" class="headerlink" title="为什么redis不支持回滚"></a>为什么redis不支持回滚</h4><p>官方给出了解释</p><ul><li>redis命令失败只会发生在语法错误或数据类型错误的情况，这一结果都是由编程过程中的错误导致，这种情况应该在开发环境中检测出来，而不是生产环境。</li><li>不使用回滚，能使redis内部设计更简单，速度更快</li><li>回滚不能避免编程逻辑中的错误，如果想要将一个键的值增加2却只增加了1，这种情况即使提供回滚也无法提供帮助。</li></ul><p>基于以上原因，redis官方选择了更简单、更快的方法，不支持错误回滚。这样的话，如果在我们的业务场景中需要保证原子性，那么就要求了开发者通过其他手段保证命令全部执行成功或失败，例如在执行命令前进行参数类型的校验，或在事务执行出现错误时及时做事务补偿。</p><h4 id="Lua脚本满足原子性吗"><a href="#Lua脚本满足原子性吗" class="headerlink" title="Lua脚本满足原子性吗"></a>Lua脚本满足原子性吗</h4><p>结论：运行错误的话只会执行错误之前的语句，还是不支持原子性</p><h4 id="Lua脚本满足原子性的原因："><a href="#Lua脚本满足原子性的原因：" class="headerlink" title="Lua脚本满足原子性的原因："></a>Lua脚本满足原子性的原因：</h4><p>在redis中是使用的同一个lua解释器来执行所有命令，也就保证了当一段lua脚本在执行时，不会有其他脚本或redis命令同时执行，保证了操作不会被其他指令插入或打扰，实现的仅仅是这种程度上的原子操作。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql redo undo bin log</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%20redo%20undo%20bin%20log/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%20redo%20undo%20bin%20log/</url>
    
    <content type="html"><![CDATA[<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志</p><p>　　作用：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，（刷脏页是个随机IO），在重启 mysql 服务的时候，根据 redo log 进行重做，从而达到事务的持久性这一特性。</p><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><p>归档日志（二进制日志）</p><p>　　作用：用于复制，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从同步。 用于数据库的基于时间点的还原。</p><p>　　内容：逻辑格式的日志，可以简单认为就是执行过的事务中的 sql 语句。但又不完全是 sql 语句这么简单，而是包括了执行的 sql 语句（增删改）反向的信息，也就意味着 delete 对应着 delete 本身和其反向的 insert；update 对应着 update 执行前后的版本的信息；insert 对应着 delete 和 insert 本身的信息。</p><p>　　binlog 有三种模式：Statement（基于 SQL 语句的复制）、Row（基于行的复制） 以及 Mixed（混合模式）</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>回滚日志</p><p>　　作用：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p><p>　　内容：逻辑格式的日志，在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于 redo log 的。</p><h3 id="redo-log-和-undo-log-的区别"><a href="#redo-log-和-undo-log-的区别" class="headerlink" title="redo log 和 undo log 的区别"></a>redo log 和 undo log 的区别</h3><p>undo 日志用于记录事务开始前的状态，用于事务失败时的回滚操作；redo 日志记录事务执行后的状态，用来恢复未写入 data file 的已成功事务更新的数据。例如某一事务的事务序号为 T1，其对数据 X 进行修改，设 X 的原值是 0，修改后的值为 1，那么 Undo 日志为 &lt;T1, X, 0&gt;，Redo 日志为 &lt; T1, X, 1&gt;。</p><h3 id="redo-log与binlog的区别"><a href="#redo-log与binlog的区别" class="headerlink" title="redo log与binlog的区别"></a><strong>redo log与binlog的区别</strong></h3><p>我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：</p><p>（1）作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。</p><p>（2）层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。</p><p>（3）内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。</p><p>（4）写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：</p><p><img src="https://img-blog.csdnimg.cn/20200509170444156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4MTIzNjk4,size_16,color_FFFFFF,t_70"></p><p>前面曾提到：当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。<br>除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis命令</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="Hash类型的操作命令"><a href="#Hash类型的操作命令" class="headerlink" title="Hash类型的操作命令"></a>Hash类型的操作命令</h3><p>1、hget</p><p>2、hset</p><pre><code class="hljs apache"><span class="hljs-attribute">hset</span> myhash id <span class="hljs-number">1</span></code></pre><p>3、hmeset </p><p>同时设置多对值</p><p>4、hgetall</p><p>获取key下所有值</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hgetall myhash</span></code></pre><p>5、hlen</p><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="language-javascript">hlen mash</span>1</code></pre><p>6、hkeys，hvals</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hkeys myhash</span></code></pre><p>获取所有key或者val</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>radis</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/radis/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/radis/</url>
    
    <content type="html"><![CDATA[<h2 id="radis基本数据类型"><a href="#radis基本数据类型" class="headerlink" title="radis基本数据类型"></a>radis基本数据类型</h2><h4 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1. String（字符串）"></a>1. String（字符串）</h4><p>String是简单的 key-value 键值对，value 不仅可以是 String，也可以是数字。String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p><h4 id="2-List（列表）"><a href="#2-List（列表）" class="headerlink" title="2. List（列表）"></a>2. List（列表）</h4><p>Redis列表是简单的字符串列表，可以类比到C++中的std::list，简单的说就是一个链表或者说是一个队列。可以从头部或尾部向Redis列表添加元素。列表的最大长度为2^32 - 1，也即每个列表支持超过40亿个元素。</p><p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p><h4 id="3-Hash（字典，哈希表）"><a href="#3-Hash（字典，哈希表）" class="headerlink" title="3. Hash（字典，哈希表）"></a>3. Hash（字典，哈希表）</h4><p>类似C#中的dict类型或者C++中的hash_map类型。</p><p>Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。</p><h4 id="4-Set（集合）"><a href="#4-Set（集合）" class="headerlink" title="4. Set（集合）"></a>4. Set（集合）</h4><p>可以理解为一堆值不重复的列表，类似数学领域中的集合概念，且Redis也提供了针对集合的求交集、并集、差集等操作。</p><p>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p><h4 id="5-Sorted-Set（有序集合）"><a href="#5-Sorted-Set（有序集合）" class="headerlink" title="5. Sorted Set（有序集合）"></a>5. Sorted Set（有序集合）</h4><p>Redis有序集合类似Redis集合，不同的是增加了一个功能，即集合是有序的。一个有序集合的每个成员带有分数，用于进行排序。</p><p>Redis有序集合添加、删除和测试的时间复杂度均为O(1)(固定时间，无论里面包含的元素集合的数量)。列表的最大长度为2^32- 1元素(4294967295，超过40亿每个元素的集合)。</p><p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>定义：大量缓存同时失效，导致大量请求打到数据库导致数据库宕机。</p><p>解决办法：让缓存失效的时间尽量均匀</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>定义：缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。</p><p>解决办法：通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>定义：缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p><p>解决办法：使用布隆过滤器判断是否在数据库中。</p><h3 id="reids是单线程为什么这么快"><a href="#reids是单线程为什么这么快" class="headerlink" title="reids是单线程为什么这么快"></a>reids是单线程为什么这么快</h3><p>Redis的性能非常之高，每秒可以承受10W+的QPS，它如此优秀的性能主要取决于以下几个方面：</p><ul><li>纯内存操作</li><li>使用IO多路复用技术</li><li>非CPU密集型任务</li><li>单线程的优势</li></ul><h3 id="纯内存操作"><a href="#纯内存操作" class="headerlink" title="纯内存操作"></a>纯内存操作</h3><p>Redis是一个内存数据库，它的数据都存储在内存中，这意味着我们读写数据都是在内存中完成，这个速度是非常快的。</p><p>Redis是一个KV内存数据库，它内部构建了一个哈希表，根据指定的KEY访问时，只需要O(1)的时间复杂度就可以找到对应的数据。同时，Redis提供了丰富的数据类型，并使用高效的操作方式进行操作，这些操作都在内存中进行，并不会大量消耗CPU资源，所以速度极快。</p><h5 id="redis-hash-key-冲突了怎么办"><a href="#redis-hash-key-冲突了怎么办" class="headerlink" title="redis hash key 冲突了怎么办"></a>redis hash key 冲突了怎么办</h5><p>​    Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p><h4 id="使用IO多路复用技术"><a href="#使用IO多路复用技术" class="headerlink" title="使用IO多路复用技术"></a>使用IO多路复用技术</h4><p>Redis采用单线程，那么它是如何处理多个客户端连接请求呢？</p><p>Redis采用了IO多路复用技术和非阻塞IO，这个技术由操作系统实现提供，Redis可以方便地操作系统的API即可。Redis可以在单线程中监听多个Socket的请求，在任意一个Socket可读&#x2F;可写时，Redis去读取客户端请求，在内存中操作对应的数据，然后再写回到Socket中。</p><p>整个过程非常高效，Redis利用了IO多路复用技术的事件驱动模型，保证在监听多个Socket连接的情况下，只针对有活动的Socket采取反应。</p><h4 id="非CPU密集型任务"><a href="#非CPU密集型任务" class="headerlink" title="非CPU密集型任务"></a>非CPU密集型任务</h4><p>采用单线程的缺点很明显，无法使用多核CPU。Redis作者提到，由于Redis的大部分操作并不是CPU密集型任务，而Redis的瓶颈在于内存和网络带宽。</p><p>在高并发请求下，Redis需要更多的内存和更高的网络带宽，否则瓶颈很容易出现在内存不够用和网络延迟等待的情况。</p><p>当然，如果你觉得单个Redis实例的性能不足以支撑业务，Redis作者推荐部署多个Redis节点，组成集群的方式来利用多核CPU的能力，而不是在单个实例上使用多线程来处理。</p><h4 id="单线程的优势"><a href="#单线程的优势" class="headerlink" title="单线程的优势"></a>单线程的优势</h4><p>基于以上特性，Redis采用单线程已足够达到非常高的性能，所以Redis没有采用多线程模型。</p><p>另外，单线程模型还带了以下好处：</p><ul><li>没有了多线程上下文切换的性能损耗</li><li>没有了访问共享资源加锁的性能损耗</li><li>开发和调试非常友好，可维护性高</li></ul><p>所以Redis正是基于以上这些方面，所以采用了单线程模型来完成请求处理的工作。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>上面介绍了单线程可以达到如此高的性能，并不是说它就没有缺点了。</p><p><strong>单线程处理最大的缺点就是，如果前一个请求发生耗时比较久的操作，那么整个Redis就会阻塞住，其他请求也无法进来，直到这个耗时久的操作处理完成并返回，其他请求才能被处理到。</strong></p><p>我们平时遇到Redis变慢或长时间阻塞的问题，90%也都是因为Redis处理请求是单线程这个原因导致的。</p><p>所以，我们在使用Redis时，一定要避免非常耗时的操作，例如使用时间复杂度过高的方式获取数据、一次性获取过多的数据、大量key集中过期导致Redis淘汰key压力变大等等，这些场景都会阻塞住整个处理线程，直到它们处理完成，势必会影响业务的访问。</p><p>我会在后期的文章中专门介绍具体有哪些场景会引发Redis阻塞的问题，并提供规避问题的方法和优化方案。</p><h1 id="什么是大key问题"><a href="#什么是大key问题" class="headerlink" title="什么是大key问题"></a>什么是大key问题</h1><p>就是一个key的value特别大，比如一个hashmap中存了超多k,v;<br>或者一个列表key中存了超长列表，等等；<br>多大算大： hashmap中有100w的k,v &#x3D;&gt; 1s延迟；<br>删除大Key的时间复杂度: O(N), N代表大key里的值数量，因为redis是单线程一个个删。<br>所以删大key也会卡qps。</p><p>因为redis是单线程处理，如果处理一些长时间的操作会造成阻塞</p><p>1.内存不均：单value较大时，可能会导致节点之间的内存使用不均匀，间接地影响key的部分和负载不均匀；<br>2.阻塞请求：redis为单线程，单value较大读写需要较长的处理时间，会阻塞后续的请求处理；<br>3.阻塞网络：单value较大时会占用服务器网卡较多带宽，可能会影响该服务器上的其他Redis实例或者应用。</p><h3 id="redis-大key怎么处理"><a href="#redis-大key怎么处理" class="headerlink" title="redis 大key怎么处理"></a>redis 大key怎么处理</h3><h4 id="1、-lazyfree机制"><a href="#1、-lazyfree机制" class="headerlink" title="1、 lazyfree机制"></a>1、 lazyfree机制</h4><p><code>unlink</code>命令：代替DEL命令；<br>会把对应的大key放到<code>BIO_LAZY_FREE</code>后台线程任务队列，然后在后台异步删除；</p><p>类似的异步删除命令:</p><pre><code class="hljs csharp">flushdb <span class="hljs-keyword">async</span>: 异步清空数据库flushall <span class="hljs-keyword">async</span>: 异步清空所有数据库</code></pre><p>异步删除配置:</p><pre><code class="hljs coq">slave-<span class="hljs-built_in">lazy</span>-flush: slave接受完rdb文件后，异步清空数据库；lazyfree-<span class="hljs-built_in">lazy</span>-eviction: 异步淘汰key;lazyfree-<span class="hljs-built_in">lazy</span>-expire:   异步key过期;lazyfree-<span class="hljs-built_in">lazy</span>-server-del: 异步内部删除key；生效于<span class="hljs-built_in">rename</span>命令## <span class="hljs-built_in">rename</span>命令: RENAME mykey new_name ## 如果new_name已经存在，会先删除new_name，此时触发上述<span class="hljs-built_in">lazy</span>机制</code></pre><p><strong>1.单个简单key的存储的value过大的解决方案：</strong></p><p><strong>将大key拆分成多个key-value，使用multiGet方法获得值，这样的拆分主要是为了减少单台操作的压力，而是将压力平摊到集群各个实例中，降低单台机器的IO操作。</strong></p><p><strong>2.hash、set、zset、list中存储过多的元素的解决方案：</strong></p><p><strong>1).类似于第一种场景，使用第一种方案拆分;</strong></p><p><strong>2).以hash为例，将原先的hget、hset方法改成（加入固定一个hash桶的数量为10000），先计算field的hash值模取10000，确定该field在哪一个key上。</strong></p><p>将大key进行分割，为了均匀分割，可以对field进行hash并通过质数N取余，将余数加到key上面，我们取质数N为997。</p><p>那么新的key则可以设置为：</p><p>newKey &#x3D; order_20200102_String.valueOf( Math.abs(order_id.hashcode() % 997) )</p><p>field &#x3D; order_id</p><p>value &#x3D; 10</p><p>hset (newKey, field, value) ;  </p><p>hget(newKey, field)</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 持久化</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%20%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%20%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="redis-持久化"><a href="#redis-持久化" class="headerlink" title="redis 持久化"></a>redis 持久化</h2><h3 id="redis持久化的概念："><a href="#redis持久化的概念：" class="headerlink" title="redis持久化的概念："></a>redis持久化的概念：</h3><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制叫做持久化。<br>持久化是为了保障数据安全的。</p><h3 id="持久化保存的是什么？"><a href="#持久化保存的是什么？" class="headerlink" title="持久化保存的是什么？"></a>持久化保存的是什么？</h3><p>那么持久化保存的是什么？<br>Redis持久化有两种形式：<br>1.快照<br>2.记录过程</p><p>快照方式就是我们所说的RDB,记录过程的方式就是AOF。</p><p>RDB(Redis DataBase):<br>RDB是将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p><p>AOF（append only file):<br>AOF是将执行过的指令记录下来，数据恢复时按照从前到后的顺序再将指令执行一遍，实现数据恢复。</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="RDB的启动方式："><a href="#RDB的启动方式：" class="headerlink" title="RDB的启动方式："></a>RDB的启动方式：</h3><p>save指令。作用就是执行一次保存操作。</p><p><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_0.jpg" alt="在这里插入图片描述"><br>通过使用save命令。我们就可以看到生成了一个rdb文件：<br><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_5.jpg" alt="在这里插入图片描述"><br>rdb中的文件是二进制文件。我们是无法打开的。</p><p><strong>当然我们也可以进行默认触发，就是将此命令写入到conf中。</strong></p><h4 id="save指令相关配置："><a href="#save指令相关配置：" class="headerlink" title="save指令相关配置："></a>save指令相关配置：</h4><p>我们使用了RDB生成了文件。接下来我们看看save指令的相关配置：</p><ul><li>dbfilename dump.rdb:<br>设置本地数据库文件名，默认值为dump.rdb，通常设置为dump-端口号.rdb</li><li>dir：<br>设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称为data</li><li>rdbcompression yes:<br>设置存储至本地数据库时是否压缩数据<br>默认为yes，采用LZF压缩。通常设置为开启状态，如果设置为no，可以节省cpu运行时间，但是会使存储的文件变大（巨大）</li><li>rdbchecksum yes<br>设置是否进行RDB文件格式校验，改校验过程在写文件和读文件过程均进行<br>通常默认设置为开启状态，如果设置为no，可以节约读写行过程约10%时间消耗，但是存储一定的数据损坏风险。</li></ul><p><strong>这些命令在conf文件中添加即可生效。</strong></p><h4 id="save指令的工作原理"><a href="#save指令的工作原理" class="headerlink" title="save指令的工作原理"></a>save指令的工作原理</h4><p>save指令是单线程任务执行序列 ，进行一个一个执行的。当我们执行save指令过长的时候，save指令的执行会阻塞当前的Redis服务器。<strong>线上的环境不建议使用</strong>。</p><h4 id="bgsave指令："><a href="#bgsave指令：" class="headerlink" title="bgsave指令："></a>bgsave指令：</h4><p>那么如何处理数据量过大，单线程执行方式造成效率过得问题？<br>我们可以通过后台指令执行。通过bgsave指令来执行。</p><p>当我们执行bgsave指令的时候，它会给redis发送一个消息。之后进行返回消息.他不会立即执行，而是通过fork生成子进程来进行创建rdb文件。做完之后会返回一个消息。</p><p><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_1.jpg" alt="在这里插入图片描述"><br>我们在log中也可以看到这句话：<br><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_3.jpg" alt="在这里插入图片描述"></p><p>bgsave命令式针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都<strong>建议采用bgsave的方式</strong>，<strong>save命令放弃使用</strong>。</p><h3 id="save配置方式"><a href="#save配置方式" class="headerlink" title="save配置方式"></a>save配置方式</h3><p>RDB的启动方式有两种，一种是通过命令的方式。还有一种就是通过写入到conf配置文件中。<br>命令如下：</p><pre><code class="hljs java">save second changes</code></pre><p>second:监控时间范围。<br>changes:监控key的变化量<br>这个的作用就是限定时间范围内key的变化数量达到指定数量及进行持久化操作。</p><p>例如：</p><pre><code class="hljs java">save <span class="hljs-number">200</span> <span class="hljs-number">10</span>：表示<span class="hljs-number">200</span> 秒内如果至少有 <span class="hljs-number">10</span> 个 key 的值变化，则保存</code></pre><p>注意：默认save配置使用的是bgsave操作。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>启动方式<br><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_2.jpg" alt="在这里插入图片描述"><br>还有一些其他的特殊形式来进行启动save：</p><ul><li>全量复制</li><li>debug reload 重启过程中</li><li>shutdown save 关闭服务器</li></ul><p>RDB优点：</p><ul><li>压缩的二进制文件，存储效率高</li><li>内部存储的是redis在某个时间点的快照，非常适合用于数据备份，全量复制场景。</li><li>RDB恢复数据的速度比AOF块</li><li>应用：服务器每隔x小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li></ul><p>RDB缺点：</p><ul><li>RDB 无法做到实时持久化</li><li>bgsave指令每次运行执行fork操作，牺牲性能</li><li>Redis多版本RDB文件格式版本未统一，有可能版本无法兼容。</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF对RDB的一些弊端进行了解决。</p><ul><li>快照思想是读写全部数据，而AOF仅仅记录操作过程</li><li>对所有操作进行记录，排除丢失数据的风险</li><li><strong>解决了数据持久化的实时性</strong></li></ul><p>由于上面的许多优点，AOF已经成为了主流的持久化方式，因此，<strong>我们在使用持久化的时候，最好选择AOF.</strong></p><p>我们看一下AOF写入的过程：<br><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_4.jpg" alt="在这里插入图片描述"><br>写数据的三种策略：</p><ul><li>always:每次写入操作珺同步到AOF文件中，性能差</li><li>everysec：每秒将缓冲区中的指令同步到AOF文件中，数据准确性高。系统宕机丢失一秒的数据。</li><li>no：由操作系统控制每次同步到AOF文件的生命周期，整体过程无法控制。</li></ul><p>从上面三种来看，丢失一秒的数据是我们可容忍的，性能还可以。所以<strong>建议选择everysec</strong>。</p><h4 id="AOF开启"><a href="#AOF开启" class="headerlink" title="AOF开启"></a>AOF开启</h4><p>将 redis.conf 的 appendonly 配置改为 yes 即可</p><pre><code class="hljs java">appendonly yes|noappendfsync always|everysec| no</code></pre><h4 id="AOF改名"><a href="#AOF改名" class="headerlink" title="AOF改名"></a>AOF改名</h4><p>appendfilename ：aof文件名，默认是”appendonly.aof”</p><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><p>随着命令不断写入AOF,文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新的AOF文件的过程。<br>简单来说就是将对同一个数据的若干跳命令执行结果转化成最终结果数据对应的指令进行记录。</p><p>我们将AOF重写之后主要有三点作用：</p><ul><li>降低磁盘占用量，提高效率</li><li>提高IO</li><li>降低数据恢复效率</li></ul><p>AOF重写规则：</p><ul><li>进程内一超市的数据不再写入文件</li><li>忽略无效指令，例如：del key1 hdel key2,srem key3 set key4 111 set key4 222.</li><li>对同一个数据的多条命令合并为一条命令<br>如：</li></ul><pre><code class="hljs java">lpush list1 alpush list1 blpush list1 c</code></pre><p>可以合并为一条</p><pre><code class="hljs java">lpush list1 a b c</code></pre><h4 id="AOF重写方式"><a href="#AOF重写方式" class="headerlink" title="AOF重写方式"></a>AOF重写方式</h4><p>手动重写：bgrewriteof<br><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_6.jpg" alt="在这里插入图片描述"></p><p>自动重写：</p><p>auto-aof-rewrite-percentage :默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。<br>auto-aof-rewrite-min-size：64mb:设置允许重写的最小aof文件大小</p><p>自动重写触发对比参数：（运行指令info persistence获取信息）</p><pre><code class="hljs java">aof_current_sizeaof_base_size</code></pre><p>自动重写触发条件：</p><pre><code class="hljs java">aof_current_size &gt;auto-aof-rewrite-min-sizeaof_current_size-aof_base_size/aof_base_size &gt;= auto-aof-rewrite-percentage</code></pre><h2 id="RDB与AOF区别"><a href="#RDB与AOF区别" class="headerlink" title="RDB与AOF区别"></a>RDB与AOF区别</h2><p><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_8.jpg" alt="在这里插入图片描述"></p><p>如何选择：</p><ul><li>对数据非常敏感，建议使用AOF<br>-AOF持久化策略使用everysecond,每秒钟fsync一次.该策略redis仍可以保持很好的处理性能。出现问题的时候，最多丢失0-1秒内的数据。<br>-aof文件存储体积较大，恢复速度较慢</li><li>数据呈现阶段有效性，建议使用RDB持久化 ,比如游戏宕机了，数据恢复到昨天。数据可以良好的做到阶段内无丢失，恢复速度较快。但是rdb持久化使redis性能降低</li></ul><p>数据敏感：AOF<br>追求大数据的恢复速度rdb<br>灾难恢复rdb<br>双保险RDB AOF同时。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis和数据库操作顺序</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="更新数据时redis和mysql的操作顺序"><a href="#更新数据时redis和mysql的操作顺序" class="headerlink" title="更新数据时redis和mysql的操作顺序"></a>更新数据时redis和mysql的操作顺序</h2><h4 id="1、先删缓存再更新mysql"><a href="#1、先删缓存再更新mysql" class="headerlink" title="1、先删缓存再更新mysql"></a>1、先删缓存再更新mysql</h4><p>结论：产生脏数据的概率较大（若出现脏数据，则意味着再不更新的情况下，查询得到的数据均为旧的数据），多一次 cache miss</p><p>比如：两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p><h4 id="2、先更新mysql再删缓存"><a href="#2、先更新mysql再删缓存" class="headerlink" title="2、先更新mysql再删缓存"></a>2、先更新mysql再删缓存</h4><p>假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p><p>（1）缓存刚好失效</p><p>（2）请求A查询数据库，得一个旧值</p><p>（3）请求B将新值写入数据库</p><p>（4）请求B删除缓存</p><p>（5）请求A将查到的旧值写入缓存</p><p>ok，如果发生上述情况，确实是会发生脏数据。</p><p>然而，发生这种情况的概率又有多少呢？</p><p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，<strong>数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</strong></p><p>副作用：多一次 cache miss</p><h4 id="3、先更新数据库再更新缓存"><a href="#3、先更新数据库再更新缓存" class="headerlink" title="3、先更新数据库再更新缓存"></a>3、先更新数据库再更新缓存</h4><p><strong>原因一：线程安全角度</strong></p><p>同时有请求A和请求B进行更新操作，那么会出现</p><p>（1）线程A更新了数据库</p><p>（2）线程B更新了数据库</p><p>（3）线程B更新了缓存</p><p>（4）线程A更新了缓存</p><p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p><p><strong>原因二：业务场景角度</strong></p><p>有如下两点：</p><p>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</p><p>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p><h4 id="4、先更新缓存再更新数据库"><a href="#4、先更新缓存再更新数据库" class="headerlink" title="4、先更新缓存再更新数据库"></a>4、先更新缓存再更新数据库</h4><p>A和B线程并发时无法保证操作的先后顺序，数据和缓存无法保证一致性，而且大概率会产生不一致。<br>同样，在没有任何分布式保证的前提下，绝对不可以使用“先更新缓存，再更新数据库”的操作顺序 。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关系型数据库和非关系型数据库的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p><strong>概念：</strong>关系型数据库是指采用了关系模型来组织数据的数据库。简单来说，关系模式就是二维表格模型。</p><p>主要代表：SQL Server，Oracle,Mysql,PostgreSQL。</p><p><strong>优点</strong></p><p>（1）容易理解，二维表的结构非常贴近现实世界，二维表格，容易理解。</p><p>（2）使用方便，通用的sql语句使得操作关系型数据库非常方便。</p><p>（3）易于维护，数据库的ACID属性，大大降低了数据冗余和数据不一致的概率。</p><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><p><strong>概念：</strong>NoSQL非关系型数据库，主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统，主要代表MongoDB，Redis、CouchDB。</p><p>NoSQL提出了另一种理念，以键值来存储，且结构不稳定，每一个元组都可以有不一样的字段，这种就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，为了获取用户的不同信息，不需要像关系型数据库中，需要进行多表查询。仅仅需要根据key来取出对应的value值即可。</p><p><strong>缺点：</strong>但是由于Nosql约束少，所以也不能够像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。有一些不能够持久化数据，所以需要和关系型数据库结合。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>关系型数据库适合存储结构化数据，比如：用户的账号、地址：</p><p>（1）这些数据通常需要做结构化查询，比如说Join，这个时候，关系型数据库就要胜出一筹。</p><p>（2）这些数据的规模、增长的速度通常是可以预期的。</p><p>（3）事务性、一致性,适合存储比较复杂的数据。</p><p>NoSql适合存储非结构化数据，比如：文章、评论：</p><p>（1）这些数据通常用于模糊处理，例如全文搜索、机器学习，适合存储较为简单的数据。</p><p>（2）这些数据是海量的，并且增长的速度是难以预期的。</p><p>（3）按照key获取数据效率很高，但是对于join或其他结构化查询的支持就比较差。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多版本并发控制</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库MVCC"><a href="#数据库MVCC" class="headerlink" title="数据库MVCC"></a>数据库MVCC</h2><p>MVCC（multiVersion Concurrency Control）多版本并发控制协议</p><p>​    在实际环境中数据库的事务大都是只读的，读请求是写请求的很多倍，如果写请求和读请求之前没有并发控制机制，那么最坏的情况也是读请求读到了已经写入的数据，这对很多应用完全是可以接受的。</p><p><img src="https://img.draveness.me/2017-10-02-multiversion-scheme.png" alt="multiversion-scheme"></p><p>在这种大前提下，数据库系统引入了另一种并发控制机制 - <em>多版本并发控制</em>（Multiversion Concurrency Control），每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回；在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。</p><h3 id="Mysql中MVCC"><a href="#Mysql中MVCC" class="headerlink" title="Mysql中MVCC"></a>Mysql中MVCC</h3><p>MySQL 中实现的多版本两阶段锁协议（Multiversion 2PL）将 MVCC 和 2PL 的优点结合了起来，每一个版本的数据行都具有一个唯一的时间戳，当有读事务请求时，数据库程序会直接从多个版本的数据项中具有最大时间戳的返回。</p><p><img src="https://img.draveness.me/2017-10-02-multiversion-2pl-read.png" alt="multiversion-2pl-read"></p><p>更新操作就稍微有些复杂了，事务会先读取最新版本的数据计算出数据更新后的结果，然后创建一个新版本的数据，新数据的时间戳是目前数据行的最大版本 <code>＋1</code>：</p><p><img src="https://img.draveness.me/2017-10-02-multiversion-2pl-write.png" alt="multiversion-2pl-write"></p><p>数据版本的删除也是根据时间戳来选择的，MySQL 会将版本最低的数据定时从数据库中清除以保证不会出现大量的遗留内容。</p><h3 id="PostgreSQL-与-MVCC"><a href="#PostgreSQL-与-MVCC" class="headerlink" title="PostgreSQL 与 MVCC"></a>PostgreSQL 与 MVCC</h3><p>与 MySQL 中使用悲观并发控制不同，PostgreSQL 中都是使用乐观并发控制的，这也就导致了 MVCC 在于乐观锁结合时的实现上有一些不同，最终实现的叫做多版本时间戳排序协议（Multiversion Timestamp Ordering），在这个协议中，所有的事务在执行之前都会被分配一个唯一的时间戳，每一个数据项都有读写两个时间戳：</p><p><img src="https://img.draveness.me/2017-10-02-dataitem-with-timestamps.png" alt="dataitem-with-timestamps"></p><p>当 PostgreSQL 的事务发出了一个读请求，数据库直接将最新版本的数据返回，不会被任何操作阻塞，而写操作在执行时，事务的时间戳一定要大或者等于数据行的读时间戳，否则就会被回滚。</p><p>这种 MVCC 的实现保证了读事务永远都不会失败并且不需要等待锁的释放，对于读请求远远多于写请求的应用程序，乐观锁加 MVCC 对数据库的性能有着非常大的提升；虽然这种协议能够针对一些实际情况做出一些明显的性能提升，但是也会导致两个问题，一个是每一次读操作都会更新读时间戳造成两次的磁盘写入，第二是事务之间的冲突是通过回滚解决的，所以如果冲突的可能性非常高或者回滚代价巨大，数据库的读写性能还不如使用传统的锁等待方式。</p><p>参考资料：<a href="https://draveness.me/database-concurrency-control/">https://draveness.me/database-concurrency-control/</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跃表</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>为了解决一个有序表查询的问题，发明的跳跃表，为了插入方便选择用链表，但是链表怎么解决查找的问题呢？这就引出我们要介绍的跳跃表</p><p>​    从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数</p><p>为 2 + 4 + 6 &#x3D; 12 次。有没有优化的算法吗?  链表是有序的，但不能使用二分查找。类似二叉</p><p>搜索树，我们把一些节点提取出来，作为索引。得到如下结构：</p><p><img src="https://images0.cnblogs.com/blog2015/408418/201505/151151540794271.jpg" alt="img"></p><p> 这里我们把 &lt; 14, 34, 50, 72 &gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。</p><p>可以再把部分一级索引的数字提取出来成为二级索引</p><h2 id="跳跃表的插入"><a href="#跳跃表的插入" class="headerlink" title="跳跃表的插入"></a>跳跃表的插入</h2><p>先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）</p><p>然后在 Level 1 … Level K 各个层的链表都插入元素。</p><p>例子：插入 119， K &#x3D; 2</p><h2 id="丢硬币决定-K"><a href="#丢硬币决定-K" class="headerlink" title="丢硬币决定 K"></a>丢硬币决定 K</h2><p>插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：</p><h2 id="跳表的高度。"><a href="#跳表的高度。" class="headerlink" title="跳表的高度。"></a>跳表的高度。</h2><p>n 个元素的跳表，每个元素插入的时候都要做一次实验，用来决定元素占据的层数 K，</p><p>跳表的高度等于这 n 次实验中产生的最大 K</p><h2 id="跳表的空间复杂度分析"><a href="#跳表的空间复杂度分析" class="headerlink" title="跳表的空间复杂度分析"></a>跳表的空间复杂度分析</h2><p>根据上面的分析，每个元素的期望高度为 2， 一个大小为 n 的跳表，其节点数目的</p><p>期望值是 2n。本质是以空间换时间</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>索引explain的使用</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95explain/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95explain/</url>
    
    <content type="html"><![CDATA[<p>有两个重要的属性，type和extre，type是类型，越左边越好。</p><p><strong>type：</strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p><p>system是查已经放入内存的系统表</p><p>const命中主键索引并且返回常数值</p><p>eq_ref是命中主键索引或者唯一索引</p><p>ref是命中普通索引</p><p>range是索引上面的范围查询</p><p>index是使用索引的全表查询，和all速度差不多，官网说比all快是因为查出来的数据是有序的吧。</p><p><strong>extra：</strong></p><p><strong>Using where】</strong></p><p><a href="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729090932514-1337263507.png"><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729090932514-1337263507.png" alt="img"></a></p><p><strong>实验语句</strong>：</p><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-symbol">``</span><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>* <span class="hljs-symbol">``</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">user</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">where</span><span class="hljs-symbol">` `</span>sex=<span class="hljs-symbol">``</span><span class="hljs-string">&#x27;no&#x27;</span><span class="hljs-symbol">``</span>;</code></pre><p><strong>结果说明</strong>：</p><p>　　Extra为Using where说明，SQL使用了where条件过滤数据。</p><p>需要注意的是：</p><p>（1）返回所有记录的SQL，不使用where条件过滤数据，大概率不符合预期，对于这类SQL往往需要进行优化；</p><p>（2）使用了where条件的SQL，并不代表不需要优化，往往需要配合explain结果中的type（连接类型）来综合判断；</p><p>　　本例虽然Extra字段说明使用了where条件过滤，但type属性是ALL，表示需要扫描全部数据，仍有优化空间。</p><p>　　常见的优化方法为，在where过滤属性上添加索引。</p><p>画外音：本例中，sex字段区分度不高，添加索引对性能提升有限。*</p><p><strong>二、【Using index】</strong>　　</p><p><a href="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091039527-949770879.png"><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091039527-949770879.png" alt="img"></a></p><p><strong>实验语句</strong>：</p><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-symbol">``</span><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>id,<span class="hljs-symbol">``</span>name<span class="hljs-symbol">` `</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">user</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">where</span><span class="hljs-symbol">` `</span>name<span class="hljs-symbol">``</span>=<span class="hljs-symbol">``</span><span class="hljs-string">&#x27;shenjian&#x27;</span><span class="hljs-symbol">``</span>;</code></pre><p><strong>结果说明</strong>：</p><p>　　Extra为Using index说明，SQL所需要返回的所有列数据均在一棵索引树上，而无需访问实际的行记录。</p><p>　　这类SQL语句往往性能较好。</p><p><strong>问题来了，什么样的列数据，会包含在索引树上呢？</strong></p><p><strong>三、【Using index condition】</strong></p><p><strong>结果说明：</strong></p><p>Extra为Using index condition说明，确实命中了索引，但不是所有的列数据都在索引树上，还需要访问实际的行记录。</p><p><em>画外音：*<em>聚集索引，普通索引的底层实现差异，详见《</em></em><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961494&idx=1&sn=34f1874c1e36c2bc8ab9f74af6546ec5&chksm=bd2d0d4a8a5a845c566006efce0831e610604a43279aab03e0a6dde9422b63944e908fcc6c05&scene=21#wechat_redirect">1分钟了解MyISAM与InnoDB的索引差异</a>》。*</p><p>这类SQL语句性能也较高，但不如Using index。</p><p><strong>问题来了，如何优化为Using index呢？</strong></p><p>添加聚簇索引，使所有列在索引中。</p><p><strong>四、【Using filesort】</strong></p><p><a href="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091428454-1485068081.png"><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091428454-1485068081.png" alt="img"></a></p><p><strong>实验语句：</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-symbol">``</span><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>* <span class="hljs-symbol">``</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">user</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">order</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">by</span><span class="hljs-symbol">` `</span>sex;</code></pre><p><strong>结果说明：</strong></p><p>　　Extra为Using filesort说明，得到所需结果集，需要对所有记录进行文件排序。</p><p>　　这类SQL语句性能极差，需要进行优化。</p><p>　　典型的，在一个没有建立索引的列上进行了order by，就会触发filesort，常见的优化方案是，在order by的列上添加索引，避免每次查询都全量排序。</p><p><strong>五、【Using temporary】</strong></p><p><a href="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091518732-1550780386.png"><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091518732-1550780386.png" alt="img"></a></p><p><strong>实验语句：</strong></p><pre><code class="hljs autohotkey">explain ``select` `* ``from` `user` `group` `by` `name` `order` `by` `sex<span class="hljs-comment">;</span></code></pre><p><strong>结果说明：</strong></p><p>　　Extra为Using temporary说明，需要建立临时表(temporary table)来暂存中间结果。 </p><p>　　这类SQL语句性能较低，往往也需要进行优化。</p><p>　　典型的，group by和order by同时存在，且作用于不同的字段时，就会建立临时表，以便计算出最终的结果集。</p><p><strong>六、【Using join buffer (Block Nested Loop)】</strong></p><p><a href="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091608174-768087803.png"><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091608174-768087803.png" alt="img"></a></p><p><strong>实验语句：</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-symbol">``</span><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>* <span class="hljs-symbol">``</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">user</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">where</span><span class="hljs-symbol">` `</span>id <span class="hljs-symbol">``</span><span class="hljs-keyword">in</span><span class="hljs-symbol">``</span>(<span class="hljs-symbol">``</span><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>id <span class="hljs-symbol">``</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">user</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">where</span><span class="hljs-symbol">` `</span>sex=<span class="hljs-symbol">``</span><span class="hljs-string">&#x27;no&#x27;</span><span class="hljs-symbol">``</span>);</code></pre><p><strong>结果说明：</strong></p><p>　　Extra为Using join buffer (Block Nested Loop)说明，需要进行嵌套循环计算。</p><p>　　<em>画外音：**内层和外层的type均为ALL，rows均为4，需要循环进行4*4次计算。</em></p><p>　　这类SQL语句性能往往也较低，需要进行优化。</p><p>　　典型的，两个关联表join，关联字段均未建立索引，就会出现这种情况。常见的优化方案是，在关联字段上添加索引，避免每次嵌套循环计算。</p><p><strong>七、使用字符串查找数字索引的列会命中吗</strong></p><p>1、在一次MySQL查询中，某字段为 varchar 字符串类型，传入参数值为 int 数字类型，发现查询的结果和预期的不一致。 如： 某两列 name&#x3D;’11’ , name &#x3D; ‘11aa’ 。 where name &#x3D; 11 ， 可以查到 ‘11’ 和 ‘11aa’ 两个结果，这里是错误的；而 where name &#x3D;’11’ ，能得到预期结果。</p><p>2、反之，字段为 int 数字类型，传入参数值为 varchar 字符串类型，也能查到数据，同样查询的结果和预期的不一致。如：age&#x3D;2的数据有2条。where age &#x3D; 2 ， 可以正常查到数据 ； 而 where age &#x3D; ‘2aabbcc’，查到的数据结果和 where age &#x3D; 2 是一样的，这里是错误的，应该查不到数据。</p><p>结论：</p><p>1、原因： 当MySQL字段类型和传入条件数据类型不一致时，会进行隐形的数据类型转换（MySQL Implicit conversion）</p><p>2、若字符串是以数字开头，且全部都是数字，则转换为数字结果是整个字符串；部分是数字，则转换为数字结果是截止到第一个不是数字的字符为止。 理解： varchar str &#x3D; “123dafa”，转换为数字是123 。 SELECT ‘123dafa’+1 ; — 124 。</p><p>3、若字符串不是以数字开头，则转换为数字结果是 0 。 varchar str &#x3D; “aabb33” ; 转换为数字是 0 。 SELECT ‘aabb33’+100 ; — 100 。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>io多路复用</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="io多路复用概念"><a href="#io多路复用概念" class="headerlink" title="io多路复用概念"></a>io多路复用概念</h3><p>​    IO多路复用是一种同步IO模型，一个线程监听多个IO事件，当有IO事件就绪时，就会通知线程去执行相应的读写操作，没有就绪事件时，就会阻塞交出cpu。多路是指网络链接，复用指的是复用同一线程。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ol><li>用户线程调用select，将fd_set从用户空间拷贝到内核空间</li><li>内核在内核空间对fd_set遍历一遍，检查是否有就绪的socket描述符，如果没有的话，就会进入休眠，直到有就绪的socket描述符</li><li>内核返回select的结果给用户线程，即就绪的文件描述符数量</li><li>用户拿到就绪文件描述符数量后，再次对fd_set进行遍历，找出就绪的文件描述符</li><li>用户线程对就绪的文件描述符进行读写操作</li></ol><p>优点</p><ol><li>所有平台都支持，良好的跨平台性</li></ol><p>缺点</p><ol><li>每次调用select，都需要将fd_set从用户空间拷贝到内核空间，当fd很多时，这个开销很大</li><li>最大连接数（支持的最大文件描述符数量）有限制，一般为1024</li><li>每次有活跃的socket描述符时，都需要遍历一次fd_set，造成大量的时间开销，时间复杂度是O(n)</li><li>将fd_set从用户空间拷贝到内核空间，内核空间也需要对fd_set遍历一遍</li></ol><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>数据结构定义如下，<strong>链表</strong>存储</p><pre><code class="hljs c"><span class="hljs-comment">/* Data structure describing a polling request.  */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span></span><span class="hljs-class">  &#123;</span>    <span class="hljs-type">int</span> fd;<span class="hljs-comment">/* File descriptor to poll.  */</span>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> events;<span class="hljs-comment">/* Types of events poller cares about.  */</span>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> revents;<span class="hljs-comment">/* Types of events that actually occurred.  */</span>  &#125;;</code></pre><p>与select的异同点</p><p>相同点：</p><p>（执行过程与select类似）</p><ol><li>内核线程都需要遍历文件描述符，并且当内核返回就绪的文件描述符数量后，还需要遍历一次找出就绪的文件描述符</li><li>需要将文件描述符数组或链表从用户空间拷贝到内核空间</li><li>性能开销会随文件描述符的数量而线性增大</li></ol><p>不同点：</p><ol><li>select存储的数据结构是文件描述符数组，poll采用链表</li><li>select有最大连接数限制，poll没有最大限制，因为poll采用链表存储</li></ol><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ol><li><p>epoll_create创建eventpoll对象（红黑树，双链表）</p></li><li><p>一棵红黑树，存储监听的所有文件描述符，并且通过epoll_ctl将文件描述符添加、删除到红黑树</p></li><li><p>一个双链表，存储就绪的文件描述符列表，epoll_wait调用时，检测此链表中是否有数据，有的话直接返回</p></li><li><p>所有添加到eventpoll中的事件都与设备驱动程序建立回调关系</p></li></ol><p>缺点</p><ol><li>只能工作在linux下</li></ol><p>优点</p><ol><li>时间复杂度为O(1)，当有事件就绪时，epoll_wait只需要检测就绪链表中有没有数据，如果有的话就直接返回</li><li>不需要从用户空间到内核空间频繁拷贝文件描述符集合，使用了内存映射(mmap)技术</li><li>当有就绪事件发生时采用回调的形式通知用户线程</li></ol><ul><li>应用场景<ol><li>连接数较少并且都很活跃,用select和poll效率更高</li><li>连接数较多并且都不很活跃,使用epoll效率更高</li></ol></li></ul><p>参考文章：<a href="https://juejin.cn/post/6931543528971436046">https://juejin.cn/post/6931543528971436046</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux由哪几部分组成</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E7%94%B1%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E7%94%B1%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h3 id="Linux由哪几部分组成"><a href="#Linux由哪几部分组成" class="headerlink" title="Linux由哪几部分组成"></a>Linux由哪几部分组成</h3><p>一．Linux内核<br>内核是操作系统的核心，具有很多最基本功能，如虚拟内存、多任务、共享库、需求加载、可执行程序和TCP&#x2F;IP网络功能。Linux内核的模块分为以下几个部分：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等。<br>二．Linux shell<br>shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。<br>三．Linux文件系统<br>文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、EXT3、FAT、FAT32、VFAT和ISO9660。<br>四．Linux应用程序<br>标准的Linux系统一般都有一套都有称为应用程序的程序集，它包括文本编辑器、编程语言、XWindow、办公套件、Internet工具和数据库等。</p><h4 id="内核的作用是什么"><a href="#内核的作用是什么" class="headerlink" title="内核的作用是什么"></a>内核的作用是什么</h4><ol><li><strong>内存管理：</strong>追踪记录有多少内存存储了什么以及存储在哪里</li><li><strong>进程管理：</strong>确定哪些进程可以使用中央处理器（CPU）、何时使用以及持续多长时间</li><li><strong>设备驱动程序：</strong>充当硬件与进程之间的调解程序&#x2F;解释程序</li><li><strong>系统调用和安全防护：</strong>从流程接受服务请求</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要用补码表示数字</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%AD%97/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么要用补码表示数字"><a href="#为什么要用补码表示数字" class="headerlink" title="为什么要用补码表示数字"></a>为什么要用补码表示数字</h3><p>1、计算机里面只有加法，没有减法，能够处理数字的减法</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟内存</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h2><p>1、保证数据的安全性，因为如果程序运行在物理内存的话会很容易内存越界访问到其他程序的数据，并且这个会导致操作系统把这个程序杀掉，这样恶意进程就不容易访问到其他进程的数据。</p><p>2、通过分段或者分页方式在内存和硬盘之间构建一层中间层，通过页表把虚拟内存和物理块连接起来，可以提高内存使用率。</p><p>3、可以把一个超过需要内存大小的程序导入到内存中，每次导入一部分，如果缺少数据就缺页中断把缺少的数据从硬盘中导入到内存。</p><p>因为每个进程都使用虚拟内存，无法知道其他进程的地址，这样如果进程间要通话的话需要借助其他方式。</p><h4 id="进程通话方式"><a href="#进程通话方式" class="headerlink" title="进程通话方式"></a><a href="http://sjy.我爱你/2022/03/25/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F">进程通话方式</a></h4>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>僵尸进程</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>一个父进程开启了一堆子进程, 当子进程比父进程先运行完(死掉),操作系统会释放子进程占用的重型资源(内存空间, CPU资源, 打开的文件),但会保留子进程的关键信息(PID, 退出状态, 运行时间等),目的是为了让父进程能随时查看自己的子进程信息(不管该子进程有没有死掉),这种已经死掉的子进程都会进入僵尸状态, ‘‘僵尸进程’’是Linux系统的一种数据结构<br>这些子进程完成执行后会发送一个 Exit 信号然后死掉。这个 Exit 信号需要被父进程所读取。父进程需要随后调用 wait 命令来读取子进程的退出状态，并将子进程从进程表中移除。</p><p>若父进程正确第读取了子进程的 Exit 信号，则子进程会从进程表中删掉。</p><p>但若父进程未能读取到子进程的 Exit 信号，则这个子进程虽然完成执行处于死亡的状态，但也不会从进程表中删掉。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>程序在运行中奔溃了，估计是框架又帮忙重启了，导致会产生僵尸进程</p><h3 id="坏处："><a href="#坏处：" class="headerlink" title="坏处："></a>坏处：</h3><p>虽然不会浪费内存、cpu资源等文件，但是会浪费pid，多了之后pid会不够用。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>操作系统保留子进程信息供父进程查看</li><li>当父进程觉得<strong>不再需要</strong>查看的时候, 会向操作系统发送一个 <strong>wait &#x2F; waitpid</strong> 系统调用</li><li>于是操作系统<strong>再次清理</strong>僵尸进程的残余信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组和链表查询效率区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="数组和链表查询效率区别"><a href="#数组和链表查询效率区别" class="headerlink" title="数组和链表查询效率区别"></a>数组和链表查询效率区别</h2><pre><code class="hljs gcode">CPU 寄存器 – immediate access <span class="hljs-comment">(0-1个CPU时钟周期)</span>CPU L<span class="hljs-number">1</span> 缓存  – fast access <span class="hljs-comment">(3个CPU时钟周期)</span>CPU L<span class="hljs-number">2</span> 缓存 – slightly slower access <span class="hljs-comment">(10个CPU时钟周期)</span>内存 <span class="hljs-comment">(RAM)</span>   – slow access <span class="hljs-comment">(100个CPU时钟周期)</span>硬盘 <span class="hljs-comment">(file system)</span> – very slow <span class="hljs-comment">(10,000,000个CPU时钟周期)</span></code></pre><p>​    CPU缓存会把一片连续的内存空间读入，因为数组结构是连续的内存地址，所以数组全部或者部分元素被连续存在CPU缓存里面，平均读取每个元素的时间只要3个CPU时钟周期。 而链表的节点是分散在堆空间里面的，这时候CPU缓存帮不上忙，只能是去读取内存，平均读取时间需要100个CPU时钟周期。这样算下来，数组访问的速度比链表快33倍！ （这里只是介绍概念，具体的数字因CPU而异）。</p><h5 id="操作系统局部性原理"><a href="#操作系统局部性原理" class="headerlink" title="操作系统局部性原理"></a>操作系统局部性原理</h5><ul><li>时间局部性</li><li>空间局部性</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程和线程上下文切换的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="进程和线程上下文切换的区别"><a href="#进程和线程上下文切换的区别" class="headerlink" title="进程和线程上下文切换的区别"></a>进程和线程上下文切换的区别</h2><h4 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h4><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-d831951a5e41bbfb1e0e1151a8a2b649_1440w.jpg" alt="img"></p><p>进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p><p>在这个过程中就发生了 CPU 上下文切换，整个过程是这样的：<br>1、保存 CPU 寄存器里原来用户态的指令位<br>2、为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。<br>3、跳转到内核态运行内核任务。<br>4、当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。</p><p>所以，<strong>一次系统调用的过程，其实是发生了两次 CPU 上下文切换</strong>。（用户态-内核态-用户态）</p><p>不过，需要注意的是，<strong>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程</strong>。这跟我们通常所说的进程上下文切换是不一样的：<strong>进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行。</strong></p><h2 id="进程上下文切换跟系统调用又有什么区别呢"><a href="#进程上下文切换跟系统调用又有什么区别呢" class="headerlink" title="进程上下文切换跟系统调用又有什么区别呢"></a>进程上下文切换跟系统调用又有什么区别呢</h2><p>首先，<strong>进程是由内核来管理和调度的，进程的切换只能发生在内核态</strong>。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p><p>因此，<strong>进程的上下文切换就比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈</strong>。</p><p>如下图所示，保存上下文和恢复上下文的过程并不是“免费”的，需要内核在 CPU 上运行才能完成。</p><p><img src="https://pic3.zhimg.com/80/v2-440bb1699b2fa0f0340b38eabcbd7452_1440w.jpg" alt="img"></p><h2 id="发生进程上下文切换的场景"><a href="#发生进程上下文切换的场景" class="headerlink" title="发生进程上下文切换的场景"></a>发生进程上下文切换的场景</h2><ol><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li><li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li></ol><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>线程与进程最大的区别在于：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><p>所以，对于线程和进程，我们可以这么理解： - 当进程只有一个线程时，可以认为进程就等于线程。 - 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。 - 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p><h2 id="发生线程上下文切换的场景"><a href="#发生线程上下文切换的场景" class="headerlink" title="发生线程上下文切换的场景"></a>发生线程上下文切换的场景</h2><ol><li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li><li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</li></ol><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/52845869">https://zhuanlan.zhihu.com/p/52845869</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的六个原则</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E4%B8%AA%E5%8E%9F%E5%88%99/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E4%B8%AA%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>一个类或者接口只负责唯一职责，尽量设计出单一功能的接口</p><p>给一个类加上各种各样的功能，这就意味着无论任何需求来，都要更改这个类，这很糟糕，维护麻烦，复用更加不可能，也缺乏灵活性。</p><h3 id="2、依赖倒转原则"><a href="#2、依赖倒转原则" class="headerlink" title="2、依赖倒转原则"></a>2、依赖倒转原则</h3><p>高层模块不应该依赖低层模块具体实现，解耦高层和低层，既面向接口编程，当发送变化时，只需要提供新的实现类，不需要修改高层代码</p><p><strong>（1）高层模块不应该依赖于低层模块，两个都应该依赖于抽象</strong></p><p><strong>（2）抽象不应该依赖细节，细节应该依赖于抽象</strong></p><h3 id="3、开放封闭原则"><a href="#3、开放封闭原则" class="headerlink" title="3、开放封闭原则"></a>3、开放封闭原则</h3><p>程序对外扩展开放，对修改关闭，当需求发生变化时，我们可以通过添加新模块来满足新需求，而不是通过修改原来的实现代码来满足新的需求。</p><h3 id="4、迪米特法则（最小知识原则）"><a href="#4、迪米特法则（最小知识原则）" class="headerlink" title="4、迪米特法则（最小知识原则）"></a>4、迪米特法则（最小知识原则）</h3><p>一个软件实体应当尽可能的少与其他实体发生相互作用，每一个软件单位对其他软件单位都只有最少知识</p><h3 id="5、接口隔离原则"><a href="#5、接口隔离原则" class="headerlink" title="5、接口隔离原则"></a>5、接口隔离原则</h3><p>客户端不应该依赖他不需要的接口，类间的依赖关系应建立在最小的接口上。</p><h4 id="接口隔离原则的优点"><a href="#接口隔离原则的优点" class="headerlink" title="接口隔离原则的优点"></a>接口隔离原则的优点</h4><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><ol><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ol><h3 id="6、里式替换原则"><a href="#6、里式替换原则" class="headerlink" title="6、里式替换原则"></a>6、里式替换原则</h3><p>任何基类可以出现的地方，子类一定可以出现，里式代换原则是继承复用的基石。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>​    举个例子，一个被装饰与多种装饰物，多个装饰物层层嵌套的，举个例子，一个人是被装饰物，衣服，裤子，鞋子，是装饰物，先给人装饰衣服，可以自己选白色衣服，然后用白色裤子装饰穿着白色衣服的人，再用黑色鞋子装饰穿着白色衣服白色鞋子的人，这个装饰关系的嵌套关系。</p><p>​    使用场景是需要添加新功能，但是旧功能全部保留，就可以用装饰模式来设计。好处是把类的核心模块和装饰模块分开了，去除相关类中重复的部分。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oauth2</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/oauth/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/oauth/</url>
    
    <content type="html"><![CDATA[<h2 id="Oauth2是什么？"><a href="#Oauth2是什么？" class="headerlink" title="Oauth2是什么？"></a>Oauth2是什么？</h2><p>概念：oauth2是一个开放标准的授权协议</p><h3 id="OAuth中的角色"><a href="#OAuth中的角色" class="headerlink" title="OAuth中的角色"></a>OAuth中的角色</h3><p>OAuth 2 标准中定义了以下几种角色：</p><ul><li>资源所有者（Resource Owner）</li><li>资源服务器（Resource Server）</li><li>授权服务器（Authorization Server）</li><li>客户端（Client）</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gn2t38nqj219s0u0diw.jpg"></p><ol><li>Authrization Request<br>客户端向用户请求对资源服务器的<code>authorization grant</code>。</li><li>Authorization Grant（Get）<br>如果用户授权该次请求，客户端将收到一个<code>authorization grant</code>。</li><li>Authorization Grant（Post）<br>客户端向授权服务器发送它自己的客户端身份标识和上一步中的<code>authorization grant</code>，请求访问令牌。</li><li>Access Token（Get）<br>如果客户端身份被认证，并且<code>authorization grant</code>也被验证通过，授权服务器将为客户端派发<code>access token</code>。授权阶段至此全部结束。</li><li>Access Token（Post &amp;&amp; Validate）<br>客户端向资源服务器发送<code>access token</code>用于验证并请求资源信息。</li><li>Protected Resource（Get）<br>如果<code>access token</code>验证通过，资源服务器将向客户端返回资源信息。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么python慢</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%B8%BA%E4%BB%80%E4%B9%88python%E6%85%A2/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%B8%BA%E4%BB%80%E4%B9%88python%E6%85%A2/</url>
    
    <content type="html"><![CDATA[<p>​    </p><p>以下是最主要的原因：</p><ul><li>“它是GIL（Global Interpreter Lock全局解释器锁）”</li><li>“它是解释型语言而非编译语言”</li><li>“它是动态类型语言”</li></ul><p>那么以上哪种原因对性能影响最大呢？</p><p><strong>“它是全局解释器锁”</strong></p><h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>当CPython创建变量时，它会预先分配存储空间，然后计算当前变量的引用数目。这个概念被称为引用计数。如果引用计数为零，那么它将从系统中释放对应存储区域。</p><p>这就是为什么在CPython中创造“临时”变量不会使应用占用大量的存储空间——尤其是当应用中使用了for循环这一类可能大量创建“临时”变量的结构时。</p><p>当存在多个线程调用变量时，CPython如何锁住引用计数成为了一个挑战。而“全局解释锁”应运而生，它能够谨慎控制线程的执行。无论有多少的线程，解释器每次只能执行一个操作。</p><p>这对Python的性能意味着什么呢？</p><p>如果你的应用基于单线程、单解释器，那么讨论速度这一点就毫无意义，因为去掉GIL并不会影响代码性能。</p><p>如果你想使用线程在单解释器（Python 进程）中实现并发，并且你的线程为IO密集型（例如网络IO或磁盘IO），你就会看到GIL争用的结果。</p><h3 id="是解释语言"><a href="#是解释语言" class="headerlink" title="是解释语言"></a>是解释语言</h3><p>文章没看懂</p><h3 id="是动态语言"><a href="#是动态语言" class="headerlink" title="是动态语言"></a>是动态语言</h3><p>​    需要在运行的时候判断类型，加快了开发效率，但是增加了编译解释的时间，提高了灵活性，牺牲了效率。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go和java和c++接口的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/go%E5%92%8Cjava%E5%92%8Cc++%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/go%E5%92%8Cjava%E5%92%8Cc++%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>依赖倒转原则：高层模块不应该依赖于低层模块，二者都应该依赖于抽象，接口就是高层模块和底层模块的中间层，用于降低耦合性。</p><p>接口的作用：    </p><p>1、降低类间的耦合性</p><p>2、提高并行开发的风险</p><p>java需要显示实现接口，就是需要写implement XXX，Golang是隐式实现，经典的鸭子理论，长的像鸭子，叫起来像鸭子，就是鸭子，举个例子是sort.Sort函数，只要是实现这个的interface里面的函数的类传进去就能调用他。</p><p>​    golang接口可以作为接近范型来使用，可以作为参数传入，java不行</p><p>C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。例如：</p><p>class Shape</p><p>{</p><p>   public:</p><p>​      &#x2F;&#x2F; 纯虚函数</p><p>​      virtual double getArea() &#x3D; 0;</p><p>   private:</p><p>​      string name;      &#x2F;&#x2F; 名称</p><p>};</p><p>设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p><p>派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。</p><p>C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</p><p>C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 <code>itab</code>， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java基本数据类型</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>整数<strong>类型</strong>：byte，short，int，long.</li><li>浮点数<strong>类型</strong>：float，double.</li><li>字符<strong>类型</strong>：char.</li><li>布尔<strong>类型</strong>：boolean.</li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java三大特性</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类继承父类，获得父类的方法和属性</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把同一类方法封装到同一个类中</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>（1）、重写：子类定义了一个方法，其方法名、返回值类型，参数列表与父类中某个方法一样，就说子类重写父类的同名方法。</p><p>（2）、重载：同一个类中存在多个方法的方法名相同，但是参数列表不同，体现了多态。</p><p>golang不支持重载。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP拥塞处理</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E/</url>
    
    <content type="html"><![CDATA[<h5 id="为什么要TCP拥塞控制"><a href="#为什么要TCP拥塞控制" class="headerlink" title="为什么要TCP拥塞控制"></a>为什么要TCP拥塞控制</h5><h5 id="网络拥塞："><a href="#网络拥塞：" class="headerlink" title="网络拥塞："></a>网络拥塞：</h5><p>​    网络中对某一资源的需求量超过该资源所提供的可用部分，网络性能就会变坏，这种叫做网络拥塞，若出现拥塞不进行控制，随着网络请求的增加会导致吞吐量越来越小，最后会导致吞吐量为0，形成死锁，TCP拥塞控制就是要解决这个问题。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gigbu8loj21080kemz8.jpg"></p><h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><h6 id="1、慢开始，拥塞避免"><a href="#1、慢开始，拥塞避免" class="headerlink" title="1、慢开始，拥塞避免"></a>1、慢开始，拥塞避免</h6><p>​    发送方维持一个动态大小的拥塞窗口cwnd（congestion window），假设初始设置慢启动阈值为sstresh16，慢开始起始cwnd为1，服务端返回一个确认报文，每次乘以2，第二次发送2个报文，服务端返回两个确认报文，直到慢启动阈值16为止，开始拥塞避免，每次只加一，服务器返回相同数量的确认报文，直到网络拥塞</p><p>怎么确认网络已经拥塞了？</p><p>假设24个报文在传输过程中有4个报文丢失，有4个报文重传计时器超时，缺失四个数量的确认报文，表示了网络拥塞，然后把慢启动阈值设为网络拥塞时的cwnd的一半，再重置cwnd为一半执行拥塞避免。（之前的版本是觉察到网络拥塞就再执行慢启动，现在已经废除了）</p><h6 id="2、快重传，快恢复"><a href="#2、快重传，快恢复" class="headerlink" title="2、快重传，快恢复"></a>2、快重传，快恢复</h6><p>​    快重传就是让发送方尽快进行重传，在重传计时器超时之前完成重传，假设在发送M3报文后发生了数据报文丢失，没有立即发送确认报文，就发送M4,M5,M6报文，每接收方接收到一次报文，就发送一个确认M3报文，接收到连续三个的确认报文，发送方就知道现在网络是不拥塞的，立即重传M3，接收方回复收到M6，避免重复传，之后从M7开始重新传报文，服务端发送确认M7报文。</p><p>​    快恢复是发送方一但接收三次重复的确认报文，会开始快恢复</p><p>1、发送发会把sstresh慢开始门限值设为当前的cwnd拥塞窗口的一半，开始执行避免拥塞算法</p><p>2、也有把快速恢复开始时的拥塞窗口cwnd再增大一些</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次完整的HTTP请求过程</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/http%E5%AE%8C%E6%95%B4%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/http%E5%AE%8C%E6%95%B4%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1、域名解析"><a href="#1、域名解析" class="headerlink" title="1、域名解析"></a>1、域名解析</h3><p>浏览器解析域名得到对应的IP地址</p><p><a href="http://sjy.我爱你/2022/03/20/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/DNS%E8%A7%A3%E6%9E%90/">DNS解析过程</a></p><h3 id="2、TCP三次握手"><a href="#2、TCP三次握手" class="headerlink" title="2、TCP三次握手"></a>2、TCP三次握手</h3><p><a href="http://sjy.我爱你/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">三次握手详解</a></p><h3 id="3、建立连接发起HTTP请求"><a href="#3、建立连接发起HTTP请求" class="headerlink" title="3、建立连接发起HTTP请求"></a>3、建立连接发起HTTP请求</h3><h3 id="4、服务器响应http请求，浏览器得到html代码"><a href="#4、服务器响应http请求，浏览器得到html代码" class="headerlink" title="4、服务器响应http请求，浏览器得到html代码"></a>4、服务器响应http请求，浏览器得到html代码</h3><h3 id="5、浏览器解析html码，并请求html代码中的资源"><a href="#5、浏览器解析html码，并请求html代码中的资源" class="headerlink" title="5、浏览器解析html码，并请求html代码中的资源"></a>5、浏览器解析html码，并请求html代码中的资源</h3><h3 id="6、浏览器对页面进行渲染给用户"><a href="#6、浏览器对页面进行渲染给用户" class="headerlink" title="6、浏览器对页面进行渲染给用户"></a>6、浏览器对页面进行渲染给用户</h3>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络协议层详情</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82%E8%AF%A6%E6%83%85/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82%E8%AF%A6%E6%83%85/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>OSI七层模型</th><th>TCP四层协议</th><th>综合五层协议</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>应用层</td></tr><tr><td>表示层</td><td></td><td></td></tr><tr><td>会话层</td><td></td><td></td></tr><tr><td>运输层</td><td>运输层</td><td>运输层</td></tr><tr><td>网络层</td><td>网络层</td><td>网络层</td></tr><tr><td>数据链路层</td><td>网络接口层</td><td>数据链路层</td></tr><tr><td>物理层</td><td></td><td>物理层</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三次握手，四次挥手</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><strong>报文结构：</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gcwqp4x2j20on0ewwft.jpg"></p><h4 id="TCP有哪些特点"><a href="#TCP有哪些特点" class="headerlink" title="TCP有哪些特点"></a>TCP有哪些特点</h4><p>1、TCP是面向连接的</p><p>2、是点对点通信的</p><p>3、TCP提供可靠交付服务，无差错，不丢失，不重复按序到达</p><p>4、TCP是面向字节流的服务</p><p>5、TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>大致理解：tcp为了确认传输数据的安全，第一次发送特殊tcp报文段给客户，客户第二次回复特殊的tcp报文段给服务器，第三次服务器发送要发送的数据给客户。</p><p><img src="https://img2018.cnblogs.com/blog/1344250/201904/1344250-20190402114137828-2119548758.png"></p><ul><li>第一次客户端发送SYN&#x3D;1和初始化的序列号seq x给服务器请求连接连接（ SYN：同步标志）</li><li>第二次服务器回复ACK&#x3D;1，ack&#x3D;x+1,seq&#x3D;y是发送数据的第一个字符的数据编号，SYN为1 代表收到消息并且也请求连接</li><li>第三次用户回复ACK&#x3D;1，ack为y+1，sep为x+1的tcp报文，连接完毕可以传输数据</li></ul><p>ACK代表确认（acknowledge character）</p><p>序列号seq就是这个报文段中的第一个字节的数据编号</p><h4 id="2、四次挥手"><a href="#2、四次挥手" class="headerlink" title="2、四次挥手"></a>2、四次挥手</h4><p><img src="https://img2018.cnblogs.com/blog/1344250/201904/1344250-20190402114059390-716421818.png"></p><ul><li>用户和服务器其中两个都可以终止连接，假设用户想取消连接了，先给服务器发送一个FIN置为1,seq为u的报文。</li><li>服务器收到之后，会立马回复一个ACK为1，ack为u+1，seq为v的报文，ack会自动回复上一个报文加一的seq数据，表示收到。</li><li>隔了一个close_wait时间回复一个FIN置为1，ACK置为1的报文，seq为w，ack为u+1表示同意，为什么要等待一段时间，是因为要询问上层的软件是否同意关闭，服务器不发FIN代表自己可以收到消息但是客户不会发消息了</li><li>最后用户回复ACK为1，seq为u+1,ack为w+1的报文，结束连接。</li></ul><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a><a href="http://sjy.我爱你/2022/03/20/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E/">TCP拥塞控制</a></h3><h3 id="SYN洪范攻击"><a href="#SYN洪范攻击" class="headerlink" title="SYN洪范攻击"></a>SYN洪范攻击</h3><p>服务器为了响应一个收到的SYN，分配并初始化连接变量和缓存，如果攻击者发送大量的TCP SYN报文，服务器不断为这些半开连接分配资源，导致服务器的连接资源消耗殆尽。</p><p>解决办法：<strong>SYN cookie</strong></p><p>服务器接收到一个SYN包的时候并不生成一个半开连接，而是生成一个源ip+目的ip+秘密数的一个值，发送过去，但是并不保存，如果客户端发过来的值是确认值+1，那就说明是合法用户，生成一个套接字的全开连接。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987546/image-20210921112213523.png" alt="img"></p><p>TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>1、 为什么三次握手？而不是两次握手</strong></p><p>三次握手是得把ACK和SYN都发送给对方，三次握手才能保证双方都接收到消息，第一次是喂，用户：我要连接，服务器：好，我收到了，用户：我收到你的收到了，如果是两次握手那服务器不知道客户收到没有。四次握手是没必要，已经有很大概率链接连接成功了，而且四次握手需要更多的网络资源。</p><p><strong>为什么第三次挥手要等一会再发送？</strong></p><p>原因就是可能上层应用还在发送数据，第一个FIN发过来就告诉上层应用连接要关闭啦，没穿完数据就快点传完，然后等一个close wait自动发送第二个fin包，这样防止数据丢失。</p><p><strong>2、为什么客户端最后还要等待2MSL？</strong></p><p>确实服务器收到了ACK&#x3D;1，如果没收到可以等计时器超时服务器再重发第三次挥手，客户端接受了再发送ACK。</p><p><strong>3、ISN代表什么？意义何在？</strong></p><p>发送方的字节数据编号的原点，isn代表双方连接的钥匙，钥匙要对上孔</p><p>4、<strong>ISN是固定不变的吗？</strong></p><p>动态随机</p><p>5、<strong>ISN为何要动态随机？</strong></p><p>防止被第三方猜到，从而被第三方仿造的RST报文的reset。</p><p><strong>6、三次握手的第一次可以携带数据吗？为何？</strong>对方难道不可以将数据缓存下来，等握手成功再提交给应用程序？</p><p><strong>不可以，三次握手还没有完成。</strong>，因为如果带大量1k字节数据的话服务器要开辟大量缓存来处理，容易使服务器拒绝访问，这是洪泛攻击</p><p><strong>7、第三次可以携带数据吗？为何？</strong></p><p>可以，能够发送第三次代表第二次报文已经接收到了，伪装的ip接收不到第二次报文，所以第三次发送的时候是安全的。</p><p><strong>8、如果输入的端口不存在会怎么办</strong></p><p>握手不能进行，会出现超时未响应的错误。</p><p><strong>9、为什么断开连接却需要四次呢？</strong></p><p>1、确保数据能够完整传输。<br>2、当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p><strong>10、TCP四次挥手出现大量time_wait是什么原因</strong></p><p>TIME_WAIT产生条件：TCP四次挥手中，第一个发送FIN&#x3D;1的TCP报文的人称为主动关闭者，主动关闭者在发送四次挥手最后一个ACK后会变成TIME_WAIT状态，持续时间为2MSL（linux一个MSL为30s，不可配置）</p><p>出现这么多短连接很可能是因为使用了http 1.0 ，使用非持久连接，因为http 1.0请求一次就建立一次tcp连接，请求完立马关闭连接。</p><p><strong>11、怎么复用TCP链接</strong></p><ul><li><p>使用http1.1中的持久连接，传输完一个数据后不关闭tcp连接，可以复用tcp链接。</p></li><li><p><a href="http://sjy.我爱你/2022/03/22/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP1.0%E5%92%8C2.0%E7%9A%84%E5%8C%BA%E5%88%AB/">使用http2.0中tcp多路复用技术</a></p></li></ul><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p>UDP报文：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ge8y7o54j22ab0t677i.jpg"></p><p>TCP的优点：提供可靠稳定安全的连接，无差错，不重复，不丢失，三次握手建立连接，数据传输时有确认、窗口、重传、拥塞控制，数据传完还有四次挥手断开连接。</p><p>TCP缺点：慢，效率低，开销较大，占用硬件资源多，传输效率较低，TCP有确认机制容易被人利用，实现DDOS等攻击</p><p>UDP的优点：无状态的传输协议，单位时间传输数据多。</p><p>UDP的缺点：不可靠，在网络不好的时候容易丢包。</p><p>TCP和UPD的区别</p><p>1、基于连接与无连接</p><p>2、对系统资源的要求不同</p><p>3、UDP程序结构比较简单</p><p>4、TCP要求数据正确，保证数据顺序；UDP可能丢包，不保证数据顺序。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>单例模式</p><p>该类负责创建自己的对象，同时确保只有单个对象被创建（构造器私有化）。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul></li></ol><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>优点：</strong></p><ul><li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>2、避免对资源的多重占用（比如写文件操作）。</li></ul><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p>饿汉式：</p><p>​    在类加载时就完成初始化并且返回，线程安全缺点是会产生垃圾对象</p><p>懒汉式：</p><p>​    每次使用判断类是否初始化，未初始化就初始化返回类，初始化了就直接返回，速度快但是无线程安全。</p><p>双次确认懒汉式：</p><p>​    在实例化的时候判断类是不是已经创建好了，如果没有再确认一次是否已经创建，速度快而且线程安全</p><p>第二种线程安全懒汉式,用synchronized来实现同步</p><pre><code class="hljs smali">public class Singleton &#123;      <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton<span class="hljs-built_in"> instance </span>= null;      <span class="hljs-keyword"> private</span> Singleton() &#123;       &#125;;      <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> synchronized Singleton getInstance() &#123;             <span class="hljs-built_in"> if </span>(instance == null) &#123;                    <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton();              &#125;             <span class="hljs-built_in"> return </span>instance;       &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>选择一个模板，用clone方法克隆一个，clone有深克隆和浅克隆，浅克隆是直接加引用，深克隆是重新new一个对象实例出来，修改克隆父亲不会改变克隆儿子。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外观模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>​    外观模式为子系统的一组接口提供一个一致的界面，封装了多个相似的类在一个外观类中，客户调用外观类中的方法来，完美体现依赖倒转原则和迪米特法则</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>定义：</strong>定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。把创建工厂的行为抽象成interface，子类工厂去实现创建工厂的行为</p><p>举例：（我们依然举pizza工厂的例子，pizza工厂有两个：纽约工厂和伦敦工厂）。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609001610898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>工厂的接口：</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbsFactory</span> </span>&#123;       Pizza CreatePizza(<span class="hljs-keyword">String</span> ordertype) ;&#125;</code></pre><p>工厂的实现：</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LDFactory</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">AbsFactory</span></span> </span>&#123;       @Override       <span class="hljs-keyword">public</span> Pizza CreatePizza(<span class="hljs-keyword">String</span> ordertype) &#123;              Pizza pizza = <span class="hljs-literal">null</span>;              <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;cheese&quot;</span>.equals(ordertype)) &#123;                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-type">LDCheesePizza</span>();              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;pepper&quot;</span>.equals(ordertype)) &#123;                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-type">LDPepperPizza</span>();              &#125;              <span class="hljs-keyword">return</span> pizza;       &#125;&#125;</code></pre><p>PizzaStroe的代码如下：</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PizzaStroe</span> &#123;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;              <span class="hljs-title class_">OrderPizza</span> mOrderPizza;              mOrderPizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderPizza</span>(<span class="hljs-string">&quot;London&quot;</span>);       &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板方法模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>提取相同的模板封装为一个类，举个例子就是一张试卷，卷子内容一样，不同同学答案不一样，就把相同的那张卷子封装为一个类，每个同学实例化一个卷子对象的时候可以填上自己的答案，这就防止冗余。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>建造者模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>举个例子，需要造一个人，需要捏手脚头和身体，就创建一个接口类，来放入捏手脚头和身体的函数的原型，构建一个类来作为指挥者，指挥人的构建，指挥类是用来隔离用户和构造过程之间的联系，最后可以输入不同参数构建起一个不同尺寸的人。这就符合开放封闭原则，要一个胖子只需要增加一个胖子类输入参数就可以构建。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>简单工厂模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>​    这种设计模式属于创建型模式，在创建对象时不会对客户端暴露创建逻辑，而是通过使用一个接口指向新创建的对象.</p><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</p><p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p><strong>关键代码：</strong>创建过程在其子类执行。</p><p><img src="https://img-blog.csdnimg.cn/20190609001610870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimplePizzaFactory</span> </span>&#123;       <span class="hljs-keyword">public</span> Pizza CreatePizza(<span class="hljs-keyword">String</span> ordertype) &#123;              Pizza pizza = <span class="hljs-literal">null</span>;              <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;cheese&quot;</span>)) &#123;                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-type">CheesePizza</span>();              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;greek&quot;</span>)) &#123;                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-type">GreekPizza</span>();              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;pepper&quot;</span>)) &#123;                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-type">PepperPizza</span>();              &#125;              <span class="hljs-keyword">return</span> pizza;       &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 和 HTTPS</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP%20%E5%92%8C%20HTTPS%20/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP%20%E5%92%8C%20HTTPS%20/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>http是超文本传输协议，最开始是为了方便传输html而创建的，传输的信息都是没经过加密的，并且是无状态的，连接通过TCP连接，端口为80，安全性很差，但是连接很简单，速度快减少界面加载延时</p><h2 id="HTTP协议的特点？"><a href="#HTTP协议的特点？" class="headerlink" title="HTTP协议的特点？"></a>HTTP协议的特点？</h2><ol><li>HTTP允许传输<strong>任意类型</strong>的数据。传输的类型由Content-Type加以标记。 </li><li><strong>无状态</strong>。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。 </li><li>支持<strong>客户端&#x2F;服务器模式</strong>。</li></ol><h4 id="http缺点"><a href="#http缺点" class="headerlink" title="http缺点"></a>http缺点</h4><p>1、无法验证报文的完整性</p><p>2、无法验证发送人，所以可能被伪装</p><p>3、通信使用明文，可能信息被窃听</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gi9djnslj20g20btdg9.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gi9j8u5uj20re0iejsd.jpg"></p><h4 id="http常见状态码"><a href="#http常见状态码" class="headerlink" title="http常见状态码"></a>http常见状态码</h4><table><thead><tr><th>http状态码</th><th>解释</th></tr></thead><tbody><tr><td>200 OK</td><td>请求成功完成</td></tr><tr><td>301 Moved Permanently</td><td>永久移动，永久重定向</td></tr><tr><td>302 Found</td><td>临时移动，临时重定向</td></tr><tr><td>400 Bad Request</td><td>客户端请求错误,服务器理解不了</td></tr><tr><td>403 Forbidden</td><td>服务器收到并且理解请求，但是拒绝提供服务</td></tr><tr><td>404 Not Found</td><td>客户端所要找的资源找不到</td></tr><tr><td>499 client has closed connection</td><td>nginx 自定义状态码，两次post提交过快或者服务器端处理的时间过长</td></tr><tr><td>500 Internal Server Error</td><td>服务器错误</td></tr><tr><td>503  Service Unavailable</td><td>服务器尚未处于可以请求状态，服务器停机或者已超载</td></tr></tbody></table><h3 id="介绍下http2-0"><a href="#介绍下http2-0" class="headerlink" title="介绍下http2.0"></a>介绍下http2.0</h3><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a><a href="http://sjy.我爱你/2022/03/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP1.0%E5%92%8C2.0%E7%9A%84%E5%8C%BA%E5%88%AB/">HTTP2.0</a></h3><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p>安全的基础是ssl协议，连接方式不同（待补充），https是http+ssl协议进行构建的加密传输、身份认证的网络协议，比http协议安全很多，连接方式通常也是tcp，也有可能是SCTP。</p><p>ssl由权威机构颁发，ssl是一个非对称加密，有一个公钥，和一个私钥，用公钥加密后的信息只能由私钥解密，用私钥加密的数据只能公钥解密,公钥放在服务器，私钥放在个人主机。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>https是经过ssl证书认证并且在传输过程加密的一种传输方式，端口为443安全性大大增加，https &#x3D; http+ssl加密</p><h2 id="什么是数字证书？"><a href="#什么是数字证书？" class="headerlink" title="什么是数字证书？"></a>什么是数字证书？</h2><p>服务端可以向证书颁发机构CA申请证书，以避免中间人攻击（防止证书被篡改）。证书包含三部分内容：<strong>证书内容、证书签名<a href="">算法</a>和签名</strong>，签名是为了验证身份。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987428/image-20211004111441594.png" alt="img"></p><p>服务端把证书传输给浏览器，浏览器从证书里取公钥。证书可以证明该公钥对应本网站。</p><p><strong>数字签名的制作过程</strong>：</p><ol><li>CA使用证书签名<a href="">算法</a>对证书内容进行<strong>hash运算</strong>。 </li><li>对hash后的值<strong>用CA的私钥加密</strong>，得到数字签名。</li></ol><p><strong>浏览器验证过程</strong>：</p><ol><li>获取证书，得到证书内容、证书签名算法和数字签名。 </li><li>用CA机构的公钥<strong>对数字签名解密</strong>（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。 </li><li>用证书里的签名<a href="">算法</a><strong>对证书内容进行hash运算</strong>。 </li><li>比较解密后的数字签名和对证书内容做hash运算后得到的哈希值，相等则表明证书可信。</li></ol><p>首先是TCP三次握手，然后客户端发起一个HTTPS连接建立请求，客户端先发一个<code>Client Hello</code>的包，然后服务端响应<code>Server Hello</code>，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。</p><ol><li><p><strong>协商加密算法</strong> 。在<code>Client Hello</code>里面客户端会告知服务端自己当前的一些信息，包括客户端要使用的TLS版本，支持的加密算法，要访问的域名，给服务端生成的一个随机数（Nonce）等。需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987415/image-20210921104210833.png" alt="img"></p></li><li><p>服务端响应<code>Server Hello</code>，告诉客户端服务端<strong>选中的加密算法</strong>。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987405/image-20210921105450791.png" alt="img"></p></li><li><p>接着服务端给客户端发来了2个证书。第二个证书是第一个证书的签发机构（CA）的证书。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987405/image-20211004172007102.png" alt="img"></p></li><li><p>客户端使用证书的认证机构CA公开发布的RSA公钥<strong>对该证书进行验证</strong>，下图表明证书认证成功。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987746/image-20210921105929268.png" alt="img"></p></li><li><p>验证通过之后，浏览器和服务器通过<strong>密钥交换算法</strong>产生共享的<strong>对称密钥</strong>。</p><p>RSA密钥交换算法：</p><p>（1）任意客户端对服务器发起请求，服务器首先发回复自己的公钥到客户端（公钥明文传输）。</p><p>（2）客户端使用随机数算法，生成一个密钥S，使用收到的公钥进行加密，生成C，把C发送到服务器。</p><p>（3）服务器收到C，使用公钥对应的私钥进行解密，得到S。</p><p>（4）上述交换步骤后，客户端和服务器都得到了S，S为密钥（预主密钥）。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987406/image-20210921110025197.png" alt="img"></p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987428/image-20210921110155075.png" alt="img"></p></li><li><p>开始传输数据，使用同一个对称密钥来加解密。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987387/image-20210921110315068.png" alt="img"></p></li></ol><h3 id="https被中间人攻击了怎么办"><a href="#https被中间人攻击了怎么办" class="headerlink" title="https被中间人攻击了怎么办"></a>https被中间人攻击了怎么办</h3><p>攻击人先使用DNS劫持把请求都到他的服务器，再用伪造的证书与客户端进行交互</p><p><strong>解决办法：</strong></p><p>第一步需要验证CA证书的时候去验证他是不是权威机构，使用权威机构的CA证书的公钥解密验证和原来的证书是否一致，如果不是就不信任他不与他进行https连接。</p><h4 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h4><p>1、get请求表示的意思是要得到信息，并且get请求参数都放header或者url上面，安全性较差放url上面有长度限制，最多1024个字符，不适合传大长度信息。</p><p>2、post请求表示添加信息 ，请求参数作为键值对放在http请求中，不会出现在url中，安全性较get较好</p><p>3、get请求在url不可加入中文字符，会乱码，post可以</p><h4 id="Restful风格的接口"><a href="#Restful风格的接口" class="headerlink" title="Restful风格的接口"></a>Restful风格的接口</h4><p>1、请求头</p><p>get  表示请求数据 ，一般数据放header里面</p><p>post 表示增加数据 ，一般数据放body里面</p><p>put 表示修改数据，一般数据放body里面</p><p>delete  表示删除数据，一般数据放body里面</p><p>2、url的复用，比如work这块，写一个group里面，然后get “&#x2F;”表示获取工作信息，post“&#x2F;”增加工作信息</p><p>3、状态码，详情看上面</p><p>4、制作一个统一的返回信息的格式，写一个可以多处用的success return和error return，返回结果统一json</p><p>参考资料：<a href="https://www.nowcoder.com/discuss/833962">https://www.nowcoder.com/discuss/833962</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B树、B+树、红黑树、AVL树</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h5 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h5><p>是一个特殊的AVL（平衡二叉搜索树）,需要遵守几个条件</p><p>1、根节点得是黑色的</p><p>2、连续两个红色节点不能连续</p><p>3、根节点到每个子节点遇到的黑色节点数量相同</p><h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><p>1、根节点是黑色的</p><p>2、最大长度为2*（log（n+1））</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>2-3树是B树的一种特例，二叉搜索树搜索效率高，但是为了保持平衡需要的代价太大，所以人想出了一个结点允许多个值的数据结构-B树</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0e0zmzuq0j20k408daa9.jpg" alt="B树"></p><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><p>1、所有叶子子结点在同一层上面，和平衡二叉树比层数低，磁盘io少，加快了查询插入速度</p><p>2、每个节点的元素从小到大排列</p><p>操作系统索引表也用了b+树</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0e10thk89j20mx094weu.jpg" alt="b+树png"></p><h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><p>1、所有叶子节点都在同一层，并且中间结点是他的子结点的最大或者最小值，最大值在根节点中</p><p>2、所有数据都在子结点上面，子结点包括了所有信息，每个元素不保存数据只用来索引，查询稳定，所有子结点都链接起来，导出全部数据方便</p><p>3、非叶子节点只有key，没有value，叶子节点有key，value</p><h4 id="B树和B-树的区别，为什么mysql会选b-树"><a href="#B树和B-树的区别，为什么mysql会选b-树" class="headerlink" title="B树和B+树的区别，为什么mysql会选b+树"></a>B树和B+树的区别，为什么mysql会选b+树</h4><p><strong>卫星数据：</strong>指索引元素所指向的数据记录，比如数据库中的某一行。</p><p>1、B+树的中间节点没有卫星数据，同样大小的磁盘页可以容纳更多的节点元素。意味着，数据量相同的情况下，B+树的结构比B树更加矮胖，因此查询时IO次数更少，B+树更加的矮胖一点，磁盘IO操作少，查询速度比B快</p><p>2、数据库扫库更加方便，范围查询更加方便，查询一段区别的数据比B树方便</p><p>3、查询性能更加稳定，B+树得每次查到叶子结点，B树可能查到中间结点查到数据就终止</p><h4 id="hash比B-树快-为什么还选B-树"><a href="#hash比B-树快-为什么还选B-树" class="headerlink" title="hash比B+树快,为什么还选B+树"></a>hash比B+树快,为什么还选B+树</h4><p>因为只选一个数据是hash块，但是范数据量大无法一次装入内存，范围查询的话是B+树快</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyISAM与InnoDB的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MyISAM%E4%B8%8EInnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MyISAM%E4%B8%8EInnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</strong> </p><p>2、 <strong>InnoDB是聚集索引</strong>，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p><p>   <strong>MyISAM是非聚集索引</strong>，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p><p>3、 <strong>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</strong> </p><p>4、 <strong>系统奔溃后，MyISAM恢复起来更困难</strong>，Innodb奔溃了能自动恢复</p><p>5、InnoDB默认是行级锁，MYISAM默认是表级锁</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>对于各种树的介绍和异同可以看这篇文章<a href="http://www.mystorys.xyz/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/">B树、B+树、红黑树、AVL树</a></p><p>索引底层数据结构是B+树，B+树最大的优点在于它将索引存放在<strong>磁盘</strong>，让检索技术摆脱了内存限制。</p><p><strong>单例索引：</strong>一个索引只能包含一个列，一个表可以有多个单例索引</p><p><strong>组合索引：</strong>一个组合索引包含两个或以上的列，原理简单，在a，b，c字段上创建索引，索引记录会首先安装A排序，A一样照B排序，B一样照C排序。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0e0abqd14j203205xq30.jpg"></p><p><strong>聚簇索引：</strong>数据存储和索引放一块，b+树叶子节点存放的是数据表的行记录，可以理解成将数据存储和索引放到了一块,这是主键索引，因为InnoDB数据文件本身要按主键聚集，所以InnoDB要求必须有主键，如果没有就自动生成一个隐含的字段作为主键</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0e0bs4mxzj20dw060aaa.jpg"></p><p>为什么mysql表要有一个自增的id主键，因为mysql索引用b+数，得是一个递增的，因为如果不递增增加数据的话得裂表影响效率，而且不建议使用太长的字段作为主键。</p><p><strong>非聚簇索引：</strong>数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。</p><p>聚簇索引优点：</p><ul><li>数据访问更快，因为聚簇索引将数据放在同一个B+树中，所以比非聚簇索引快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul><p>缺点：</p><ul><li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将出现页分裂，严重影响性能，我们一般会定义一个自增的ID作为主键</li><li>更新主键的代价很高</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><h4 id="1、一级索引"><a href="#1、一级索引" class="headerlink" title="1、一级索引"></a>1、一级索引</h4><p>索引和数据存储在一起，都存储在同一个B+tree中的叶子节点。一般主键索引都是一级索引。</p><h4 id="2、二级索引"><a href="#2、二级索引" class="headerlink" title="2、二级索引"></a>2、二级索引</h4><p>二级索引树的叶子节点存储的是主键而不是数据。也就是说，在找到索引后，得到对应的主键，再回到一级索引中找主键对应的数据记录。</p><h4 id="3、一级索引和二级索引的关系：回表"><a href="#3、一级索引和二级索引的关系：回表" class="headerlink" title="3、一级索引和二级索引的关系：回表"></a>3、一级索引和二级索引的关系：回表</h4><p>一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引，这叫做“回表”。</p><p>select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表</p><h4 id="4、索引建立原则"><a href="#4、索引建立原则" class="headerlink" title="4、索引建立原则"></a>4、索引建立原则</h4><p>（1）最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的。<br>如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>（2）&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，<br>mysql的查询优化器会帮你优化成索引可以识别的形式</p><p>（3）尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，<br>比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，<br>那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，<br>一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</p><p>（4）索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，<br>原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，<br>显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’);</p><p>（5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p><h4 id="5、可能索引失效的原因"><a href="#5、可能索引失效的原因" class="headerlink" title="5、可能索引失效的原因"></a>5、可能索引失效的原因</h4><p>和索引建立原则类似</p><ul><li><p>范围查询，&gt;,&lt;,!&#x3D;,or会导致索引失效,like ‘%liu’ 百分号在前也会导致索引失效</p><ul><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，把c&gt;3放到最后。</li></ul></li><li><p>使用select * 类似的语句可能会导致不用索引，优化器可能会选择TABLE ACCESS FULL</p></li><li><p>单键值的b树索引列上存在null值，导致COUNT(*)不能走索引</p></li><li><p>索引列上有函数运算，导致不走索引</p></li><li><p>建立组合索引，但查询谓词并未使用组合索引的第一列，此处有一个INDEX SKIP SCAN概念</p></li></ul><h4 id="6、唯一索引和主键索引的区别"><a href="#6、唯一索引和主键索引的区别" class="headerlink" title="6、唯一索引和主键索引的区别"></a>6、唯一索引和主键索引的区别</h4><p>1、概念：主键是一种约束、是一种逻辑键实际上不存在；唯一索引是一个索引、是物理键，实际上存在。</p><p>2、主键索引不能有空值，唯一索引可以有空值（可以有多个空值）</p><p>3、主键可以建立外键， 唯一索引不能</p><p>4、一个表中只能有一个主键，但是可以有多个外键</p><p>5、主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等</p><h4 id="7、为什么唯一索引比普通索引快（查询会快一点点点点）"><a href="#7、为什么唯一索引比普通索引快（查询会快一点点点点）" class="headerlink" title="7、为什么唯一索引比普通索引快（查询会快一点点点点）"></a>7、为什么唯一索引比普通索引快（查询会快一点点点点）</h4><p><strong>查询效率：</strong>唯一索引查询时有很小概率会比普通索引快，有概率普通索引有一条数据在一个页表末尾，一条数据在页表前面，需要两次io，这时唯一索引会比普通索引快一点。</p><p><strong>更新效率：</strong>唯一索引更新的时候需要把索引页读到内存中，不然不能判断数据是否唯一，会比普通索引慢</p><p><strong>总结：</strong>少用唯一索引。</p><h4 id="8、为什么数据库联合索引不符合最左前缀就会失效"><a href="#8、为什么数据库联合索引不符合最左前缀就会失效" class="headerlink" title="8、为什么数据库联合索引不符合最左前缀就会失效"></a>8、为什么数据库联合索引不符合最左前缀就会失效</h4><p>这就得看看联合索引在底层是怎么放的</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nqys5zfcj20hs0ewmyh.jpg"></p><p>单一索引是一个节点存一个键，联合索引是一个节点存多个键，每个键都是有顺序的，两个节点比较是第一个节点如果相同，就比较第二个节点，查找的时候也是这样，如果第一个节点找到了，就开始比较第二个节点是否相同。</p><h4 id="9、为什么b-树大层数总是2-4层"><a href="#9、为什么b-树大层数总是2-4层" class="headerlink" title="9、为什么b+树大层数总是2-4层"></a>9、为什么b+树大层数总是2-4层</h4><p>​    我们来计算一下3层b+树能放多少数据，mysql默认页是16KB，假设一条数据1KB，一页就能放16条记录，假设有三层数据，假如我们的主键id为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节。这样算下来就是 16384 &#x2F; 14 &#x3D; 1170，就是说一个页上可以存放1170个指针，两层是1170*16，三层是1170 * 16 * 1170，千万行足够大部分场景，再大也要分库分表了。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务和隔离级别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>数据库事务的定义：</strong>一个或多个数据库操作</p><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><p><strong>A atom 原子性</strong>  事务执行是原子，一个事务中所有操作，要么全部完成，要么全部不完成，不会结束在中间的环节。</p><p><strong>C Consistency 一致性</strong>    在事务开始和事务开始后，数据库的完整性约束没被破坏完整性约束：主键的约束没有变，数据库中不能输入不符合约束的值。</p><p><strong>I    isolation 隔离性</strong>    多个并发事务相互独立互不影响，多个用户的并发事务访问同一个数据库，一个用户的事务应该被隔离起来不被干扰。</p><p><strong>D durability 持久性</strong>    事务处理后对数据的修改是永久的</p><h3 id="Mysql-事务是如何实现的"><a href="#Mysql-事务是如何实现的" class="headerlink" title="Mysql 事务是如何实现的"></a>Mysql 事务是如何实现的</h3><p><strong>原子性：</strong>通过undo log实现的。每条数据变更都伴随一条undo log日志的生成，当系统发生错误或执行回滚根据undo log做逆向操作。<br><strong>持久性：</strong>通过redo log实现的。redo log记录了数据的修改日志。数据持久化到磁盘，先是储存到缓冲池里，然后缓冲池中的数据定期同步到磁盘中，如果系统宕机，可能会丢失数据，系统重启后会读取redo log恢复数据。<br><strong>隔离性：</strong>mysql数据库通过MVCC + next-key机制实现了隔离性<br><strong>一致性：</strong>以上3大特性，保障了事务的一致性</p><h4 id="mysql四种隔离级别"><a href="#mysql四种隔离级别" class="headerlink" title="mysql四种隔离级别"></a>mysql四种隔离级别</h4><p>1、读未提交</p><p>如果一个事物已经开始写数据，则另外一个事物则不允许同时进行写操作，但是允许读数据，会出现脏读。</p><p>2、读已提交</p><p>未提交的写事务禁止其他事物访问，可避免脏读</p><p>3、可重复读(数据库默认隔离级别)</p><p>sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。</p><p>​    可避免脏读，不可重复读</p><p>4、串行化</p><p>​    可避免脏读、不可重复读和幻读</p><table><thead><tr><th>隔离界别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED：读未提交</td><td>可能发生</td><td>可能发生</td><td>可能发生</td></tr><tr><td>READ COMMITTED：读已提交</td><td>解决</td><td>可能发生</td><td>可能发生</td></tr><tr><td>REPEATABLE READ：可重复读</td><td>解决</td><td>解决</td><td>可能发生</td></tr><tr><td>SERIALIZABLE：可串行化</td><td>解决</td><td>解决</td><td>解决</td></tr></tbody></table><h4 id="不考虑隔离级别会发生的事情"><a href="#不考虑隔离级别会发生的事情" class="headerlink" title="不考虑隔离级别会发生的事情"></a>不考虑隔离级别会发生的事情</h4><p>1、脏读</p><p>一个事务在处理数据时读到别的未提交事务的数据，然后这个数据回滚了</p><p>2、不可重复读</p><p>数据库中的某个数据，在一次事务中多次查询得到的数据不一致，因为另一个事务修改并且提交了</p><p>3、幻读</p><p>在一次事务里面，多次查询之后，查询的结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做 幻行但是不可重复读是一个数据，幻读是一批数据整体，解决不可重复读的办法<strong>是行锁</strong>，解决幻读的办法是<strong>锁表</strong>。</p><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><ul><li><p><strong>第一范式</strong></p><p>一列不能有多个值</p></li><li><p><strong>第二范式</strong>，属性完全依赖于主键 [ 消除部分子函数依赖 ]</p><p><strong>非主属性完全依赖于主关键字</strong></p><p>(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)</p><p>这个数据库表不满足第二范式，因为存在如下决定关系： </p><p>(课程名称) → (学分)</p><p>(学号) → (姓名, 年龄)</p><p>即存在组合关键字中的字段决定非关键字的情况。</p></li><li><p><strong>第三范式</strong> 属性不依赖于其它非主属性 [ <strong>消除传递依赖</strong> ]</p></li></ul><p>​    (学号) → (所在学院) → (学院地点, 学院电话) 这样是不符合的，得分成两个表</p><p>​    <strong>学生：(学号, 姓名, 年龄, 所在学院)；</strong></p><p>​    <strong>学院：(学院, 地点, 电话)；</strong></p><p>Mysql的事务该怎么手写</p><pre><code class="hljs abnf">begin<span class="hljs-comment">;</span>xxxxcommit<span class="hljs-comment">;</span>orbegin<span class="hljs-comment">;</span>rollback<span class="hljs-comment">;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux定时任务</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ArchLinux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ArchLinux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>sudo pacman -S cronie</code></p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><pre><code class="hljs nsis"><span class="hljs-comment">#设置开机启动</span>sudo <span class="hljs-params">system</span>ctl enable cronie.service<span class="hljs-comment">#立即启动</span>sudo <span class="hljs-params">system</span>ctl start cronie.service</code></pre><h4 id="crontab用法"><a href="#crontab用法" class="headerlink" title="crontab用法"></a>crontab用法</h4><p>crontab –e : 修改 crontab 文件，如果文件不存在会自动创建。<br>crontab –l : 显示 crontab 文件。<br>crontab -r : 删除 crontab 文件。<br>crontab -ir : 删除 crontab 文件前提醒用户。</p><pre><code class="hljs arcade"><span class="hljs-built_in">minute</span> <span class="hljs-built_in">hour</span> <span class="hljs-built_in">day</span>-of-<span class="hljs-built_in">month</span> <span class="hljs-built_in">month</span>-of-<span class="hljs-built_in">year</span> <span class="hljs-built_in">day</span>-of-<span class="hljs-built_in">week</span> commands</code></pre><p>除了数字还有几个特殊的符号：”*”、”&#x2F;“和”-“、”,”</p><ul><li>*代表所有的取值范围内的数字</li><li>“&#x2F;“代表每的意思,”&#x2F;5”表示每5个单位</li><li>“-“代表从某个数字到某个数字</li><li>“,”分开几个离散的数字</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="三月份-周一到周五-每1分钟执行一次-x2F-runonce-sh"><a href="#三月份-周一到周五-每1分钟执行一次-x2F-runonce-sh" class="headerlink" title="三月份 周一到周五 每1分钟执行一次.&#x2F;runonce.sh"></a>三月份 周一到周五 每1分钟执行一次.&#x2F;runonce.sh</h5><p>*&#x2F;1 * * mar mon-fri .&#x2F;runonce.sh</p><h4 id="每分钟执行一次-x2F-restartTomcat-sh"><a href="#每分钟执行一次-x2F-restartTomcat-sh" class="headerlink" title="每分钟执行一次~&#x2F;restartTomcat.sh"></a>每分钟执行一次~&#x2F;restartTomcat.sh</h4><p>*&#x2F;1 * * * * sh &#x2F;home&#x2F;itkey&#x2F;restartTomcat.sh</p><h5 id="凌晨1点10分执行一次操作"><a href="#凌晨1点10分执行一次操作" class="headerlink" title="凌晨1点10分执行一次操作"></a>凌晨1点10分执行一次操作</h5><p>10 1 * * * sh &#x2F;home&#x2F;apex&#x2F;restartTomcat.sh</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql锁</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>用处：保证数据安全，处理并发访问</p><p>首先对mysql锁进行划分：</p><ol><li>按照锁的粒度划分：行锁、表锁、页锁</li><li>按照锁的使用方式划分：共享锁、排它锁（悲观锁的一种实现）</li><li>还有两种思想上的锁：悲观锁、乐观锁。</li><li>InnoDB中有几种行级锁类型：Record Lock、Gap Lock、Next-key Lock</li><li>Record Lock：在索引记录上加锁</li><li>Gap Lock：间隙锁</li><li>Next-key Lock：Record Lock+Gap Lock</li></ol><p>InnoDB默认的是行级锁</p><p>乐观锁定义：（现实中用的较多）默认用户访问正在改变的数据的概率很小，直到修改完成准备提交所作的修改才会将数据锁住修改为再释放。</p><p>悲观锁定义：默认用户访问正在改变的数据的概率很大，会在数据修改时上锁，只有能数据修改后提交才能解锁让其他用户修改这个数据。使用悲观锁会让访问数据库的时间增加，并发性不好。</p><p>共享读锁（S锁）：</p><p>​    如果一个事务对这个对象加了锁，当前事务只能进行读操作，其他事务也可以对这个对象加共享锁。</p><p>排他写锁（X锁）：</p><p>​    加锁之后只能有一个事务对他做写操作和更新操作。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU时间片</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E6%97%B6%E9%97%B4%E7%89%87/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E6%97%B6%E9%97%B4%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h2><p>定义： 现在的操作系统是分时系统，会给每个进程分配相同时间CPU资源，如果这个进程在时间片结束前阻塞或者结束，可以进行CPU切换来提高CPU的利用率。这样就不会因为一个进程阻塞住导致电脑无响应，提高了电脑的交互性。</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="轮状调度算法"><a href="#轮状调度算法" class="headerlink" title="轮状调度算法"></a>轮状调度算法</h4><p>​    时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。</p><h4 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h4><h5 id="1、优先调度算法的类型"><a href="#1、优先调度算法的类型" class="headerlink" title="1、优先调度算法的类型"></a>1、优先调度算法的类型</h5><ul><li><p>非抢占式优先调度算法</p></li><li><p>抢占式优先调度算法</p></li></ul><h5 id="2、优先权的类型"><a href="#2、优先权的类型" class="headerlink" title="2、优先权的类型"></a>2、优先权的类型</h5><ul><li>静态优先权</li><li>动态优先权</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LINUX和Windows的区别（从底层来说）</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LINUX%E5%92%8CWindows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BB%8E%E5%BA%95%E5%B1%82%E6%9D%A5%E8%AF%B4%EF%BC%89/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LINUX%E5%92%8CWindows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BB%8E%E5%BA%95%E5%B1%82%E6%9D%A5%E8%AF%B4%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>先说一下现象，Linux是服务器和嵌入式的主流操作系统,Windows是个人pc领域的绝对王者</p><p>再来说一下为什么</p><p><strong>Linux的优点：</strong>Linux是开源的，并且有完善的权限管理机制，是适合多用户的操作系统，在广大贡献者的作用下，Linux安全性和稳定性好，能运行一年很少宕机，并且要常年处于开机状态要最好避免内存碎片问题，使用伙伴系统进行内存管理。</p><p>**Windows的优点:**是闭源的，有高度完善好用的图形化界面，吸引广大用户使用，使用傻瓜式的安装软件使用体验，安装包是二进制，防止泄露源代码。</p><p> <strong>Linux和Windows的最大区别在于Linux是高度模块化的</strong></p><p>​    Linux是由数百个小型的独立程序一起运行组成，Linux可以去除不需要的模块从而创造一个迎合特定需要的强健而简洁的操作系统。并且可以模块化编译，修改内核十分方便，修改了一个小东西不用编译整个操作系统。Linux内核分为进程调度，内存管理，进程通信，虚拟文件系统和网络接口。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用命令</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>1、ls (list) 查看linux文件夹包含的文件</p><p>ls -a 列出所以文件，包含隐藏文件</p><p>ls -t 以文件修改时间排序</p><p>ls -S 以文件大小排序</p><p>ls -h 以易读大小显示</p><p>ls -l除了文件名之外，还有文件的权限、所有者、文件大小等信息</p><p>2、cd (chaneg directory) 进入目录</p><p>cd   &#x2F;     进入根目录</p><p>cd ~     进入home目录</p><p>cd -     进入上一次工作路径</p><p>cd     !$ 把上个命令的参数作为cd参数用</p><p>3、pwd     查看当前工作路径目录</p><p>pwd    -p    查看软连接的实际路径</p><p>4、rm    remove</p><p>rm    -rf    删除子目录及子目录中所以档案</p><p>5、mkdir    （make directory）创建文件夹</p><p>6、rmdir    (remove directory) 只能删除空目录，删除时必须具有对其父目录的写权限。</p><p>7、mv    （move）    移动文件</p><p>8、cp    （copy）  将原文件复制至目标文件</p><p>cp -i    提示</p><p>cd -r    复制目录及目录内所有项目</p><p>cp    -a    复制的文件与原文件时间一样</p><p>9、cat    </p><p>cat  filename    一次性显示整个文件</p><p>cat    &gt;    filename    从键盘创建一个文件</p><p>cat    file1    file2    &gt;    file    将几个文件合并为一个文件</p><p>cat    -n    输出所有行号</p><p>10、more    功能类似于cat但是可以一页一页方便逐页阅读，按space下一页，b就往回</p><p>more    +3    text.txt    显示文件从第三行起的内容</p><p>11、less    和more类型</p><p>12、head    用来显示档案的开头至标志输出</p><p>13、tail    用于显示指定文件末尾内容</p><p>14、which    </p><p>15、whereis</p><p>16、locate</p><p>17、find</p><p>18、chmod    用于改变linux系统文件或者目录的访问权限，</p><p>u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</p><p>常用参数：</p><p>​    -c 当发送改变时，报告处理信息</p><p>​    -R处理指定目录以及子目录下所有文件</p><p>权限范围：</p><p>​    u：目录或者文件的当前的用户</p><p>​    g：目录或者文件的当前的群组</p><p>​    a：所有 的用户及群组</p><p>实例：</p><p>chmod    a+x    t.log    增加文件t.log所有用户可执行权限</p><p>chmod 777 +文件 就是给这个文件所以人的读、写、执行权限</p><pre><code class="hljs lua">读权限（<span class="hljs-built_in">read</span>，r）的值是<span class="hljs-number">4</span>，写权限（<span class="hljs-built_in">write</span>，w）的值是<span class="hljs-number">2</span>，执行权限（<span class="hljs-built_in">execute</span>，x）的值是<span class="hljs-number">1</span></code></pre><p>19、tar    用于压缩和解压文件，本身只有打包功能，打包是将一大堆文件或者目录变成一个总的文件</p><p>常用参数：</p><p>​    -c    （creat）建立新的压缩文件</p><p>​    -f    (file)指定压缩文件</p><p>​    -u 添加改了和现有的文件到压缩包中</p><p>​    -x    从压缩包中抽取文件</p><p>​    -t    显示压缩文件的内容</p><p>​    -z    支持gzip压缩</p><p>​    -j    支持bzip2压缩</p><p>​    -Z    支持compress解压文件</p><p>​    -v    显示操作过程</p><p>20、chown</p><p>21、df    显示磁盘空间使用情况,磁盘空间以1KB显示</p><p>-a    全部文件系统列表</p><p>-h    方便阅读方式显示信息</p><p>-i    显示inode信息</p><p>-l    只显示本地磁盘</p><p>22、du命令</p><p>23、ln    （link）为文件在另外一个位置建立一个同步的链接，默认为硬链接</p><p><a href="http://sjy.我爱你/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/">硬链接和软链接</a></p><p>24、netstat</p><p>-t：显示TCP端口</p><p>-u：显示udp端口</p><p>-n:  不进行DNS轮询，显示IP加快速度</p><p>-a： 显示所有socket</p><p>-p：显示标识符和程序名称</p><p>dmesg</p><p>isomod</p><p>rmmod</p><p>make</p><p>dhcpcd</p><p>ipconfig</p><p>ifconfig</p><p>xrandr</p><p>pacman</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程线程和协程的特性和区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程是操作系统分配资源的最小单位</strong></p><p>​    一个进程中有多个线程，一个线程里面可以有多个协程，因为进程是最大的了，进程切换需要的开销很大，但是进程挂了，其他进程因为保护机制会不受影响，但是这个进程里面的线程协程也都会挂掉。</p><h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><p>1）管道(pipe)及有名管道(named pipe)：</p><p>　　管道可用于具有亲缘关系的父子进程间的通信；有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><p>　　2）信号(signal)：</p><p>　　信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</p><p>　　3）消息队列(message queue)：</p><p>　　消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。</p><p>　　4）共享内存(shared memory)：</p><p>　　可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p><p>　　5）信号量(semaphore)：</p><p>　　主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。</p><p>　　6）套接字(socket)；</p><p>　　这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程是操作系统所能调度执行的最小单位</strong></p><p>计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程，线程是cpu调度分配的最小单位</p><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><p>1）<strong>锁机制：</strong>包括互斥锁、条件变量、读写锁</p><p>　　　　a. 互斥锁提供了以排他方式防止数据结构被并发修改的方法。</p><p>　　　　b. 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</p><p>　　　　c. 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p><p>　　2）<strong>信号量机制</strong>(Semaphore)：包括无名线程信号量和命名线程信号量</p><p>　　3）<strong>信号机制</strong>(Signal)：类似进程间的信号处理</p><h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><p>**1、新建状态(New)**：新创建了一个线程对象。</p><p>**2、就绪状态(Runnable)**：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权，</p><p>  即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。</p><p>**3、运行状态(Running)**：就绪状态的线程获取了CPU，执行程序代码。</p><p>**4、阻塞状态(Blocked)**：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。</p><p>  阻塞的情况分三种：</p><p>①.等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，</p><p>  必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，</p><p>②.同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。</p><p>③.其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时，</p><p>  或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</p><p>**5、死亡状态(Dead)**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p><h3 id="什么是线程死锁？"><a href="#什么是线程死锁？" class="headerlink" title="什么是线程死锁？"></a>什么是线程死锁？</h3><p><strong>概念：</strong>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行</p><h4 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h4><ul><li>系统资源不足</li><li>进程推进的顺序不合适</li><li>资源分配不当</li></ul><h4 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h4><ul><li><strong>互斥条件：</strong>进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放</li><li><strong>请求和保持条件：</strong>一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件：</strong>任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用</li><li><strong>循环等待条件：</strong>当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。</li></ul><h4 id="避免死锁的办法：银行家算法"><a href="#避免死锁的办法：银行家算法" class="headerlink" title="避免死锁的办法：银行家算法"></a>避免死锁的办法：银行家算法</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oe3hnzgkj20rk0fbjt4.jpg"></p><p>假设资源P1申请资源，银行家算法先试探的分配给它（当然先要看看当前资源池中的资源数量够不够），若申请的资源数量小于等于Available，然后接着判断分配给P1后剩余的资源，能不能使进程队列的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁状态）。</p><p>若有进程可执行完毕，则假设回收已分配给它的资源（剩余资源数量增加），把这个进程标记为可完成，并继续判断队列中的其它进程，若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列（如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0–&gt;回收（Work+已分配给P0的A0&#x3D;Work）–&gt;分配给P3–&gt;回收（Work+A3&#x3D;Work）–&gt;分配给P2–&gt;······满足所有进程）。</p><h4 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h4><p>破坏产生死锁的必要条件，增加系统资源，改变合理的进程推进顺序，改善资源分配方式</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>协程是用户态的轻量级线程，操作系统所不能开辟的，但是可以由程序控制</strong></p><p>协程主要是为了提高并发，而且主要是IO并发。协程并不适合并行计算或者并行处理任务，因为同一时刻运行的协程数不可能大于操作系统线程。</p><h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><p>1、极高的执行效率，因为子程序切换不是线程切换，而是程序自身切换，没有线程切换开销效率高。</p><p>2、不需要多线程的锁机制，因为只有一个线程不存在同时写变量冲突。</p><h3 id="为什么协程切换代价比线程低"><a href="#为什么协程切换代价比线程低" class="headerlink" title="为什么协程切换代价比线程低"></a>为什么协程切换代价比线程低</h3><p>协程切换流程：</p><p>1、保存当前寄存器信息</p><p>2、选择下一个要执行的协程</p><p>3、恢复寄存器上下文</p><p>线程切换流程：</p><p>1、软中断</p><p>2、保存寄存器信息到内核堆栈、</p><p>3、选择下一个要执行的线程</p><p>4、恢复上下文</p><p>5、返回用户堆栈</p><ul><li><p>需要保存的寄存器信息大小不同，线程需要把寄存器保存到内核堆栈，并且 返回用户堆栈</p></li><li><p>协程无多线程锁机制，因为一个协程运行就一个线程。</p></li><li><p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p></li></ul><p><strong>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行</strong>。</p><p>协程的特点在于是一个线程执行</p><p>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><h3 id="问题：为什么要把线程的上下文信息保存到内核态中"><a href="#问题：为什么要把线程的上下文信息保存到内核态中" class="headerlink" title="问题：为什么要把线程的上下文信息保存到内核态中"></a>问题：为什么要把线程的上下文信息保存到内核态中</h3><p>因为用户态的权限比较低，不能直接访问硬盘内存等资源，只能通过系统调用来做。</p><h4 id="go语言内的协程"><a href="#go语言内的协程" class="headerlink" title="go语言内的协程"></a>go语言内的协程</h4><p>goroutine 非常的<strong>轻量</strong>，初始分配只有 2KB，当栈空间不够用时，会自动扩容。同时，自身存储了执行 stack 信息，用于在调度时能恢复上下文信息。</p><p>而线程比较重，一般初始大小有几 MB(不同系统分配不同)，线程是由操作系统调度，是操作系统的调度基本单位。而 golang 实现了自己的调度机制，goroutine 是它的调度基本单位。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux硬连接和软连接</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ff2yhqszj20ng0irgn5.jpg"></p><h4 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h4><p>Linux 下的文件是通过索引节点（inode）识别文件，硬链接可以认为为一个指针指向文件索引节点，系统并不分配inode，文件链接数加一。</p><ul><li>删除硬链接文件或者删除源文件任意之一，文件实体并未被删除；</li><li>只有删除了源文件和所有对应的硬链接文件，文件实体才会被删除；</li><li>硬链接文件是文件的另一个入口；</li><li>可以通过给文件设置硬链接文件来防止重要文件被误删；</li></ul><p><strong>不足：</strong></p><p>1、不可以在不同文件系统的文件间建立链接</p><p>2、只有超级用户才可以为目录创建硬链接</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>没有任何文件系统的限制，任何用户可以创建指向目录的符号链接，有更大灵活性，可以跨越不同机器</p><ul><li>软链接里面存放的是源文件的路径，指向源文件；</li><li>删除源文件，软链接依然存在，但无法访问源文件内容；</li><li>软链接失效时一般是白字红底闪烁；</li><li>创建软链接命令 ln -s 源文件 软链接文件；</li><li>软链接和源文件是不同的文件，文件类型也不同，inode号也不同</li></ul><p>缺点：</p><p>1、链接文件包含有源文件的路径信息，需要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</p><h4 id="硬链接和软链接的区别"><a href="#硬链接和软链接的区别" class="headerlink" title="硬链接和软链接的区别"></a>硬链接和软链接的区别</h4><p>​    原理上，硬链接和源文件的inode节点号相同，两者互为硬链接。软连接和源文件的inode节点号不同，进而指向的block也不同，软连接block中存放了源文件的路径名。 实际上，硬链接和源文件是同一份文件，而软连接是独立的文件，类似于快捷方式，存储着源文件的位置信息便于指向。 使用限制上，不能对目录创建硬链接，不能对不同文件系统创建硬链接，不能对不存在的文件创建硬链接；可以对目录创建软连接，可以跨文件系统创建软连接，可以对不存在的文件创建软连接。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目遇到的问题</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%81%9A%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98_%E8%80%81%E7%89%88/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%81%9A%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98_%E8%80%81%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>1、url最后加了一个&#x2F;</p><p>不加”&#x2F;“,系统会自动进行301的重定向，把url变成末尾加”&#x2F;“的地址。而request.getParameter(“”)仅有一次生命周期，经过两次跳转后，前系统传的值失效了。此外，如直接发送 URL：<a href="http://msdn.microsoft.com/ie/">http://msdn.microsoft.com/ie/</a> 比发送<a href="http://msdn.microsoft.com/ie%E9%80%9F%E5%BA%A6%E5%B0%86%E4%BC%9A%E6%9B%B4%E5%BF%AB%EF%BC%8C%E5%BD%93%E7%84%B6%E8%BF%99%E7%A7%8D%E9%80%9F%E5%BA%A6%E6%98%AF%E6%84%9F%E8%A7%89%E4%B8%8D%E5%88%B0%E7%9A%84%EF%BC%8C%E4%BD%86%E4%BC%98%E5%8C%96%E5%BA%94%E8%AF%A5%E2%80%9C%E5%B0%BD%E5%8F%AF%E8%83%BD%E2%80%9D%EF%BC%8C%E5%87%8F%E5%B0%91%E6%B5%AA%E8%B4%B9%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%82">http://msdn.microsoft.com/ie速度将会更快，当然这种速度是感觉不到的，但优化应该“尽可能”，减少浪费的时间。</a></p><p><strong>2、开发app遇到过什么问题</strong></p><p>有一个第一次登陆时会黑屏的bug，因为黑屏的时候是后台使用webview登陆上课啦界面隐藏的原因，原因是路由转跳时间太短啦，原来是100ms，改成6s就不会导致黑屏，为什么要后台登陆是因为上课啦得学校的统一登陆平台的token，但是那个token是一小时后失效，所以每次登陆后台请求才能实现免登。</p><p>都是一些小显示错误bug修复，比如空安全导致加载失败之类的，加一个判断数据是否为空就行。</p><p><strong>3、各个界面是怎么实现免登的</strong></p><p>通过<a href="">oauth2协议</a>获得学校cas登陆的token，然后登陆成功之后再用oauth服务以第三方的形式请求助手服务的token，然后实现统一免登的是发现页很多app，先请求接口获得所有app的实现免登的方式，然后要登陆的时候代码判断用</p><ul><li>我们这边有自己官网的界面，是在url后面加上？auth+token的形式实现免登</li><li>老版本的lemon是从接口获得workflow参数然后重定向到一个地址，再请求这个地址加上token才可以实现免登。</li><li>都是有免登协议的，访问的接口帮我们中间封装了一层就会很方便</li></ul><p><strong>4、数据库是怎么设计的，索引怎么加，怎么排查哪边慢</strong></p><p>数据库开启慢查询日志，可以看到哪句数据库执行慢，使用explain来看这句查询语句是否使用了索引,看type和extra里面的数据</p><p><a href="http://sjy.我爱你/2022/03/20/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95explain/">using explain</a></p><p><strong>5、数据库是怎么benchmark的</strong></p><p>​    业务是告诉你学号然后查一个excel表告诉你这个学号的姓名，从老的数据库取6w条数据来，老数据库很慢是因为完全不加索引，查一个数据是2&#x2F;n的时间复杂度，然后用写好的程序把这6w条数据重新转化成二维string然后再插入到新数据库，然后随机查询100条数据看是否会查询失败和查询到时间。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer函数</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/defer%E5%87%BD%E6%95%B0/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/defer%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="1、defer函数参数即时求值"><a href="#1、defer函数参数即时求值" class="headerlink" title="1、defer函数参数即时求值"></a>1、<strong>defer函数参数即时求值</strong></h4><pre><code class="hljs stylus">func <span class="hljs-built_in">g</span>(<span class="hljs-selector-tag">i</span> int) &#123;   fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;g i:&quot;</span>, i)&#125;func <span class="hljs-built_in">f</span>() &#123;   <span class="hljs-selector-tag">i</span> := <span class="hljs-number">100</span>   defer <span class="hljs-built_in">g</span>(i)  <span class="hljs-comment">//1</span>   fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;begin i:&quot;</span>, i)   <span class="hljs-selector-tag">i</span> = <span class="hljs-number">200</span>   fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;end i:&quot;</span>, i)   return&#125;</code></pre><p>会输出begin i :100,end i: 200,最后输出g i:100</p><p><strong>g（）函数延迟执行，参数不会</strong></p><h4 id="2、反序调用"><a href="#2、反序调用" class="headerlink" title="2、反序调用"></a>2、反序调用</h4><pre><code class="hljs gradle">func f() &#123;   defer fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;defer01&quot;</span>)   fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;begin&quot;</span>)   defer fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;defer02&quot;</span>)   fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;----&quot;</span>)   defer fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;defer03&quot;</span>)   fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;end&quot;</span>)   <span class="hljs-keyword">return</span>&#125;</code></pre><pre><code class="hljs asciidoc"><span class="hljs-section">begin</span><span class="hljs-section">----</span>enddefer03defer02defer01</code></pre><h4 id="3、defer与return"><a href="#3、defer与return" class="headerlink" title="3、defer与return"></a>3、defer与return</h4><p><strong>defer 函数的执行既不是在 return 之后也不是在 return 之前，而是一条go语言的 return 语句包含了对 defer 函数的调用</strong>,给你举个例子：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-keyword">var</span> g = <span class="hljs-number">100</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        g = <span class="hljs-number">200</span>    &#125;()     fmt.Printf(<span class="hljs-string">&quot;f: g = %d\n&quot;</span>, g)     <span class="hljs-keyword">return</span> g&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    i := f()    fmt.Printf(<span class="hljs-string">&quot;main: i = %d, g = %d\n&quot;</span>, i, g)&#125;</code></pre><p>输出g &#x3D;100，i &#x3D;100, g &#x3D;200</p><p>这个简单理解，看看下一个例子</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-keyword">var</span> g = <span class="hljs-number">100</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;    r = g    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        r = <span class="hljs-number">200</span>    &#125;()     fmt.Printf(<span class="hljs-string">&quot;f: r = %d\n&quot;</span>, r)     r = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> r&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    i := f()    fmt.Printf(<span class="hljs-string">&quot;main: i = %d, g = %d\n&quot;</span>, i, g)&#125;</code></pre><p>输出：</p><p>r &#x3D;100</p><p>i &#x3D;200, g &#x3D;100</p><p>看起来很冲突的结果，到汇编层面来看，用gdb层面来看，我看不懂，直接说结论</p><p>defer 函数的执行既不是在 return 之后也不是在 return 之前，而是一条go语言的 return 语句包含了对 defer 函数的调用，即 return 会被翻译成如下几条伪指令</p><pre><code class="hljs go">保存返回值到栈上调用<span class="hljs-keyword">defer</span>函数调整函数栈retq指令返回</code></pre><h4 id="自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return-g是先g把值赋值给r-然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r-的值改变了，所以最后return的时候r-x3D-200。"><a href="#自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return-g是先g把值赋值给r-然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r-的值改变了，所以最后return的时候r-x3D-200。" class="headerlink" title="自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return g是先g把值赋值给r,然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r 的值改变了，所以最后return的时候r&#x3D;200。"></a>自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return g是先g把值赋值给r,然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r 的值改变了，所以最后return的时候r&#x3D;200。</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GMP</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/GMP/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/GMP/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是GMP？"><a href="#1、什么是GMP？" class="headerlink" title="1、什么是GMP？"></a>1、什么是GMP？</h3><p><strong>GMP是golang 1.1出现的特性，由1.0版本的GM模型演化而来</strong></p><p>G是goroutine,M全称是Machine内核级线程，P是逻辑处理器（Processor），提供执行一个 go 语言代码片段所需要的资源，内存分配状态，任务队列（G），存储了所有需要它来调度的G，可以用户使用gomaxprocs来设置。就是讲golang怎么从cup到实现goroutine</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0h97o56kkj20pb0nnq48.jpg"></p><h3 id="2、如果某个M陷入阻塞如何处理？"><a href="#2、如果某个M陷入阻塞如何处理？" class="headerlink" title="2、如果某个M陷入阻塞如何处理？"></a>2、如果某个M陷入阻塞如何处理？</h3><p>当一个os线程由于io操作而陷入阻塞，P会带其中的G链接到其他M中去，如果M恢复了，会从别的M上拿过来一个P，把原先跑在上面的G0放到p的队列里面，如果找不到P，就把运行在其上面的G0放到全局global runqueue里面。</p><h3 id="3、如果有的M较忙，有的M较闲？"><a href="#3、如果有的M较忙，有的M较闲？" class="headerlink" title="3、如果有的M较忙，有的M较闲？"></a>3、如果有的M较忙，有的M较闲？</h3><p>链接M的P中gorouitne做完了，会去global runqueue中要G，如果没有会从别的M里面要G，一般是一个进程的一半Goroutine。</p><h3 id="4、如果一个G的运行时间过长，导致队列中后续G无法运行？"><a href="#4、如果一个G的运行时间过长，导致队列中后续G无法运行？" class="headerlink" title="4、如果一个G的运行时间过长，导致队列中后续G无法运行？"></a>4、如果一个G的运行时间过长，导致队列中后续G无法运行？</h3><p>会专门创建一个线程sysmon，用于监控和管理，在内部是一个循环，记录所有P的G任务计数schedtick，如果一个P的schedtick一直不增加说明一个G一直在运行，如果运行时间太长（&gt;10ms）就给这个goroutine打标记，下一次遇到这个就直接放到总队列的最后</p><h3 id="5、一个G由于调用被中断，此后如何恢复？"><a href="#5、一个G由于调用被中断，此后如何恢复？" class="headerlink" title="5、一个G由于调用被中断，此后如何恢复？"></a>5、一个G由于调用被中断，此后如何恢复？</h3><p>终端你的时候把在寄存器中的栈信息重新赋值给G，等下一次运行把保存的信息复制到栈里面就可。</p><h3 id="GMP调度流程"><a href="#GMP调度流程" class="headerlink" title="GMP调度流程"></a>GMP调度流程</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ha3u9e5fj20u00gwdha.jpg"></p><ul><li><ul><li><ol><li>调用 go func()创建一个goroutine；</li></ol></li><li><ol start="2"><li>新创建的G优先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</li></ol></li><li><ol start="3"><li>M需要在P的本地队列弹出一个可执行的G，如果P的本地队列为空，则先会去全局队列中获取G，如果全局队列也为空则去其他P中偷取G放到自己的P中</li></ol></li><li><ol start="4"><li>G将相关参数传输给M，为M执行G做准备</li></ol></li><li><ol start="5"><li>当M执行某一个G时候如果发生了系统调用产生导致M会阻塞，如果当前P队列中有一些G，runtime会将线程M和P分离，然后再获取空闲的线程或创建一个新的内核级的线程来服务于这个P，阻塞调用完成后G被销毁将值返回；</li></ol></li><li><ol start="6"><li>销毁G，将执行结果返回</li></ol></li><li><ol start="7"><li>当M系统调用结束时候，这个M会尝试获取一个空闲的P执行，如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中。</li></ol></li></ul></li></ul><h2 id="GM与GMP"><a href="#GM与GMP" class="headerlink" title="GM与GMP"></a>GM与GMP</h2><h4 id="GMP相对于GM做了哪些优化"><a href="#GMP相对于GM做了哪些优化" class="headerlink" title="GMP相对于GM做了哪些优化"></a>GMP相对于GM做了哪些优化</h4><p>优化点有三个</p><p>1、每个 P 有自己的本地队列，而不是所有的G操作都要经过全局的G队列，这样锁的竞争会少的多的多。而 GM 模型的性能开销大头就是锁竞争。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hal3f11xj20sw0dpmxt.jpg"></p><p>2、P的本地队列平衡上，在 GMP 模型中也实现了 Work Stealing 算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行（通常是偷一半），减少空转，提高了资源利用率。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hakw745aj20gp0ja74v.jpg"></p><p>3、hand off机制当M0线程因为G1进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程M1执行，同样也是提高了资源利用率。</p><h4 id="队列和线程的优化可以做在G层和M层，为什么要加一个P层呢？"><a href="#队列和线程的优化可以做在G层和M层，为什么要加一个P层呢？" class="headerlink" title="队列和线程的优化可以做在G层和M层，为什么要加一个P层呢？"></a>队列和线程的优化可以做在G层和M层，为什么要加一个P层呢？</h4><p>因为M层是放在内核的，我们无权修改，内核级也是用户级线程发展成熟才加入内核中。所以在M无法修改的情况下，所有的修改只能放在用户层。将队列和M绑定，由于hand off机制M会一直扩增，因此队列也需要一直扩增，那么为了使Work Stealing 能够正常进行，队列管理将会变的复杂。因此设定了P层作为中间层，进行队列管理，控制GMP数量（最大个数为P的数量）。</p><p>参考网站：（讲的特别好）<a href="http://www.9ong.com/072021/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85go%E8%AF%AD%E8%A8%80gmp%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B.html">http://www.9ong.com/072021/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85go%E8%AF%AD%E8%A8%80gmp%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B.html</a> </p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang内存分配</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>go语言启动时会分配一块内存，然后切成小块进行管理，分成span，bitmap，arena，</p><p>arena：将内存分成8kb的页（page），一起组成起来称mspan，成为go内存管理的基本单元。</p><p>bitmap：标记堆区使用的映射表，记录哪些区保存对象，哪些区包含指针</p><p>spans:存放mspan指针，根据spans信息很容易找到mspan，可以在GC时更快速找到大块内存mspan。</p><h3 id="goroutine的栈内存分配"><a href="#goroutine的栈内存分配" class="headerlink" title="goroutine的栈内存分配"></a>goroutine的栈内存分配</h3><p>在<code>Go</code>应用程序运行时，每个<code>goroutine</code>都维护着一个自己的栈区，这个栈区只能自己使用不能被其他<code>goroutine</code>使用。<strong>栈区的初始大小是2KB</strong>（比x86_64架构下线程的默认栈2M要小很多），在<code>goroutine</code>运行的时候栈区会按照需要增长和收缩，占用的内存最大限制的默认值在64位系统上是1GB。栈大小的初始值和上限这部分的设置都可以在<code>Go</code>的源码<code>runtime/stack.go</code>里找到：</p><pre><code class="hljs go"><span class="hljs-comment">// rumtime.stack.go</span><span class="hljs-comment">// The minimum size of stack used by Go code</span>_StackMin = <span class="hljs-number">2048</span><span class="hljs-keyword">var</span> maxstacksize <span class="hljs-type">uintptr</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span> <span class="hljs-comment">// enough until runtime.main sets it for real</span></code></pre><p>其实栈内存空间、结构和初始大小在最开始并不是2KB，也是经过了几个版本的更迭</p><ul><li>v1.0 ~ v1.1 — 最小栈内存空间为 4KB；</li><li>v1.2 — 将最小栈内存提升到了 8KB；</li><li>v1.3 — 使用<strong>连续栈</strong>替换之前版本的分段栈；</li><li>v1.4 — 将最小栈内存降低到了 2KB；</li></ul><h3 id="分段栈和连续栈"><a href="#分段栈和连续栈" class="headerlink" title="分段栈和连续栈"></a>分段栈和连续栈</h3><h4 id="分段栈"><a href="#分段栈" class="headerlink" title="分段栈"></a>分段栈</h4><p>Go 1.3 版本前使用的栈结构是分段栈，随着<code>goroutine</code> 调用的函数层级的深入或者局部变量需要的越来越多时，运行时会调用 <code>runtime.morestack</code> 和 <code>runtime.newstack</code>创建一个新的栈空间，这些栈空间是不连续的，但是当前 <code>goroutine</code> 的多个栈空间会以双向链表的形式串联起来，运行时会通过指针找到连续的栈片段：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98871ce62ad74f578ddcc1f879c49f07~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>分段栈虽然能够按需为当前 <code>goroutine</code> 分配内存并且及时减少内存的占用，但是它也存在一个比较大的问题：</p><ul><li>如果当前 <code>goroutine</code> 的栈几乎充满，那么任意的函数调用都会触发栈的扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）。</li></ul><p>为了解决这个问题，Go在1.2版本的时候不得不将栈的初始化内存从4KB增大到了8KB。后来把采用连续栈结构后，又把初始栈大小减小到了2KB。</p><h3 id="连续栈"><a href="#连续栈" class="headerlink" title="连续栈"></a>连续栈</h3><p>连续栈可以解决分段栈中存在的两个问题，其核心原理就是每当程序的栈空间不足时，初始化一片比旧栈大两倍的新栈并将原栈中的所有值都迁移到新的栈中，新的局部变量或者函数调用就有了充足的内存空间。使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：</p><ol><li>调用用<code>runtime.newstack</code>在内存空间中分配更大的栈内存空间；</li><li>使用<code>runtime.copystack</code>将旧栈中的所有内容复制到新的栈中；</li><li><strong>将指向旧栈对应变量的指针重新指向新栈</strong>；</li><li>调用<code>runtime.stackfree</code>销毁并回收旧栈的内存空间；</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/498c581f48894526850a3f05708b38c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><h4 id="栈区的内存管理"><a href="#栈区的内存管理" class="headerlink" title="栈区的内存管理"></a>栈区的内存管理</h4><p>前面说了每个<code>goroutine</code>都维护着自己的栈区，栈结构是连续栈，是一块连续的内存，在<code>goroutine</code>的类型定义的源码里我们可以找到标记着栈区边界的<code>stack</code>信息，<code>stack</code>里记录着栈区边界的高位内存地址和低位内存地址：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;stack       stack  ...&#125;<span class="hljs-keyword">type</span> stack <span class="hljs-keyword">struct</span> &#123;lo <span class="hljs-type">uintptr</span>hi <span class="hljs-type">uintptr</span>&#125;</code></pre><h3 id="栈扩容"><a href="#栈扩容" class="headerlink" title="栈扩容"></a>栈扩容</h3><p>编译器会为函数调用插入运行时检查<code>runtime.morestack</code>，它会在几乎所有的函数调用之前检查当前<code>goroutine</code> 的栈内存是否充足，如果当前栈需要扩容，会调用<code>runtime.newstack</code> 创建新的栈：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newstack</span><span class="hljs-params">()</span></span> &#123;   ......   <span class="hljs-comment">// Allocate a bigger segment and move the stack.</span>   oldsize := gp.stack.hi - gp.stack.lo   newsize := oldsize * <span class="hljs-number">2</span>   <span class="hljs-keyword">if</span> newsize &gt; maxstacksize &#123;       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;runtime: goroutine stack exceeds &quot;</span>, maxstacksize, <span class="hljs-string">&quot;-byte limit\n&quot;</span>)      throw(<span class="hljs-string">&quot;stack overflow&quot;</span>)   &#125;   <span class="hljs-comment">// The goroutine must be executing in order to call newstack,</span>   <span class="hljs-comment">// so it must be Grunning (or Gscanrunning).</span>   casgstatus(gp, _Grunning, _Gcopystack)   <span class="hljs-comment">// The concurrent GC will not scan the stack while we are doing the copy since</span>   <span class="hljs-comment">// the gp is in a Gcopystack status.</span>   copystack(gp, newsize, <span class="hljs-literal">true</span>)   <span class="hljs-keyword">if</span> stackDebug &gt;= <span class="hljs-number">1</span> &#123;      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stack grow done\n&quot;</span>)   &#125;   casgstatus(gp, _Gcopystack, _Grunning)&#125;复制代码</code></pre><p>旧栈的大小是通过我们上面说的保存在<code>goroutine</code>中的<code>stack</code>信息里记录的栈区内存边界计算出来的，然后用旧栈两倍的大小创建新栈，创建前会检查是新栈的大小是否超过了单个栈的内存上限。</p><pre><code class="hljs go">   oldsize := gp.stack.hi - gp.stack.lo   newsize := oldsize * <span class="hljs-number">2</span>   <span class="hljs-keyword">if</span> newsize &gt; maxstacksize &#123;       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;runtime: goroutine stack exceeds &quot;</span>, maxstacksize, <span class="hljs-string">&quot;-byte limit\n&quot;</span>)      throw(<span class="hljs-string">&quot;stack overflow&quot;</span>)   &#125;复制代码</code></pre><p>如果目标栈的大小没有超出程序的限制，会将 <code>goroutine</code> 切换至 <code>_Gcopystack</code> 状态并调用 <code>runtime.copystack</code> 开始栈的拷贝，在拷贝栈的内存之前，运行时会先通过<code>runtime.stackalloc</code> 函数分配新的栈空间：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copystack</span><span class="hljs-params">(gp *g, newsize <span class="hljs-type">uintptr</span>)</span></span> &#123;old := gp.stackused := old.hi - gp.sched.sp  <span class="hljs-comment">// 创建新栈</span><span class="hljs-built_in">new</span> := stackalloc(<span class="hljs-type">uint32</span>(newsize))...  <span class="hljs-comment">// 把旧栈的内容拷贝至新栈</span>memmove(unsafe.Pointer(<span class="hljs-built_in">new</span>.hi-ncopy), unsafe.Pointer(old.hi-ncopy), ncopy)  ...  <span class="hljs-comment">// 调整指针</span>  adjustctxt(gp, &amp;adjinfo)  <span class="hljs-comment">// groutine里记录新栈的边界</span>  gp.stack = <span class="hljs-built_in">new</span>  ...  <span class="hljs-comment">// 释放旧栈</span>  stackfree(old)&#125;复制代码</code></pre><p>新栈的初始化和数据的复制是一个比较简单的过程，整个过程中最复杂的地方是将指向源栈中内存的指针调整为指向新的栈，这一步完成后就会释放掉旧栈的内存空间了。</p><p>我们可以通过修改一下源码文件<code>runtime.stack.go</code>，把常量<code>stackDebug</code>的值修改为1，使用命令<strong>go build -gcflags -S main.go</strong> 运行文章最开始的那个例子，观察栈的初始化和扩容过程：</p><pre><code class="hljs shell">stackalloc 2048stackcacherefill order=0  allocated 0xc000030000...copystack gp=0xc000000180 [0xc000030000 0xc0000306e0 0xc000030800] -&gt; [0xc00005c000 0xc00005cee0 0xc00005d000]/4096stackfree 0xc000030000 2048stack grow done...copystack gp=0xc000000180 [0xc00005c000 0xc00005c890 0xc00005d000] -&gt; [0xc000064000 0xc000065890 0xc000066000]/8192stackfree 0xc00005c000 4096stack grow done...copystack gp=0xc000000180 [0xc000064000 0xc000065890 0xc000066000] -&gt; [0xc00006c000 0xc00006f890 0xc000070000]/16384stackfree 0xc000064000 8192stack grow done...copystack gp=0xc000000180 [0xc00006c000 0xc00006f890 0xc000070000] -&gt; [0xc000070000 0xc000077890 0xc000078000]/32768stackfree 0xc00006c000 16384stack grow done复制代码</code></pre><h3 id="栈缩容"><a href="#栈缩容" class="headerlink" title="栈缩容"></a>栈缩容</h3><p>在<code>goroutine</code>运行的过程中，如果栈区的空间使用率不超过1&#x2F;4，那么在垃圾回收的时候使用<code>runtime.shrinkstack</code>进行栈缩容，当然进行缩容前会执行一堆前置检查，都通过了才会进行缩容</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shrinkstack</span><span class="hljs-params">(gp *g)</span></span> &#123;...oldsize := gp.stack.hi - gp.stack.lonewsize := oldsize / <span class="hljs-number">2</span><span class="hljs-keyword">if</span> newsize &lt; _FixedStack &#123;<span class="hljs-keyword">return</span>&#125;avail := gp.stack.hi - gp.stack.lo<span class="hljs-keyword">if</span> used := gp.stack.hi - gp.sched.sp + _StackLimit; used &gt;= avail/<span class="hljs-number">4</span> &#123;<span class="hljs-keyword">return</span>&#125;copystack(gp, newsize)&#125;复制代码</code></pre><p>如果要触发栈的缩容，新栈的大小会是原始栈的一半，不过如果新栈的大小低于程序的最低限制 2KB，那么缩容的过程就会停止。缩容也会调用扩容时使用的 <code>runtime.copystack</code> 函数开辟新的栈空间，将旧栈的数据拷贝到新栈以及调整原来指针的指向。</p><p>在我们上面的那个例子里，当<code>main</code>函数里的其他函数执行完后，只有<code>main</code>函数还在栈区的空间里，如果这个时候系统进行垃圾回收就会对这个<code>goroutine</code>的栈区进行缩容。在这里我们可以在程序里通过调用<code>runtime.GC</code>，强制系统进行垃圾回收，来试验看一下栈缩容的过程和效果：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   <span class="hljs-keyword">var</span> x [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>   <span class="hljs-built_in">println</span>(&amp;x)   a(x)   runtime.GC()   <span class="hljs-built_in">println</span>(&amp;x)&#125;复制代码</code></pre><p>执行命令<strong>go build -gcflags -S main.go</strong>后会看到类似下面的输出。</p><pre><code class="hljs dns">...shrinking stack <span class="hljs-number">32768</span>-&gt;<span class="hljs-number">16384</span>stackalloc <span class="hljs-number">16384</span>  allocated <span class="hljs-number">0</span>xc<span class="hljs-number">000076000</span>copystack gp=<span class="hljs-number">0</span>xc<span class="hljs-number">000000180</span> [<span class="hljs-number">0</span>xc<span class="hljs-number">00007a000</span> <span class="hljs-number">0</span>xc<span class="hljs-number">000081e60</span> <span class="hljs-number">0</span>xc<span class="hljs-number">000082000</span>] -&gt; [<span class="hljs-number">0</span>xc<span class="hljs-number">000076000</span> <span class="hljs-number">0</span>xc<span class="hljs-number">000079e60</span> <span class="hljs-number">0</span>xc<span class="hljs-number">00007a000</span>]/<span class="hljs-number">16384</span>...复制代码</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>参考文章：</strong><a href="https://juejin.cn/post/6871550379432574990">https://juejin.cn/post/6871550379432574990</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang后台面试题目</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1、go struct 能不能比较</p><p>struct是强类型语言，不同类型不能比较，同类型才能比较，实例也不能比较，因为实例是指针类型</p><p>2、写出下面代码输出内容</p><pre><code class="hljs autoit">package mainimport (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">func</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;defer_call()&#125;<span class="hljs-keyword">func</span> <span class="hljs-title function_">defer_call</span><span class="hljs-params">()</span> &#123;defer <span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123; <span class="hljs-title function_">fmt</span>.<span class="hljs-title function_">Println</span><span class="hljs-params">(<span class="hljs-string">&quot;打印前&quot;</span>)</span> &#125;<span class="hljs-params">()</span>defer <span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123; <span class="hljs-title function_">fmt</span>.<span class="hljs-title function_">Println</span><span class="hljs-params">(<span class="hljs-string">&quot;打印中&quot;</span>)</span> &#125;<span class="hljs-params">()</span>defer <span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123; <span class="hljs-title function_">fmt</span>.<span class="hljs-title function_">Println</span><span class="hljs-params">(<span class="hljs-string">&quot;打印后&quot;</span>)</span> &#125;<span class="hljs-params">()</span>panic(<span class="hljs-string">&quot;触发异常&quot;</span>)&#125;</code></pre><p>打印后<br>打印中<br>打印前<br>panic: 触发异常</p><h4 id="3、range陷阱"><a href="#3、range陷阱" class="headerlink" title="3、range陷阱"></a>3、range陷阱</h4><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span>import <span class="hljs-string">&quot;fmt&quot;</span>type AStruct struct &#123;    bar string&#125;func <span class="hljs-selector-tag">main</span>() &#123;    list := <span class="hljs-selector-attr">[]</span>AStruct&#123;        &#123;<span class="hljs-string">&quot;1&quot;</span>&#125;,        &#123;<span class="hljs-string">&quot;2&quot;</span>&#125;,        &#123;<span class="hljs-string">&quot;3&quot;</span>&#125;,    &#125;    copyedList := <span class="hljs-built_in">make</span>(<span class="hljs-selector-attr">[]</span>*AStruct, <span class="hljs-built_in">len</span>(list))    <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>,v:= range list &#123;        copyedList<span class="hljs-selector-attr">[i]</span> = &amp;v    &#125;    fmt<span class="hljs-selector-class">.Println</span>(list<span class="hljs-selector-attr">[0]</span>, list<span class="hljs-selector-attr">[1]</span>, list<span class="hljs-selector-attr">[2]</span>)    fmt<span class="hljs-selector-class">.Println</span>(copyedList<span class="hljs-selector-attr">[0]</span>, copyedList<span class="hljs-selector-attr">[1]</span>, copyedList<span class="hljs-selector-attr">[2]</span>)&#125;</code></pre><p>运行这段代码，你就会发现</p><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;2&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"></span><span class="language-xml">&amp;</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"> &amp;</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"> &amp;</span><span class="hljs-template-variable">&#123;3&#125;</span></code></pre><p>怎么都是同一个地址，因为range赋值用的是用的是一个循环变量的地址，Go每次循环都会复用这一”循环变量”，所以一直会输出最后一个数的地址</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> list &#123;  copyedList[i] = &amp;list[i]&#125;</code></pre><h4 id="4、变量的作用域陷阱"><a href="#4、变量的作用域陷阱" class="headerlink" title="4、变量的作用域陷阱"></a>4、变量的作用域陷阱</h4><p>下面这段程序会有什么输出结果？</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;runtime&quot;</span>    <span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)    wg := sync.WaitGroup&#123;&#125;    wg.Add(<span class="hljs-number">20</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;            fmt.Println(<span class="hljs-string">&quot;A: &quot;</span>, i)            wg.Done()        &#125;()    &#125;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;            fmt.Println(<span class="hljs-string">&quot;B: &quot;</span>, i)            wg.Done()        &#125;(i)    &#125;    wg.Wait()&#125;</code></pre><p>A都输出10，B先输出9，然后按顺序输出</p><pre><code class="hljs apache"><span class="hljs-attribute">B</span>:  <span class="hljs-number">9</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">0</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">1</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">2</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">4</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">5</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">6</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">7</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">8</span></code></pre><p>如果不用runtime.GOMAXPROCS(1)约束，就会随机输出A和B，A和B中数字也随机输出,但是A是10</p><pre><code class="hljs apache"><span class="hljs-attribute">A</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">5</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">9</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">1</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">0</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">2</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">4</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">6</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">7</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">8</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span></code></pre><p>为什么A一直会是10，这是一个变量作用域不同引起的</p><h4 id="5、继承和组合的区别和优势劣势（还不懂）"><a href="#5、继承和组合的区别和优势劣势（还不懂）" class="headerlink" title="5、继承和组合的区别和优势劣势（还不懂）"></a>5、继承和组合的区别和优势劣势（还不懂）</h4><p><strong>继承</strong>是一个白盒模型，父类的内部细节对子类是透明的，</p><p><strong>组合</strong>是黑盒模型，父类的内部细节对子类不透明，对现有的对象进行拼装组合产生更复杂的功能</p><h5 id="继承的优点："><a href="#继承的优点：" class="headerlink" title="继承的优点："></a>继承的优点：</h5><p>易于操作，易于修改和拓展父类</p><h5 id="继承的缺点："><a href="#继承的缺点：" class="headerlink" title="继承的缺点："></a>继承的缺点：</h5><p>1、子类和父类缺乏独立性，父类改变子类不得不改变</p><p>2、破坏了封装性</p><h5 id="组合的优点"><a href="#组合的优点" class="headerlink" title="组合的优点"></a>组合的优点</h5><p>1、降低各个模块之间的耦合性</p><p>2、不会破坏封装性，只用一个接口用来连接对象内部的函数</p><p>3、减少依存关系</p><h5 id="组合的缺点"><a href="#组合的缺点" class="headerlink" title="组合的缺点"></a>组合的缺点</h5><p>1、操作困难，对不熟悉的人难以操作</p><p>2、比继承要写更多的代码</p><h4 id="6、go的组合和继承"><a href="#6、go的组合和继承" class="headerlink" title="6、go的组合和继承"></a>6、go的组合和继承</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowA() &#123;    fmt.Println(<span class="hljs-string">&quot;showA&quot;</span>)    p.ShowB()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowB() &#123;    fmt.Println(<span class="hljs-string">&quot;showB&quot;</span>)&#125;<span class="hljs-keyword">type</span> Teacher <span class="hljs-keyword">struct</span> &#123;    People&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Teacher)</span></span> ShowB() &#123;    fmt.Println(<span class="hljs-string">&quot;teacher showB&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    t := Teacher&#123;&#125;    t.ShowA()&#125;</code></pre><p>输出</p><pre><code class="hljs ebnf"><span class="hljs-attribute">showA</span><span class="hljs-attribute">showB</span></code></pre><p>解答：被组合的类型People虽然被包装成Teacher，执行t.ShowA()但是people并不自己会被什么类型组合，所以t.showB()不会执行</p><h4 id="7、select的随机性"><a href="#7、select的随机性" class="headerlink" title="7、select的随机性"></a>7、select的随机性</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)    int_chan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)    string_chan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">1</span>)    int_chan &lt;- <span class="hljs-number">1</span>    string_chan &lt;- <span class="hljs-string">&quot;hello&quot;</span>    <span class="hljs-keyword">select</span> &#123;    <span class="hljs-keyword">case</span> value := &lt;-int_chan:        fmt.Println(value)    <span class="hljs-keyword">case</span> value := &lt;-string_chan:        <span class="hljs-built_in">panic</span>(value)    &#125;&#125;</code></pre><p>答案：select随机执行一个case，有一定概率出现panic（“hello”），一定概率输出1</p><h4 id="8、defer执行顺序"><a href="#8、defer执行顺序" class="headerlink" title="8、defer执行顺序"></a>8、defer执行顺序</h4><pre><code class="hljs stylus">func <span class="hljs-built_in">calc</span>(index string, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> int) int &#123;ret := <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>fmt<span class="hljs-selector-class">.Println</span>(index, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, ret)return ret&#125;func <span class="hljs-selector-tag">main</span>() &#123;<span class="hljs-selector-tag">a</span> := <span class="hljs-number">1</span><span class="hljs-selector-tag">b</span> := <span class="hljs-number">2</span>defer <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-selector-tag">a</span>, <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-selector-tag">a</span>, b))<span class="hljs-selector-tag">a</span> = <span class="hljs-number">0</span>defer <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-selector-tag">a</span>, <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;20&quot;</span>, <span class="hljs-selector-tag">a</span>, b))<span class="hljs-selector-tag">b</span> = <span class="hljs-number">1</span>&#125;</code></pre><p>结果</p><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">20 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre><p>解析;calc(“1”, a, calc(“10”, a, b))会先对这句话里面的a，b赋值，赋值过程中先执行10，同理下一句话先执行20，再是2，最后1，因为defer是像栈一样，最后的先执行</p><h4 id="9、看看下面会有什么问题"><a href="#9、看看下面会有什么问题" class="headerlink" title="9、看看下面会有什么问题"></a>9、看看下面会有什么问题</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> UserAges <span class="hljs-keyword">struct</span> &#123;ages <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>sync.Mutex&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ua *UserAges)</span></span> Add(name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>) &#123;ua.Lock()<span class="hljs-keyword">defer</span> ua.Unlock()ua.ages[name] = age&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ua *UserAges)</span></span> Get(name <span class="hljs-type">string</span>) <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> age, ok := ua.ages[name]; ok &#123;<span class="hljs-keyword">return</span> age&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><p>解答：在并发处理的时候可能会出现<code>fatal error: concurrent map read and map write</code>.，因为get没上锁，在同一时间读写一个东西会出现竞争</p><h4 id="10、printf和Sprintf的区别"><a href="#10、printf和Sprintf的区别" class="headerlink" title="10、printf和Sprintf的区别"></a>10、printf和Sprintf的区别</h4><p>printf</p><ol><li>用传入的格式化规则符将传入的变量写入到标准输出里面(即在终端中有显示)，</li><li>返回值为 写入标准输出的字节数和写入过程中遇到的问题。</li></ol><p>sprintf</p><ol><li>用传入的格式化规则符将传入的变量格式化，(终端中不会有显示)</li><li>返回为 格式化后的字符串。</li></ol><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span>import (    <span class="hljs-string">&quot;fmt&quot;</span>)func <span class="hljs-selector-tag">main</span>()  &#123;    testStr := <span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(<span class="hljs-string">&quot;test str&quot;</span>)    fmt<span class="hljs-selector-class">.Println</span>(testStr, <span class="hljs-string">&quot;hello world&quot;</span>)    <span class="hljs-comment">//[116 101 115 116 32 115 116 114] hello world</span>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, testStr) <span class="hljs-comment">//test str</span>    fmt<span class="hljs-selector-class">.Println</span>()    fmt<span class="hljs-selector-class">.Sprintf</span>(<span class="hljs-string">&quot;%s&quot;</span>, testStr) <span class="hljs-comment">//空，无IO输出</span>    fmt<span class="hljs-selector-class">.Println</span>()    printStr := fmt<span class="hljs-selector-class">.Sprintf</span>(<span class="hljs-string">&quot;%s&quot;</span>, testStr)    fmt<span class="hljs-selector-class">.Println</span>(printStr)    <span class="hljs-comment">//test str</span>&#125;</code></pre><p>sprintf就是把一个[]byte类型的东西格式化成string</p><h4 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h4><p>​    二者都是内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零。所以在我们编写程序的时候，就可以根据自己的需要很好的选择了。</p><p>make返回的还是这三个引用类型本身；而new返回的是指向类型的指针。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go语言chan缓存和阻塞</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80chan%E7%BC%93%E5%AD%98%E5%92%8C%E9%98%BB%E5%A1%9E/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80chan%E7%BC%93%E5%AD%98%E5%92%8C%E9%98%BB%E5%A1%9E/</url>
    
    <content type="html"><![CDATA[<p>问题：下面迭代会有什么问题</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>) <span class="hljs-comment">//下面的迭代会有什么问题？</span><span class="hljs-keyword">type</span> threadSafeSet <span class="hljs-keyword">struct</span> &#123;sync.RWMutexs []<span class="hljs-keyword">interface</span>&#123;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(set *threadSafeSet)</span></span> Iter() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// 解除注释看看！</span><span class="hljs-comment">//ch := make(chan interface&#123;&#125;,len(set.s))</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;set.RLock()<span class="hljs-keyword">for</span> elem,value := <span class="hljs-keyword">range</span> set.s &#123;ch &lt;- elemfmt.Println(<span class="hljs-string">&quot;Iter:&quot;</span>,elem,value)&#125;<span class="hljs-built_in">close</span>(ch)set.RUnlock()&#125;()<span class="hljs-keyword">return</span> ch&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;th:=threadSafeSet&#123;s:[]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>&#125;,&#125;vs := th.Iter()fmt.Println(&lt;- vs)&#125;</code></pre><p>结果</p><pre><code class="hljs apache"><span class="hljs-attribute">Iter</span>: <span class="hljs-number">0</span> <span class="hljs-number">1</span><span class="hljs-attribute">0</span></code></pre><p>解释一下这段代码，在iter（）里面有一个goroutin，用来执行输入数据到channel里面，这里创了一个0空间的channel缓存，只要输入一个数据就会阻塞，为什么这里还能输入一个，因为倒数第二行输出了一个channel，就可以再输入一个数据然后阻塞。</p><p>如果把vs这个变量取消掉，然后把prinln也去掉，就什么都不能输出了</p><p>为了方便你的理解，把代码里面注释的去掉，把原来那行注释</p><pre><code>ch := make(chan interface&#123;&#125;) //ch := make(chan interface&#123;&#125;,len(set.s))</code></pre><p>现在channel就有两个缓存了，只有能够把数据输入到channel里面不堵塞才能执行这句话</p><pre><code class="hljs reasonml">fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;Iter:&quot;</span>,<span class="hljs-params">elem</span>,<span class="hljs-params">value</span>)</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言runtime</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80runtime/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80runtime/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/map/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/map/</url>
    
    <content type="html"><![CDATA[<h2 id="map是怎么实现的"><a href="#map是怎么实现的" class="headerlink" title="map是怎么实现的"></a>map是怎么实现的</h2><p>Go 语言采用的是哈希查找表，并且使用链表解决哈希冲突。</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> A header <span class="hljs-keyword">for</span> a Go map.type hmap struct &#123;    <span class="hljs-regexp">//</span> 元素个数，调用 len(map) 时，直接返回此值    count     int    flags     uint8    <span class="hljs-regexp">//</span> buckets 的对数 log_2    B         uint8    <span class="hljs-regexp">//</span> overflow 的 bucket 近似数    noverflow uint16    <span class="hljs-regexp">//</span> 计算 key 的哈希的时候会传入哈希函数    hash0     uint32    <span class="hljs-regexp">//</span> 指向 buckets 数组，大小为 <span class="hljs-number">2</span>^B    <span class="hljs-regexp">//</span> 如果元素个数为<span class="hljs-number">0</span>，就为 nil    buckets    unsafe.Pointer    <span class="hljs-regexp">//</span> 扩容的时候，buckets 长度会是 oldbuckets 的两倍    oldbuckets unsafe.Pointer    <span class="hljs-regexp">//</span> 指示扩容进度，小于此地址的 buckets 迁移完成    nevacuate  uintptr    extra *mapextra <span class="hljs-regexp">//</span> optional fields&#125;</code></pre><p>map分为hmap和bmap，hmap是一个哈希表，bmap是一个数组，golang用链表法解决哈希冲突，如果溢出会弄一个溢出bucket放进去。</p><p>bmap 是存放 k-v 的地方，我们把视角拉近，仔细看 bmap 的内部组成。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;    topbits  [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span>    keys     [<span class="hljs-number">8</span>]keytype    values   [<span class="hljs-number">8</span>]valuetype    pad      <span class="hljs-type">uintptr</span>    overflow <span class="hljs-type">uintptr</span>&#125;</code></pre><p><img src="https://user-images.githubusercontent.com/7698088/57577391-f88f1d80-74a7-11e9-893c-4783dc4fb35e.png" alt="img"></p><h3 id="创建map"><a href="#创建map" class="headerlink" title="创建map"></a>创建map</h3><p>从语法层面上来说，创建 map 很简单：</p><pre><code class="hljs go">ageMp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<span class="hljs-comment">// 指定 map 长度</span>ageMp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">8</span>)<span class="hljs-comment">// ageMp 为 nil，不能向其添加元素，会直接panic</span><span class="hljs-keyword">var</span> ageMp <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span></code></pre><p>通过汇编语言可以看到，实际上底层调用的是 <code>makemap</code> 函数，主要做的工作就是初始化 <code>hmap</code> 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。</p><pre><code>func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap &#123; // 省略各种条件检查...// 找到一个 B，使得 map 的装载因子在正常范围内B := uint8(0)for ; overLoadFactor(hint, B); B++ &#123;&#125;// 初始化 hash table// 如果 B 等于 0，那么 buckets 就会在赋值的时候再分配// 如果长度比较大，分配内存会花费长一点buckets := bucketvar extra *mapextraif B != 0 &#123;    var nextOverflow *bmap    buckets, nextOverflow = makeBucketArray(t, B)    if nextOverflow != nil &#123;        extra = new(mapextra)        extra.nextOverflow = nextOverflow    &#125;&#125;// 初始化 hampif h == nil &#123;    h = (*hmap)(newobject(t.hmap))&#125;h.count = 0h.B = Bh.extra = extrah.flags = 0h.hash0 = fastrand()h.buckets = bucketsh.oldbuckets = nilh.nevacuate = 0h.noverflow = 0return h&#125;</code></pre><h2 id="key-定位过程"><a href="#key-定位过程" class="headerlink" title="key 定位过程"></a>key 定位过程</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h58uhkib28j20u01270vw.jpg"></p><p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B &#x3D; 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 &#x3D; 32。</p><p>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p><p> 10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</p><p>用最后的 5 个 bit 位，也就是 <code>01010</code>，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。</p><p>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p><p>buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p><h3 id="map扩容过程是怎么样的"><a href="#map扩容过程是怎么样的" class="headerlink" title="map扩容过程是怎么样的"></a>map扩容过程是怎么样的</h3><p>需要一个指标来判断是否要扩容，这就是<code>装载因子</code>。Go 源码里这样定义 <code>装载因子</code>：</p><pre><code class="hljs apache"><span class="hljs-attribute">loadFactor</span> := count / (<span class="hljs-number">2</span>^B)</code></pre><p>count 就是 map 的元素个数，2^B 表示 bucket 数量。</p><p>再来说触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：</p><ol><li>装载因子超过阈值，源码里定义的阈值是 6.5。</li><li>overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &gt;&#x3D; 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。</li></ol><pre><code class="hljs reasonml"><span class="hljs-comment">// src/runtime/hashmap.go/mapassign</span><span class="hljs-comment">// 触发扩容时机</span><span class="hljs-keyword">if</span> !h.growing<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>(over<span class="hljs-constructor">LoadFactor(<span class="hljs-params">int64</span>(<span class="hljs-params">h</span>.<span class="hljs-params">count</span>)</span>, h.B)<span class="hljs-operator"> || </span>too<span class="hljs-constructor">ManyOverflowBuckets(<span class="hljs-params">h</span>.<span class="hljs-params">noverflow</span>, <span class="hljs-params">h</span>.B)</span>) &#123;        hash<span class="hljs-constructor">Grow(<span class="hljs-params">t</span>, <span class="hljs-params">h</span>)</span>    &#125;<span class="hljs-comment">// 装载因子超过 6.5</span>func over<span class="hljs-constructor">LoadFactor(<span class="hljs-params">count</span> <span class="hljs-params">int64</span>, B <span class="hljs-params">uint8</span>)</span> <span class="hljs-built_in">bool</span> &#123;    return count &gt;= bucketCnt<span class="hljs-operator"> &amp;&amp; </span>float32(count) &gt;= loadFactor*float32((uint64(<span class="hljs-number">1</span>)&lt;&lt;B))&#125;<span class="hljs-comment">// overflow buckets 太多</span>func too<span class="hljs-constructor">ManyOverflowBuckets(<span class="hljs-params">noverflow</span> <span class="hljs-params">uint16</span>, B <span class="hljs-params">uint8</span>)</span> <span class="hljs-built_in">bool</span> &#123;    <span class="hljs-keyword">if</span> B &lt; <span class="hljs-number">16</span> &#123;        return noverflow &gt;= uint16(<span class="hljs-number">1</span>)&lt;&lt;B    &#125;    return noverflow &gt;= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>&#125;</code></pre><p>再来看看真正执行搬迁工作的 growWork() 函数。</p><pre><code class="hljs reasonml">func grow<span class="hljs-constructor">Work(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">maptype</span>, <span class="hljs-params">h</span> <span class="hljs-operator">*</span><span class="hljs-params">hmap</span>, <span class="hljs-params">bucket</span> <span class="hljs-params">uintptr</span>)</span> &#123;    <span class="hljs-comment">// 确认搬迁老的 bucket 对应正在使用的 bucket</span>    evacuate(t, h, bucket&amp;h.oldbucketmask<span class="hljs-literal">()</span>)    <span class="hljs-comment">// 再搬迁一个 bucket，以加快搬迁进程</span>    <span class="hljs-keyword">if</span> h.growing<span class="hljs-literal">()</span> &#123;        evacuate(t, h, h.nevacuate)    &#125;&#125;</code></pre><p>h.growing() 函数非常简单：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hmap)</span></span> growing() <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">return</span> h.oldbuckets != <span class="hljs-literal">nil</span>&#125;</code></pre><p>如果 <code>oldbuckets</code> 不为空，说明还没有搬迁完毕，还得继续搬。</p><p>TODO:evacuate函数干了什么下次看懂源码再写，一个搬迁的细节是搬到大内存去的时候得重新hash计算放到哪个bucket中，因为比原来多了一位。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1、为什么map不可以寻址，map是怎么存储的"><a href="#1、为什么map不可以寻址，map是怎么存储的" class="headerlink" title="1、为什么map不可以寻址，map是怎么存储的"></a>1、为什么map不可以寻址，map是怎么存储的</h3><ol><li>如果字典的元素不存在，则返回零值，而零值是不可变对象，如果能寻址问题就大了。</li><li>而如果字典的元素存在，考虑到 Go 中 map 实现中元素的地址是变化的，这意味着寻址的结果也是无意义的。</li></ol><p>参考网站：<a href="https://qcrao91.gitbook.io/go/map/map-de-di-ceng-shi-xian-yuan-li-shi-shi-mo">https://qcrao91.gitbook.io/go/map/map-de-di-ceng-shi-xian-yuan-li-shi-shi-mo</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go slice 扩容深度分析（1.18版本的golang已经改变之前的分配方式）</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E5%88%87%E7%89%87/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h4 id="1、切片扩容常规操作"><a href="#1、切片扩容常规操作" class="headerlink" title="1、切片扩容常规操作"></a>1、切片扩容常规操作</h4><p>如果超过容量，会重新扩一个内存，创建新的数组，并把指针指向这个数组，容量如果不超过1024会扩一倍，如果容量超过1024扩容量会每次增加25%。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    a := []<span class="hljs-type">int</span>&#123;&#125;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">33</span>; i++ &#123;        a = <span class="hljs-built_in">append</span>(a, i)        fmt.Print(<span class="hljs-built_in">cap</span>(a), <span class="hljs-string">&quot; &quot;</span>)    &#125;&#125;</code></pre><p>结果：</p><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span></code></pre><h4 id="2、切片扩容非常规操作（一次插入多个数字）"><a href="#2、切片扩容非常规操作（一次插入多个数字）" class="headerlink" title="2、切片扩容非常规操作（一次插入多个数字）"></a>2、切片扩容非常规操作（一次插入多个数字）</h4><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span>import <span class="hljs-string">&quot;fmt&quot;</span>func <span class="hljs-selector-tag">main</span>() &#123;    <span class="hljs-selector-tag">b</span> := <span class="hljs-selector-attr">[]</span>int&#123;<span class="hljs-number">23</span>, <span class="hljs-number">51</span>&#125;    <span class="hljs-selector-tag">b</span> = <span class="hljs-built_in">append</span>(<span class="hljs-selector-tag">b</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)    fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;cap of b is &quot;</span>,<span class="hljs-built_in">cap</span>(b))&#125;</code></pre><p>猜猜结果是多少？</p><pre><code class="hljs actionscript">cap of b <span class="hljs-keyword">is</span>  <span class="hljs-number">6</span></code></pre><p>想知道结果我们翻看golang 的源码，我的版本是1.18beta1，老版本的扩容代码和新版本有些许区别</p><p>代码位置：src&#x2F;runtime&#x2F;slice.go</p><pre><code class="hljs haxe"><span class="hljs-comment">//老版本</span><span class="hljs-keyword">new</span><span class="hljs-type">cap</span> :<span class="hljs-type"></span>= old.cap<span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span><span class="hljs-type">cap</span>+<span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &lt; cap &#123;    <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = cap&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">for</span> &#123;        <span class="hljs-keyword">if</span> old.len &lt; <span class="hljs-number">1024</span> &#123;            <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> += <span class="hljs-keyword">new</span><span class="hljs-type">cap</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> += <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> / <span class="hljs-number">4</span>        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &gt;= cap &#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;&#125;<span class="hljs-comment">// 1.18beta版</span><span class="hljs-keyword">new</span><span class="hljs-type">cap</span> :<span class="hljs-type"></span>= old.capdoublecap :<span class="hljs-type"></span>= <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> + <span class="hljs-keyword">new</span><span class="hljs-type">cap</span><span class="hljs-keyword">if</span> cap &gt; doublecap &#123;<span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = cap&#125; <span class="hljs-keyword">else</span> &#123;const threshold = <span class="hljs-number">256</span><span class="hljs-keyword">if</span> old.cap &lt; threshold &#123;<span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = doublecap&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><span class="hljs-comment">// and prevent an infinite loop.</span><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &amp;&amp; <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &lt; cap &#123;<span class="hljs-comment">// Transition from growing 2x for small slices</span><span class="hljs-comment">// to growing 1.25x for large slices. This formula</span><span class="hljs-comment">// gives a smooth-ish transition between the two.</span><span class="hljs-keyword">new</span><span class="hljs-type">cap</span> += (<span class="hljs-keyword">new</span><span class="hljs-type">cap</span> + <span class="hljs-number">3</span>*threshold) / <span class="hljs-number">4</span>&#125;<span class="hljs-comment">// Set newcap to the requested cap when</span><span class="hljs-comment">// the newcap calculation overflowed.</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &lt;= <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = cap&#125;&#125;&#125;</code></pre><ul><li>第一行的 old.cap：扩容前的容量，对于此例，就是 2</li><li>第二行的 cap：扩容前容量加上扩容的元素数量，对于此例，就是 2+3</li></ul><p>新版本的和老版本的区别在于新版本把阈值设为256，并且改变了增长公式</p><p>newcap +&#x3D; (newcap + 3*threshold) &#x2F; 4，使之增长更加平滑</p><p><strong>看代码那最终容量不是5吗？</strong></p><p>其实不然，newcap是计算出扩容后的预估容量，并不是最终的容量，要计算最终的容量，还需要参考另一个维度，也就是内存分配。</p><p>关于内存管理模块的代码，在 <code>runtime/sizeclasses.go</code></p><pre><code class="hljs tap">// class  bytes/obj  bytes/span  objects  tail waste  max waste//    <span class="hljs-number"> 1 </span>        <span class="hljs-number"> 8 </span>      <span class="hljs-number"> 8192 </span>   <span class="hljs-number"> 1024 </span>         <span class="hljs-number"> 0 </span>    87.50%//    <span class="hljs-number"> 2 </span>       <span class="hljs-number"> 16 </span>      <span class="hljs-number"> 8192 </span>    <span class="hljs-number"> 512 </span>         <span class="hljs-number"> 0 </span>    43.75%//    <span class="hljs-number"> 3 </span>       <span class="hljs-number"> 32 </span>      <span class="hljs-number"> 8192 </span>    <span class="hljs-number"> 256 </span>         <span class="hljs-number"> 0 </span>    46.88%//    <span class="hljs-number"> 4 </span>       <span class="hljs-number"> 48 </span>      <span class="hljs-number"> 8192 </span>    <span class="hljs-number"> 170 </span>        <span class="hljs-number"> 32 </span>    31.52%...//   <span class="hljs-number"> 17 </span>      <span class="hljs-number"> 256 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 32 </span>         <span class="hljs-number"> 0 </span>     5.86%//   <span class="hljs-number"> 18 </span>      <span class="hljs-number"> 288 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 28 </span>       <span class="hljs-number"> 128 </span>    12.16%//   <span class="hljs-number"> 19 </span>      <span class="hljs-number"> 320 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 25 </span>       <span class="hljs-number"> 192 </span>    11.80%//   <span class="hljs-number"> 20 </span>      <span class="hljs-number"> 352 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 23 </span>        <span class="hljs-number"> 96 </span>     9.88%//   <span class="hljs-number"> 21 </span>      <span class="hljs-number"> 384 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 21 </span>       <span class="hljs-number"> 128 </span>     9.51%//   <span class="hljs-number"> 22 </span>      <span class="hljs-number"> 416 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 19 </span>       <span class="hljs-number"> 288 </span>    10.71%//   <span class="hljs-number"> 23 </span>      <span class="hljs-number"> 448 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 18 </span>       <span class="hljs-number"> 128 </span>     8.37%//   <span class="hljs-number"> 24 </span>      <span class="hljs-number"> 480 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 17 </span>        <span class="hljs-number"> 32 </span>     6.82%//   <span class="hljs-number"> 25 </span>      <span class="hljs-number"> 512 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 16 </span>         <span class="hljs-number"> 0 </span>     6.05%...//   <span class="hljs-number"> 66 </span>    <span class="hljs-number"> 32768 </span>     <span class="hljs-number"> 32768 </span>      <span class="hljs-number"> 1 </span>         <span class="hljs-number"> 0 </span>    12.50%</code></pre><p>5个int是40字节，向上取整是48字节所以cap是6的原因。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang是怎么实现函数返回多个值的</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC%E7%9A%84/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>Go语言是支持多值返回的。怎么实现的呢？让我们先看一看C语言是如果返回多个值的。在C中如果想返回多个值，通常会在调用函数中分配返回值的空间，并将返回值的指针传给被调函数。</p><pre><code class="hljs c"><span class="hljs-type">int</span> ret1, ret2;f(a, b, &amp;ret1, &amp;ret2)</code></pre><p>被调函数被定义为下面形式，在函数中会修改ret1和ret2。对指针参数所指向的内容的修改会被返回到调用函数，用这种方式实现多值返回。</p><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> arg1, <span class="hljs-type">int</span> arg2, <span class="hljs-type">int</span> *ret1, <span class="hljs-type">int</span> *ret2)</span>;</code></pre><p>所以，从表面上看Go的多值返回只不过像是这种实现方式的一个语法糖衣。其实简单的这么理解也没什么影响，但实际上Go不是这么干的，Go和我们常用的C编译器的函数调用协议是不同的。</p><p>假设我们定义一个Go函数如下：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(arg1, arg2 <span class="hljs-type">int</span>)</span></span> (ret1, ret2 <span class="hljs-type">int</span>)</code></pre><p>Go的做法是在传入的参数之上留了两个空位，被调者直接将返回值放在这两空位，函数f调用前其内存布局是这样的：</p><pre><code class="hljs llvm">为<span class="hljs-keyword">ret</span><span class="hljs-number">2</span>保留空位为<span class="hljs-keyword">ret</span><span class="hljs-number">1</span>保留空位参数<span class="hljs-number">3</span>参数<span class="hljs-number">2</span>参数<span class="hljs-number">1</span>  &lt;-SP</code></pre><p>调用之后变为：</p><pre><code class="hljs armasm">为ret2保留空位为ret1保留空位参数<span class="hljs-number">2</span>参数<span class="hljs-number">1</span>  &lt;-<span class="hljs-built_in">FP</span>保存<span class="hljs-built_in">PC</span> &lt;-<span class="hljs-built_in">SP</span>f的栈<span class="hljs-symbol">...</span></code></pre><p><img src="https://tiancaiamao.gitbooks.io/go-internals/content/zh/images/3.2.funcall.jpg?raw=true" alt="img"></p><p>Go的C编译器按是plan9的C编译器实现的，在被调函数中对参数值的修改是会返回到调用函数中的。在函数体中设置ret1和ret2的值，实际上会被编译成这样：</p><pre><code class="hljs x86asm"><span class="hljs-keyword">MOVQ</span>    <span class="hljs-built_in">BX</span>,ret1+<span class="hljs-number">16</span>(FP)...<span class="hljs-keyword">MOVQ</span>    <span class="hljs-built_in">BX</span>,ret2+<span class="hljs-number">24</span>(FP)</code></pre><p>对ret1+16(FP)的赋值其实是修改的调用函数的栈中的内容，这样就会将结果返回给调用函数了。这就是Go和C函数调用协议中很重要的一个区别：为了实现多值返回，Go是使用栈空间来返回值的。而常见的C语言是通过寄存器来返回值的。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON和XML的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/JSON%E5%92%8CXML%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/JSON%E5%92%8CXML%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>(1)XML定义</strong><br>扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML使用DTD(document type definition)文档类型定义来组织数据;格式统一，跨平台和语言，早已成为业界公认的标准。<br>XML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。</p><p><strong>(2)JSON定义</strong><br>JSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言文本格式，同时也具备类似于C语言的习惯(包括C, C++, C#, Java, JavaScript, Perl, Python等)体系的行为。这些特性使JSON成为理想的数据交换语言。<br>JSON基于JavaScript Programming Language , Standard ECMA-262 3rd Edition - December 1999 的一个子集。</p><h4 id="XML的优缺点"><a href="#XML的优缺点" class="headerlink" title="XML的优缺点"></a>XML的优缺点</h4><p>​    <strong>优点：</strong>1、格式统一，符合标准</p><p>​                2、容易和其他系统进行远程交互</p><p>​                3、SAX解析方式XML提供了对大规模数据的逐步解析方案，这种方案很适合于对大量数据的处理。</p><p>​    <strong>缺点：</strong>1、服务端和客户端解析需要花费大量时间和资源，代码效率过低</p><p>​                2、XML文件庞大，格式复杂，不易压缩，传输占带宽</p><p>​                3、不同浏览器解析XML格式不一样，不兼容</p><h4 id="JSON的优缺点"><a href="#JSON的优缺点" class="headerlink" title="JSON的优缺点"></a>JSON的优缺点</h4><p>​    优点：1、文件简单，格式简单，易压缩，占用带宽小，传输速度更快</p><p>​                2、解析简单，简单的对JSON数据进行读取，占很少服务器时间</p><p>​                3、JSON格式能直接为服务器端代码使用，大大简化服务器端和客户端的代码开发量</p><p>​    缺点：1、没有XML推广的那么深入人心，没有XML那么通用性</p><p>​                2、JSON只提供整体解析方案，而这种方法只在解析较少的数据时才能起到良好的效果</p><p>​                </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>json</category>
      
    </categories>
    
    
    <tags>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA的垃圾回收</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/JAVA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/JAVA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p>1、怎么样进行垃圾回收</p><p>它自动地释放不再被程序引用的对象，java会在所有活的进程中判断如果没有进程引用它就把它放入删除缓冲区之后隔段时间删除</p><p>2、哪时候运行GC</p><p>在内存快满时或手动执行</p><p>3、可以程序员手动操控吗？</p><p>不可以，是jvm按照程序来回收内存，该对象符合删除条件，就将其加入回收队列，但不是立即销毁对象，何时销毁并释放内存是无法预知的。。</p><p>4、什么内存GC不回收</p><p>静态变量</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java网易后端一面面试问题</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E7%BD%91%E6%98%93%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E7%BD%91%E6%98%93%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1、有没有了解过spring</p><p>没有了解过</p><p>2、java的继承封装多态概念</p><p>封装:隐藏对象的属性和细节，对外提供公共访问方式，让使用者只能通过程序员规定的方法来访问数据</p><p>继承：子类继承父类的方法，具有父类非private 的方法</p><p>多态：重写和重载是实现多态的两种主要方式</p><p>（1）、重写：子类定义了一个方法，其方法名、返回值类型，参数列表与父类中某个方法一样，就说子类重写父类的同名方法。</p><p>（2）、重载：同一个类中存在多个方法的方法名相同，但是参数列表不同，体现了多态。</p><p>3、gorm框架中怎么把go语句转化成mysql语句</p><p>​    对象关系映射（Object Relational Mapping，简称ORM），在业务逻辑层和数据库之间充当桥梁，能够把struct类映射成表，将sql查询全部封装成编程语言的函数，通过函数的链式组合生成最终的sql代码</p><p>4、协程的调度</p><p>每个协程有独立的栈，而栈既保留了变量的值，也保留了函数的调用关系、参数和返回值，CPU中的栈寄存器SP指向了当前协程的栈，而指令寄存器IP保存着下一条要执行的指令地址。因此，从协程1切换到协程2时，首先要把SP、IP寄存器的值为线程1保存下来，再从内存中找出协程2上一次切换前保存好的寄存器值，写入CPU的寄存器，这样就完成了协程切换。（Swoole4实现原理相似。）</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>接口和抽象类的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ol><li>抽象类只能继承一次，但是可以实现多个接口</li><li>接口和抽象类必须实现其中所有的方法，抽象类中如果有未实现的抽象方法，那么子类也需要定义为抽象类。抽象类中可以有非抽象的方法，继承接口必须实现接口的全部方法</li><li>接口中的变量必须用 public static final 修饰，并且需要给出初始值。所以实现类不能重新定义，也不能改变其值。</li><li>接口中的方法默认是 public abstract，也只能是这个类型。不能是 static，接口中的方法也不允许子类覆写，抽象类中允许有static 的方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆和栈的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h4><ul><li>申请方式不同：栈是由系统自动分配的，堆是程序员自己申请的（实例化一个对象）</li><li>申请大小不同：栈申请获得的空间较小，堆获得的空间较大</li><li>申请效率不同：栈由系统自动分配，速度较快，堆分配速度较慢</li><li>底层不同，栈是连续空间，堆是分散空间</li><li>存储内容不同：栈在函数调用时，在声明一个函数或者声明一个局部变量时会把这个函数放入栈中，函数的各种参数入栈，然后函数结束这个函数就从栈中pop掉，堆一般是头部用一个字节存放堆的大小,存放静态变量，堆中具体内容是人为安排，长时间不用会被gc掉。</li></ul><p>内存泄露：堆内存中内存申请了但是没有释放，每次执行就会申请内存以至于可用内存减少。</p><h4 id="函数调用时候栈是怎么push和pop的"><a href="#函数调用时候栈是怎么push和pop的" class="headerlink" title="函数调用时候栈是怎么push和pop的"></a>函数调用时候栈是怎么push和pop的</h4><p>先讲栈是怎么push的，在A函数调用B的时候，函数的栈会向高地址扩张，会把<strong>函数调用过程</strong>中的各种信息（参数，返回地址，本地变量等）放入栈中，并且会有栈顶指针和栈底指针分别指向B的栈顶和B的栈底，然后在运行完pop的时候会根据返回地址把原来指向B栈底的指针指向返回地址（A的栈底），栈顶B指向新的A的栈顶（就是运行完的函数的B的栈底）。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 27. 二叉树的镜像</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><font size=6px>二叉树的镜像</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code> 4</code></pre><p>   &#x2F;   <br>  2     7<br> &#x2F; \   &#x2F; <br>1   3 6   9<br>镜像输出：</p><pre><code> 4</code></pre><p>   &#x2F;   <br>  7     2<br> &#x2F; \   &#x2F; <br>9   6 3   1</p><p>示例 1：</p><p>输入：root &#x3D; [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>每次交互一个父节点的左右子结点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mirrorTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span>  root    &#125;    root.Left,root.Right = mirrorTree(root.Right),mirrorTree(root.Left)    <span class="hljs-keyword">return</span> root&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了18.27%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣第一题：两数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>观前啰嗦：</strong>这是我第一次做力扣题目，本题用c语言做的，接下来打算用go语言写，来锻炼我go语言能力，无论用哪种语言其实都一样，语言是一种工具，思想才是最重要的。</p><h2>1、两数之和</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p> <strong>示例</strong></p><pre><code class="hljs inform7">给定 nums = <span class="hljs-comment">[2, 7, 11, 15]</span>, target = 9因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> = 2 + 7 = 9所以返回 <span class="hljs-comment">[0, 1]</span></code></pre><p>思想：这题思想不难理解，就是第一次错题有些细节要注意，target表示给的最终指，returnSize是个指针，表示最终的返回数个数。</p><p><strong>代码</strong></p><pre><code class="hljs c"><span class="hljs-comment">/*我用最传统的方法写的*/</span><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span>&#123;    *returnSize =<span class="hljs-number">2</span>;<span class="hljs-comment">//用来说明有几个返回大小</span>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a[<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;numsSize;j++)        &#123;            <span class="hljs-keyword">if</span>((nums[i]+nums[j])==target)            &#123;                a[<span class="hljs-number">0</span>]=i;                a[<span class="hljs-number">1</span>]=j;                <span class="hljs-keyword">return</span> a;            &#125;         &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">  执行用时：12 ms, 在所有 C 提交中击败了30.82%的用户<br>  内存消耗：6 MB, 在所有 C 提交中击败了50.75%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十一;乘最多水的容器</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/11.%E4%B9%98%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/11.%E4%B9%98%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:乘最多水的容器</font></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p>示例 1：</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"></p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>示例 2：</p><p>输入：height &#x3D; [1,1]<br>输出：1<br>示例 3：</p><p>输入：height &#x3D; [4,3,2,1,4]<br>输出：16<br>示例 4：</p><p>输入：height &#x3D; [1,2,1]<br>输出：2</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​            用到对撞指针的思路，指针开始指向开头和末尾，从开始和末尾分别判断， 如果  (height[end]&gt;height[first])，就first++。</p><h4 id="go代码"><a href="#go代码" class="headerlink" title="go代码"></a>go代码</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    max:=<span class="hljs-number">0</span>    end:=<span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span>    first:=<span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> first&lt;end&#123;        width := end-first        <span class="hljs-keyword">if</span>(height[end]&gt;height[first])&#123;            ans=width*height[first]            first++        &#125;<span class="hljs-keyword">else</span>&#123;            ans=width*height[end]            end--        &#125;        <span class="hljs-keyword">if</span>(max&lt;ans)&#123;            max=ans        &#125;    &#125;   <span class="hljs-keyword">return</span> max &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了83.14%的用户<br>   内存消耗：6.3 MB, 在所有 Go 提交中击败了53.07%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十三：罗马数字转整数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目-罗马数字转整数"><a href="#题目-罗马数字转整数" class="headerlink" title="题目:罗马数字转整数"></a><font size=6px>题目:罗马数字转整数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>​    一个难点如果小的数字出现在大的数字前面的时候，这个数字变成减而不是加上这个数字的大小，用switch写比较清楚。其他比较简单易理解。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    sum:=<span class="hljs-number">0</span>    len_s:=<span class="hljs-built_in">len</span>(s)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;len_s;i++&#123;        <span class="hljs-keyword">switch</span> s[i]&#123;           <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>:                 sum++                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;V&#x27;</span>|| s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;X&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-2</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>:                sum+=<span class="hljs-number">5</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;V&#x27;</span>|| s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;X&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-2</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>:                sum+=<span class="hljs-number">10</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-20</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:                sum+=<span class="hljs-number">50</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-100</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:                sum+=<span class="hljs-number">100</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-200</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:                sum+=<span class="hljs-number">500</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-1000</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:                sum+=<span class="hljs-number">1000</span>                <span class="hljs-keyword">break</span>         &#125;    &#125;    <span class="hljs-keyword">return</span> sum&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了47.27%的用户<br>   内存消耗：3.1 MB, 在所有 Go 提交中击败了99.24%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十五;三数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="题目-三数之和"><a href="#题目-三数之和" class="headerlink" title="题目:三数之和"></a><font size=6px>题目:三数之和</font></h4><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>难度中等</p><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c &#x3D;</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><pre><code class="hljs inform7">给定数组 nums = <span class="hljs-comment">[-1, 0, 1, 2, -1, -4]</span>，满足要求的三元组集合为：<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[-1, 0, 1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[-1, -1, 2]</span></span><span class="hljs-comment">]</span></code></pre><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​    先排序，再用for从0到length-2中选一个k值，选定k值之后把k后面的数用对撞指针从k+1到length-1用对撞指针求一个值等于-num[k]，记得判断left右边和right左边的值是否和自己相同</p><p><strong>一直出现这个错误，检查之后发现最后少个大括号</strong></p><p><code>Line 40: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;<span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-comment">//先排序</span>    sort.Ints(nums)    length:=<span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    <span class="hljs-comment">//确认好一个数之后用对撞指针</span>     <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;length<span class="hljs-number">-2</span>;k++&#123;        <span class="hljs-keyword">if</span> nums[k]&gt;<span class="hljs-number">0</span> &#123;            <span class="hljs-keyword">break</span>        &#125;        <span class="hljs-keyword">if</span> k&gt;<span class="hljs-number">0</span>&amp;&amp;nums[k]==nums[k<span class="hljs-number">-1</span>]&#123;            <span class="hljs-keyword">continue</span>        &#125;        left:=k+<span class="hljs-number">1</span>        right:=length<span class="hljs-number">-1</span>        <span class="hljs-keyword">for</span> left&lt;right&#123;            sum := nums[left]+nums[right]+nums[k]            <span class="hljs-comment">//要判断left和它右边的值一不一样，right的值和它左边的一不一样</span>            <span class="hljs-keyword">if</span> sum&gt;<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">for</span> right=right<span class="hljs-number">-1</span>;right&gt;left &amp;&amp;nums[right]==nums[right+<span class="hljs-number">1</span>];right-- &#123;&#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum&lt;<span class="hljs-number">0</span> &#123;                <span class="hljs-keyword">for</span> left=left+<span class="hljs-number">1</span>;right&gt;left &amp;&amp;nums[left]==nums[left<span class="hljs-number">-1</span>];left++ &#123;&#125;            &#125;<span class="hljs-keyword">else</span>&#123;                res = <span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;nums[k],nums[left],nums[right]&#125;)                <span class="hljs-keyword">for</span> right=right<span class="hljs-number">-1</span>;right&gt;left &amp;&amp;nums[right]==nums[right+<span class="hljs-number">1</span>];right-- &#123;&#125;                <span class="hljs-keyword">for</span> left=left+<span class="hljs-number">1</span>;right&gt;left &amp;&amp;nums[left]==nums[left<span class="hljs-number">-1</span>];left++ &#123;&#125;                     &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：40 ms, 在所有 Go 提交中击败了52.12%的用户<br>   内存消耗：7.3 MB, 在所有 Go 提交中击败了42.04%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十六 最接近的三数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">庆祝自己第一次达到百分之95以上<p>执行用时：4 ms, 在所有 Go 提交中击败了95.59%的用户</p><p>内存消耗：2.7 MB, 在所有 Go 提交中击败了98.89%的用户</p></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</p><p><strong>提示：</strong></p><ul><li><p>3 &lt;&#x3D; nums.length &lt;&#x3D; 10^3</p></li><li><p>-10^3 &lt;&#x3D; nums[i] &lt;&#x3D; 10^3</p></li><li><p>*-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</p></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>和第十五题类似，先排序，后用对撞指针对后面的数字进行扫描，只需注意一点<strong>return的是sum的值，min却是target-sum</strong></p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-comment">//先排序</span>    min:=<span class="hljs-number">999999</span>    <span class="hljs-keyword">var</span> value <span class="hljs-type">int</span>    sort.Ints(nums)    length:=<span class="hljs-built_in">len</span>(nums)    <span class="hljs-comment">//确认好一个数之后用对撞指针</span>     <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;length<span class="hljs-number">-2</span>;k++&#123;        left:=k+<span class="hljs-number">1</span>        right:=length<span class="hljs-number">-1</span>        <span class="hljs-keyword">for</span> left&lt;right&#123;            sum := nums[left]+nums[right]+nums[k]            <span class="hljs-keyword">if</span>(sum==target)&#123;                <span class="hljs-keyword">return</span> sum            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)&#123;                <span class="hljs-keyword">if</span>(target-sum&lt;min)&#123;                    min=target-sum                    value=sum  <span class="hljs-comment">//这里要注意，return的是sum的值，min却是target-sum</span>                &#125;                left++            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(sum-target&lt;min)&#123;                    min=sum-target                    value=sum                &#125;                right--            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> value&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><font size=6px>电话号码的字母组合</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png"></p><p>示例 1：</p><p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p><p>输入：digits &#x3D; “”<br>输出：[]<br>示例 3：</p><p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]</p><p>提示：</p><p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="map的初体验和使用"><a href="#map的初体验和使用" class="headerlink" title="map的初体验和使用"></a>map的初体验和使用</h5><p>还不知道golang里面的map是什么怎么用，上网搜了一下map是哈希表差不读的，有键值对，直接mp：&#x3D;map[string]string出来的是一个空的没开辟地址的map，要mp：&#x3D;make（map[string]string）才是开辟好地址的，在下面代码使用的结束时候别忘记加逗号</p><p>一道典型的dfs搜索算法，先把一个个字母放进path里面，等i&gt;&#x3D;len(digits)后就append到结果里面<br>还学会了自定义函数里面再自定义函数的用法。dfs看着很简洁，递归代码还是不好理解</p><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(digits <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(digits)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;    &#125;    mp:=<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;    <span class="hljs-string">&quot;2&quot;</span>:<span class="hljs-string">&quot;abc&quot;</span>,    <span class="hljs-string">&quot;3&quot;</span>:<span class="hljs-string">&quot;def&quot;</span>,    <span class="hljs-string">&quot;4&quot;</span>:<span class="hljs-string">&quot;ghi&quot;</span>,    <span class="hljs-string">&quot;5&quot;</span>:<span class="hljs-string">&quot;jkl&quot;</span>,    <span class="hljs-string">&quot;6&quot;</span>:<span class="hljs-string">&quot;mno&quot;</span>,    <span class="hljs-string">&quot;7&quot;</span>:<span class="hljs-string">&quot;pqrs&quot;</span>,    <span class="hljs-string">&quot;8&quot;</span>:<span class="hljs-string">&quot;tuv&quot;</span>,    <span class="hljs-string">&quot;9&quot;</span>:<span class="hljs-string">&quot;wxyz&quot;</span>,    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">string</span>)</span></span>    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">string</span>    dfs=<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>,path <span class="hljs-type">string</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-built_in">len</span>(digits)&#123;            ans=<span class="hljs-built_in">append</span>(ans,path)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> mp[<span class="hljs-type">string</span>(digits[i])]&#123;            <span class="hljs-comment">//第一次写的时候把path+string(v)写在了dfs上一行，结果会不对，回溯的时候回溯会不对</span>            dfs(i+<span class="hljs-number">1</span>,path+<span class="hljs-type">string</span>(v))        &#125;    &#125;    <span class="hljs-comment">//这里是dfs进入的入口</span>    dfs(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>)    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了93.14%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣二十：有效的括号</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="力扣二十：有效的括号"><a href="#力扣二十：有效的括号" class="headerlink" title="力扣二十：有效的括号"></a><font size=6px>力扣二十：有效的括号</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p>示例 1：</p><p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p><p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p><p>输入：s &#x3D; “(]”<br>输出：false<br>示例 4：</p><p>输入：s &#x3D; “([)]”<br>输出：false<br>示例 5：</p><p>输入：s &#x3D; “{[]}”<br>输出：true</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s 仅由括号 ‘()[]{}’ 组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="知道的golang语言知识"><a href="#知道的golang语言知识" class="headerlink" title="知道的golang语言知识"></a>知道的golang语言知识</h5><p>1、知道了golang里面没有数组里面++，–的情况，得写出来，比如是s[i++]不可以，i++可以</p><p>2、’a’在golang里面代表的是int类型，就是字母转ascii码之后的数字，string类型的s，s[0]就是int类型的数字，是rune类型。</p><p>讲一下思路把，简单的数组栈，碰到左边的括号就++，碰到右边的括号就判断–后的数组里面的字母是不是他的左括号，代码里面有三种特殊情况要考虑一些</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> str [<span class="hljs-number">5000</span>]<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> k <span class="hljs-type">int</span>    s_len:=<span class="hljs-built_in">len</span>(s)    <span class="hljs-comment">//情况1：如果括号个数不等于2的倍数或者为0 就说明是false</span>    <span class="hljs-keyword">if</span> s_len%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>||s_len==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;s_len;i++&#123;        <span class="hljs-keyword">if</span> s[i]==<span class="hljs-string">&#x27;(&#x27;</span>||s[i]==<span class="hljs-string">&#x27;[&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>&#123;            str[k]=<span class="hljs-type">string</span>(s[i])            k++        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//情况2：如果第一个就是‘）’，‘]’，‘&#125;’就说明的false</span>            <span class="hljs-keyword">if</span> k==<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;            <span class="hljs-keyword">switch</span> s[i]&#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:                    k--                    <span class="hljs-keyword">if</span> str[k]!=<span class="hljs-string">&quot;(&quot;</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>:                    k--                    <span class="hljs-keyword">if</span> str[k]!=<span class="hljs-string">&quot;[&quot;</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>:                    k--                    <span class="hljs-keyword">if</span> str[k]!=<span class="hljs-string">&quot;&#123;&quot;</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                    <span class="hljs-keyword">break</span>            &#125;        &#125;    &#125;    <span class="hljs-comment">//情况3：如果没有做到一一对应k会大于0 就false</span>    <span class="hljs-keyword">if</span> k&gt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了23.58%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣三：无重复字字符的最长字串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:无重复字字符的最长字串</font></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p><p>输入: s &#x3D; “”<br>输出: 0</p><p>提示：</p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>s 由英文字母、数字、符号和空格组成</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>用滑动窗口法，设置一个数组，初始为0，再初设一个left和right，如果一个字母没有用过就把它</p><p>**&#96;&#96;&#96;**<em>freq[s[right+1]-‘a’]++</em></p><p>，并且往右边划，如果在往右边划的时候遇到一个用到过的字母，就left++，把left上面的字母的频率减1，</p><p>`&#96;&#96;freq[s[left]-‘a’]–</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs golang"><span class="hljs-comment">//用滑动窗口法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;  left,right,max:=<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>  <span class="hljs-keyword">var</span> freq[<span class="hljs-number">256</span>] <span class="hljs-type">int</span>  <span class="hljs-keyword">for</span> left&lt;<span class="hljs-built_in">len</span>(s)&#123;​    <span class="hljs-comment">//go语言很严格，单个字符不能用“a”</span>​    <span class="hljs-keyword">if</span> right+<span class="hljs-number">1</span>&lt;<span class="hljs-built_in">len</span>(s)&amp;&amp;freq[s[right+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-number">0</span>&#123;​      freq[s[right+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]++​      right++​    &#125;<span class="hljs-keyword">else</span>&#123;​      freq[s[left]-<span class="hljs-string">&#x27;a&#x27;</span>]--​      left++​    &#125;​    <span class="hljs-keyword">if</span> max&lt;right-left+<span class="hljs-number">1</span>&#123;​      max=right-left+<span class="hljs-number">1</span>​    &#125;  &#125;  <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.5 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-四十一：缺失一个正数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/41.%E7%BC%BA%E5%A4%B1%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/41.%E7%BC%BA%E5%A4%B1%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p> <font size=6px>题目:缺失一个正数</font></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>​    给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><p>输入: [1,2,0]<br>输出: 3</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><p>输入: [3,4,-1,1]<br>输出: 2</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4><p>输入: [7,8,9,11,12]<br>输出: 1</p><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>用map做，先把数放进map里面<code>map_num[v]=v</code>，再用哈希的思想，判断这个下标和值相不相同。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    map_num:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))    <span class="hljs-keyword">for</span> _,v :=<span class="hljs-keyword">range</span> nums&#123;        map_num[v]=v    &#125;    <span class="hljs-comment">//用map来判断这个值在不在确实很方便</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> _,ok:=map_num[i];!ok&#123;            <span class="hljs-keyword">return</span> i        &#125;    &#125;    <span class="hljs-comment">//如果数字全部有序，就输出个数加一</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了9.44%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣四十八：旋转图像</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/48.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/48.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:旋转图像</font></p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><p><strong>示例 1:</strong></p><pre><code class="hljs inform7">给定 matrix = <span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[4,5,6]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[7,8,9]</span></span><span class="hljs-comment">]</span>,原地旋转输入矩阵，使其变为:<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[7,4,1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[8,5,2]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[9,6,3]</span></span><span class="hljs-comment">]</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs inform7">给定 matrix =<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[ 5, 1, 9,11]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[ 2, 4, 8,10]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[13, 3, 6, 7]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[15,14,12,16]</span></span><span class="hljs-comment">]</span>, 原地旋转输入矩阵，使其变为:<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[15,13, 2, 5]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[14, 3, 4, 1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[12, 6, 8, 9]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[16, 7,10,11]</span></span><span class="hljs-comment">]</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这题想清楚了不难，找找规律，就是<strong>矩阵转置</strong>再<strong>镜像翻转</strong>一下就得到结果</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;    swap:=<span class="hljs-number">0</span>    a:=<span class="hljs-built_in">len</span>(matrix)     b:=<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])    <span class="hljs-comment">//下面是矩阵转置部分</span>    <span class="hljs-keyword">for</span> k:=a<span class="hljs-number">-1</span>;k&gt;<span class="hljs-number">0</span>;k--&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;            swap=matrix[a-k<span class="hljs-number">-1</span>][a-i<span class="hljs-number">-1</span>]            matrix[a-k<span class="hljs-number">-1</span>][a-i<span class="hljs-number">-1</span>]=matrix[a-i<span class="hljs-number">-1</span>][a-k<span class="hljs-number">-1</span>]            matrix[a-i<span class="hljs-number">-1</span>][a-k<span class="hljs-number">-1</span>]=swap        &#125;    &#125;    <span class="hljs-comment">//下面是矩阵镜像翻转部分</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;a;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=b/<span class="hljs-number">2</span>;j++&#123;            swap = matrix[i][j<span class="hljs-number">-1</span>]            matrix[i][j<span class="hljs-number">-1</span>] = matrix[i][b-j]            matrix[i][b-j] =swap        &#125;    &#125;&#125;</code></pre><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣四十二：接雨水</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:接雨水</font></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="示例1图片"></p><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：height &#x3D; [4,2,0,3,2,5]<br>输出：9</p><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><li>n == height.length</li><li>0 <= n <= 3 * 104</li><li>0 <= height[i] <= 105</li><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p class="note note-primary">    单词注释：     height[left] left位置上的格子的数量    maxl 左边格子最大的格子</p><p>  这题比较难，用双指针方法代码比较简洁，用示例1举例子，先找height[left]与height[right]中小的数字，然后执行小数字方代码，如果height[left]比maxl还要大,就把maxl&#x3D;height[left]，如果不是，那就说明这一格肯定可以装水（可以看代码的第一个注释的解释），把所有可以装水的格子的装水量加起来就是答案。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    left,right,maxl,maxr,res := <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> left&lt;=right&#123;         <span class="hljs-keyword">if</span> height[left]&lt;height[right]&#123;             <span class="hljs-keyword">if</span> maxl&lt;=height[left]&#123;                maxl=height[left]             &#125;<span class="hljs-keyword">else</span>&#123;                 <span class="hljs-comment">//左边肯定有比height[left]高的墙，右边有maxr＞maxl，右边肯定有比height[left]高的墙，水在这一格的高度就是maxl-height[left]，下面同理</span>                res = res+maxl-height[left]             &#125;             left++         &#125;<span class="hljs-keyword">else</span>&#123;             <span class="hljs-keyword">if</span> maxr&lt;height[right]&#123;                 maxr=height[right]             &#125;<span class="hljs-keyword">else</span>&#123;                 <span class="hljs-comment">//右边肯定有比height[right]高的墙</span>                res = res+maxr-height[right];             &#125;             right--         &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了74.89%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了81.87%的用户</p><pre><code class="hljs go"><span class="hljs-comment">// 单调栈解法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i,h := <span class="hljs-keyword">range</span> height&#123;        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span> &amp;&amp; height[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &lt; h&#123;            top := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">continue</span>             &#125;            left := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            width := i-left<span class="hljs-number">-1</span>            height := min(h, height[left]) - height[top]            res += width*height        &#125;        stack = <span class="hljs-built_in">append</span>(stack, i)    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>; <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size:22px&quot;</span>&gt;</span>   执行用时：8 ms, 在所有 Go 提交中击败了67.12%的用户<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>   内存消耗：4.9 MB, 在所有 Go 提交中击败了31.09%的用户<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣九十三：复原IP地址</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/93.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/93.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a><font size=6px>复原IP地址</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#50;&#46;&#49;&#54;&#56;&#64;&#x31;&#46;&#x31;">&#x31;&#x39;&#50;&#46;&#49;&#54;&#56;&#64;&#x31;&#46;&#x31;</a>“ 是 无效的 IP 地址。</p><p>示例 1：</p><p>输入：s &#x3D; “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]<br>示例 2：</p><p>输入：s &#x3D; “0000”<br>输出：[“0.0.0.0”]<br>示例 3：</p><p>输入：s &#x3D; “1111”<br>输出：[“1.1.1.1”]<br>示例 4：</p><p>输入：s &#x3D; “010010”<br>输出：[“0.10.0.10”,”0.100.1.0”]<br>示例 5：</p><p>输入：s &#x3D; “101023”<br>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p><p>提示：</p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 3000<br>s 仅由数字组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="学到的东西"><a href="#学到的东西" class="headerlink" title="学到的东西"></a>学到的东西</h5><p>1、搞清楚了切片和数组的区别，切片要导入的话得用append，没有大小限制</p><p>2、s[i]-‘0’出来的结果是byte类型的</p><p>3、要重置一个字符串型的变量，var一个新的string变量，然后要它等于新的string变量</p><p>4、要返回一个空的字符串切片，return []string{}</p><p>5、要用len求数字的长度，要用strconv.Itoa把数字转化成字符串才能求</p><p>思路：</p><p>第一步先求长度符不符合标准，第二步求有无非法字符，第三步开始正式处理，这道题好像是一串数字，在里面加上3个点，然后判断被三个点隔开的4个数字符不符合标准，把4个数字取出来，然后分别判断是否小于255，然后判断这4个数字的长度和s的长度一不一样，如果不一样说明数字前面有0，就不符合条件</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-keyword">var</span> s_len <span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> s1 ,s3 <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> s2 []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> n1,n2,n3,n4,sum_len <span class="hljs-type">int</span>    s_len=<span class="hljs-built_in">len</span>(s)    <span class="hljs-comment">//如果长度不达标</span>    <span class="hljs-keyword">if</span> s_len&lt;<span class="hljs-number">4</span> || s_len&gt;<span class="hljs-number">12</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;    &#125;    <span class="hljs-comment">//如果出现非法字符</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;s_len;i++&#123;        <span class="hljs-keyword">if</span> s[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span> || s[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>&#123;            <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;s_len<span class="hljs-number">-3</span>&amp;&amp;i&lt;=<span class="hljs-number">2</span>;i++&#123;        <span class="hljs-keyword">for</span> j:=i+<span class="hljs-number">1</span>;j&lt;s_len<span class="hljs-number">-2</span>&amp;&amp;j-i&lt;=<span class="hljs-number">3</span>;j++&#123;            <span class="hljs-keyword">for</span> k:=j+<span class="hljs-number">1</span>;k&lt;s_len<span class="hljs-number">-1</span>&amp;&amp;k-j&lt;=<span class="hljs-number">3</span>;k++&#123;                n1,n2,n3,n4,sum_len=stio(s,i,j,k)                <span class="hljs-keyword">if</span> n1&lt;=<span class="hljs-number">255</span>&amp;&amp;n2&lt;=<span class="hljs-number">255</span>&amp;&amp;n3&lt;=<span class="hljs-number">255</span>&amp;&amp;n4&lt;=<span class="hljs-number">255</span>&amp;&amp;sum_len==s_len&#123;                    <span class="hljs-keyword">for</span> m:=<span class="hljs-number">0</span>;m&lt;s_len;m++&#123;                        s1=s1+<span class="hljs-type">string</span>(s[m])                        <span class="hljs-keyword">if</span> m==i||m==j||m==k&#123;                            s1=s1+<span class="hljs-string">&quot;.&quot;</span>                        &#125;                    &#125;                    s2=<span class="hljs-built_in">append</span>(s2,s1)                    <span class="hljs-comment">//重置s1</span>                    s1=s3                &#125;                n1,n2,n3=<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> s2&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stio</span><span class="hljs-params">(s <span class="hljs-type">string</span>,a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span> ,c <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">var</span> n1,n2,n3,n4 <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> sum_len <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=a;i++&#123;        n1=n1*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=a+<span class="hljs-number">1</span>;i&lt;=b;i++&#123;        n2=n2*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=b+<span class="hljs-number">1</span>;i&lt;=c;i++&#123;        n3=n3*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=c+<span class="hljs-number">1</span>;i&lt;s_len;i++&#123;        n4=n4*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;        sum_len=<span class="hljs-built_in">len</span>(strconv.Itoa(n1))+<span class="hljs-built_in">len</span>(strconv.Itoa(n2))+<span class="hljs-built_in">len</span>(strconv.Itoa(n3))+<span class="hljs-built_in">len</span>(strconv.Itoa(n4))    <span class="hljs-keyword">return</span> n1,n2,n3,n4,sum_len&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了56.25%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 116. 省份数量</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20116.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20116.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a><font size=6px>省份数量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p>示例 1：</p><p>输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]<br>输出：2<br>示例 2：</p><p>输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]<br>输出：3</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 200<br>n &#x3D;&#x3D; isConnected.length<br>n &#x3D;&#x3D; isConnected[i].length<br>isConnected[i][j] 为 1 或 0<br>isConnected[i][i] &#x3D;&#x3D; 1<br>isConnected[i][j] &#x3D;&#x3D; isConnected[j][i]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用并查集思路，两个城市连起来就把city【i】 &#x3D;j，判断city【i】是否等于i就知道有几个省了，并查集合并有点困难</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(isConnected [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> city [<span class="hljs-number">201</span>]<span class="hljs-type">int</span><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">201</span>; i++ &#123;city[i] = i&#125;<span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> city[x] != x &#123;city[x] = find(city[x])&#125;<span class="hljs-keyword">return</span> city[x]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span> &#123;city[find(i)] = find(j)&#125;&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<span class="hljs-keyword">if</span> city[i] == i &#123;res++&#125;&#125;<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了91.90%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了95.76%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>547. 省份数量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a><font size=6px>省份数量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p>示例 1：</p><p>输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]<br>输出：2<br>示例 2：</p><p>输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]<br>输出：3</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 200<br>n &#x3D;&#x3D; isConnected.length<br>n &#x3D;&#x3D; isConnected[i].length<br>isConnected[i][j] 为 1 或 0<br>isConnected[i][i] &#x3D;&#x3D; 1<br>isConnected[i][j] &#x3D;&#x3D; isConnected[j][i]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用并查集思路，两个城市连起来就把city【i】 &#x3D;j，判断city【i】是否等于i就知道有几个省了，并查集合并有点困难</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(isConnected [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> city [<span class="hljs-number">201</span>]<span class="hljs-type">int</span><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">201</span>; i++ &#123;city[i] = i&#125;<span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> city[x] != x &#123;city[x] = find(city[x])&#125;<span class="hljs-keyword">return</span> city[x]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span> &#123;city[find(i)] = find(j)&#125;&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<span class="hljs-keyword">if</span> city[i] == i &#123;res++&#125;&#125;<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了91.90%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了95.76%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>567. 字符串的排列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><font size=6px>字符串的排列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的 子串 。</p><p>示例 1：</p><p>输入: s1 &#x3D; “ab” s2 &#x3D; “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).<br>示例 2：</p><p>输入: s1&#x3D; “ab” s2 &#x3D; “eidboaoo”<br>输出: False</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>判断相不相等就是判断26个字母的个数相不相等，用滑动窗口法，第一次传入len（s1）开始判断，移动一次第一个字母的数量减去，加上最后一个字母的数量</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(s1 <span class="hljs-type">string</span>, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1) &gt; <span class="hljs-built_in">len</span>(s2) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;     mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,<span class="hljs-number">26</span>)    mp2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,<span class="hljs-number">26</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1);i++&#123;        mp[s1[i]]++        mp2[s2[i]]++    &#125;    <span class="hljs-keyword">if</span> check(mp,mp2)==<span class="hljs-literal">true</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(s1);i&lt;<span class="hljs-built_in">len</span>(s2);i++&#123;        mp2[s2[i-<span class="hljs-built_in">len</span>(s1)]]--        mp2[s2[i]]++        <span class="hljs-keyword">if</span> check(mp,mp2)==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(mp1 <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,mp2 <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> i <span class="hljs-type">byte</span>    <span class="hljs-keyword">for</span> i=<span class="hljs-string">&#x27;a&#x27;</span>;i&lt;<span class="hljs-string">&#x27;z&#x27;</span>;i++&#123;        <span class="hljs-keyword">if</span> mp1[i]!=mp2[i]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了43.98%的用户<br>   内存消耗：2.6 MB, 在所有 Go 提交中击败了23.90%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>sting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>56. 合并区间</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><font size=6px>合并区间</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p><p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p><p>提示：</p><p>1 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>intervals[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; starti &lt;&#x3D; endi &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>思路很简单，按第一个数字升序排序，然后判断pre的第二个数字是否大于等于cur的第一个数字，如果大就合并</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">//第二版代码</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> b&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]&#125;)pre :=intervals[<span class="hljs-number">0</span>]<span class="hljs-keyword">var</span> arr [][]<span class="hljs-type">int</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> ;i&lt;<span class="hljs-built_in">len</span>(intervals);i++&#123;    cur :=intervals[i]    <span class="hljs-keyword">if</span> pre[<span class="hljs-number">1</span>] &gt;= cur[<span class="hljs-number">0</span>]&#123;        pre [<span class="hljs-number">1</span>] = max(pre[<span class="hljs-number">1</span>],cur[<span class="hljs-number">1</span>])        &#125;<span class="hljs-keyword">else</span>&#123;            arr = <span class="hljs-built_in">append</span>(arr,pre)            pre = cur        &#125;    &#125;    arr = <span class="hljs-built_in">append</span>(arr,pre)    <span class="hljs-keyword">return</span>  arr&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了99.84%的用户<br>   内存消耗：4.5 MB, 在所有 Go 提交中击败了90.14%的用户</p><pre><code class="hljs angelscript"><span class="hljs-comment">//第一版代码，时间很慢，因为是合并数组中把原数组这个数去除的做法太费时间</span>func max (a,b <span class="hljs-built_in">int</span>)<span class="hljs-built_in">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;func merge(<span class="hljs-built_in">int</span>ervals [][]<span class="hljs-built_in">int</span>) [][]<span class="hljs-built_in">int</span> &#123;    <span class="hljs-comment">//sortclass := new(Sort)</span><span class="hljs-comment">//sortclass.arr = intervals</span>    <span class="hljs-comment">//</span><span class="hljs-comment">//sort.Sort(sortclass)</span>    sort.Slice(<span class="hljs-built_in">int</span>ervals, func(i, j <span class="hljs-built_in">int</span>) <span class="hljs-built_in">bool</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &lt;<span class="hljs-built_in">int</span>ervals[j][<span class="hljs-number">0</span>]    &#125;)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; len(<span class="hljs-built_in">int</span>ervals)<span class="hljs-number">-1</span>; i++ &#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>] &gt;= <span class="hljs-built_in">int</span>ervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &#123;            <span class="hljs-built_in">int</span>ervals = mergearray(<span class="hljs-built_in">int</span>ervals, i)            i--        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals&#125;func mergearray(<span class="hljs-built_in">int</span>ervals [][]<span class="hljs-built_in">int</span>, start <span class="hljs-built_in">int</span>) [][]<span class="hljs-built_in">int</span> &#123;    first := <span class="hljs-built_in">int</span>ervals[start][<span class="hljs-number">0</span>]    last := max(<span class="hljs-built_in">int</span>ervals[start][<span class="hljs-number">1</span>],<span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])    <span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = first    <span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = last    <span class="hljs-built_in">int</span>ervals = append(<span class="hljs-built_in">int</span>ervals[:start], <span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>:]...)    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals&#125;</code></pre><p class="note note-primary"; style="font-size:22px">   执行用时：28 ms, 在所有 Go 提交中击败了10.27%的用户<br>   内存消耗：4.4 MB, 在所有 Go 提交中击败了99.10%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>60. 排列序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/60.%20%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/60.%20%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="排列序列"><a href="#排列序列" class="headerlink" title="排列序列"></a><font size=6px>排列序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n &#x3D; 3 时, 所有排列如下：</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p><p>示例 1：</p><p>输入：n &#x3D; 3, k &#x3D; 3<br>输出：”213”<br>示例 2：</p><p>输入：n &#x3D; 4, k &#x3D; 9<br>输出：”2314”<br>示例 3：</p><p>输入：n &#x3D; 3, k &#x3D; 1<br>输出：”123”</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 9<br>1 &lt;&#x3D; k &lt;&#x3D; n!</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>难得双百分比，思路是参考题解大神的，是一道类似于数学题，就例子中 3 3举例，第一个数字是怎么判断的呢，是 3 除以 2（1*2）等于1，知道第一个数为2，就是k &#x2F;（n-1）的阶乘就知道第一个数是哪个数，以此类推求出之后的数，记得求出一个数就把这个数从数组中取出</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getPermutation</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;num ,total := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>,<span class="hljs-number">0</span>,n),<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        num = <span class="hljs-built_in">append</span>(num,<span class="hljs-type">byte</span>(i)+<span class="hljs-string">&#x27;0&#x27;</span>)        total *= i    &#125;    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>,<span class="hljs-number">0</span>,n)    <span class="hljs-keyword">for</span> i:=n;i&gt;<span class="hljs-number">0</span>;i--&#123;        t :=total / i           idx := k / t <span class="hljs-number">-1</span>          <span class="hljs-keyword">if</span> k % t !=<span class="hljs-number">0</span>&#123;            idx+=<span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">if</span> idx&lt;<span class="hljs-number">0</span>&#123;            idx = <span class="hljs-number">0</span>        &#125;        res = <span class="hljs-built_in">append</span>(res,num[idx])        total , k = t , k-t*idx        num = <span class="hljs-built_in">append</span>(num[:idx],num[idx+<span class="hljs-number">1</span>:]...)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(res)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>64. 最小路径和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><font size=6px>最小路径和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例 1：</p><p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p><p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以用dfs和动态规划做，我是动态规划</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;       &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> grid == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    m,n := <span class="hljs-built_in">len</span>(grid),<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m;i++ &#123;        grid[i][<span class="hljs-number">0</span>] += grid[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++ &#123;        grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]    &#125;    <span class="hljs-keyword">for</span>  i:=<span class="hljs-number">1</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;n;j++ &#123;            grid[i][j] = min(grid[i][j<span class="hljs-number">-1</span>],grid[i<span class="hljs-number">-1</span>][j]) + grid[i][j]            &#125;    &#125;    <span class="hljs-keyword">return</span> grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了97.88%的用户<br>   内存消耗：3.7 MB, 在所有 Go 提交中击败了92.14%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>674. 最长连续递增序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a><font size=6px>最长连续递增序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;&#x3D; i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。<br>示例 2：</p><p>输入：nums &#x3D; [2,2,2,2,2]<br>输出：1<br>解释：最长连续递增序列是 [2], 长度为1。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    count :=<span class="hljs-number">1</span>    max :=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> nums[i<span class="hljs-number">-1</span>]&lt;nums[i]&#123;            count ++        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> count&gt;max&#123;                max = count            &#125;            count =<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> count&gt;max&#123;            max = count        &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了81.10%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>69. x 的平方根</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: 4<br>输出: 2<br>示例 2:</p><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一般会说不能用sqrt，就用二分法查找最合适的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;     l:=<span class="hljs-number">0</span>     r:=x     <span class="hljs-keyword">for</span> l&lt;=r&#123;        mid := (l+r)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> mid*mid&gt;x&#123;            r=mid<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            l=mid+<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> r&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了99.92%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><font size=6px>爬楼梯</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>斐波那契数列</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> f []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>    &#125;    f = <span class="hljs-built_in">append</span>(f,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>; i&lt;=n;i++&#123;        f = <span class="hljs-built_in">append</span>(f,f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>])    &#125;    <span class="hljs-keyword">return</span> f[n<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了43.50%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>695. 岛屿的最大面积</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a><font size=6px>岛屿的最大面积</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><p>示例 1:</p><p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p><p>示例 2:</p><p>[[0,0,0,0,0,0,0,0]]<br>对于上面这个给定的矩阵, 返回 0。</p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典dfs题目，加一个flag【i】【j】，如果访问了就把它置1，这样就不会有回去原来的位置</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>number := <span class="hljs-number">1</span><span class="hljs-keyword">var</span> flag [<span class="hljs-number">51</span>][<span class="hljs-number">51</span>]<span class="hljs-type">int</span>move := [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(grid); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]); j++ &#123;<span class="hljs-keyword">if</span> grid[i][j] != <span class="hljs-number">0</span> &amp;&amp; flag[i][j] == <span class="hljs-number">0</span> &#123;queue := []<span class="hljs-type">int</span>&#123;i, j&#125;flag[i][j] = <span class="hljs-number">1</span><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;tmppoint1 := queue[<span class="hljs-number">0</span>]tmppoint2 := queue[<span class="hljs-number">1</span>]<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> move &#123;<span class="hljs-keyword">if</span> tmppoint1+v[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; tmppoint1+v[<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">len</span>(grid) &amp;&amp; tmppoint2+v[<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; tmppoint2+v[<span class="hljs-number">1</span>] &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) &amp;&amp; grid[tmppoint1+v[<span class="hljs-number">0</span>]][tmppoint2+v[<span class="hljs-number">1</span>]] == <span class="hljs-number">1</span> &amp;&amp; flag[tmppoint1+v[<span class="hljs-number">0</span>]][tmppoint2+v[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span> &#123;queue = <span class="hljs-built_in">append</span>(queue, tmppoint1+v[<span class="hljs-number">0</span>], tmppoint2+v[<span class="hljs-number">1</span>])flag[tmppoint1+v[<span class="hljs-number">0</span>]][tmppoint2+v[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>number++&#125;&#125;queue = <span class="hljs-built_in">append</span>(queue[<span class="hljs-number">2</span>:])&#125;<span class="hljs-keyword">if</span> number &gt; max &#123;max = number&#125;number = <span class="hljs-number">1</span>&#125;&#125;&#125;<span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>71. 简化路径</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/71.%20%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/71.%20%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a><font size=6px>简化路径</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘&#x2F;‘ 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’&#x2F;&#x2F;‘）都被视为单个斜杠 ‘&#x2F;‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件&#x2F;目录名称。</p><p>请注意，返回的 规范路径 必须遵循下述格式：</p><p>始终以斜杠 ‘&#x2F;‘ 开头。<br>两个目录名之间必须只有一个斜杠 ‘&#x2F;‘ 。<br>最后一个目录名（如果存在）不能 以 ‘&#x2F;‘ 结尾。<br>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。<br>返回简化后得到的 规范路径 。</p><p>示例 1：</p><p>输入：path &#x3D; “&#x2F;home&#x2F;“<br>输出：”&#x2F;home”<br>解释：注意，最后一个目录名后面没有斜杠。<br>示例 2：</p><p>输入：path &#x3D; “&#x2F;..&#x2F;“<br>输出：”&#x2F;“<br>解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。<br>示例 3：</p><p>输入：path &#x3D; “&#x2F;home&#x2F;&#x2F;foo&#x2F;“<br>输出：”&#x2F;home&#x2F;foo”<br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br>示例 4：</p><p>输入：path &#x3D; “&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;“<br>输出：”&#x2F;c”</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>代码参考题解，写的特别巧妙和简洁，先用split函数分成一个切片，用switch-case(判断。。和。)最后再组合</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">simplifyPath</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> path==<span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> path    &#125;    <span class="hljs-keyword">var</span> str []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> strs <span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> _,v :=<span class="hljs-keyword">range</span> strings.Split(path,<span class="hljs-string">&quot;/&quot;</span>)&#123;        <span class="hljs-keyword">switch</span> v &#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&quot;</span>:  <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.&quot;</span>: <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;..&quot;</span>: <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(str)&gt;<span class="hljs-number">0</span>&#123;            str = str[:<span class="hljs-built_in">len</span>(str)<span class="hljs-number">-1</span>]        &#125;        <span class="hljs-keyword">default</span>:str = <span class="hljs-built_in">append</span>(str,v)        &#125;    &#125;    strs = <span class="hljs-string">&quot;/&quot;</span>+strings.Join(str,<span class="hljs-string">&quot;/&quot;</span>)    <span class="hljs-keyword">return</span>  strs&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.1 MB, 在所有 Go 提交中击败了73.61%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>81. 搜索旋转排序数组 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a><font size=6px>搜索旋转排序数组 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0<br>输出：true<br>示例 2：</p><p>输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3<br>输出：false</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p><p>进阶：</p><p>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跟旋转排序数组差不多，就是把重复的前几个数去掉保证第一个和最后一个事不相同</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>&amp;&amp;nums[i]==nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>];&#123;        nums = <span class="hljs-built_in">append</span>(nums[<span class="hljs-number">1</span>:])    &#125;    <span class="hljs-keyword">if</span> search1(nums,target)==<span class="hljs-number">-1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search1</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) ==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] ==target&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;    &#125;        i,j:=<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i&lt;=j&#123;        mid := (i+j)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> nums[mid] == target&#123;            <span class="hljs-keyword">return</span> mid        &#125;        <span class="hljs-keyword">if</span> nums[mid] &gt;=nums[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">if</span> target &lt;nums[mid]&amp;&amp;target&gt;=nums[<span class="hljs-number">0</span>]&#123;                j = mid<span class="hljs-number">-1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                i = mid+<span class="hljs-number">1</span>            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> nums[mid]&lt;target&amp;&amp;target&lt;=nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#123;                i = mid+<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                j = mid<span class="hljs-number">-1</span>            &#125;        &#125;            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了92.09%的用户<br>   内存消耗：3.2 MB, 在所有 Go 提交中击败了99.94%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>85. 最大矩形</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a><font size=6px>最大矩形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p>示例 1：</p><p>输入：matrix &#x3D; [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：6<br>解释：最大矩形如上图所示。<br>示例 2：</p><p>输入：matrix &#x3D; []<br>输出：0<br>示例 3：</p><p>输入：matrix &#x3D; [[“0”]]<br>输出：0<br>示例 4：</p><p>输入：matrix &#x3D; [[“1”]]<br>输出：1<br>示例 5：</p><p>输入：matrix &#x3D; [[“0”,”0”]]<br>输出：0</p><p>提示：</p><p>rows &#x3D;&#x3D; matrix.length<br>cols &#x3D;&#x3D; matrix[0].length<br>0 &lt;&#x3D; row, cols &lt;&#x3D; 200<br>matrix[i][j] 为 ‘0’ 或 ‘1’</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用哨兵和单调栈思路，和84题思路相同，区别是这得一行一行遍历，算出这一行的最大矩阵，最后得出最大矩阵</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> levelheight []<span class="hljs-type">int</span><span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>num := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(matrix);i++&#123;<span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]);j++&#123;<span class="hljs-keyword">for</span> k:=i;k&gt;=<span class="hljs-number">0</span>;k--&#123;                <span class="hljs-keyword">if</span> matrix[k][j]==<span class="hljs-string">&#x27;1&#x27;</span>&#123;                    num++                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">break</span>                &#125;            &#125;levelheight = <span class="hljs-built_in">append</span>(levelheight,num)            num = <span class="hljs-number">0</span>&#125;        <span class="hljs-comment">//fmt.Println(levelheight)</span>linemax :=largestRectangleArea(levelheight)levelheight = levelheight[:<span class="hljs-number">0</span>]<span class="hljs-keyword">if</span> max &lt; linemax&#123;max = linemax&#125;&#125;<span class="hljs-keyword">return</span> max&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heights) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;stack := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(heights))heights = <span class="hljs-built_in">append</span>(heights, <span class="hljs-number">-1</span>)heights = <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;, heights...)<span class="hljs-keyword">var</span> maxsize <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(heights); i++ &#123;<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span>&amp;&amp;heights[Peek(stack)] &gt; heights[i] &#123;s, v := Pop(stack)stack = s<span class="hljs-keyword">if</span> sum := (i - Peek(stack) - <span class="hljs-number">1</span>) * heights[v]; sum &gt; maxsize &#123;maxsize = sum&#125;&#125;stack = <span class="hljs-built_in">append</span>(stack, i)&#125;<span class="hljs-keyword">return</span> maxsize&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> ([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;s := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> stack, s&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Peek</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了86.94%的用户<br>   内存消耗：4.9 MB, 在所有 Go 提交中击败了35.08%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>84. 柱状图中最大的矩形</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a><font size=6px>柱状图中最大的矩形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><h4 id="思路-‘"><a href="#思路-‘" class="headerlink" title="思路:‘"></a>思路:‘</h4><p>第一种解法，暴力，这道问题的暴力解法比「接雨水」那道题要其实好想得多：可以枚举以每个柱形为高度的最大矩形的面积。</p><p>具体来说就是：依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。（golang会超时）</p><p>第二种解法是哨兵加上单调栈，就是如果出现前一个和后一个都比这个数小，就说明这个数的最大面积已经算出来的，可以出局了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">//第一种解法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heights)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> sum,max,i,j <span class="hljs-type">int</span>     <span class="hljs-keyword">for</span> k,v :=<span class="hljs-keyword">range</span> heights&#123;        <span class="hljs-keyword">for</span> i = k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;<span class="hljs-built_in">len</span>(heights);i--&#123;            <span class="hljs-keyword">if</span> heights[i]&lt;heights[k]&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">for</span> j = k+<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;<span class="hljs-built_in">len</span>(heights);j++&#123;            <span class="hljs-keyword">if</span> heights[j]&lt;heights[k]&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        sum = (j-i<span class="hljs-number">-1</span>) *v        fmt.Println(sum)        <span class="hljs-keyword">if</span> sum&gt;max&#123;            max = sum        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><pre><code class="hljs go"><span class="hljs-comment">//解法二</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heights) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;stack := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(heights))heights = <span class="hljs-built_in">append</span>(heights, <span class="hljs-number">-1</span>)heights = <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;, heights...)<span class="hljs-keyword">var</span> maxsize <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(heights); i++ &#123;<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span>&amp;&amp;heights[Peek(stack)] &gt; heights[i] &#123;stack, v := Pop(stack)<span class="hljs-keyword">if</span> sum := (i - Peek(stack) - <span class="hljs-number">1</span>) * heights[v]; sum &gt; maxsize &#123;maxsize = sum&#125;&#125;stack = <span class="hljs-built_in">append</span>(stack, i)&#125;<span class="hljs-keyword">return</span> maxsize&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> ([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;s := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> stack, s&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Peek</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：108 ms, 在所有 Go 提交中击败了49.43%的用户<br>   内存消耗：9.1 MB, 在所有 Go 提交中击败了30.36%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23. 合并K个升序链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a><font size=6px>合并K个升序链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例 1：</p><p>输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>示例 2：</p><p>输入：lists &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：lists &#x3D; [[]]<br>输出：[]</p><p>提示：</p><p>k &#x3D;&#x3D; lists.length<br>0 &lt;&#x3D; k &lt;&#x3D; 10^4<br>0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500<br>-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4<br>lists[i] 按 升序 排列<br>lists[i].length 的总和不超过 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>思路很简单，写一个两个链表合并的函数，每次两个链表合并最后输出</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lists)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lists)&lt;<span class="hljs-number">2</span>&#123;         <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>]            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(lists);i++&#123;        lists[<span class="hljs-number">0</span>] = mergeTwoLists(lists[i],lists[<span class="hljs-number">0</span>])    &#125;    <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> l1==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> l2    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> l1    &#125;    head,l3 := &amp;ListNode&#123;&#125;,&amp;ListNode&#123;&#125;    <span class="hljs-keyword">if</span> l1.Val&gt;l2.Val&#123;        head = l2    &#125;<span class="hljs-keyword">else</span>&#123;        head = l1    &#125;        <span class="hljs-keyword">for</span> l1!=<span class="hljs-literal">nil</span>&amp;&amp;l2!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> l1.Val &gt; l2.Val&#123;            l3.Next=l2            l3 = l2            l2 = l2.Next        &#125;<span class="hljs-keyword">else</span>&#123;            l3.Next=l1            l3 = l1            l1 = l1.Next        &#125;    &#125;    <span class="hljs-keyword">if</span> l1!=<span class="hljs-literal">nil</span>&#123;        l3.Next = l1    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2!=<span class="hljs-literal">nil</span>&#123;        l3.Next = l2    &#125;    <span class="hljs-keyword">return</span> head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：112 ms, 在所有 Go 提交中击败了32.23%的用户<br>   内存消耗：5.3 MB, 在所有 Go 提交中击败了73.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>236. 二叉树的最近公共祖先</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><font size=6px>二叉树的最近公共祖先</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例 1：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p><p>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1</p><p>提示：</p><p>树中节点数目在范围 [2, 105] 内。<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用递归的思路做，从下往上找，如果left！&#x3D;nil&amp;&amp;right!&#x3D;nil 则代表找到了，返回那个结点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-keyword">if</span> q.Val==root.Val||p.Val==root.Val&#123;        <span class="hljs-keyword">return</span> root    &#125;    left := lowestCommonAncestor(root.Left,p,q)    right := lowestCommonAncestor(root.Right,p,q)    <span class="hljs-comment">//代表左右结点都找到了</span>    <span class="hljs-keyword">if</span> left!=<span class="hljs-literal">nil</span> &amp;&amp; right!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> root    &#125;    <span class="hljs-keyword">if</span> right==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> left    &#125;    <span class="hljs-keyword">return</span> right&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了91.60%的用户<br>   内存消耗：7.6 MB, 在所有 Go 提交中击败了31.55%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>234. 回文链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><font size=6px>234. 回文链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第一种简单的思路是遍历一遍，将数据保存在数组里面，然后从两边开始遍历</p><p>第二种是进阶算法，用快慢指针，一个指针一次走两步，一个一次走一步，然后快指针走完慢指针刚刚走到一半，将后半链表逆置，然后前半链表和后半比较</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> head.Next==<span class="hljs-literal">nil</span>||head==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">var</span> pre *ListNode=<span class="hljs-literal">nil</span>    fast,slow :=head,head    <span class="hljs-keyword">for</span> fast!=<span class="hljs-literal">nil</span>&amp;&amp;fast.Next!=<span class="hljs-literal">nil</span>&#123;        fast=fast.Next.Next        pre=slow        slow=slow.Next    &#125;    pre.Next=<span class="hljs-literal">nil</span><span class="hljs-comment">//翻转链表</span><span class="hljs-keyword">var</span> head2 *ListNode=<span class="hljs-literal">nil</span><span class="hljs-keyword">for</span>(slow!=<span class="hljs-literal">nil</span>)&#123;    tmp:=slow.Next    slow.Next=head2    head2=slow    slow=tmp&#125;    <span class="hljs-keyword">for</span> head!=<span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> head2.Val!=head.Val&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;<span class="hljs-keyword">else</span>&#123;                head=head.Next                head2=head2.Next            &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：172 ms, 在所有 Go 提交中击败了23.75%的用户<br>   内存消耗：9.3 MB, 在所有 Go 提交中击败了29.47%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25. K 个一组翻转链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title=" K 个一组翻转链表"></a><font size=6px> K 个一组翻转链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[2,1,4,3,5]<br>示例 2：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3<br>输出：[3,2,1,4,5]<br>示例 3：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1<br>输出：[1,2,3,4,5]<br>示例 4：</p><p>输入：head &#x3D; [1], k &#x3D; 1<br>输出：[1]<br>提示：</p><p>列表中节点的数量在范围 sz 内<br>1 &lt;&#x3D; sz &lt;&#x3D; 5000<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>1 &lt;&#x3D; k &lt;&#x3D; sz</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先遍历k遍判断有没有到终点，遍历之后找到一段的tail和head，然后进入reverse函数，倒转head和tail，表的head和tail连接主表的pre和nex</p><pre><code class="hljs ini"><span class="hljs-attr">pre.Next</span>=head<span class="hljs-attr">tail.Next</span>=nex</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;    hair := &amp;ListNode&#123;Next: head&#125;    pre:=hair    <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> head    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> head!=<span class="hljs-literal">nil</span>&#123;            tail:=pre            <span class="hljs-comment">//判断结点数量大不大于k个</span>            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;                tail=tail.Next                <span class="hljs-keyword">if</span> tail==<span class="hljs-literal">nil</span>&#123;                    <span class="hljs-keyword">return</span> hair.Next                &#125;            &#125;            nex:=tail.Next            head,tail=reverse(head,tail)            pre.Next=head            tail.Next=nex            pre=tail            head=tail.Next                    &#125;    &#125;    <span class="hljs-keyword">return</span> hair.Next&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head,tail *ListNode)</span></span>(*ListNode,*ListNode)&#123;    <span class="hljs-keyword">var</span> head2 *ListNode=<span class="hljs-literal">nil</span>    p:=head    tail.Next=<span class="hljs-literal">nil</span>    <span class="hljs-keyword">for</span> p!=<span class="hljs-literal">nil</span>&#123;        tmp:=p.Next        p.Next=head2        head2=p        p=tmp    &#125;    <span class="hljs-keyword">return</span> head2,head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了90.13%的用户<br>   内存消耗：3.6 MB, 在所有 Go 提交中击败了50.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300. 最长递增子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><font size=6px>最长递增子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p><p>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><p>进阶：</p><p>你可以设计时间复杂度为 O(n2) 的解决方案吗？<br>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>进阶的还没想出来，本方法时间复杂度位O（n^2）</p><p>用动态规划，在 第i个数，arr[i] 比0到第i-1个数大，就找dp[i-1到0]最大的那个数加1，dp数组意思是这个数为结尾的最大递增序列为多少。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> nums==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> dp [<span class="hljs-number">2501</span>]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">2501</span> ;i++&#123;        dp[i]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        max =<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;i;j++&#123;            <span class="hljs-keyword">if</span> nums[i]&gt;nums[j]&#123;                <span class="hljs-keyword">if</span> max&lt;dp[j]+<span class="hljs-number">1</span>&#123;                    max = dp[j]+<span class="hljs-number">1</span>                &#125;            &#125;        &#125;        dp[i] = max            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> max &lt; dp[i]&#123;            max = dp[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：64 ms, 在所有 Go 提交中击败了68.43%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了95.62%的用户</p><p>优化版本</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    <span class="hljs-built_in">len</span> := <span class="hljs-number">1</span>    dp[<span class="hljs-built_in">len</span>] = nums[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> dp[<span class="hljs-built_in">len</span>] &lt; nums[i]&#123;            <span class="hljs-built_in">len</span>++            dp[<span class="hljs-built_in">len</span>] = nums[i]        &#125;<span class="hljs-keyword">else</span>&#123;            l,r,pos := <span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>,<span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> l &lt;= r&#123;                mid := (l+r)&gt;&gt;<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> dp[mid] &lt; nums[i]&#123;                     l = mid+<span class="hljs-number">1</span>                    pos = mid                                    &#125;<span class="hljs-keyword">else</span>&#123;                   r = mid<span class="hljs-number">-1</span>                &#125;            &#125;            dp[pos+<span class="hljs-number">1</span>] = nums[i]        &#125;        <span class="hljs-comment">//fmt.Println(dp)</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>&#125;</code></pre><p>执行用时：4 ms, 在所有 Go 提交中击败了98.09%的用户</p><p>内存消耗：3.4 MB, 在所有 Go 提交中击败了89.60%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>32. 最长有效括号</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><font size=6px>最长有效括号</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>示例 1：</p><p>输入：s &#x3D; “(()”<br>输出：2<br>解释：最长有效括号子串是 “()”<br>示例 2：</p><p>输入：s &#x3D; “)()())”<br>输出：4<br>解释：最长有效括号子串是 “()()”<br>示例 3：</p><p>输入：s &#x3D; “”<br>输出：0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用栈的思想做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> maxnum <span class="hljs-type">int</span>    stack = <span class="hljs-built_in">append</span>(stack,<span class="hljs-number">-1</span>)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;            stack = <span class="hljs-built_in">append</span>(stack,i)        &#125;<span class="hljs-keyword">else</span>&#123;            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack ) == <span class="hljs-number">0</span>&#123;                stack = <span class="hljs-built_in">append</span>(stack,i)            &#125;<span class="hljs-keyword">else</span>&#123;                maxnum = max(maxnum,i-stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> maxnum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">( a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了30.20%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>354. 俄罗斯套娃信封问题</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/354.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/354.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="俄罗斯套娃信封问题"><a href="#俄罗斯套娃信封问题" class="headerlink" title="俄罗斯套娃信封问题"></a><font size=6px>俄罗斯套娃信封问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] &#x3D; [wi, hi] ，表示第 i 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>注意：不允许旋转信封。</p><p>示例 1：</p><p>输入：envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]<br>输出：3<br>解释：最多信封的个数为 3, 组合为: [2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]。<br>示例 2：</p><p>输入：envelopes &#x3D; [[1,1],[1,1],[1,1]]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; envelopes.length &lt;&#x3D; 5000<br>envelopes[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; wi, hi &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把二维排序 先固定一维，就变成了一维问题，先按第一列升序，第二列降序排序，之后就变成第二列的最大升序问题，就可以求出答案</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(envelopes [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    myarr:=&amp;Intarr&#123;envelopes,<span class="hljs-number">0</span>&#125;    sort.Sort(myarr)    max:=lengthOfLIS(envelopes)    <span class="hljs-keyword">return</span> max&#125;<span class="hljs-keyword">type</span> Intarr <span class="hljs-keyword">struct</span> &#123;    marr [][]<span class="hljs-type">int</span>    line <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr *Intarr)</span></span>Len() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(arr.marr)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr *Intarr)</span></span>Swap(i,j <span class="hljs-type">int</span>)  &#123;    arr.marr[i],arr.marr[j]=arr.marr[j],arr.marr[i]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr *Intarr)</span></span>Less(i,j <span class="hljs-type">int</span>)<span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">if</span> arr.marr[i][arr.line] &lt; arr.marr[j][arr.line]&#123;        <span class="hljs-keyword">return</span>  <span class="hljs-literal">true</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> arr.marr[i][arr.line] &gt; arr.marr[j][arr.line]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span> arr.marr[i][<span class="hljs-number">1</span>]&gt;arr.marr[j][<span class="hljs-number">1</span>]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> nums==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> dp [<span class="hljs-number">5001</span>]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">5001</span>;i++&#123;        dp[i]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        max =<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;i;j++&#123;            <span class="hljs-keyword">if</span> nums[i][<span class="hljs-number">1</span>]&gt;nums[j][<span class="hljs-number">1</span>]&#123;                <span class="hljs-keyword">if</span> max&lt;dp[j]+<span class="hljs-number">1</span>&#123;                    max = dp[j]+<span class="hljs-number">1</span>                &#125;            &#125;        &#125;        dp[i] = max            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> max &lt; dp[i]&#123;            max = dp[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：268 ms, 在所有 Go 提交中击败了42.09%的用户<br>   内存消耗：6.3 MB, 在所有 Go 提交中击败了99.65%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a><font size=6px>搜索旋转排序数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出：4<br>示例 2：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出：-1<br>示例 3：</p><p>输入：nums &#x3D; [1], target &#x3D; 0<br>输出：-1</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第二个是顺序查找的快速版，主要讲第一个二分查找版，因为mid两边肯定有一边是有序的，如果左边有序，并且target大于有序的边的最小数，那就往有序边查，如果没有那就往半有序边查</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">//二分查找版</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) ==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] ==target&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;    &#125;        i,j:=<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i&lt;=j&#123;        mid := (i+j)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> nums[mid] == target&#123;            <span class="hljs-keyword">return</span> mid        &#125;        <span class="hljs-keyword">if</span> nums[mid] &gt;=nums[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">if</span> target &lt;nums[mid]&amp;&amp;target&gt;=nums[<span class="hljs-number">0</span>]&#123;                j = mid<span class="hljs-number">-1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                i = mid+<span class="hljs-number">1</span>            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> nums[mid]&lt;target&amp;&amp;target&lt;=nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#123;                i = mid+<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                j = mid<span class="hljs-number">-1</span>            &#125;        &#125;            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;    <span class="hljs-keyword">if</span> target&gt;nums[<span class="hljs-number">0</span>]&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums)&amp;&amp;nums[i<span class="hljs-number">-1</span>]&lt;nums[i];i++&#123;            <span class="hljs-keyword">if</span> target == nums[i]&#123;                <span class="hljs-keyword">return</span> i            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> target == nums[<span class="hljs-number">0</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> target == nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    &#125; <span class="hljs-keyword">else</span>  &#123;        <span class="hljs-keyword">for</span> j:= <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[j] &lt; nums[j+<span class="hljs-number">1</span>];j--&#123;            <span class="hljs-keyword">if</span> target ==nums[j]&#123;                <span class="hljs-keyword">return</span> j            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>393. UTF-8 编码验证</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/393.%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/393.%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h3 id="UTF-8-编码验证"><a href="#UTF-8-编码验证" class="headerlink" title="UTF-8 编码验证"></a><font size=6px>UTF-8 编码验证</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：</p><p>对于 1 字节的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。<br>对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。<br>这是 UTF-8 编码的工作方式：</p><p>   Char. number range  |        UTF-8 octet sequence<br>      (hexadecimal)    |              (binary)<br>   ——————–+———————————————<br>   0000 0000-0000 007F | 0xxxxxxx<br>   0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。</p><p>注意：<br>输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。</p><p>示例 1：</p><p>data &#x3D; [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.</p><p>返回 true 。<br>这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。<br>示例 2：</p><p>data &#x3D; [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.</p><p>返回 false 。<br>前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。<br>下一个字节是开头为 10 的延续字节，这是正确的。<br>但第二个延续字节不以 10 开头，所以是不符合规则的。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>相信很多人都跟我一样读不懂题目，我稍微讲解一下，要看第一个数字，第一个数字的最后八位如果是110xxxxx，说明之后有1个数是10xxxxxx，0xxxxxx的数字可以有好多个，如果是1110xxxx，说明有2个数字10xxxxxx，0xxxxxxx依旧可以有好多个，理解了题目做起来不难，不会看我的代码</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validUtf8</span><span class="hljs-params">(data []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    count :=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(data);i++&#123;        <span class="hljs-keyword">if</span> count==<span class="hljs-number">0</span>&#123;            count = bitNuber(data[i])        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//等不等于10xxxxxx</span>            <span class="hljs-keyword">if</span> (data[i] &gt;&gt;<span class="hljs-number">6</span>) != <span class="hljs-number">2</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;            count--            <span class="hljs-keyword">if</span> count==<span class="hljs-number">-1</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;                   &#125;    &#125;    <span class="hljs-keyword">return</span> count==<span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bitNuber</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-comment">//0xxxxxxx</span>    <span class="hljs-keyword">if</span> num&gt;&gt;<span class="hljs-number">7</span> ==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-comment">//11110xxx</span>    <span class="hljs-keyword">if</span> num &gt;&gt;<span class="hljs-number">3</span> ==<span class="hljs-number">30</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>    &#125;    <span class="hljs-comment">//1110xxxx</span>    <span class="hljs-keyword">if</span> num &gt;&gt;<span class="hljs-number">4</span> == <span class="hljs-number">14</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>    &#125;    <span class="hljs-comment">//110xxxxx</span>    <span class="hljs-keyword">if</span> num &gt;&gt;<span class="hljs-number">5</span> ==<span class="hljs-number">6</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了75.95%的用户<br>   内存消耗：5.2 MB, 在所有 Go 提交中击败了29.11%的用户</p><h2 id="后面第二次又因为每日一题做到了，就再做了一次"><a href="#后面第二次又因为每日一题做到了，就再做了一次" class="headerlink" title="后面第二次又因为每日一题做到了，就再做了一次"></a>后面第二次又因为每日一题做到了，就再做了一次</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h3><p>硬模拟就行了，代码丑但是竟然效率还高了</p><pre><code class="hljs kotlin">func validUtf8(<span class="hljs-keyword">data</span> []int) bool &#123;    cnt :=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;len(<span class="hljs-keyword">data</span>);&#123;        <span class="hljs-keyword">if</span> cnt != <span class="hljs-number">0</span>&#123;            <span class="hljs-comment">// 后面的数字个数符不符合</span>            <span class="hljs-keyword">if</span> i+cnt &gt;len(<span class="hljs-keyword">data</span>)&#123;                               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">for</span> j:=i;j&lt;i+cnt;j++&#123;                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">data</span>[j]&lt;<span class="hljs-number">128</span> || <span class="hljs-keyword">data</span>[j]&gt;<span class="hljs-number">191</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                &#125;                i += cnt                cnt = <span class="hljs-number">0</span>                <span class="hljs-keyword">continue</span>            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">data</span>[i]&lt;<span class="hljs-number">128</span>&#123;            i++            <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">data</span>[i] &gt;<span class="hljs-number">247</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>  (<span class="hljs-keyword">data</span>[i] &amp; <span class="hljs-number">240</span>) == <span class="hljs-number">240</span>&#123;                cnt = <span class="hljs-number">3</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span>[i] &amp; <span class="hljs-number">224</span>) == <span class="hljs-number">224</span>&#123;            cnt = <span class="hljs-number">2</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span>[i] &amp; <span class="hljs-number">192</span> == <span class="hljs-number">192</span>)&#123;            cnt = <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        i++    &#125;    <span class="hljs-keyword">if</span> cnt != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>; <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size:22px&quot;</span>&gt;</span>   执行用时：8 ms, 在所有 Go 提交中击败了97.44%的用户<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>   内存消耗：5 MB, 在所有 Go 提交中击败了92.31%的用户<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39. 组合总和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><font size=6px>组合总和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>示例 1：</p><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。<br>示例 2：</p><p>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]<br>示例 3：</p><p>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []<br>示例 4：</p><p>输入: candidates &#x3D; [1], target &#x3D; 1<br>输出: [[1]]<br>示例 5：</p><p>输入: candidates &#x3D; [1], target &#x3D; 2<br>输出: [[1,1]]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用dfs遍历</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span>temp := []<span class="hljs-type">int</span>&#123;&#125;dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;cpy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(temp))<span class="hljs-built_in">copy</span>(cpy, temp)res = <span class="hljs-built_in">append</span>(res, cpy)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">for</span> i := idx; i &lt; <span class="hljs-built_in">len</span>(candidates); i++ &#123;<span class="hljs-keyword">if</span> target-candidates[i] &gt;= <span class="hljs-number">0</span> &#123;temp = <span class="hljs-built_in">append</span>(temp, candidates[i])dfs(target-candidates[i], i)temp = temp[:<span class="hljs-built_in">len</span>(temp)<span class="hljs-number">-1</span>]&#125;&#125;&#125;dfs(target, <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.7 MB, 在所有 Go 提交中击败了98.82%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>432. 全 O(1) 的数据结构</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/432.%20%E5%85%A8%20O(1)%20%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/432.%20%E5%85%A8%20O(1)%20%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="全-O-1-的数据结构"><a href="#全-O-1-的数据结构" class="headerlink" title="全 O(1) 的数据结构"></a><font size=6px>全 O(1) 的数据结构</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请你实现一个数据结构支持以下操作：</p><p>Inc(key) - 插入一个新的值为 1 的 key。或者使一个存在的 key 增加一，保证 key 不为空字符串。<br>Dec(key) - 如果这个 key 的值是 1，那么把他从数据结构中移除掉。否则使一个存在的 key 值减一。如果这个 key 不存在，这个函数不做任何事情。key 保证不为空字符串。<br>GetMaxKey() - 返回 key 中值最大的任意一个。如果没有元素存在，返回一个空字符串”” 。<br>GetMinKey() - 返回 key 中值最小的任意一个。如果没有元素存在，返回一个空字符串””。</p><p>挑战：</p><p>你能够以 O(1) 的时间复杂度实现所有操作吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跟LRU类似，用哈希双向链表来做，还有很多不足，代码有些插入和删除可以提取出来写成函数，懒了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> AllOne <span class="hljs-keyword">struct</span> &#123;mp   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*nodetail *nodehead *node&#125;<span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;next  *nodepre   *nodekey   <span class="hljs-type">string</span>value <span class="hljs-type">int</span>&#125;<span class="hljs-comment">/** Initialize your data structure here. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> AllOne &#123;tail := &amp;node&#123;&#125;head := &amp;node&#123;&#125;head.next = tailtail.pre = head<span class="hljs-keyword">return</span> AllOne&#123;mp: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node), tail: tail, head: head&#125;&#125;<span class="hljs-comment">/** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> Inc(key <span class="hljs-type">string</span>) &#123;<span class="hljs-keyword">if</span> _, ok := this.mp[key]; ok &#123;this.mp[key].value++nodeNext := this.mp[key].next<span class="hljs-comment">//delete the node</span>this.mp[key].pre.next = this.mp[key].nextthis.mp[key].next.pre = this.mp[key].pre<span class="hljs-keyword">for</span> this.mp[key].value &gt;= nodeNext.value &amp;&amp; nodeNext != this.tail &#123;nodeNext = nodeNext.next&#125;nodeNext.pre.next = this.mp[key]this.mp[key].pre = nodeNext.prethis.mp[key].next = nodeNextnodeNext.pre = this.mp[key]&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//insert</span>headNext := this.head.nextnode := &amp;node&#123;key: key, value: <span class="hljs-number">1</span>&#125;this.mp[key] = nodethis.head.next = this.mp[key]this.mp[key].pre = this.headthis.mp[key].next = headNextheadNext.pre = this.mp[key]&#125;&#125;<span class="hljs-comment">/* Decrements an existing key by 1. If Key&#x27;s value is 1, remove it from the data structure. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> Dec(key <span class="hljs-type">string</span>) &#123;<span class="hljs-keyword">if</span> this.mp[key].value &gt; <span class="hljs-number">1</span> &#123;this.mp[key].value--&#125; <span class="hljs-keyword">else</span> &#123;this.mp[key].pre.next = this.mp[key].nextthis.mp[key].next.pre = this.mp[key].pre<span class="hljs-built_in">delete</span>(this.mp, key)&#125;&#125;<span class="hljs-comment">/** Returns one of the keys with maximal value. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> GetMaxKey() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> this.tail.pre == this.head &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> this.tail.pre.key&#125;&#125;<span class="hljs-comment">/** Returns one of the keys with Minimal value. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> GetMinKey() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> this.tail.pre == this.head &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> this.head.next.key&#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：36 ms, 在所有 Go 提交中击败了84.78%的用户<br>   内存消耗：9.3 MB, 在所有 Go 提交中击败了99.46%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>43. 字符串相乘</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a><font size=6px>字符串相乘</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><p>输入: num1 &#x3D; “2”, num2 &#x3D; “3”<br>输出: “6”<br>示例 2:</p><p>输入: num1 &#x3D; “123”, num2 &#x3D; “456”<br>输出: “56088”<br>说明：</p><p>num1 和 num2 的长度小于110。<br>num1 和 num2 只包含数字 0-9。<br>num1 和 num2 均不以零开头，除非是数字 0 本身。<br>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>很普通的大数相乘，就是golang如果想用【】byte来处理会溢出，记得用数组处理</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> num1[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> || num2[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>&#125;s1, s2 := []<span class="hljs-type">byte</span>(num1), []<span class="hljs-type">byte</span>(num2)s3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s1)+<span class="hljs-built_in">len</span>(s2))<span class="hljs-comment">//string reverse</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s1)/<span class="hljs-number">2</span>; i++ &#123;s1[i], s1[<span class="hljs-built_in">len</span>(s1)<span class="hljs-number">-1</span>-i] = s1[<span class="hljs-built_in">len</span>(s1)<span class="hljs-number">-1</span>-i], s1[i]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s2)/<span class="hljs-number">2</span>; i++ &#123;s2[i], s2[<span class="hljs-built_in">len</span>(s2)<span class="hljs-number">-1</span>-i] = s2[<span class="hljs-built_in">len</span>(s2)<span class="hljs-number">-1</span>-i], s2[i]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s1); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(s2); j++ &#123;s3[i+j] += <span class="hljs-type">int</span>((s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (s2[j] - <span class="hljs-string">&#x27;0&#x27;</span>))&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s1)+<span class="hljs-built_in">len</span>(s2); i++ &#123;<span class="hljs-keyword">if</span> s3[i] &gt;= <span class="hljs-number">10</span> &#123;s3[i+<span class="hljs-number">1</span>] += s3[i] / <span class="hljs-number">10</span>s3[i] = s3[i] % <span class="hljs-number">10</span>&#125;&#125;i := <span class="hljs-built_in">len</span>(s1) + <span class="hljs-built_in">len</span>(s2) - <span class="hljs-number">1</span><span class="hljs-keyword">for</span> s3[i] == <span class="hljs-number">0</span> &#123;i--&#125;s3 = s3[<span class="hljs-number">0</span> : i+<span class="hljs-number">1</span>]<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(s3)/<span class="hljs-number">2</span>; j++ &#123;s3[j], s3[<span class="hljs-built_in">len</span>(s3)<span class="hljs-number">-1</span>-j] = s3[<span class="hljs-built_in">len</span>(s3)<span class="hljs-number">-1</span>-j], s3[j]&#125;<span class="hljs-keyword">var</span> tmp []<span class="hljs-type">byte</span><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s3); i++ &#123;tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-type">byte</span>(s3[i])+<span class="hljs-string">&#x27;0&#x27;</span>)&#125;<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(tmp)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了84.69%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>46. 全排列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/46.%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/46.%20%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><font size=6px>46. 全排列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一道经典dfs的题目，记得使用完之后得复原之前的样子，为什么要复制一份再append进去，因为这个path所指向的内存空间在之后还得用，所以path所引用的内容会变化</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;    &#125;res := [][]<span class="hljs-type">int</span>&#123;&#125;<span class="hljs-keyword">var</span> recall <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(path []<span class="hljs-type">int</span>,start <span class="hljs-type">int</span>)</span></span>recall = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(path []<span class="hljs-type">int</span>,start <span class="hljs-type">int</span>)</span></span>&#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums)&#123;            temp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<span class="hljs-built_in">copy</span>(temp, path)res = <span class="hljs-built_in">append</span>(res, temp)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">for</span> i:=start;i&lt;<span class="hljs-built_in">len</span>(nums)&amp;&amp;i&gt;=<span class="hljs-number">0</span>;i++&#123;            flag := <span class="hljs-literal">false</span>            <span class="hljs-comment">//看是否有重复的数字</span>            <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> path&#123;                <span class="hljs-keyword">if</span> v ==nums[i]&#123;                    flag = <span class="hljs-literal">true</span>                    <span class="hljs-keyword">break</span>                &#125;            &#125;            <span class="hljs-keyword">if</span> flag==<span class="hljs-literal">true</span>&#123;                <span class="hljs-keyword">continue</span>            &#125;            path = <span class="hljs-built_in">append</span>(path,nums[i])            recall(path,start)            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]        &#125;&#125;    recall([]<span class="hljs-type">int</span>&#123;&#125;,<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.7 MB, 在所有 Go 提交中击败了56.75%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53. 最大子序和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a><font size=6px>最大子序和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例 1：</p><p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p><p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p><p>输入：nums &#x3D; [0]<br>输出：0<br>示例 4：</p><p>输入：nums &#x3D; [-1]<br>输出：-1<br>示例 5：</p><p>输入：nums &#x3D; [-100000]<br>输出：-100000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>就累加，如果小于0就重新累加，如果都是负数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> i,sum,flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>=<span class="hljs-number">-999</span>    max=nums[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        sum+=nums[i]        <span class="hljs-keyword">if</span> sum&lt;<span class="hljs-number">0</span>&#123;            sum=<span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            flag=<span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> max&lt;sum&#123;                max=sum            &#125;        &#125;    &#125;    <span class="hljs-comment">//为了防止都是负数的情况</span>    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;            <span class="hljs-keyword">if</span> max&lt;nums[i]&#123;                max=nums[i]            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了45.81%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><font size=6px><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例 1：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”<br>输出：true<br>示例 2：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “SEE”<br>输出：true<br>示例 3：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCB”<br>输出：false</p><p>提示：</p><p>m &#x3D;&#x3D; board.length<br>n &#x3D; board[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 6<br>1 &lt;&#x3D; word.length &lt;&#x3D; 15<br>board 和 word 仅由大小写英文字母组成</p><p>进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典dfs题，visit访问时要置1，最后访问完后重新置0</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    m,n := <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])     visit := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(board))    valid := <span class="hljs-literal">false</span>    move := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(board); i++&#123;        visit[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(board[i]))    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num, x,y <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(count,x,y <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> count == <span class="hljs-built_in">len</span>(word)&#123;            valid = <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">if</span> valid&#123;            <span class="hljs-keyword">return</span>         &#125;        visit[x][y] = <span class="hljs-literal">true</span>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>;i++&#123;            new_x := x+move[i*<span class="hljs-number">2</span>]            new_y := y+move[i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> new_x &gt;= <span class="hljs-number">0</span> &amp;&amp; new_x &lt; m &amp;&amp; new_y &gt;=<span class="hljs-number">0</span> &amp;&amp; new_y &lt;n &amp;&amp; visit[new_x][new_y] == <span class="hljs-literal">false</span> &amp;&amp; board[new_x][new_y ] == word[count]&#123;                                dfs(count+<span class="hljs-number">1</span>, new_x,new_y)            &#125;        &#125;        visit[x][y] = <span class="hljs-literal">false</span>    &#125;        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(board); i++&#123;        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j&lt;<span class="hljs-built_in">len</span>(board[i]); j++&#123;            count := <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> board[i][j] == word[<span class="hljs-number">0</span>] &amp;&amp; !valid&#123;                                dfs(count, i, j)            &#125;                    &#125;     &#125;    <span class="hljs-keyword">return</span> valid&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：92 ms, 在所有 Go 提交中击败了59.42%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了91.92%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 029. 排序的循环链表</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20029.%20%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20029.%20%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="排序的循环链表"><a href="#排序的循环链表" class="headerlink" title="排序的循环链表"></a><font size=6px>排序的循环链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。</p><p>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</p><p>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</p><p>如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</p><p>示例 1：</p><p>输入：head &#x3D; [3,4,1], insertVal &#x3D; 2<br>输出：[3,4,1,2]<br>解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。</p><p>示例 2：</p><p>输入：head &#x3D; [], insertVal &#x3D; 1<br>输出：[1]<br>解释：列表为空（给定的节点是 null），创建一个循环有序列表并返回这个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], insertVal &#x3D; 0<br>输出：[1,0]</p><p>提示：</p><p>0 &lt;&#x3D; Number of Nodes &lt;&#x3D; 5 * 10^4<br>-10^6 &lt;&#x3D; Node.val &lt;&#x3D; 10^6<br>-10^6 &lt;&#x3D; insertVal &lt;&#x3D; 10^6</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>先找到有序的头部，比如3 1 2，先找到有序的开头1，然后把这个作为头部，开始遍历找到插入点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a Node.</span><span class="hljs-comment"> * type Node struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *Node</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">news</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span>*Node&#123;    node := Node&#123;&#125;    node.Val = x    node.Next = <span class="hljs-literal">nil</span>    <span class="hljs-keyword">return</span> &amp;node&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insert</span><span class="hljs-params">(aNode *Node, x <span class="hljs-type">int</span>)</span></span> *Node &#123;    node := news(x)    <span class="hljs-keyword">if</span> aNode == <span class="hljs-literal">nil</span>&#123;        node.Next = node        <span class="hljs-keyword">return</span> node    &#125;    <span class="hljs-keyword">if</span> aNode.Next == aNode&#123;        aNode.Next = node        node.Next = aNode        <span class="hljs-keyword">return</span> aNode    &#125;    head := aNode    tmp := aNode    <span class="hljs-keyword">for</span> aNode.Next != head&#123;        next := aNode.Next        <span class="hljs-keyword">if</span> next.Val &lt; aNode.Val&#123;            head = next            <span class="hljs-keyword">break</span>        &#125;        aNode = next    &#125;    bNode := head    flag := <span class="hljs-literal">false</span>    <span class="hljs-keyword">for</span> bNode.Next != head&#123;        next := bNode.Next        <span class="hljs-keyword">if</span> next.Val &gt;=x &amp;&amp; bNode.Val &lt;=x&#123;            bNode.Next = node            node.Next = next            flag = <span class="hljs-literal">true</span>            <span class="hljs-keyword">break</span>        &#125;        bNode = next    &#125;    <span class="hljs-keyword">if</span> !flag&#123;        bNode.Next = node        node.Next = head    &#125;    <span class="hljs-keyword">return</span> tmp&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了98.29%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 091. 粉刷房子</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20091.%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20091.%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="粉刷房子"><a href="#粉刷房子" class="headerlink" title="粉刷房子"></a><font size=6px>粉刷房子</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。</p><p>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。</p><p>请计算出粉刷完所有房子最少的花费成本。</p><p>示例 1：</p><p>输入: costs &#x3D; [[17,2,17],[16,16,5],[14,3,19]]<br>输出: 10<br>解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。<br>     最少花费: 2 + 5 + 3 &#x3D; 10。<br>示例 2：</p><p>输入: costs &#x3D; [[7,6,2]]<br>输出: 2</p><p>提示:</p><p>costs.length &#x3D;&#x3D; n<br>costs[i].length &#x3D;&#x3D; 3<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>1 &lt;&#x3D; costs[i][j] &lt;&#x3D; 20</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用动态规划做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCost</span><span class="hljs-params">(costs [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(costs)    dp1,dp2,dp3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(costs)),<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(costs)),<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(costs))    dp1[<span class="hljs-number">0</span>],dp2[<span class="hljs-number">0</span>], dp3[<span class="hljs-number">0</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],costs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i&lt;<span class="hljs-built_in">len</span>(costs); i++&#123;        dp1[i] = min(dp2[i<span class="hljs-number">-1</span>],dp3[i<span class="hljs-number">-1</span>]) + costs[i][<span class="hljs-number">0</span>]        dp2[i] = min(dp1[i<span class="hljs-number">-1</span>],dp3[i<span class="hljs-number">-1</span>]) + costs[i][<span class="hljs-number">1</span>]        dp3[i] = min(dp1[i<span class="hljs-number">-1</span>],dp2[i<span class="hljs-number">-1</span>]) + costs[i][<span class="hljs-number">2</span>]    &#125;    <span class="hljs-keyword">return</span> min(min(dp1[n<span class="hljs-number">-1</span>],dp2[n<span class="hljs-number">-1</span>]),dp3[n<span class="hljs-number">-1</span>])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了84.92%的用户<br>   内存消耗：3 MB, 在所有 Go 提交中击败了56.98%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>175. 组合两个表</title>
    <link href="/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93/175.%20%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/"/>
    <url>/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93/175.%20%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="组合两个表"><a href="#组合两个表" class="headerlink" title="组合两个表"></a><font size=6px>组合两个表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>表1: Person</p><p>+————-+———+<br>| 列名         | 类型     |<br>+————-+———+<br>| PersonId    | int     |<br>| FirstName   | varchar |<br>| LastName    | varchar |<br>+————-+———+<br>PersonId 是上表主键<br>表2: Address</p><p>+————-+———+<br>| 列名         | 类型    |<br>+————-+———+<br>| AddressId   | int     |<br>| PersonId    | int     |<br>| City        | varchar |<br>| State       | varchar |<br>+————-+———+<br>AddressId 是上表主键</p><p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p><p>FirstName, LastName, City, State</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">select</span> p.firstName, p.lastName, a.city, a.state from Person p left join Address a on p.PersonId = a.PersonId</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：426 ms, 在所有 MySQL 提交中击败了75.79%的用户<br>   内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>181. 超过经理收入的员工</title>
    <link href="/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93/181.%20%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/"/>
    <url>/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93/181.%20%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="超过经理收入的员工"><a href="#超过经理收入的员工" class="headerlink" title="超过经理收入的员工"></a><font size=6px>超过经理收入的员工</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>表：Employee </p><p>+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| id          | int     |<br>| name        | varchar |<br>| salary      | int     |<br>| managerId   | int     |<br>+————-+———+<br>Id是该表的主键。<br>该表的每一行都表示雇员的ID、姓名、工资和经理的ID。</p><p>编写一个SQL查询来查找收入比经理高的员工。</p><p>以 任意顺序 返回结果表。</p><p>查询结果格式如下所示。</p><p>示例 1:</p><p>输入:<br>Employee 表:<br>+—-+——-+——–+———–+<br>| id | name  | salary | managerId |<br>+—-+——-+——–+———–+<br>| 1  | Joe   | 70000  | 3         |<br>| 2  | Henry | 80000  | 4         |<br>| 3  | Sam   | 60000  | Null      |<br>| 4  | Max   | 90000  | Null      |<br>+—-+——-+——–+———–+<br>输出:<br>+———-+<br>| Employee |<br>+———-+<br>| Joe      |<br>+———-+<br>解释: Joe 是唯一挣得比经理多的雇员。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>子查询做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">select</span> a.name as Employee from Employee a where salary &gt; (<span class="hljs-keyword">select</span> b.salary from Employee b where id = a.managerId);</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：991 ms, 在所有 MySQL 提交中击败了5.06%的用户<br>   内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>头条笔试题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%A4%B4%E6%9D%A1%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%A4%B4%E6%9D%A1%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1、折木棍"><a href="#1、折木棍" class="headerlink" title="1、折木棍"></a><font size=6px>1、折木棍</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在你的面前从左到右摆放着 nn 根长短不一的木棍，你每次可以折断一根木棍，并将折断后得到的两根木棍一左一右放在原来的位置（即若原木棍有左邻居，则两根新木棍必须放在左邻居的右边，若原木棍有右邻居，新木棍必须放在右邻居的左边，所有木棍保持左右排列）。折断后的两根木棍的长度必须为整数，且它们之和等于折断前的木棍长度。你希望最终从左到右的木棍长度单调不减，那么你需要折断多少次呢？</p><p>输入描述<br>第一行是一个数 nn，表示开始时有多少根木棍 (1&lt;&#x3D;n&lt;&#x3D;3000)(1&lt;&#x3D;n&lt;&#x3D;3000) 第二行有 nn 个数，从第 11 个到第 nn 个分别表示从左到右的木棍长度。对任意木棍的长度 ll，有 1&lt;&#x3D;l&lt;&#x3D;30001&lt;&#x3D;l&lt;&#x3D;3000。</p><p>输出描述<br>输出一行，一个数，你最少所需的折断木棍的次数 xx</p><p>示例</p><p>输入:<br>5<br>3 5 13 9 12</p><p>输出:<br>1<br>说明<br>你可以将长度为 1313 的木棍折成长度分别为 55 和 88 的两根木棍，最终得到的排列是 3 5 5 8 9 12</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从后往前遍历，建立一个单调栈，如果遇到比top大的，就想办法折出均匀的几段，这是在要比后一个小前一个大的情况，并且把折的最小的一个放栈里面</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-type">int</span> breakNum(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    stack&lt;<span class="hljs-type">int</span>&gt; st;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">if</span> (!st.empty() &amp;&amp; st.top() &lt; nums[i]) &#123;            <span class="hljs-type">int</span> t = (nums[i] - <span class="hljs-number">1</span>) / st.top();            ans += t;            st.push(nums[i] / (t + <span class="hljs-number">1</span>));            <span class="hljs-keyword">continue</span>;        &#125;        st.push(nums[i]);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre><h3 id="2、打印出失序的线程ID"><a href="#2、打印出失序的线程ID" class="headerlink" title="2、打印出失序的线程ID"></a>2、打印出失序的线程ID</h3><blockquote><p><strong>题目描述</strong></p></blockquote><p>输入一个正整数n.表示接下来有n行数字，每行一个数字（不重复，可能无序），表示线程id,输出未出现的失序的线程ID</p><p>n的大小是小于等于2的32次方</p><blockquote><p><strong>示例</strong></p></blockquote><p><strong>例如1：</strong></p><pre><code class="hljs properties"><span class="hljs-attr">输入(输入的线程ID不一定有序)</span><span class="hljs-attr">5</span><span class="hljs-attr">2</span><span class="hljs-attr">3</span><span class="hljs-attr">4</span><span class="hljs-attr">5</span><span class="hljs-attr">6</span><span class="hljs-attr">输出：</span><span class="hljs-attr">1</span></code></pre><p><strong>例如2：</strong></p><pre><code class="hljs properties"><span class="hljs-attr">输入：</span><span class="hljs-attr">4</span><span class="hljs-attr">1</span><span class="hljs-attr">2</span><span class="hljs-attr">3</span><span class="hljs-attr">4</span><span class="hljs-attr">输出：</span><span class="hljs-attr">5</span></code></pre><p>思路：</p><p>输入数组中，排序一个，然后从前往后遍历，找出空缺的位置。</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分模块刷力扣题</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/0%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E5%8A%9B%E6%89%A3%E9%A2%98/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/0%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E5%8A%9B%E6%89%A3%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><style>table th:first-of-type {    width: 20%;}table th:nth-of-type(2) {    width: 50%;}table th:nth-of-type(3) {    width: 20%;} table th:nth-of-type(4) {    width: 30%;}</style><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">题目</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">两数之和</td><td align="center">c</td><td align="center">Easy</td></tr><tr><td align="center">11</td><td align="center">乘最多的水</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">15.三数之和</td><td align="center">学会了双指针法</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">16</td><td align="center">最接近的三数之和</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">33. 搜索旋转排序数组</td><td align="center">学会半有序的二分查找</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">41</td><td align="center">缺失一个正数</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">42</td><td align="center">接雨水</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">46. 全排列</td><td align="center">学会dfs</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">48</td><td align="center">旋转图像</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">56. 合并区间</td><td align="center">学会简便排序二维数组</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">81. 搜索旋转排序数组 II</td><td align="center">和33题差不多</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">84. 柱状图中最大的矩形</td><td align="center">学会哨兵和单调栈</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">121</td><td align="center">买卖股票的最佳时机</td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">122</td><td align="center">买卖股票的最佳时机||</td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">123</td><td align="center">买卖股票的最佳时机|||</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">128. 最长连续序列</td><td align="center">学会遍历map</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">215. 数组中的第K个最大元素</td><td align="center">学会了堆排序</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">300. 最长递增子序列</td><td align="center">学会了用动态规划求最大子序列</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">393. UTF-8 编码验证</td><td align="center">学会了位运算</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">547. 省份数量</td><td align="center">学会并查集合并</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">674. 最长连续递增序列</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">695. 岛屿的最大面积</td><td align="center">锻炼了dfs</td><td align="center">go</td><td align="center">medium</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">3无重复字符的最长子串</td><td align="center"></td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">13罗马数字转整数</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">43. 字符串相乘</td><td align="center">学会大数乘法</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">71. 简化路径</td><td align="center">学会了split函数和怎么删除切片指定字符串</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">20</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">22</td><td align="center"></td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">14. 最长公共前缀</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">567. 字符串的排列</td><td align="center">复习了移动窗口法</td><td align="center">go</td><td align="center">Medium</td></tr></tbody></table><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">53. 最大子序和</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">85. 最大矩形</td><td align="center">学会单调栈和哨兵的另外一种应用</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">120. 三角形最小路径和</td><td align="center">数塔问题</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">1416 恢复数组</td><td align="center">锻炼了递推思路</td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center">354. 俄罗斯套娃信封问题</td><td align="center">学会自定义快排和求最大升序序列</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">21. 合并两个有序链表</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">23. 合并K个升序链表</td><td align="center"></td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center">25. K 个一组翻转链表</td><td align="center">指针逆置，后面复习，再写一次</td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center">141. 环形链表</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">143. 重排链表</td><td align="center">锻炼了插入链表的顺序，学会了归并排序排序链表</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">160. 相交链表</td><td align="center">学会map的使用</td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">206. 反转链表</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">234. 回文链表</td><td align="center">知道什么原地让指针逆置</td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">236. 二叉树的最近公共祖先</td><td align="center">学会递归找公共祖先结点</td><td align="center">go</td><td align="center">medium</td></tr></tbody></table><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">102. 二叉树的层序遍历</td><td align="center">学会用队列遍历二叉树</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">103. 二叉树的锯齿形层序遍历</td><td align="center">学会把二叉树放进切片里面</td><td align="center">goeasy</td><td align="center">medium</td></tr><tr><td align="center">110. 平衡二叉树</td><td align="center">学会怎么判断平衡二叉树</td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">55. 最小栈</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">146. LRU 缓存机制</td><td align="center">学会了LRU算法，用链表哈希数据结构</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">432. 全 O(1) 的数据结构</td><td align="center">学会哈希双向链表的使用</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">55. 最小栈</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">60. 排列序列</td><td align="center">学会怎么快速知道在全排列中第几个数</td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1000. 合并石头的最低成本</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1000.%20%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1000.%20%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="合并石头的最低成本"><a href="#合并石头的最低成本" class="headerlink" title="合并石头的最低成本"></a><font size=6px>合并石头的最低成本</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。</p><p>每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。</p><p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。</p><p>示例 1：</p><p>输入：stones &#x3D; [3,2,4,1], K &#x3D; 2<br>输出：20<br>解释：<br>从 [3, 2, 4, 1] 开始。<br>合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。<br>合并 [4, 1]，成本为 5，剩下 [5, 5]。<br>合并 [5, 5]，成本为 10，剩下 [10]。<br>总成本 20，这是可能的最小值。<br>示例 2：</p><p>输入：stones &#x3D; [3,2,4,1], K &#x3D; 3<br>输出：-1<br>解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.<br>示例 3：</p><p>输入：stones &#x3D; [3,5,1,2,6], K &#x3D; 3<br>输出：25<br>解释：<br>从 [3, 5, 1, 2, 6] 开始。<br>合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。<br>合并 [3, 8, 6]，成本为 17，剩下 [17]。<br>总成本 25，这是可能的最小值。</p><p>提示：</p><p>1 &lt;&#x3D; stones.length &lt;&#x3D; 30<br>2 &lt;&#x3D; K &lt;&#x3D; 30<br>1 &lt;&#x3D; stones[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><p>区间dp经典题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeStones</span><span class="hljs-params">(stones []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;n := <span class="hljs-built_in">len</span>(stones)<span class="hljs-keyword">if</span> (n<span class="hljs-number">-1</span>)%(k<span class="hljs-number">-1</span>) != <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123;dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)&#125;sum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;sum[i] = sum[i<span class="hljs-number">-1</span>] + stones[i<span class="hljs-number">-1</span>]&#125;<span class="hljs-keyword">for</span> l := k; l &lt;= n;l++ &#123; <span class="hljs-comment">// 枚举区间长度</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span> &lt;= n;i++ &#123; <span class="hljs-comment">// 枚举区间起点</span>j := i + l - <span class="hljs-number">1</span>dp[i][j] = math.MaxInt32<span class="hljs-keyword">for</span> p := i; p &lt; j;p += k - <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 枚举分界点</span><span class="hljs-keyword">if</span> dp[i][j]&gt; dp[i][p]+dp[p+<span class="hljs-number">1</span>][j]&#123;dp[i][j] = dp[i][p]+dp[p+<span class="hljs-number">1</span>][j]&#125;&#125;<span class="hljs-keyword">if</span> (j-i)%(k<span class="hljs-number">-1</span>) == <span class="hljs-number">0</span> &#123;dp[i][j] += sum[j] - sum[i<span class="hljs-number">-1</span>]&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][n]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了71.43%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1014. 最佳观光组合</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1014.%20%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1014.%20%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="最佳观光组合"><a href="#最佳观光组合" class="headerlink" title="最佳观光组合"></a><font size=6px>最佳观光组合</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。</p><p>一对景点（i &lt; j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p>示例 1：</p><p>输入：values &#x3D; [8,1,5,2,6]<br>输出：11<br>解释：i &#x3D; 0, j &#x3D; 2, values[i] + values[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11<br>示例 2：</p><p>输入：values &#x3D; [1,2]<br>输出：2</p><p>提示：</p><p>2 &lt;&#x3D; values.length &lt;&#x3D; 5 * 104<br>1 &lt;&#x3D; values[i] &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>可以拆分成num[i] +i 和 num[j]-j，后面这个是不变的，前面这个是变的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxScoreSightseeingPair</span><span class="hljs-params">(values []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(values)    ans,maxNum := <span class="hljs-number">0</span>,values[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        ans = max(ans, maxNum+values[i]-i)        maxNum = max(maxNum,values[i]+i)    &#125;    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了42.68%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了91.46%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1020. 飞地的数量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1020.%20%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1020.%20%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="飞地的数量"><a href="#飞地的数量" class="headerlink" title="飞地的数量"></a><font size=6px>飞地的数量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。</p><p>一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。</p><p>返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。</p><p>示例 1：</p><p>输入：grid &#x3D; [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]<br>输出：3<br>解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。<br>示例 2：</p><p>输入：grid &#x3D; [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]<br>输出：0<br>解释：所有 1 都在边界上或可以到达边界。</p><p>提示：</p><p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 500<br>grid[i][j] 的值为 0 或 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>Dfs 题，遍历周边的，然后遍历中间的数有几个岛屿</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numEnclaves</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> dirs = []<span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    vis := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, m)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> vis &#123;        vis[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>,<span class="hljs-type">bool</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r, c <span class="hljs-type">int</span> , flag <span class="hljs-type">bool</span>)</span></span> &#123;        <span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> || r &gt;= m || c &lt; <span class="hljs-number">0</span> || c &gt;= n || grid[r][c] == <span class="hljs-number">0</span> || vis[r][c] &#123;            <span class="hljs-keyword">return</span>        &#125;        vis[r][c] = <span class="hljs-literal">true</span>        <span class="hljs-keyword">if</span> flag&#123;            count++        &#125;        <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;            dfs(r+d.x, c+d.y,flag)        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span> &amp;&amp; vis[<span class="hljs-number">0</span>][i] == <span class="hljs-literal">false</span>&#123;            dfs(<span class="hljs-number">0</span>,i,<span class="hljs-literal">false</span>)        &#125;         <span class="hljs-keyword">if</span> grid[m<span class="hljs-number">-1</span>][i] == <span class="hljs-number">1</span> &amp;&amp; vis[m<span class="hljs-number">-1</span>][i] == <span class="hljs-literal">false</span>&#123;            dfs(m<span class="hljs-number">-1</span>,i,<span class="hljs-literal">false</span>)        &#125;    &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m<span class="hljs-number">-1</span>;i++&#123;        <span class="hljs-keyword">if</span> grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; vis[i][<span class="hljs-number">0</span>] == <span class="hljs-literal">false</span>&#123;            dfs(i,<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>)        &#125;         <span class="hljs-keyword">if</span> grid[i][n<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span> &amp;&amp; vis[i][n<span class="hljs-number">-1</span>] == <span class="hljs-literal">false</span>&#123;            dfs(i,n<span class="hljs-number">-1</span>,<span class="hljs-literal">false</span>)        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m<span class="hljs-number">-1</span>;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;n<span class="hljs-number">-1</span>;j++&#123;            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; vis[i][j] == <span class="hljs-literal">false</span>&#123;                dfs(i,j,<span class="hljs-literal">true</span>)                            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：60 ms, 在所有 Go 提交中击败了35.64%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了75.25%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1022. 从根到叶的二进制数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1022.%20%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1022.%20%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="从根到叶的二进制数之和"><a href="#从根到叶的二进制数之和" class="headerlink" title="从根到叶的二进制数之和"></a><font size=6px>从根到叶的二进制数之和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。</p><p>例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。<br>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p><p>返回这些数字之和。题目数据保证答案是一个 32 位 整数。</p><p>示例 1：</p><p>输入：root &#x3D; [1,0,1,0,1,0,1]<br>输出：22<br>解释：(100) + (101) + (110) + (111) &#x3D; 4 + 5 + 6 + 7 &#x3D; 22<br>示例 2：</p><p>输入：root &#x3D; [0]<br>输出：0</p><p>提示：</p><p>树中的节点数在 [1, 1000] 范围内<br>Node.val 仅为 0 或 1 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>只要递归求出二叉树叶子节点的值就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumRootToLeaf</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;    sum,res := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        sum = sum*<span class="hljs-number">2</span>+root.Val        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span>&#123;            dfs(root.Left)        &#125;        <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span>&#123;            dfs(root.Right)        &#125;        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>&#123;                      res += sum        &#125;        sum /=<span class="hljs-number">2</span>            &#125;    dfs(root)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.9 MB, 在所有 Go 提交中击败了80.30%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1021. 删除最外层的括号</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1021.%20%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1021.%20%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="删除最外层的括号"><a href="#删除最外层的括号" class="headerlink" title="删除最外层的括号"></a><font size=6px>删除最外层的括号</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有效括号字符串为空 “”、”(“ + A + “)” 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。</p><p>例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。<br>如果有效字符串 s 非空，且不存在将其拆分为 s &#x3D; A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p><p>给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s &#x3D; P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p><p>对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。</p><p>示例 1：</p><p>输入：s &#x3D; “(()())(())”<br>输出：”()()()”<br>解释：<br>输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，<br>删除每个部分中的最外层括号后得到 “()()” + “()” &#x3D; “()()()”。<br>示例 2：</p><p>输入：s &#x3D; “(()())(())(()(()))”<br>输出：”()()()()(())”<br>解释：<br>输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，<br>删除每个部分中的最外层括号后得到 “()()” + “()” + “()(())” &#x3D; “()()()()(())”。<br>示例 3：</p><p>输入：s &#x3D; “()()”<br>输出：””<br>解释：<br>输入字符串为 “()()”，原语化分解得到 “()” + “()”，<br>删除每个部分中的最外层括号后得到 “” + “” &#x3D; “”。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用栈做，每次栈空就找到一个原语了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeOuterParentheses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>    &#125;    <span class="hljs-keyword">var</span> res <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">byte</span>    stack = <span class="hljs-built_in">append</span>(stack, s[<span class="hljs-number">0</span>])    tmp := <span class="hljs-type">string</span>(stack[<span class="hljs-number">0</span>])    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;          tmp += <span class="hljs-type">string</span>(s[i])        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span>&#123;            stack = <span class="hljs-built_in">append</span>(stack, s[i])                      <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">if</span> s[i]==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>&#123;                        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]                    &#125;<span class="hljs-keyword">else</span>&#123;            stack = <span class="hljs-built_in">append</span>(stack, s[i])        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span>&#123;            res += tmp[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]            tmp = <span class="hljs-string">&quot;&quot;</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了48.68%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了43.42%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1037. 有效的回旋镖</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1037.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%96/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1037.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%96/</url>
    
    <content type="html"><![CDATA[<h3 id="有效的回旋镖"><a href="#有效的回旋镖" class="headerlink" title="有效的回旋镖"></a><font size=6px>有效的回旋镖</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组 points ，其中 points[i] &#x3D; [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。</p><p>回旋镖 定义为一组三个点，这些点 各不相同 且 不在一条直线上 。</p><p>示例 1：</p><p>输入：points &#x3D; [[1,1],[2,3],[3,2]]<br>输出：true<br>示例 2：</p><p>输入：points &#x3D; [[1,1],[2,2],[3,3]]<br>输出：false</p><p>提示：</p><p>points.length &#x3D;&#x3D; 3<br>points[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; xi, yi &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>简单题，把情况判断清楚就好，好久没双百了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBoomerang</span><span class="hljs-params">(points [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &amp;&amp; points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] == points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &amp;&amp; points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&amp;&amp;points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] == points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&amp;&amp;points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&amp;&amp;points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">float64</span>    a = <span class="hljs-type">float64</span>(points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])/<span class="hljs-type">float64</span>(points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])    b = <span class="hljs-type">float64</span>(points[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]-points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])/<span class="hljs-type">float64</span>(points[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]-points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])    <span class="hljs-keyword">if</span> a == b&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>538. Convert BST to Greater Tree</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1038.%20Convert%20BST%20to%20Greater%20Tree/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1038.%20Convert%20BST%20to%20Greater%20Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="Convert-BST-to-Greater-Tree"><a href="#Convert-BST-to-Greater-Tree" class="headerlink" title="Convert BST to Greater Tree"></a><font size=6px>Convert BST to Greater Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p><p>As a reminder, a binary search tree is a tree that satisfies these constraints:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p><p>Example 1:</p><p>Input: root &#x3D; [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]<br>Example 2:</p><p>Input: root &#x3D; [0,null,1]<br>Output: [1,null,1]</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [0, 104].<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>All the values in the tree are unique.<br>root is guaranteed to be a valid binary search tree.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>dfs 搜索，右中左序列就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertBST</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    <span class="hljs-keyword">var</span> maxNum <span class="hljs-type">int</span>     dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        dfs(root.Right)        root.Val += maxNum        maxNum = root.Val        dfs(root.Left)            &#125;dfs(root)<span class="hljs-keyword">return</span> root&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><font size=6px>从前序与中序遍历序列构造二叉树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p>示例 1:</p><p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p><p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]</p><p>提示:</p><p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用递归写最容易，前序的第一个节点是根结点，找到前序第一个节点在中序中第几个，中序左边的左子树，右边是右子树</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    root := &amp;TreeNode&#123;preorder[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;    i:=<span class="hljs-number">0</span>     <span class="hljs-keyword">for</span> ;i&lt;<span class="hljs-built_in">len</span>(inorder); i++&#123;        <span class="hljs-keyword">if</span> inorder[i] == preorder[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    root.Left = buildTree(preorder[<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>], inorder[:i])    root.Right = buildTree(preorder[i+<span class="hljs-number">1</span>:], inorder[i+<span class="hljs-number">1</span>:])    <span class="hljs-keyword">return</span> root&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.86%的用户<br>   内存消耗：4 MB, 在所有 Go 提交中击败了96.69%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1051. 高度检查器</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1051.%20%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1051.%20%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="高度检查器"><a href="#高度检查器" class="headerlink" title="高度检查器"></a><font size=6px>高度检查器</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 非递减 的高度顺序排成一行。</p><p>排序后的高度情况用整数数组 expected 表示，其中 expected[i] 是预计排在这一行中第 i 位的学生的高度（下标从 0 开始）。</p><p>给你一个整数数组 heights ，表示 当前学生站位 的高度情况。heights[i] 是这一行中第 i 位学生的高度（下标从 0 开始）。</p><p>返回满足 heights[i] !&#x3D; expected[i] 的 下标数量 。</p><p>示例：</p><p>输入：heights &#x3D; [1,1,4,2,1,3]<br>输出：3<br>解释：<br>高度：[1,1,4,2,1,3]<br>预期：[1,1,1,2,3,4]<br>下标 2 、4 、5 处的学生高度不匹配。<br>示例 2：</p><p>输入：heights &#x3D; [5,1,2,3,4]<br>输出：5<br>解释：<br>高度：[5,1,2,3,4]<br>预期：[1,2,3,4,5]<br>所有下标的对应学生高度都不匹配。<br>示例 3：</p><p>输入：heights &#x3D; [1,2,3,4,5]<br>输出：0<br>解释：<br>高度：[1,2,3,4,5]<br>预期：[1,2,3,4,5]<br>所有下标的对应学生高度都匹配。</p><p>提示：</p><p>1 &lt;&#x3D; heights.length &lt;&#x3D; 100<br>1 &lt;&#x3D; heights[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>排序后求</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heightChecker</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    height2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    res := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> heights&#123;        height2 = <span class="hljs-built_in">append</span>(height2, v)    &#125;    sort.Ints(height2)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(height2); i++&#123;        <span class="hljs-keyword">if</span> height2[i] != heights[i]&#123;            res ++        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了5.75%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1089. 复写零</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1089.%20%E5%A4%8D%E5%86%99%E9%9B%B6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1089.%20%E5%A4%8D%E5%86%99%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="复写零"><a href="#复写零" class="headerlink" title="复写零"></a><font size=6px>复写零</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。</p><p>注意：请不要在超过该数组长度的位置写入元素。</p><p>要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。</p><p>示例 1：</p><p>输入：[1,0,2,3,0,4,5,0]<br>输出：null<br>解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]<br>示例 2：</p><p>输入：[1,2,3]<br>输出：null<br>解释：调用函数后，输入的数组将被修改为：[1,2,3]</p><p>提示：</p><p>1 &lt;&#x3D; arr.length &lt;&#x3D; 10000<br>0 &lt;&#x3D; arr[i] &lt;&#x3D; 9</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>额外开辟n的空间来存储中间结果然后覆盖</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">duplicateZeros</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>  &#123;    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(arr))    n := <span class="hljs-built_in">len</span>(arr)    <span class="hljs-keyword">var</span> i,j <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span>  ;i&lt;n;&#123;        <span class="hljs-keyword">if</span> arr[j] != <span class="hljs-number">0</span>&#123;            res[i] = arr[j]            j++            i++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i&lt;n<span class="hljs-number">-1</span>&#123;            res[i],res[i+<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>            i += <span class="hljs-number">2</span>            j++        &#125;<span class="hljs-keyword">else</span>&#123;            i++        &#125;    &#125;    <span class="hljs-keyword">for</span> k,v :=<span class="hljs-keyword">range</span> res&#123;        arr[k] = v    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.3 MB, 在所有 Go 提交中击败了14.81%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1108. IP 地址无效化</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="IP-地址无效化"><a href="#IP-地址无效化" class="headerlink" title="IP 地址无效化"></a><font size=6px>IP 地址无效化</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。</p><p>所谓无效化 IP 地址，其实就是用 “[.]” 代替了每个 “.”。</p><p>示例 1：</p><p>输入：address &#x3D; “1.1.1.1”<br>输出：”1[.]1[.]1[.]1”<br>示例 2：</p><p>输入：address &#x3D; “255.100.50.0”<br>输出：”255[.]100[.]50[.]0”</p><p>提示：</p><p>给出的 address 是一个有效的 IPv4 地址</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>模拟</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defangIPaddr</span><span class="hljs-params">(address <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> address&#123;        <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;.&#x27;</span>&#123;            res += <span class="hljs-string">&quot;[.]&quot;</span>        &#125;<span class="hljs-keyword">else</span>&#123;            res += <span class="hljs-type">string</span>(v)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了86.23%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>113. 路径总和 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a><font size=6px>路径总和 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p><p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[]</p><p>提示：</p><p>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>dfs遍历到根节点就判断是否等于target</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode,tmp []<span class="hljs-type">int</span>,sum <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode,tmp []<span class="hljs-type">int</span>,sum <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>        &#125;        tmp = <span class="hljs-built_in">append</span>(tmp,root.Val)        sum += root.Val        dfs(root.Left,tmp,sum)        dfs(root.Right,tmp,sum)         <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> sum == targetSum&#123;                tmp2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(tmp))                <span class="hljs-built_in">copy</span>(tmp2,tmp)                res = <span class="hljs-built_in">append</span>(res,tmp2)            &#125;        &#125;    &#125;    dfs(root,[]<span class="hljs-type">int</span>&#123;&#125;,<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了85.39%的用户<br>   内存消耗：4.4 MB, 在所有 Go 提交中击败了44.71%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>112. 路径总和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><font size=6px>路径总和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。<br>示例 2：</p><p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：false<br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 –&gt; 2): 和为 3<br>(1 –&gt; 3): 和为 4<br>不存在 sum &#x3D; 5 的根节点到叶子节点的路径。<br>示例 3：</p><p>输入：root &#x3D; [], targetSum &#x3D; 0<br>输出：false<br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p><p>提示：</p><p>树中节点的数目在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>Dfs 遍历搜查</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> flag  <span class="hljs-type">bool</span>     flag = <span class="hljs-literal">false</span>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> flag    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sum <span class="hljs-type">int</span>,root *TreeNode)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sum <span class="hljs-type">int</span>,root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span>&#123;            dfs(sum+root.Val, root.Left)        &#125;        <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span>&#123;            dfs(sum+root.Val, root.Right)        &#125;        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> sum+root.Val == targetSum&#123;                flag = <span class="hljs-literal">true</span>            &#125;        &#125;    &#125;    dfs(<span class="hljs-number">0</span>, root)    <span class="hljs-keyword">return</span> flag&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了91.38%的用户<br>   内存消耗：4.4 MB, 在所有 Go 提交中击败了96.55%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>114. Flatten Binary Tree to Linked List</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/</url>
    
    <content type="html"><![CDATA[<h3 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a><font size=6px>Flatten Binary Tree to Linked List</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given the root of a binary tree, flatten the tree into a “linked list”:</p><p>The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.<br>The “linked list” should be in the same order as a pre-order traversal of the binary tree.</p><p>Example 1:</p><p>Input: root &#x3D; [1,2,5,3,4,null,6]<br>Output: [1,null,2,null,3,null,4,null,5,null,6]<br>Example 2:</p><p>Input: root &#x3D; []<br>Output: []<br>Example 3:</p><p>Input: root &#x3D; [0]<br>Output: [0]</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [0, 2000].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>Follow up: Can you flatten the tree in-place (with O(1) extra space)?</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;    curr := root    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">if</span> curr.Left != <span class="hljs-literal">nil</span> &#123;            next := curr.Left            predecessor := next            <span class="hljs-keyword">for</span> predecessor.Right != <span class="hljs-literal">nil</span> &#123;                predecessor = predecessor.Right            &#125;            predecessor.Right = curr.Right            curr.Left, curr.Right = <span class="hljs-literal">nil</span>, next        &#125;        curr = curr.Right    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了98.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1143. 最长公共子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><font size=6px>最长公共子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。<br>示例 2：</p><p>输入：text1 &#x3D; “abc”, text2 &#x3D; “abc”<br>输出：3<br>解释：最长公共子序列是 “abc” ，它的长度为 3 。<br>示例 3：</p><p>输入：text1 &#x3D; “abc”, text2 &#x3D; “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0 。</p><p>提示：</p><p>1 &lt;&#x3D; text1.length, text2.length &lt;&#x3D; 1000<br>text1 和 text2 仅由小写英文字符组成。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span></code></pre><p>dp</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(text1),<span class="hljs-built_in">len</span>(text2)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,m+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=n;j++&#123;            <span class="hljs-keyword">if</span> text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>]&#123;                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])            &#125;                    &#125;    &#125;    <span class="hljs-keyword">return</span> dp[m][n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了76.63%的用户<br>   内存消耗：10.5 MB, 在所有 Go 提交中击败了90.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>115. 不同的子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/115.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/115.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><font size=6px>不同的子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p>示例 1：</p><p>输入：s &#x3D; “rabbbit”, t &#x3D; “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。<br>rabbbit<br>rabbbit<br>rabbbit<br>示例 2：</p><p>输入：s &#x3D; “babgbag”, t &#x3D; “bag”<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 “bag” 的方案。<br>babgbag<br>babgbag<br>babgbag<br>babgbag<br>babgbag</p><p>提示：</p><p>0 &lt;&#x3D; s.length, t.length &lt;&#x3D; 1000<br>s 和 t 由英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span></code></pre><p>使用dp做，有两个字符串使用二维dp，如果相同dp[i] [j] &#x3D; dp[i-1] [j-1]+dp[i-1] [j]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(s),<span class="hljs-built_in">len</span>(t)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=m;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j&lt;=n ; j++&#123;            <span class="hljs-keyword">if</span> s[i<span class="hljs-number">-1</span>] == t[j<span class="hljs-number">-1</span>]&#123;                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-1</span>][j]            &#125;<span class="hljs-keyword">else</span> &#123;                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]            &#125;        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> dp[m][n]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了84.24%的用户<br>   内存消耗：14.3 MB, 在所有 Go 提交中击败了63.42%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1184. 公交站间的距离</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1184.%20%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1184.%20%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="公交站间的距离"><a href="#公交站间的距离" class="headerlink" title="公交站间的距离"></a><font size=6px>公交站间的距离</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。</p><p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p><p>返回乘客从出发点 start 到目的地 destination 之间的最短距离。</p><p>示例 1：</p><p>输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 1<br>输出：1<br>解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。</p><p>示例 2：</p><p>输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 2<br>输出：3<br>解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。</p><p>示例 3：</p><p>输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 3<br>输出：4<br>解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 10^4<br>distance.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; start, destination &lt; n<br>0 &lt;&#x3D; distance[i] &lt;&#x3D; 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>比较两条路哪条比较近</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">distanceBetweenBusStops</span><span class="hljs-params">(distance []<span class="hljs-type">int</span>, start <span class="hljs-type">int</span>, destination <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(distance)    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> start &gt;destination&#123;        start,destination = destination,start    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> i&gt;=start &amp;&amp; i &lt; destination&#123;            a+= distance[i]        &#125;<span class="hljs-keyword">else</span>&#123;            b += distance[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> min(a,b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.6 MB, 在所有 Go 提交中击败了65.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1186. 删除一次得到子数组最大和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1186.%20%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1%E5%BE%97%E5%88%B0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1186.%20%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1%E5%BE%97%E5%88%B0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="删除一次得到子数组最大和"><a href="#删除一次得到子数组最大和" class="headerlink" title="删除一次得到子数组最大和"></a><font size=6px>删除一次得到子数组最大和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p><p>注意，删除一个元素后，子数组 不能为空。</p><p>示例 1：</p><p>输入：arr &#x3D; [1,-2,0,3]<br>输出：4<br>解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。<br>示例 2：</p><p>输入：arr &#x3D; [1,-2,-2,3]<br>输出：3<br>解释：我们直接选出 [3]，这就是最大和。<br>示例 3：</p><p>输入：arr &#x3D; [-1,-1,-1,-1]<br>输出：-1<br>解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。<br>     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。</p><p>提示：</p><p>1 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; arr[i] &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划题，dp[1][i] &#x3D; max(dp[0][i - 1], dp[1][i - 1] + arr[i])是关键</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumSum</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(arr)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span> , <span class="hljs-number">2</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    &#125;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>]    res := arr[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;        dp[<span class="hljs-number">0</span>][i] = max(dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + arr[i], arr[i])        dp[<span class="hljs-number">1</span>][i] = max(dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + arr[i])        res = max(res, max(dp[<span class="hljs-number">0</span>][i], dp[<span class="hljs-number">1</span>][i]))    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a &gt; b &#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：28 ms, 在所有 Go 提交中击败了85.71%的用户<br>   内存消耗：9.4 MB, 在所有 Go 提交中击败了32.14%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1175. 质数排列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1175.%20%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1175.%20%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="质数排列"><a href="#质数排列" class="headerlink" title="质数排列"></a><font size=6px>质数排列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。</p><p>让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。</p><p>由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。</p><p>示例 1：</p><p>输入：n &#x3D; 5<br>输出：12<br>解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。<br>示例 2：</p><p>输入：n &#x3D; 100<br>输出：682289015</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>数学题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numPrimeArrangements</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> primeSum <span class="hljs-type">int</span>    res := <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        <span class="hljs-keyword">if</span> isprime(i)&#123;            primeSum++        &#125;    &#125;     <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=primeSum;i++&#123;        res *= i        res %= <span class="hljs-number">1000000007</span>    &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=(n-primeSum);i++&#123;        res *= i        res %= <span class="hljs-number">1000000007</span>    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isprime</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">if</span> a == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> a == <span class="hljs-number">2</span>|| a == <span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=a/<span class="hljs-number">2</span>;i++&#123;        <span class="hljs-keyword">if</span> a %i == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了8.70%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>119. 杨辉三角 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="杨辉三角-II"><a href="#杨辉三角-II" class="headerlink" title="杨辉三角 II"></a><font size=6px>杨辉三角 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p>示例 1:</p><p>输入: rowIndex &#x3D; 3<br>输出: [1,3,3,1]<br>示例 2:</p><p>输入: rowIndex &#x3D; 0<br>输出: [1]<br>示例 3:</p><p>输入: rowIndex &#x3D; 1<br>输出: [1,1]</p><p>提示:</p><p>0 &lt;&#x3D; rowIndex &lt;&#x3D; 33</p><p>进阶：</p><p>你可以优化你的算法到 O(rowIndex) 空间复杂度吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRow</span><span class="hljs-params">(rowIndex <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    C := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, rowIndex+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> C &#123;        C[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, i+<span class="hljs-number">1</span>)        C[i][<span class="hljs-number">0</span>], C[i][i] = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; i; j++ &#123;            C[i][j] = C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + C[i<span class="hljs-number">-1</span>][j]        &#125;    &#125;    <span class="hljs-keyword">return</span> C[rowIndex]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1189. “气球” 的最大数量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1189.%20%E2%80%9C%E6%B0%94%E7%90%83%E2%80%9D%20%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1189.%20%E2%80%9C%E6%B0%94%E7%90%83%E2%80%9D%20%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Maximum-Number-of-Balloons"><a href="#Maximum-Number-of-Balloons" class="headerlink" title="Maximum Number of Balloons"></a><font size=6px>Maximum Number of Balloons</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given a string text, you want to use the characters of text to form as many instances of the word “balloon” as possible.</p><p>You can use each character in text at most once. Return the maximum number of instances that can be formed.</p><p>Example 1:</p><p>Input: text &#x3D; “nlaebolko”<br>Output: 1<br>Example 2:</p><p>Input: text &#x3D; “loonbalxballpoon”<br>Output: 2<br>Example 3:</p><p>Input: text &#x3D; “leetcode”<br>Output: 0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找这些词的频率，找到最短板的单词即可</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxNumberOfBalloons</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)    <span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-built_in">len</span>(text); i++&#123;        <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;b&#x27;</span>&#123;            s[<span class="hljs-number">0</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;a&#x27;</span>&#123;            s[<span class="hljs-number">1</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;l&#x27;</span>&#123;            s[<span class="hljs-number">2</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;o&#x27;</span>&#123;            s[<span class="hljs-number">3</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;n&#x27;</span>&#123;            s[<span class="hljs-number">4</span>]++        &#125;    &#125;     s[<span class="hljs-number">2</span>] /= <span class="hljs-number">2</span>    s[<span class="hljs-number">3</span>] /= <span class="hljs-number">2</span>    sort.Ints(s)    <span class="hljs-keyword">return</span> s[<span class="hljs-number">0</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1191. K 次串联后最大子数组之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1191.%20K%20%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1191.%20K%20%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="K-次串联后最大子数组之和"><a href="#K-次串联后最大子数组之和" class="headerlink" title="K 次串联后最大子数组之和"></a><font size=6px>K 次串联后最大子数组之和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 arr 和一个整数 k。</p><p>首先，我们要对该数组进行修改，即把原数组 arr 重复 k 次。</p><p>举个例子，如果 arr &#x3D; [1, 2] 且 k &#x3D; 3，那么修改后的数组就是 [1, 2, 1, 2, 1, 2]。</p><p>然后，请你返回修改后的数组中的最大的子数组之和。</p><p>注意，子数组长度可以是 0，在这种情况下它的总和也是 0。</p><p>由于 结果可能会很大，所以需要 模（mod） 10^9 + 7 后再返回。 </p><p>示例 1：</p><p>输入：arr &#x3D; [1,2], k &#x3D; 3<br>输出：9<br>示例 2：</p><p>输入：arr &#x3D; [1,-2,1], k &#x3D; 5<br>输出：2<br>示例 3：</p><p>输入：arr &#x3D; [-1,-2], k &#x3D; 7<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5<br>1 &lt;&#x3D; k &lt;&#x3D; 10^5<br>-10^4 &lt;&#x3D; arr[i] &lt;&#x3D; 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>需要考虑三种情况，k&#x3D;1,k&#x3D;2,k&gt;2,k&#x3D;1就是最大子序列问题，k&#x3D;2是两个连续最大子序列问题，k&gt;2是max(ans2,(ans2+(k-2) * sum) ) ，ans2是k&#x3D;2时最大连续子序列的大小。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kConcatenationMaxSum</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> r ,ans, ans2 <span class="hljs-type">int</span>    base := <span class="hljs-number">1000000007</span>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;        r = max(r+arr[i], arr[i])        ans = max(r, ans)        sum += arr[i]    &#125;    <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> ans %base    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(arr); i++&#123;        r= max(r+arr[i], arr[i])        ans2 = max(r, ans2)    &#125;    <span class="hljs-keyword">if</span> k ==<span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> ans2 % base    &#125;    <span class="hljs-keyword">return</span> max(ans2,(ans2+(k<span class="hljs-number">-2</span>) * sum) % base) % base&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：52 ms, 在所有 Go 提交中击败了85.71%的用户<br>   内存消耗：8.3 MB, 在所有 Go 提交中击败了50.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1200. 最小绝对差</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1200.%20%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1200.%20%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="最小绝对差"><a href="#最小绝对差" class="headerlink" title="最小绝对差"></a><font size=6px>最小绝对差</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你个整数数组 arr，其中每个元素都 不相同。</p><p>请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。</p><p>示例 1：</p><p>输入：arr &#x3D; [4,2,1,3]<br>输出：[[1,2],[2,3],[3,4]]<br>示例 2：</p><p>输入：arr &#x3D; [1,3,6,10,15]<br>输出：[[1,3]]<br>示例 3：</p><p>输入：arr &#x3D; [3,8,-10,23,19,-4,-14,27]<br>输出：[[-14,-10],[19,23],[23,27]]</p><p>提示：</p><p>2 &lt;&#x3D; arr.length &lt;&#x3D; 10^5<br>-10^6 &lt;&#x3D; arr[i] &lt;&#x3D; 10^6</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>排序后两个数字间比较</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumAbsDifference</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    n := <span class="hljs-built_in">len</span>(arr)    sort.Ints(arr)    minNum := <span class="hljs-number">9999999</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> arr[i]-arr[i<span class="hljs-number">-1</span>]&lt;minNum&#123;            minNum = arr[i]-arr[i<span class="hljs-number">-1</span>]            res = [][]<span class="hljs-type">int</span>&#123;&#125;            res = <span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;arr[i<span class="hljs-number">-1</span>],arr[i]&#125;)        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> arr[i]-arr[i<span class="hljs-number">-1</span>] == minNum&#123;            res = <span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;arr[i<span class="hljs-number">-1</span>],arr[i]&#125;)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：60 ms, 在所有 Go 提交中击败了94.52%的用户<br>   内存消耗：8.1 MB, 在所有 Go 提交中击败了82.19%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1217. 玩筹码</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1217.%20%E7%8E%A9%E7%AD%B9%E7%A0%81/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1217.%20%E7%8E%A9%E7%AD%B9%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="玩筹码"><a href="#玩筹码" class="headerlink" title="玩筹码"></a><font size=6px>玩筹码</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个筹码。第 i 个筹码的位置是 position[i] 。</p><p>我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 i 个筹码的位置从 position[i] 改变为:</p><p>position[i] + 2 或 position[i] - 2 ，此时 cost &#x3D; 0<br>position[i] + 1 或 position[i] - 1 ，此时 cost &#x3D; 1<br>返回将所有筹码移动到同一位置上所需要的 最小代价 。</p><p>示例 1：</p><p>输入：position &#x3D; [1,2,3]<br>输出：1<br>解释：第一步:将位置3的筹码移动到位置1，成本为0。<br>第二步:将位置2的筹码移动到位置1，成本&#x3D; 1。<br>总成本是1。<br>示例 2：</p><p>输入：position &#x3D; [2,2,2,3,3]<br>输出：2<br>解释：我们可以把位置3的两个筹码移到位置2。每一步的成本为1。总成本&#x3D; 2。<br>示例 3:</p><p>输入：position &#x3D; [1,1000000000]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; chips.length &lt;&#x3D; 100<br>1 &lt;&#x3D; chips[i] &lt;&#x3D; 10^9</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>最小奇偶数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostToMoveChips</span><span class="hljs-params">(position []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> position&#123;        <span class="hljs-keyword">if</span> v %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;            a++        &#125;<span class="hljs-keyword">else</span>&#123;            b++        &#125;    &#125;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了64.44%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1219. 黄金矿工</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1219.%20%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1219.%20%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="黄金矿工"><a href="#黄金矿工" class="headerlink" title="黄金矿工"></a><font size=6px>黄金矿工</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。</p><p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p><p>每当矿工进入一个单元，就会收集该单元格中的所有黄金。<br>矿工每次可以从当前位置向上下左右四个方向走。<br>每个单元格只能被开采（进入）一次。<br>不得开采（进入）黄金数目为 0 的单元格。<br>矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。</p><p>示例 1：</p><p>输入：grid &#x3D; [[0,6,0],[5,8,7],[0,9,0]]<br>输出：24<br>解释：<br>[[0,6,0],<br> [5,8,7],<br> [0,9,0]]<br>一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。<br>示例 2：</p><p>输入：grid &#x3D; [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]<br>输出：28<br>解释：<br>[[1,0,7],<br> [2,0,6],<br> [3,4,5],<br> [0,3,0],<br> [9,0,20]]<br>一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>带回溯的dfs题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">var</span> dirs = []<span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMaximumGold</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y, gold <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y, gold <span class="hljs-type">int</span>)</span></span> &#123;        gold += grid[x][y]        <span class="hljs-keyword">if</span> gold &gt; ans &#123;            ans = gold        &#125;        rec := grid[x][y]        grid[x][y] = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;            nx, ny := x+d.x, y+d.y            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &amp;&amp; nx &lt; <span class="hljs-built_in">len</span>(grid) &amp;&amp; <span class="hljs-number">0</span> &lt;= ny &amp;&amp; ny &lt; <span class="hljs-built_in">len</span>(grid[nx]) &amp;&amp; grid[nx][ny] &gt; <span class="hljs-number">0</span> &#123;                dfs(nx, ny, gold)            &#125;        &#125;        grid[x][y] = rec    &#125;    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;        <span class="hljs-keyword">for</span> j, gold := <span class="hljs-keyword">range</span> row &#123;            <span class="hljs-keyword">if</span> gold &gt; <span class="hljs-number">0</span> &#123;                dfs(i, j, <span class="hljs-number">0</span>)            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>124. Binary Tree Maximum Path Sum</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/124.%20Binary%20Tree%20Maximum%20Path%20Sum/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/124.%20Binary%20Tree%20Maximum%20Path%20Sum/</url>
    
    <content type="html"><![CDATA[<h3 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a><font size=6px>Binary Tree Maximum Path Sum</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.</p><p>The path sum of a path is the sum of the node’s values in the path.</p><p>Given the root of a binary tree, return the maximum path sum of any non-empty path.</p><p>Example 1:</p><p>Input: root &#x3D; [1,2,3]<br>Output: 6<br>Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 &#x3D; 6.<br>Example 2:</p><p>Input: root &#x3D; [-10,9,20,null,null,15,7]<br>Output: 42<br>Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [1, 3 * 104].<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用dfs遍历，返回左或者右子树加上自身值的最大值，算最大值的时候需要特殊处理，需要计算左+右子树+自身值是否是最大值，是就更换最大值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    maxNum := <span class="hljs-number">-99999</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><span class="hljs-type">int</span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><span class="hljs-type">int</span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;        l := dfs(root.Left)        r := dfs(root.Right)        maxNum = max(maxNum, max(root.Val, max(root.Val+l,max(root.Val+r, root.Val+r+l))))        root.Val = max(root.Val, max(root.Val+l,root.Val+r))        <span class="hljs-keyword">return</span> root.Val    &#125;    dfs(root)    <span class="hljs-keyword">return</span> maxNum    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> i &gt;j&#123;        <span class="hljs-keyword">return</span> i    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> j    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了80.91%的用户<br>   内存消耗：7.4 MB, 在所有 Go 提交中击败了89.68%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>118. 杨辉三角</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    
    <content type="html"><![CDATA[<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a><font size=6px>杨辉三角</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p>示例 1:</p><p>输入: numRows &#x3D; 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br>示例 2:</p><p>输入: numRows &#x3D; 1<br>输出: [[1]]</p><p>提示:</p><p>1 &lt;&#x3D; numRows &lt;&#x3D; 30</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generate</span><span class="hljs-params">(numRows <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    ans := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, numRows)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ans &#123;        ans[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, i+<span class="hljs-number">1</span>)        ans[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>        ans[i][i] = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; i; j++ &#123;            ans[i][j] = ans[i<span class="hljs-number">-1</span>][j] + ans[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]        &#125;    &#125;    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了55.44%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1260. 二维网格迁移</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="二维网格迁移"><a href="#二维网格迁移" class="headerlink" title="二维网格迁移"></a><font size=6px>二维网格迁移</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。</p><p>每次「迁移」操作将会引发下述活动：</p><p>位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。<br>位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。<br>位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。<br>请你返回 k 次迁移操作后最终得到的 二维网格。</p><p>示例 1：</p><p>输入：grid &#x3D; [[1,2,3],[4,5,6],[7,8,9]], k &#x3D; 1<br>输出：[[9,1,2],[3,4,5],[6,7,8]]<br>示例 2：</p><p>输入：grid &#x3D; [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k &#x3D; 4<br>输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]<br>示例 3：</p><p>输入：grid &#x3D; [[1,2,3],[4,5,6],[7,8,9]], k &#x3D; 9<br>输出：[[1,2,3],[4,5,6],[7,8,9]]</p><p>提示：</p><p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m &lt;&#x3D; 50<br>1 &lt;&#x3D; n &lt;&#x3D; 50<br>-1000 &lt;&#x3D; grid[i][j] &lt;&#x3D; 1000<br>0 &lt;&#x3D; k &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span><span class="hljs-operator">*</span><span class="hljs-params">m</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span><span class="hljs-operator">*</span><span class="hljs-params">m</span>)</span></code></pre><p>变成一维位移后再变成二维</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shiftGrid</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;       m,n := <span class="hljs-built_in">len</span>(grid),<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    <span class="hljs-keyword">var</span> tmp []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            tmp = <span class="hljs-built_in">append</span>(tmp,grid[i][j])        &#125;    &#125;    k = k%(m*n)    tmp2 := tmp[m*n-k:]    tmp = tmp[:m*n-k]    tmp = <span class="hljs-built_in">append</span>(tmp2,tmp...)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            grid[i][j] = tmp[i*n+j]        &#125;    &#125;    <span class="hljs-keyword">return</span> grid&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了95.12%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了90.24%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1282. 用户分组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1282.%20%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1282.%20%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="用户分组"><a href="#用户分组" class="headerlink" title="用户分组"></a><font size=6px>用户分组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个人被分成数量未知的组。每个人都被标记为一个从 0 到 n - 1 的唯一ID 。</p><p>给定一个整数数组 groupSizes ，其中 groupSizes[i] 是第 i 个人所在的组的大小。例如，如果 groupSizes[1] &#x3D; 3 ，则第 1 个人必须位于大小为 3 的组中。</p><p>返回一个组列表，使每个人 i 都在一个大小为 groupSizes[i] 的组中。</p><p>每个人应该 恰好只 出现在 一个组 中，并且每个人必须在一个组中。如果有多个答案，返回其中 任何 一个。可以 保证 给定输入 至少有一个 有效的解。</p><p>示例 1：</p><p>输入：groupSizes &#x3D; [3,3,3,3,3,1,3]<br>输出：[[5],[0,1,2],[3,4,6]]<br>解释：<br>第一组是 [5]，大小为 1，groupSizes[5] &#x3D; 1。<br>第二组是 [0,1,2]，大小为 3，groupSizes[0] &#x3D; groupSizes[1] &#x3D; groupSizes[2] &#x3D; 3。<br>第三组是 [3,4,6]，大小为 3，groupSizes[3] &#x3D; groupSizes[4] &#x3D; groupSizes[6] &#x3D; 3。<br>其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。<br>示例 2：</p><p>输入：groupSizes &#x3D; [2,1,3,3,3,2]<br>输出：[[1],[0,5],[2,3,4]]</p><p>提示：</p><p>groupSizes.length &#x3D;&#x3D; n<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>1 &lt;&#x3D; groupSizes[i] &lt;&#x3D; n</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">groupThePeople</span><span class="hljs-params">(groupSizes []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(groupSizes); i++&#123;        mp[groupSizes[i]] = <span class="hljs-built_in">append</span>(mp[groupSizes[i]], i)    &#125;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> mp&#123;        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(v) !=<span class="hljs-number">0</span>&#123;            res =<span class="hljs-built_in">append</span>(res,v[:k])            v = v[k:]        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了40.91%的用户<br>   内存消耗：5.2 MB, 在所有 Go 提交中击败了59.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>129. 求根节点到叶节点数字之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/129.%20%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/129.%20%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="求根节点到叶节点数字之和"><a href="#求根节点到叶节点数字之和" class="headerlink" title="求根节点到叶节点数字之和"></a><font size=6px>求根节点到叶节点数字之和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 &#x3D; 12 + 13 &#x3D; 25<br>示例 2：</p><p>输入：root &#x3D; [4,9,0,5,1]<br>输出：1026<br>解释：<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491<br>从根到叶子节点路径 4-&gt;0 代表数字 40<br>因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026</p><p>提示：</p><p>树中节点的数目在范围 [1, 1000] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9<br>树的深度不超过 10</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用dfs做就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, prevSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    sum := prevSum*<span class="hljs-number">10</span> + root.Val    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> sum    &#125;    <span class="hljs-keyword">return</span> dfs(root.Left, sum) + dfs(root.Right, sum)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了76.78%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1305. 两棵二叉搜索树中的所有元素</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1305.%20%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1305.%20%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="两棵二叉搜索树中的所有元素"><a href="#两棵二叉搜索树中的所有元素" class="headerlink" title="两棵二叉搜索树中的所有元素"></a><font size=6px>两棵二叉搜索树中的所有元素</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.</p><p>示例 1：</p><p>输入：root1 &#x3D; [2,1,4], root2 &#x3D; [1,0,3]<br>输出：[0,1,1,2,3,4]<br>示例 2：</p><p>输入：root1 &#x3D; [1,null,8], root2 &#x3D; [8,1]<br>输出：[1,1,8,8]</p><p>提示：</p><p>每棵树的节点数在 [0, 5000] 范围内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">m</span>+<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">m</span>+<span class="hljs-params">n</span>)</span></code></pre><p>中序遍历，然后有个有序数组合并</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAllElements</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res,res1,res2 []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        dfs(root.Left)        res2 = <span class="hljs-built_in">append</span>(res2, root.Val)        dfs(root.Right)    &#125;    dfs(root1)    res1 = res2    res2 = []<span class="hljs-type">int</span>&#123;&#125;    dfs(root2)    l,r ,m,n := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(res1),<span class="hljs-built_in">len</span>(res2)    <span class="hljs-keyword">for</span> l&lt;m &amp;&amp; r &lt;n&#123;        <span class="hljs-keyword">if</span> res1[l]&lt;res2[r]&#123;                       res = <span class="hljs-built_in">append</span>(res, res1[l])             l++        &#125;<span class="hljs-keyword">else</span>&#123;            res = <span class="hljs-built_in">append</span>(res, res2[r])             r++        &#125;    &#125;    <span class="hljs-keyword">for</span> ;l&lt;m;l++&#123;        res = <span class="hljs-built_in">append</span>(res, res1[l])    &#125;    <span class="hljs-keyword">for</span> ;r&lt;n;r++&#123;        res = <span class="hljs-built_in">append</span>(res, res2[r])    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：80 ms, 在所有 Go 提交中击败了86.21%的用户<br>   内存消耗：8 MB, 在所有 Go 提交中击败了63.79%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1331. 数组序号转换</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1331.%20%E6%95%B0%E7%BB%84%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1331.%20%E6%95%B0%E7%BB%84%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="数组序号转换"><a href="#数组序号转换" class="headerlink" title="数组序号转换"></a><font size=6px>数组序号转换</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。</p><p>序号代表了一个元素有多大。序号编号的规则如下：</p><p>序号从 1 开始编号。<br>一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。<br>每个数字的序号都应该尽可能地小。</p><p>示例 1：</p><p>输入：arr &#x3D; [40,10,20,30]<br>输出：[4,1,2,3]<br>解释：40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。<br>示例 2：</p><p>输入：arr &#x3D; [100,100,100]<br>输出：[1,1,1]<br>解释：所有元素有相同的序号。<br>示例 3：</p><p>输入：arr &#x3D; [37,12,28,9,100,56,80,5,12]<br>输出：[5,3,4,2,8,6,7,1,3]</p><p>提示：</p><p>0 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; arr[i] &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>使用排序，然后利用map来存位置</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">arrayRankTransform</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(arr)    arr2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    <span class="hljs-built_in">copy</span>(arr2,arr)    sort.Ints(arr2)    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)    cnt := <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> i!= <span class="hljs-number">0</span> &amp;&amp; arr2[i] == arr2[i<span class="hljs-number">-1</span>] &#123;            <span class="hljs-keyword">continue</span>        &#125;        mp[arr2[i]] = cnt        cnt ++    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        res = <span class="hljs-built_in">append</span>(res,mp[arr[i]])    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：64 ms, 在所有 Go 提交中击败了79.17%的用户<br>   内存消耗：14.2 MB, 在所有 Go 提交中击败了8.33%</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1342. 将数字变成 0 的操作次数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1342.%20%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%90%200%20%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1342.%20%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%90%200%20%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="将数字变成-0-的操作次数"><a href="#将数字变成-0-的操作次数" class="headerlink" title="将数字变成 0 的操作次数"></a><font size=6px>将数字变成 0 的操作次数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p><p>示例 1：</p><p>输入：num &#x3D; 14<br>输出：6<br>解释：<br>步骤 1) 14 是偶数，除以 2 得到 7 。<br>步骤 2） 7 是奇数，减 1 得到 6 。<br>步骤 3） 6 是偶数，除以 2 得到 3 。<br>步骤 4） 3 是奇数，减 1 得到 2 。<br>步骤 5） 2 是偶数，除以 2 得到 1 。<br>步骤 6） 1 是奇数，减 1 得到 0 。<br>示例 2：</p><p>输入：num &#x3D; 8<br>输出：4<br>解释：<br>步骤 1） 8 是偶数，除以 2 得到 4 。<br>步骤 2） 4 是偶数，除以 2 得到 2 。<br>步骤 3） 2 是偶数，除以 2 得到 1 。<br>步骤 4） 1 是奇数，减 1 得到 0 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfSteps</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> num != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> num %<span class="hljs-number">2</span> == <span class="hljs-number">1</span>&#123;            num--        &#125;<span class="hljs-keyword">else</span>&#123;            num /= <span class="hljs-number">2</span>        &#125;        count++    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1380. 矩阵中的幸运数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1380.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1380.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。</p><p>幸运数是指矩阵中满足同时下列两个条件的元素：</p><p>在同一行的所有元素中最小<br>在同一列的所有元素中最大</p><p>示例 1：</p><p>输入：matrix &#x3D; [[3,7,8],[9,11,13],[15,16,17]]<br>输出：[15]<br>解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。<br>示例 2：</p><p>输入：matrix &#x3D; [[1,10,4,2],[9,3,8,7],[15,16,17,12]]<br>输出：[12]<br>解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。<br>示例 3：</p><p>输入：matrix &#x3D; [[7,8],[1,2]]<br>输出：[7]</p><p>提示：</p><p>m &#x3D;&#x3D; mat.length<br>n &#x3D;&#x3D; mat[i].length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 50<br>1 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 10^5<br>矩阵中的所有元素都是不同的</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找到每一行最小的和每一列最大的，他们之间的相同数就是答案，用哈希了，内存占用比较大。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">luckyNumbers</span> <span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    m ,n := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])    hash := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-number">100002</span>)    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        minNUm := matrix[i][<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;n;j++&#123;            minNUm = min(minNUm, matrix[i][j])        &#125;        hash[minNUm] = <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        maxNUm := matrix[<span class="hljs-number">0</span>][i]        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;m;j++&#123;            maxNUm = max(maxNUm, matrix[j][i])        &#125;        <span class="hljs-keyword">if</span> hash[maxNUm] == <span class="hljs-literal">true</span>&#123;            ans = <span class="hljs-built_in">append</span>(ans, maxNUm)        &#125;          &#125;    <span class="hljs-keyword">return</span> ans    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span>  a    &#125;    <span class="hljs-keyword">return</span> b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span>  a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：6.6 MB, 在所有 Go 提交中击败了9.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1374. 生成每种字符都是奇数个的字符串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1374.%20%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1374.%20%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="生成每种字符都是奇数个的字符串"><a href="#生成每种字符都是奇数个的字符串" class="headerlink" title="生成每种字符都是奇数个的字符串"></a><font size=6px>生成每种字符都是奇数个的字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。</p><p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p><p>示例 1：</p><p>输入：n &#x3D; 4<br>输出：”pppz”<br>解释：”pppz” 是一个满足题目要求的字符串，因为 ‘p’ 出现 3 次，且 ‘z’ 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：”ohhh” 和 “love”。<br>示例 2：</p><p>输入：n &#x3D; 2<br>输出：”xy”<br>解释：”xy” 是一个满足题目要求的字符串，因为 ‘x’ 和 ‘y’ 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：”ag” 和 “ur”。<br>示例 3：</p><p>输入：n &#x3D; 7<br>输出：”holasss”</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 500</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>放松题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateTheString</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-1</span>;i++&#123;        res += <span class="hljs-string">&quot;a&quot;</span>    &#125;    <span class="hljs-keyword">if</span> n %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;        res += <span class="hljs-string">&quot;b&quot;</span>    &#125;<span class="hljs-keyword">else</span>&#123;        res += <span class="hljs-string">&quot;a&quot;</span>    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：5.4 MB, 在所有 Go 提交中击败了35.29%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1314. 矩阵区域和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1314.%20%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1314.%20%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="矩阵区域和"><a href="#矩阵区域和" class="headerlink" title="矩阵区域和"></a><font size=6px>矩阵区域和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： </p><p>i - k &lt;&#x3D; r &lt;&#x3D; i + k,<br>j - k &lt;&#x3D; c &lt;&#x3D; j + k 且<br>(r, c) 在矩阵内。</p><p>示例 1：</p><p>输入：mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]], k &#x3D; 1<br>输出：[[12,21,16],[27,45,33],[24,39,28]]<br>示例 2：</p><p>输入：mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]], k &#x3D; 2<br>输出：[[45,45,45],[45,45,45],[45,45,45]]</p><p>提示：</p><p>m &#x3D;&#x3D; mat.length<br>n &#x3D;&#x3D; mat[i].length<br>1 &lt;&#x3D; m, n, k &lt;&#x3D; 100<br>1 &lt;&#x3D; mat[i][j] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><p>得先求得二维矩阵前缀和的方法</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">matrixBlockSum</span><span class="hljs-params">(mat [][]<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(mat), <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)    res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=m;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        res[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=n;j++&#123;            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>] - dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+ mat[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            li,lj,ri,rj := max(<span class="hljs-number">0</span>,i-k),max(<span class="hljs-number">0</span>,j-k), min(m,i+k+<span class="hljs-number">1</span>),min(n, j+k+<span class="hljs-number">1</span>)            res[i][j] = dp[ri][rj] - dp[li][rj] - dp[ri][lj] + dp[li][lj]        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了81.40%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了46.51%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1408. 数组中的字符串匹配</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1408.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1408.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="数组中的字符串匹配"><a href="#数组中的字符串匹配" class="headerlink" title="数组中的字符串匹配"></a><font size=6px>数组中的字符串匹配</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。</p><p>如果你可以删除 words[j] 最左侧和&#x2F;或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。</p><p>示例 1：</p><p>输入：words &#x3D; [“mass”,”as”,”hero”,”superhero”]<br>输出：[“as”,”hero”]<br>解释：”as” 是 “mass” 的子字符串，”hero” 是 “superhero” 的子字符串。<br>[“hero”,”as”] 也是有效的答案。<br>示例 2：</p><p>输入：words &#x3D; [“leetcode”,”et”,”code”]<br>输出：[“et”,”code”]<br>解释：”et” 和 “code” 都是 “leetcode” 的子字符串。<br>示例 3：</p><p>输入：words &#x3D; [“blue”,”green”,”bu”]<br>输出：[]</p><p>提示：</p><p>1 &lt;&#x3D; words.length &lt;&#x3D; 100<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 30<br>words[i] 仅包含小写英文字母。<br>题目数据 保证 每个 words[i] 都是独一无二的。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O()</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stringMatching</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> (ret []<span class="hljs-type">string</span>) &#123;sentence := strings.Join(words, <span class="hljs-string">&quot;,&quot;</span>)<span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> words &#123;<span class="hljs-keyword">if</span> strings.Index(sentence, word) != strings.LastIndex(sentence, word) &#123;ret = <span class="hljs-built_in">append</span>(ret, word)&#125;&#125;<span class="hljs-keyword">return</span> &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了45.16%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1405. 最长快乐字符串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1405.%20%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1405.%20%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="最长快乐字符串"><a href="#最长快乐字符串" class="headerlink" title="最长快乐字符串"></a><font size=6px>最长快乐字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>如果字符串中不含有任何 ‘aaa’，’bbb’ 或 ‘ccc’ 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</p><p>给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：</p><p>s 是一个尽可能长的快乐字符串。<br>s 中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。<br>s 中只含有 ‘a’、’b’ 、’c’ 三种字母。<br>如果不存在这样的字符串 s ，请返回一个空字符串 “”。</p><p>示例 1：</p><p>输入：a &#x3D; 1, b &#x3D; 1, c &#x3D; 7<br>输出：”ccaccbcc”<br>解释：”ccbccacc” 也是一种正确答案。<br>示例 2：</p><p>输入：a &#x3D; 2, b &#x3D; 2, c &#x3D; 1<br>输出：”aabbc”<br>示例 3：</p><p>输入：a &#x3D; 7, b &#x3D; 1, c &#x3D; 0<br>输出：”aabaa”<br>解释：这是该测试用例的唯一正确答案。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>贪心算法，每次选择个数最多的一个字母，如果连续两次使用相同字母，下次就需要使用第二多的字母。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestDiverseString</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>, c <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    ans := []<span class="hljs-type">byte</span>&#123;&#125;    cnt := []<span class="hljs-keyword">struct</span>&#123; c <span class="hljs-type">int</span>; ch <span class="hljs-type">byte</span> &#125;&#123;&#123;a, <span class="hljs-string">&#x27;a&#x27;</span>&#125;, &#123;b, <span class="hljs-string">&#x27;b&#x27;</span>&#125;, &#123;c, <span class="hljs-string">&#x27;c&#x27;</span>&#125;&#125;    <span class="hljs-keyword">for</span> &#123;        sort.Slice(cnt, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> cnt[i].c &gt; cnt[j].c &#125;)        <span class="hljs-keyword">if</span> cnt[<span class="hljs-number">0</span>].c == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">break</span>        &#125;        ans = <span class="hljs-built_in">append</span>(ans, cnt[<span class="hljs-number">0</span>].ch)        cnt[<span class="hljs-number">0</span>].c --;        sort.Slice(cnt, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> cnt[i].c &gt; cnt[j].c &#125;)        <span class="hljs-keyword">if</span> cnt[<span class="hljs-number">0</span>].c == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">break</span>        &#125;        ans = <span class="hljs-built_in">append</span>(ans, cnt[<span class="hljs-number">0</span>].ch)        cnt[<span class="hljs-number">0</span>].c--        <span class="hljs-keyword">if</span> ans[<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-1</span>] == ans[<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-2</span>]&#123;            <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">1</span>].c) &gt;<span class="hljs-number">0</span>&#123;                ans = <span class="hljs-built_in">append</span>(ans, cnt[<span class="hljs-number">1</span>].ch)                cnt[<span class="hljs-number">1</span>].c--            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(ans)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了82.41%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1413. 逐步求和得到正数的最小值</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1413.%20%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1413.%20%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="逐步求和得到正数的最小值"><a href="#逐步求和得到正数的最小值" class="headerlink" title="逐步求和得到正数的最小值"></a><font size=6px>逐步求和得到正数的最小值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。</p><p>你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。</p><p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。</p><p>示例 1：</p><p>输入：nums &#x3D; [-3,2,-3,4,2]<br>输出：5<br>解释：如果你选择 startValue &#x3D; 4，在第三次累加时，和小于 1 。<br>                累加求和<br>                startValue &#x3D; 4 | startValue &#x3D; 5 | nums<br>                  (4 -3 ) &#x3D; 1  | (5 -3 ) &#x3D; 2    |  -3<br>                  (1 +2 ) &#x3D; 3  | (2 +2 ) &#x3D; 4    |   2<br>                  (3 -3 ) &#x3D; 0  | (4 -3 ) &#x3D; 1    |  -3<br>                  (0 +4 ) &#x3D; 4  | (1 +4 ) &#x3D; 5    |   4<br>                  (4 +2 ) &#x3D; 6  | (5 +2 ) &#x3D; 7    |   2<br>示例 2：</p><p>输入：nums &#x3D; [1,2]<br>输出：1<br>解释：最小的 startValue 需要是正数。<br>示例 3：</p><p>输入：nums &#x3D; [1,-2,-3]<br>输出：5</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>-100 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>题目意思是累加求一个最小数然后去反加1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minStartValue</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    accSum, accSumMin := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;        accSum += num        accSumMin = min(accSumMin, accSum)    &#125;    <span class="hljs-keyword">return</span> -accSumMin + <span class="hljs-number">1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a &gt; b &#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1414. 和为 K 的最少斐波那契数字数目</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1414.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1414.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="和为-K-的最少斐波那契数字数目"><a href="#和为-K-的最少斐波那契数字数目" class="headerlink" title="和为 K 的最少斐波那契数字数目"></a><font size=6px>和为 K 的最少斐波那契数字数目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p><p>斐波那契数字定义为：</p><p>F1 &#x3D; 1<br>F2 &#x3D; 1<br>Fn &#x3D; Fn-1 + Fn-2 ， 其中 n &gt; 2 。<br>数据保证对于给定的 k ，一定能找到可行解。</p><p>示例 1：</p><p>输入：k &#x3D; 7<br>输出：2<br>解释：斐波那契数字为：1，1，2，3，5，8，13，……<br>对于 k &#x3D; 7 ，我们可以得到 2 + 5 &#x3D; 7 。<br>示例 2：</p><p>输入：k &#x3D; 10<br>输出：2<br>解释：对于 k &#x3D; 10 ，我们可以得到 2 + 8 &#x3D; 10 。<br>示例 3：</p><p>输入：k &#x3D; 19<br>输出：3<br>解释：对于 k &#x3D; 19 ，我们可以得到 1 + 5 + 13 &#x3D; 19 。</p><p>提示：</p><p>1 &lt;&#x3D; k &lt;&#x3D; 10^9</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>​    先找到斐波那切数列第一个大于k的数字，之后从后往前找减去这个数的第一个大于的数字。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMinFibonacciNumbers</span><span class="hljs-params">(k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> fibo []<span class="hljs-type">int</span>    fibo = <span class="hljs-built_in">append</span>(fibo, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>)    i := <span class="hljs-number">1</span>    count := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> fibo[i] &lt;=k&#123;        fibo = <span class="hljs-built_in">append</span>(fibo, fibo[i<span class="hljs-number">-1</span>]+fibo[i])        i++    &#125;       <span class="hljs-keyword">for</span> k != <span class="hljs-number">0</span>&#123;       <span class="hljs-keyword">if</span> fibo[i]&lt;=k&#123;           k -= fibo[i]             count++       &#125;        i--   &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了33.33%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1417. 重新格式化字符串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1417.%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1417.%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="重新格式化字符串"><a href="#重新格式化字符串" class="headerlink" title="重新格式化字符串"></a><font size=6px>重新格式化字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。</p><p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p><p>请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。</p><p>示例 1：</p><p>输入：s &#x3D; “a0b1c2”<br>输出：”0a1b2c”<br>解释：”0a1b2c” 中任意两个相邻字符的类型都不同。 “a0b1c2”, “0a1b2c”, “0c2a1b” 也是满足题目要求的答案。<br>示例 2：</p><p>输入：s &#x3D; “leetcode”<br>输出：””<br>解释：”leetcode” 中只有字母，所以无法满足重新格式化的条件。<br>示例 3：</p><p>输入：s &#x3D; “1229857369”<br>输出：””<br>解释：”1229857369” 中只有数字，所以无法满足重新格式化的条件。<br>示例 4：</p><p>输入：s &#x3D; “covid2019”<br>输出：”c2o0v1i9d”<br>示例 5：</p><p>输入：s &#x3D; “ab123”<br>输出：”1a2b3”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 500<br>s 仅由小写英文字母和&#x2F;或数字组成。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>只需要计算字母和数字的数量就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reformat</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> ss,num,res []<span class="hljs-type">byte</span>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++ &#123;        <span class="hljs-keyword">if</span> s[i] &gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&#123;            num = <span class="hljs-built_in">append</span>(num, s[i])        &#125;<span class="hljs-keyword">else</span>&#123;            ss = <span class="hljs-built_in">append</span>(ss, s[i])        &#125;    &#125;    <span class="hljs-keyword">if</span> abs(<span class="hljs-built_in">len</span>(num)-<span class="hljs-built_in">len</span>(ss))&lt;=<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(num) &gt;<span class="hljs-built_in">len</span>(ss)&#123;            res = <span class="hljs-built_in">append</span>(res,num[<span class="hljs-number">0</span>])            num = num[<span class="hljs-number">1</span>:]            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(num);i++&#123;                res = <span class="hljs-built_in">append</span>(res, ss[i])                res = <span class="hljs-built_in">append</span>(res, num[i])            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(num) &lt;<span class="hljs-built_in">len</span>(ss)&#123;            res = <span class="hljs-built_in">append</span>(res,ss[<span class="hljs-number">0</span>])            ss = ss[<span class="hljs-number">1</span>:]            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(num);i++&#123;                res = <span class="hljs-built_in">append</span>(res, num[i])                res = <span class="hljs-built_in">append</span>(res, ss[i])            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(num);i++&#123;                res = <span class="hljs-built_in">append</span>(res, ss[i])                res = <span class="hljs-built_in">append</span>(res, num[i])                            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(res)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a &lt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> -a    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3 MB, 在所有 Go 提交中击败了65.71%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1422. 分割字符串的最大得分</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1422.%20%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1422.%20%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="分割字符串的最大得分"><a href="#分割字符串的最大得分" class="headerlink" title="分割字符串的最大得分"></a><font size=6px>分割字符串的最大得分</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。</p><p>「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。</p><p>示例 1：</p><p>输入：s &#x3D; “011101”<br>输出：5<br>解释：<br>将字符串 s 划分为两个非空子字符串的可行方案有：<br>左子字符串 &#x3D; “0” 且 右子字符串 &#x3D; “11101”，得分 &#x3D; 1 + 4 &#x3D; 5<br>左子字符串 &#x3D; “01” 且 右子字符串 &#x3D; “1101”，得分 &#x3D; 1 + 3 &#x3D; 4<br>左子字符串 &#x3D; “011” 且 右子字符串 &#x3D; “101”，得分 &#x3D; 1 + 2 &#x3D; 3<br>左子字符串 &#x3D; “0111” 且 右子字符串 &#x3D; “01”，得分 &#x3D; 1 + 1 &#x3D; 2<br>左子字符串 &#x3D; “01110” 且 右子字符串 &#x3D; “1”，得分 &#x3D; 2 + 1 &#x3D; 3<br>示例 2：</p><p>输入：s &#x3D; “00111”<br>输出：5<br>解释：当 左子字符串 &#x3D; “00” 且 右子字符串 &#x3D; “111” 时，我们得到最大得分 &#x3D; 2 + 3 &#x3D; 5<br>示例 3：</p><p>输入：s &#x3D; “1111”<br>输出：3</p><p>提示：</p><p>2 &lt;&#x3D; s.length &lt;&#x3D; 500<br>字符串 s 仅由字符 ‘0’ 和 ‘1’ 组成。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>左边遍历一次右边遍历一次记录下来0和1的数量就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    score := <span class="hljs-type">int</span>(<span class="hljs-string">&#x27;1&#x27;</span>-s[<span class="hljs-number">0</span>]) + strings.Count(s[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot;1&quot;</span>)    ans := score    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s[<span class="hljs-number">1</span> : <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] &#123;        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;0&#x27;</span> &#123;            score++        &#125; <span class="hljs-keyword">else</span> &#123;            score--        &#125;        ans = max(ans, score)    &#125;    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> b &gt; a &#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了84.21%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1403. 非递增顺序的最小子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1403.%20%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1403.%20%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="非递增顺序的最小子序列"><a href="#非递增顺序的最小子序列" class="headerlink" title="非递增顺序的最小子序列"></a><font size=6px>非递增顺序的最小子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。</p><p>如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。</p><p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p><p>注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,3,10,9,8]<br>输出：[10,9]<br>解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。<br>示例 2：</p><p>输入：nums &#x3D; [4,4,7,6,7]<br>输出：[7,7,6]<br>解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 &#x3D; 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。<br>示例 3：</p><p>输入：nums &#x3D; [6]<br>输出：[6]</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 500<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlgon</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>先排序然后再做会比较简单</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minSubsequence</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    sort.Ints(nums)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>;i++&#123;        nums[i],nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>-i] = nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>-i] ,nums[i]    &#125;    n := <span class="hljs-built_in">len</span>(nums)    sum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))    sum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        sum[i] = nums[i]+sum[i<span class="hljs-number">-1</span>]    &#125;    <span class="hljs-comment">//fmt.Println(sum)</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> sum[i]  &gt; sum[n<span class="hljs-number">-1</span>]-sum[i]&#123;            <span class="hljs-keyword">return</span> nums[:i+<span class="hljs-number">1</span>]        &#125;    &#125;    <span class="hljs-keyword">return</span> nums&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了93.48%的用户<br>   内存消耗：3.2 MB, 在所有 Go 提交中击败了15.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1447. Simplified Fractions</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1447.%20Simplified%20Fractions/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1447.%20Simplified%20Fractions/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. You can return the answer in any order.</p><p>Example 1:</p><p>Input: n &#x3D; 2<br>Output: [“1&#x2F;2”]<br>Explanation: “1&#x2F;2” is the only unique fraction with a denominator less-than-or-equal-to 2.<br>Example 2:</p><p>Input: n &#x3D; 3<br>Output: [“1&#x2F;2”,”1&#x2F;3”,”2&#x2F;3”]<br>Example 3:</p><p>Input: n &#x3D; 4<br>Output: [“1&#x2F;2”,”1&#x2F;3”,”1&#x2F;4”,”2&#x2F;3”,”3&#x2F;4”]<br>Explanation: “2&#x2F;4” is not a simplified fraction because it can be simplified to “1&#x2F;2”.</p><p>Constraints:</p><p>1 &lt;&#x3D; n &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>两层遍历，不把最大公约数不为1的数放进去就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> gcd(b,a%b)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">simplifiedFractions</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>     <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;i;j++&#123;                        <span class="hljs-keyword">if</span>  gcd(i,j) !=<span class="hljs-number">1</span>&#123;                <span class="hljs-keyword">continue</span>            &#125;            s := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, j)+<span class="hljs-string">&quot;/&quot;</span>+strconv.Itoa(i)            res = <span class="hljs-built_in">append</span>(res, s)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了51.61%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了96.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1463. 摘樱桃 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1463.%20%E6%91%98%E6%A8%B1%E6%A1%83%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1463.%20%E6%91%98%E6%A8%B1%E6%A1%83%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="摘樱桃-II"><a href="#摘樱桃-II" class="headerlink" title="摘樱桃 II"></a><font size=6px>摘樱桃 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。</p><p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。</p><p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p><p>从格子 (i,j) 出发，机器人可以移动到格子 (i+1, j-1)，(i+1, j) 或者 (i+1, j+1) 。<br>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。<br>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。<br>两个机器人在任意时刻都不能移动到 grid 外面。<br>两个机器人最后都要到达 grid 最底下一行。</p><p>示例 1：</p><p>输入：grid &#x3D; [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]<br>输出：24<br>解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。<br>机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) &#x3D; 12 。<br>机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) &#x3D; 12 。<br>樱桃总数为： 12 + 12 &#x3D; 24 。<br>示例 2：</p><p>输入：grid &#x3D; [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]<br>输出：28<br>解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。<br>机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) &#x3D; 17 。<br>机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) &#x3D; 11 。<br>樱桃总数为： 17 + 11 &#x3D; 28 。<br>示例 3：</p><p>输入：grid &#x3D; [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]<br>输出：22<br>示例 4：</p><p>输入：grid &#x3D; [[1,1],[1,1]]<br>输出：4</p><p>提示：</p><p>rows &#x3D;&#x3D; grid.length<br>cols &#x3D;&#x3D; grid[i].length<br>2 &lt;&#x3D; rows, cols &lt;&#x3D; 70<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^3)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><p>三维dp，滚动更新，压缩成二维<br>dp(i, j1, j2)表示在第i层的时候第一个机器人在j1，第二个机器人在j2，所能摘到的最多的樱桃</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cherryPickup</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            dp[i][j] = <span class="hljs-number">-1</span>        &#125;    &#125;    dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + grid[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]     nxt := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> nxt &#123;        nxt[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    &#125;    nxt[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + grid[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>]        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j1:=<span class="hljs-number">0</span>;j1&lt;n;j1++&#123;            <span class="hljs-keyword">for</span> j2:=<span class="hljs-number">0</span>;j2&lt;n;j2++&#123;                best := <span class="hljs-number">-1</span>                               <span class="hljs-keyword">for</span> j:=j1<span class="hljs-number">-1</span>;j&lt;=j1+<span class="hljs-number">1</span>;j++&#123;                    <span class="hljs-keyword">for</span> k:=j2<span class="hljs-number">-1</span>;k&lt;=j2+<span class="hljs-number">1</span>;k++&#123;                        <span class="hljs-keyword">if</span> j&lt;<span class="hljs-number">0</span> || j &gt;=n || k&lt;<span class="hljs-number">0</span> || k &gt;=n || dp[j][k] == <span class="hljs-number">-1</span>&#123;                            <span class="hljs-keyword">continue</span>                        &#125;                        tmp := dp[j][k]                        <span class="hljs-keyword">if</span> j1 == j2&#123;                            tmp += grid[i][j1]                        &#125;<span class="hljs-keyword">else</span>&#123;                            tmp += grid[i][j1]+grid[i][j2]                        &#125;                        best = max(best,tmp)                    &#125;                &#125;                nxt[j1][j2] = best            &#125;        &#125;                dp, nxt = nxt, dp    &#125;    ans := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> j1 := <span class="hljs-number">0</span>; j1 &lt; n; j1 ++ &#123;        <span class="hljs-keyword">for</span> j2 := <span class="hljs-number">0</span>; j2 &lt; n; j2 ++ &#123;            ans = max(ans, dp[j1][j2])        &#125;    &#125;    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了88.89%的用户<br>   内存消耗：3.7 MB, 在所有 Go 提交中击败了88.89%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>150. 逆波兰表达式求值</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a><font size=6px>逆波兰表达式求值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>注意 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：</p><p>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9<br>示例 2：</p><p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6<br>示例 3：</p><p>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22</p><p>提示：</p><p>1 &lt;&#x3D; tokens.length &lt;&#x3D; 104<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数</p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用栈做就行，特殊情况都不用判断</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">class Solution &#123;public:    <span class="hljs-type">int</span> evalRPN(vector&lt;<span class="hljs-type">string</span>&gt;&amp; tokens) &#123;        stack&lt;<span class="hljs-type">int</span>&gt; stk;        <span class="hljs-type">int</span> n = tokens.size();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-type">string</span>&amp; token = tokens[i];            <span class="hljs-keyword">if</span> (isNumber(token)) &#123;                stk.push(atoi(token.c_str()));            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-type">int</span> num2 = stk.top();                stk.pop();                <span class="hljs-type">int</span> num1 = stk.top();                stk.pop();                <span class="hljs-keyword">switch</span> (token[<span class="hljs-number">0</span>]) &#123;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:                        stk.push(num1 + num2);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:                        stk.push(num1 - num2);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:                        stk.push(num1 * num2);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:                        stk.push(num1 / num2);                        <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> stk.top();    &#125;    <span class="hljs-type">bool</span> isNumber(<span class="hljs-type">string</span>&amp; token) &#123;        <span class="hljs-keyword">return</span> !(token == <span class="hljs-string">&quot;+&quot;</span> || token == <span class="hljs-string">&quot;-&quot;</span> || token == <span class="hljs-string">&quot;*&quot;</span> || token == <span class="hljs-string">&quot;/&quot;</span>);    &#125;&#125;;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 C++ 提交中击败了43.50%的用户<br>   内存消耗：11.6 MB, 在所有 C++ 提交中击败了69.97%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>151. 翻转字符串里的单词</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/151.%20%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/151.%20%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a><font size=6px>翻转字符串里的单词</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>说明：</p><p>无空格字符构成一个 单词 。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>示例 1：</p><p>输入：”the sky is blue”<br>输出：”blue is sky the”<br>示例 2：</p><p>输入：”  hello world!  “<br>输出：”world! hello”<br>解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p><p>输入：”a good   example”<br>输出：”example good a”<br>解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>示例 4：</p><p>输入：s &#x3D; “  Bob    Loves  Alice   “<br>输出：”Alice Loves Bob”<br>示例 5：</p><p>输入：s &#x3D; “Alice does not even like bob”<br>输出：”bob like even not does Alice”</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>还是自己太垃圾，字符串类型的题目不行了</p><p>要先把前面的空格和后面的空格去掉，这这之间把字符串之间的空格控制在1个，然后用spilt函数分割字符串，然后倒转，再用join合起来</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> s==<span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>    &#125;    str := clearSpace(s)    <span class="hljs-keyword">var</span> str1 <span class="hljs-type">string</span>    ss :=strings.Split(<span class="hljs-type">string</span>(str),<span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(ss)/<span class="hljs-number">2</span>;i++&#123;        ss[i],ss[<span class="hljs-built_in">len</span>(ss)<span class="hljs-number">-1</span>-i] = ss[<span class="hljs-built_in">len</span>(ss)<span class="hljs-number">-1</span>-i],ss[i]    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ss[<span class="hljs-number">0</span>])==<span class="hljs-number">0</span>&#123;ss = <span class="hljs-built_in">append</span>(ss[:<span class="hljs-number">0</span>],ss[<span class="hljs-number">1</span>:]...)    &#125;        str1 = strings.Join(ss,<span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">return</span>  str1&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clearSpace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span>&#123;    <span class="hljs-keyword">var</span> str []<span class="hljs-type">byte</span>    <span class="hljs-keyword">var</span> i <span class="hljs-type">int</span>    j  :=<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i&lt;<span class="hljs-built_in">len</span>(s)&amp;&amp;s[i]==<span class="hljs-string">&#x27; &#x27;</span>&#123;        i++    &#125;    flag :=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> ;i&lt;=j;i++&#123;        <span class="hljs-keyword">if</span> s[i]!=<span class="hljs-string">&#x27; &#x27;</span>&#123;            str = <span class="hljs-built_in">append</span>(str,s[i])            flag=<span class="hljs-number">0</span>        &#125;        <span class="hljs-keyword">if</span> s[i]==<span class="hljs-string">&#x27; &#x27;</span>&amp;&amp;flag==<span class="hljs-number">0</span>&#123;            flag=<span class="hljs-number">1</span>            str = <span class="hljs-built_in">append</span>(str,s[i])        &#125;    &#125;    <span class="hljs-keyword">return</span>  <span class="hljs-type">string</span>(str)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.1 MB, 在所有 Go 提交中击败了63.42%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>152. 乘积最大子数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><font size=6px>乘积最大子数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>示例 1:</p><p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p><p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划做，需要额外一个dp_min数组，用于放最小数，是为了考虑两个负数乘变成正数的情况。</p><p>dp_min[i] &#x3D; min(min(dp_min[i-1]*nums[i],dp_max[i-1]*nums[i] ),nums[i])</p><p> dp_max[i] &#x3D; max(max(dp_max[i-1]*nums[i], dp_min[i-1]*nums[i]),nums[i])</p><p>res &#x3D; max(res,dp_max[i])</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]    &#125;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    dp_min := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    dp_max := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    dp_max[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]    dp_min[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]    res = dp_max[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        dp_min[i] = min(min(dp_min[i<span class="hljs-number">-1</span>]*nums[i],dp_max[i<span class="hljs-number">-1</span>]*nums[i] ),nums[i])        dp_max[i] = max(max(dp_max[i<span class="hljs-number">-1</span>]*nums[i], dp_min[i<span class="hljs-number">-1</span>]*nums[i]),nums[i])        res = max(res,dp_max[i])    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a     &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了80.65%的用户<br>   内存消耗：3.8 MB, 在所有 Go 提交中击败了15.50%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>155. 最小栈</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><font size=6px>最小栈</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>在编写的时候就把这个数到之前数的最小数append进去</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;stack  []<span class="hljs-type">int</span>    minnum []<span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> b&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> a&#125;&#125;<span class="hljs-comment">/** initialize your data structure here. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<span class="hljs-keyword">return</span> MinStack&#123;stack:  []<span class="hljs-type">int</span>&#123;&#125;,minnum: []<span class="hljs-type">int</span>&#123;math.&#125;,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(val <span class="hljs-type">int</span>) &#123;this.stack = <span class="hljs-built_in">append</span>(this.stack, val)this.minnum = <span class="hljs-built_in">append</span>(this.minnum, min(this.minnum[<span class="hljs-built_in">len</span>(this.minnum)<span class="hljs-number">-1</span>],val))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop() &#123;this.stack = <span class="hljs-built_in">append</span>(this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>])this.minnum = <span class="hljs-built_in">append</span>(this.minnum[:<span class="hljs-built_in">len</span>(this.minnum)<span class="hljs-number">-1</span>])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> this.minnum[<span class="hljs-built_in">len</span>(this.minnum)<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了86.09%的用户<br>   内存消耗：8.3 MB, 在所有 Go 提交中击败了81.90%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>154. 寻找旋转排序数组中的最小值 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/154.%20%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/154.%20%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="寻找旋转排序数组中的最小值-II"><a href="#寻找旋转排序数组中的最小值-II" class="headerlink" title="寻找旋转排序数组中的最小值 II"></a><font size=6px>寻找旋转排序数组中的最小值 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><p>你必须尽可能减少整个过程的操作步骤。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,5]<br>输出：1<br>示例 2：</p><p>输入：nums &#x3D; [2,2,2,0,1]<br>输出：0</p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 5000<br>-5000 &lt;&#x3D; nums[i] &lt;&#x3D; 5000<br>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p><p>进阶：这道题与 寻找旋转排序数组中的最小值 类似，但 nums 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(logn),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>使用二分查找合适的序列</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMin</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    numbers := nums    n := <span class="hljs-built_in">len</span>(numbers)    l,r := <span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> l &lt;= r&#123;        m := l + (r-l)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> numbers[m] &gt; numbers[r]&#123;            l = m+<span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> numbers[m] &lt; numbers[r]&#123;            r = m        &#125;<span class="hljs-keyword">else</span>&#123;            r--        &#125;            &#125;    <span class="hljs-keyword">return</span> numbers[l]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了85.54%的用户<br>   内存消耗：2.9 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>160. 相交链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a><font size=6px>相交链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表：</p><p>在节点 c1 开始相交。</p><p>示例 1：</p><p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Reference of the node with value &#x3D; 8<br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Reference of the node with value &#x3D; 2<br>输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p>注意：</p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第一版效率低，讲第二版的思路，相交结点屁股后面结点数量是相同的，先分别遍历两个链表求长度，如果一个长就先遍历这个链表长的部分，之后两个链表就等长了一起遍历。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> headA==<span class="hljs-literal">nil</span>|| headB ==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>)    <span class="hljs-keyword">for</span> headA!=<span class="hljs-literal">nil</span>&amp;&amp;headB!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> mp[headA]==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> headA        &#125;<span class="hljs-keyword">else</span>&#123;            mp[headA] = <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">if</span> mp[headB]==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> headB        &#125;<span class="hljs-keyword">else</span>&#123;            mp[headB] = <span class="hljs-literal">true</span>        &#125;        headA = headA.Next        headB = headB.Next    &#125;    <span class="hljs-keyword">for</span> headA!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> mp[headA]==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> headA        &#125;        headA = headA.Next    &#125;    <span class="hljs-keyword">for</span> headB!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> mp[headB]==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> headB        &#125;        headB = headB.Next    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了28.89%的用户<br>   内存消耗：7.5 MB, 在所有 Go 提交中击败了18.97%的用户</p><pre><code class="hljs go"><span class="hljs-comment">//第二版</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;    l1:=<span class="hljs-number">0</span>    p1:=headA    <span class="hljs-keyword">for</span> p1!=<span class="hljs-literal">nil</span>&#123;        l1++        p1=p1.Next    &#125;    l2:=<span class="hljs-number">0</span>    p2:=headB    <span class="hljs-keyword">for</span> p2!=<span class="hljs-literal">nil</span>&#123;        l2++        p2=p2.Next    &#125;    <span class="hljs-keyword">if</span> l1&gt;l2&#123;        <span class="hljs-keyword">for</span> l1!=l2&#123;            headA=headA.Next            l1--        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> l1!=l2&#123;            headB=headB.Next            l2--        &#125;    &#125;    <span class="hljs-keyword">for</span> headA!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> headA==headB&#123;            <span class="hljs-keyword">return</span> headA        &#125;<span class="hljs-keyword">else</span>&#123;            headA=headA.Next            headB=headB.Next        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;</code></pre><p class="note note-primary"; style="font-size:22px">   执行用时：40 ms, 在所有 Go 提交中击败了71.48%的用户<br>   内存消耗：7.2 MB, 在所有 Go 提交中击败了84.56%的用户</p><pre><code class="hljs vim">//最后贴上大神极简的代码func getIntersectionNode(headA, headB *ListNode) *ListNode &#123;<span class="hljs-keyword">ha</span>, hb := headA, headB<span class="hljs-keyword">for</span> <span class="hljs-keyword">ha</span> != hb &#123;<span class="hljs-keyword">if</span> <span class="hljs-keyword">ha</span> != nil &#123;<span class="hljs-keyword">ha</span> = <span class="hljs-keyword">ha</span>.<span class="hljs-keyword">Next</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">ha</span> = headB&#125;<span class="hljs-keyword">if</span> hb != nil &#123;hb = hb.<span class="hljs-keyword">Next</span>&#125; <span class="hljs-keyword">else</span> &#123;hb = headA&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">ha</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1672. 最富有客户的资产总量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1672.%20%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%80%BB%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1672.%20%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%80%BB%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="最富有客户的资产总量"><a href="#最富有客户的资产总量" class="headerlink" title="最富有客户的资产总量"></a><font size=6px>最富有客户的资产总量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。</p><p>客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。</p><p>示例 1：</p><p>输入：accounts &#x3D; [[1,2,3],[3,2,1]]<br>输出：6<br>解释：<br>第 1 位客户的资产总量 &#x3D; 1 + 2 + 3 &#x3D; 6<br>第 2 位客户的资产总量 &#x3D; 3 + 2 + 1 &#x3D; 6<br>两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。<br>示例 2：</p><p>输入：accounts &#x3D; [[1,5],[7,3],[3,5]]<br>输出：10<br>解释：<br>第 1 位客户的资产总量 &#x3D; 6<br>第 2 位客户的资产总量 &#x3D; 10<br>第 3 位客户的资产总量 &#x3D; 8<br>第 2 位客户是最富有的，资产总量是 10<br>示例 3：</p><p>输入：accounts &#x3D; [[2,8,7],[7,1,3],[1,9,5]]<br>输出：17</p><p>提示：</p><p>m &#x3D;&#x3D; accounts.length<br>n &#x3D;&#x3D; accounts[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 50<br>1 &lt;&#x3D; accounts[i][j] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumWealth</span><span class="hljs-params">(accounts [][]<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">for</span> _, account := <span class="hljs-keyword">range</span> accounts &#123;        sum := <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> account &#123;            sum += val        &#125;        <span class="hljs-keyword">if</span> sum &gt; ans &#123;            ans = sum        &#125;    &#125;    <span class="hljs-keyword">return</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了84.38%的用户<br>   内存消耗：2.9 MB, 在所有 Go 提交中击败了71.88%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1566. 重复至少 K 次且长度为 M 的模式</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1566.%20%E9%87%8D%E5%A4%8D%E8%87%B3%E5%B0%91%20K%20%E6%AC%A1%E4%B8%94%E9%95%BF%E5%BA%A6%E4%B8%BA%20M%20%E7%9A%84%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1566.%20%E9%87%8D%E5%A4%8D%E8%87%B3%E5%B0%91%20K%20%E6%AC%A1%E4%B8%94%E9%95%BF%E5%BA%A6%E4%B8%BA%20M%20%E7%9A%84%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="重复至少-K-次且长度为-M-的模式"><a href="#重复至少-K-次且长度为-M-的模式" class="headerlink" title="重复至少 K 次且长度为 M 的模式"></a><font size=6px>重复至少 K 次且长度为 M 的模式</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个正整数数组 arr，请你找出一个长度为 m 且在数组中至少重复 k 次的模式。</p><p>模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但 不重叠 。 模式由其长度和重复次数定义。</p><p>如果数组中存在至少重复 k 次且长度为 m 的模式，则返回 true ，否则返回  false 。</p><p>示例 1：</p><p>输入：arr &#x3D; [1,2,4,4,4,4], m &#x3D; 1, k &#x3D; 3<br>输出：true<br>解释：模式 (4) 的长度为 1 ，且连续重复 4 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。<br>示例 2：</p><p>输入：arr &#x3D; [1,2,1,2,1,1,1,3], m &#x3D; 2, k &#x3D; 2<br>输出：true<br>解释：模式 (1,2) 长度为 2 ，且连续重复 2 次。另一个符合题意的模式是 (2,1) ，同样重复 2 次。<br>示例 3：</p><p>输入：arr &#x3D; [1,2,1,2,1,3], m &#x3D; 2, k &#x3D; 3<br>输出：false<br>解释：模式 (1,2) 长度为 2 ，但是只连续重复 2 次。不存在长度为 2 且至少重复 3 次的模式。<br>示例 4：</p><p>输入：arr &#x3D; [1,2,3,1,2], m &#x3D; 2, k &#x3D; 2<br>输出：false<br>解释：模式 (1,2) 出现 2 次但并不连续，所以不能算作连续重复 2 次。<br>示例 5：</p><p>输入：arr &#x3D; [2,2,2,2], m &#x3D; 2, k &#x3D; 3<br>输出：false<br>解释：长度为 2 的模式只有 (2,2) ，但是只连续重复 2 次。注意，不能计算重叠的重复次数。</p><p>提示：</p><p>2 &lt;&#x3D; arr.length &lt;&#x3D; 100<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 100<br>1 &lt;&#x3D; m &lt;&#x3D; 100<br>2 &lt;&#x3D; k &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>硬模拟就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">containsPattern</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, m <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> m*k &gt;<span class="hljs-built_in">len</span>(arr)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    n := <span class="hljs-built_in">len</span>(arr)    <span class="hljs-keyword">var</span> j <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> p <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n-m*k;i++&#123;        <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>;j&lt;k;j++&#123;            <span class="hljs-keyword">for</span> p=<span class="hljs-number">0</span>;p&lt;m;p++&#123;                <span class="hljs-keyword">if</span> arr[p+i] != arr[i+j*m+p]&#123;                    <span class="hljs-keyword">break</span>                &#125;            &#125;            <span class="hljs-comment">// 如果上面的for循环break了这个也要break</span>            <span class="hljs-keyword">if</span> p != m&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> j ==k &amp;&amp; p == m&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了84.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1688. 比赛中的配对次数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1688.%20%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%85%8D%E5%AF%B9%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1688.%20%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%85%8D%E5%AF%B9%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="比赛中的配对次数"><a href="#比赛中的配对次数" class="headerlink" title="比赛中的配对次数"></a><font size=6px>比赛中的配对次数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：</p><p>如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n &#x2F; 2 场比赛，且产生 n &#x2F; 2 支队伍进入下一轮。<br>如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) &#x2F; 2 场比赛，且产生 (n - 1) &#x2F; 2 + 1 支队伍进入下一轮。<br>返回在比赛中进行的配对次数，直到决出获胜队伍为止。</p><p>示例 1：</p><p>输入：n &#x3D; 7<br>输出：6<br>解释：比赛详情：</p><ul><li>第 1 轮：队伍数 &#x3D; 7 ，配对次数 &#x3D; 3 ，4 支队伍晋级。</li><li>第 2 轮：队伍数 &#x3D; 4 ，配对次数 &#x3D; 2 ，2 支队伍晋级。</li><li>第 3 轮：队伍数 &#x3D; 2 ，配对次数 &#x3D; 1 ，决出 1 支获胜队伍。<br>总配对次数 &#x3D; 3 + 2 + 1 &#x3D; 6<br>示例 2：</li></ul><p>输入：n &#x3D; 14<br>输出：13<br>解释：比赛详情：</p><ul><li>第 1 轮：队伍数 &#x3D; 14 ，配对次数 &#x3D; 7 ，7 支队伍晋级。</li><li>第 2 轮：队伍数 &#x3D; 7 ，配对次数 &#x3D; 3 ，4 支队伍晋级。 </li><li>第 3 轮：队伍数 &#x3D; 4 ，配对次数 &#x3D; 2 ，2 支队伍晋级。</li><li>第 4 轮：队伍数 &#x3D; 2 ，配对次数 &#x3D; 1 ，决出 1 支获胜队伍。<br>总配对次数 &#x3D; 7 + 3 + 2 + 1 &#x3D; 13</li></ul><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 200<br>通过</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfMatches</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> n !=<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> n %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;            n = (n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>            res += n<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            res += n/<span class="hljs-number">2</span>            n /= <span class="hljs-number">2</span>        &#125;            &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1656. 设计有序流</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1656.%20%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1656.%20%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="设计有序流"><a href="#设计有序流" class="headerlink" title="设计有序流"></a><font size=6px>设计有序流</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。</p><p>设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。</p><p>实现 OrderedStream 类：</p><p>OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。<br>String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后：<br>如果流存储有 id &#x3D; ptr 的 (id, value) 对，则找出从 id &#x3D; ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个  id + 1 。<br>否则，返回一个空列表。</p><p>示例：</p><p>输入<br>[“OrderedStream”, “insert”, “insert”, “insert”, “insert”, “insert”]<br>[[5], [3, “ccccc”], [1, “aaaaa”], [2, “bbbbb”], [5, “eeeee”], [4, “ddddd”]]<br>输出<br>[null, [], [“aaaaa”], [“bbbbb”, “ccccc”], [], [“ddddd”, “eeeee”]]</p><p>解释<br>OrderedStream os&#x3D; new OrderedStream(5);<br>os.insert(3, “ccccc”); &#x2F;&#x2F; 插入 (3, “ccccc”)，返回 []<br>os.insert(1, “aaaaa”); &#x2F;&#x2F; 插入 (1, “aaaaa”)，返回 [“aaaaa”]<br>os.insert(2, “bbbbb”); &#x2F;&#x2F; 插入 (2, “bbbbb”)，返回 [“bbbbb”, “ccccc”]<br>os.insert(5, “eeeee”); &#x2F;&#x2F; 插入 (5, “eeeee”)，返回 []<br>os.insert(4, “ddddd”); &#x2F;&#x2F; 插入 (4, “ddddd”)，返回 [“ddddd”, “eeeee”]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 1000<br>1 &lt;&#x3D; id &lt;&#x3D; n<br>value.length &#x3D;&#x3D; 5<br>value 仅由小写字母组成<br>每次调用 insert 都会使用一个唯一的 id<br>恰好调用 n 次 insert</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> OrderedStream <span class="hljs-keyword">struct</span> &#123;    stream []<span class="hljs-type">string</span>    ptr    <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> OrderedStream &#123;    <span class="hljs-keyword">return</span> OrderedStream&#123;<span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, n+<span class="hljs-number">1</span>), <span class="hljs-number">1</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *OrderedStream)</span></span> Insert(idKey <span class="hljs-type">int</span>, value <span class="hljs-type">string</span>) []<span class="hljs-type">string</span> &#123;    s.stream[idKey] = value    start := s.ptr    <span class="hljs-keyword">for</span> s.ptr &lt; <span class="hljs-built_in">len</span>(s.stream) &amp;&amp; s.stream[s.ptr] != <span class="hljs-string">&quot;&quot;</span> &#123;        s.ptr++    &#125;    <span class="hljs-keyword">return</span> s.stream[start:s.ptr]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：7.1 MB, 在所有 Go 提交中击败了57.89%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1706. 球会落何处</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1706.%20%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1706.%20%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<h3 id="球会落何处"><a href="#球会落何处" class="headerlink" title="球会落何处"></a><font size=6px>球会落何处</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。</p><p>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。</p><p>将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。<br>将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。<br>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。</p><p>返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。</p><p>示例 1：</p><p>输入：grid &#x3D; [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]<br>输出：[1,-1,-1,-1,-1]<br>解释：示例如图：<br>b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。<br>b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 “V” 形里。<br>b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 “V” 形里。<br>b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 “V” 形里。<br>b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 “V” 形里。<br>示例 2：</p><p>输入：grid &#x3D; [[-1]]<br>输出：[-1]<br>解释：球被卡在箱子左侧边上。<br>示例 3：</p><p>输入：grid &#x3D; [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]<br>输出：[0,1,2,3,4,-1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用模拟做，如果是1就看看右边是不是1，如果碰墙就返回-1，是-1就看看左边是不是-1，如果是1或者碰墙就返回-1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBall</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> level <span class="hljs-type">int</span>    m,n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        column := i;        <span class="hljs-keyword">for</span> level =<span class="hljs-number">0</span>; level&lt;m; level++&#123;            <span class="hljs-keyword">if</span> grid[level][column] == <span class="hljs-number">1</span>&#123;                <span class="hljs-keyword">if</span> column+<span class="hljs-number">1</span> == n || grid[level][column+<span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>&#123;                    res = <span class="hljs-built_in">append</span>(res, <span class="hljs-number">-1</span>)                    <span class="hljs-keyword">break</span>                &#125;<span class="hljs-keyword">else</span> &#123;                    column++                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span> column<span class="hljs-number">-1</span> == <span class="hljs-number">-1</span> || grid[level][column<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>&#123;                    res = <span class="hljs-built_in">append</span>(res, <span class="hljs-number">-1</span>)                    <span class="hljs-keyword">break</span>                &#125;<span class="hljs-keyword">else</span>&#123;                    column--                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> level == m&#123;            res = <span class="hljs-built_in">append</span>(res, column)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了76.92%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了38.46%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1725. 可以形成最大正方形的矩形数目</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1725.%20%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1725.%20%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="可以形成最大正方形的矩形数目"><a href="#可以形成最大正方形的矩形数目" class="headerlink" title="可以形成最大正方形的矩形数目"></a><font size=6px>可以形成最大正方形的矩形数目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个数组 rectangles ，其中 rectangles[i] &#x3D; [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。</p><p>如果存在 k 同时满足 k &lt;&#x3D; li 和 k &lt;&#x3D; wi ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。</p><p>设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。</p><p>请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 数目 。</p><p>示例 1：</p><p>输入：rectangles &#x3D; [[5,8],[3,9],[5,12],[16,5]]<br>输出：3<br>解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。<br>最大正方形的边长为 5 ，可以由 3 个矩形切分得到。<br>示例 2：</p><p>输入：rectangles &#x3D; [[2,3],[3,7],[4,3],[3,7]]<br>输出：3</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countGoodRectangles</span><span class="hljs-params">(rectangles [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    count, max := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,i := <span class="hljs-keyword">range</span> rectangles&#123;        <span class="hljs-keyword">if</span> max == min(i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>])&#123;            count++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> max &lt; min(i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>])&#123;            max = min(i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>])            count = <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> b    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a     &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了95.56%的用户<br>   内存消耗：6.4 MB, 在所有 Go 提交中击败了97.78%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>172. 阶乘后的零</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/172.%20%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/172.%20%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a><font size=6px>阶乘后的零</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数 n ，返回 n! 结果中尾随零的数量。</p><p>提示 n! &#x3D; n * (n - 1) * (n - 2) * … * 3 * 2 * 1</p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：0<br>解释：3! &#x3D; 6 ，不含尾随 0<br>示例 2：</p><p>输入：n &#x3D; 5<br>输出：1<br>解释：5! &#x3D; 120 ，有一个尾随 0<br>示例 3：</p><p>输入：n &#x3D; 0<br>输出：0</p><p>提示：</p><p>0 &lt;&#x3D; n &lt;&#x3D; 104</p><p>进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>有5的地方就有0，如果是25是5*5说明有两个5可以cnt++两次</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    cnt := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">5</span>;i&lt;=n;i+=<span class="hljs-number">5</span>&#123;        <span class="hljs-keyword">for</span> j:=i;j%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>;j/=<span class="hljs-number">5</span> &#123;            cnt++        &#125;            &#125;    <span class="hljs-keyword">return</span> cnt&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了29.18%</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1748. 唯一元素的和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1748.%20%E5%94%AF%E4%B8%80%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1748.%20%E5%94%AF%E4%B8%80%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="唯一元素的和"><a href="#唯一元素的和" class="headerlink" title="唯一元素的和"></a><font size=6px>唯一元素的和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。</p><p>请你返回 nums 中唯一元素的 和 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,2]<br>输出：4<br>解释：唯一元素为 [1,3] ，和为 4 。<br>示例 2：</p><p>输入：nums &#x3D; [1,1,1,1,1]<br>输出：0<br>解释：没有唯一元素，和为 0 。<br>示例 3 ：</p><p>输入：nums &#x3D; [1,2,3,4,5]<br>输出：15<br>解释：唯一元素为 [1,2,3,4,5] ，和为 15 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一样的只能减去一次</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumOfUnique</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    count := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-built_in">len</span>(nums); i++&#123;        <span class="hljs-keyword">if</span> _,ok := m[nums[i]]; !ok&#123;            count+= nums[i]            m[nums[i]]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> m[nums[i]] == <span class="hljs-number">1</span>&#123;            m[nums[i]] = <span class="hljs-number">2</span>            count -=nums[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了72.55%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1765. 地图中的最高点</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1765.%20%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1765.%20%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="地图中的最高点"><a href="#地图中的最高点" class="headerlink" title="地图中的最高点"></a><font size=6px>地图中的最高点</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个大小为 m x n 的整数矩阵 isWater ，它代表了一个由 陆地 和 水域 单元格组成的地图。</p><p>如果 isWater[i][j] &#x3D;&#x3D; 0 ，格子 (i, j) 是一个 陆地 格子。<br>如果 isWater[i][j] &#x3D;&#x3D; 1 ，格子 (i, j) 是一个 水域 格子。<br>你需要按照如下规则给每个单元格安排高度：</p><p>每个格子的高度都必须是非负的。<br>如果一个格子是是 水域 ，那么它的高度必须为 0 。<br>任意相邻的格子高度差 至多 为 1 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）<br>找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。</p><p>请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。如果有多种解法，请返回 任意一个 。</p><p>示例 1：</p><p>输入：isWater &#x3D; [[0,1],[0,0]]<br>输出：[[1,0],[2,1]]<br>解释：上图展示了给各个格子安排的高度。<br>蓝色格子是水域格，绿色格子是陆地格。<br>示例 2：</p><p>输入：isWater &#x3D; [[0,0,1],[1,0,0],[0,0,0]]<br>输出：[[1,1,0],[0,1,1],[1,2,2]]<br>解释：所有安排方案中，最高可行高度为 2 。<br>任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。</p><p>提示：</p><p>m &#x3D;&#x3D; isWater.length<br>n &#x3D;&#x3D; isWater[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 1000<br>isWater[i][j] 要么是 0 ，要么是 1 。<br>至少有 1 个水域格子。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用bfs，从每个水面开始bfs便利，每便利到一个就比之前加1 </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">highestPeak</span><span class="hljs-params">(isWater [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span> &#123;x,y <span class="hljs-type">int</span>&#125;    <span class="hljs-keyword">var</span> dirs = []pair&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;    <span class="hljs-keyword">var</span> p []pair    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;<span class="hljs-built_in">len</span>(isWater); i++&#123;        <span class="hljs-keyword">for</span> j:= <span class="hljs-number">0</span>; j&lt;<span class="hljs-built_in">len</span>(isWater[i]); j++&#123;            <span class="hljs-keyword">if</span> isWater[i][j] == <span class="hljs-number">1</span>&#123;                isWater[i][j] = <span class="hljs-number">0</span>                p = <span class="hljs-built_in">append</span>(p, pair&#123;i,j&#125;)            &#125;<span class="hljs-keyword">else</span>&#123;                isWater[i][j] = <span class="hljs-number">-1</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p) != <span class="hljs-number">0</span>&#123;        q := p[<span class="hljs-number">0</span>]        p = p[<span class="hljs-number">1</span>:]        <span class="hljs-keyword">for</span> _,i := <span class="hljs-keyword">range</span> dirs&#123;            x:= q.x + i.x            y := q.y + i.y            <span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;<span class="hljs-built_in">len</span>(isWater) &amp;&amp; y &gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;<span class="hljs-built_in">len</span>(isWater[<span class="hljs-number">0</span>]) &amp;&amp; isWater[x][y] == <span class="hljs-number">-1</span>&#123;                isWater[x][y] = isWater[q.x][q.y]+<span class="hljs-number">1</span>                p = <span class="hljs-built_in">append</span>(p,pair&#123;x,y&#125;)            &#125;                    &#125;    &#125;    <span class="hljs-keyword">return</span> isWater&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1763. 最长的美好子字符串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1763.%20%E6%9C%80%E9%95%BF%E7%9A%84%E7%BE%8E%E5%A5%BD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1763.%20%E6%9C%80%E9%95%BF%E7%9A%84%E7%BE%8E%E5%A5%BD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="最长的美好子字符串"><a href="#最长的美好子字符串" class="headerlink" title="最长的美好子字符串"></a><font size=6px>最长的美好子字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。比方说，”abABB” 是美好字符串，因为 ‘A’ 和 ‘a’ 同时出现了，且 ‘B’ 和 ‘b’ 也同时出现了。然而，”abA” 不是美好字符串因为 ‘b’ 出现了，而 ‘B’ 没有出现。</p><p>给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。</p><p>示例 1：</p><p>输入：s &#x3D; “YazaAay”<br>输出：”aAa”<br>解释：”aAa” 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 ‘a’ 和大写形式 ‘A’ 也同时出现了。<br>“aAa” 是最长的美好子字符串。<br>示例 2：</p><p>输入：s &#x3D; “Bb”<br>输出：”Bb”<br>解释：”Bb” 是美好字符串，因为 ‘B’ 和 ‘b’ 都出现了。整个字符串也是原字符串的子字符串。<br>示例 3：</p><p>输入：s &#x3D; “c”<br>输出：””<br>解释：没有美好子字符串。<br>示例 4：</p><p>输入：s &#x3D; “dDzeE”<br>输出：”dD”<br>解释：”dD” 和 “eE” 都是最长美好子字符串。<br>由于有多个美好子字符串，返回 “dD” ，因为它出现得最早。</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含大写和小写英文字母。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用n2复杂度去遍历，判断的时候有个小技巧是用26个二进制分别代表大写的字母和小写的字母，然后判断两个相不相等</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestNiceSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt;=<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>    &#125;    length := <span class="hljs-number">-1</span>    start := <span class="hljs-number">-1</span>    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span>    n = <span class="hljs-built_in">len</span>(s)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n ;i++&#123;        a,b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> j:=i; j&lt;n;j++&#123;            <span class="hljs-keyword">if</span> s[j]&gt;=<span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[j] &lt;=<span class="hljs-string">&#x27;z&#x27;</span>&#123;                a |= <span class="hljs-number">1</span>&lt;&lt;(s[j]-<span class="hljs-string">&#x27;a&#x27;</span>)            &#125;            <span class="hljs-keyword">if</span> s[j]&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[j]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>&#123;                b |= <span class="hljs-number">1</span>&lt;&lt;(s[j] - <span class="hljs-string">&#x27;A&#x27;</span>)            &#125;            <span class="hljs-keyword">if</span> a == b&amp;&amp; a != <span class="hljs-number">0</span> &amp;&amp;j-i &gt;length&#123;                length = j-i                start = i            &#125;                   &#125;    &#125;    res := <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">if</span> start == <span class="hljs-number">-1</span>&#123;        <span class="hljs-keyword">return</span> res    &#125;    <span class="hljs-keyword">for</span> i:=start;i&lt;=start+length;i++&#123;        res += <span class="hljs-type">string</span>(s[i])    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了83.39%</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1838. 最高频元素的频数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1838.%20%E6%9C%80%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1838.%20%E6%9C%80%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="最高频元素的频数"><a href="#最高频元素的频数" class="headerlink" title="最高频元素的频数"></a><font size=6px>最高频元素的频数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>元素的 频数 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。</p><p>执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,4], k &#x3D; 5<br>输出：3<br>解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums &#x3D; [4,4,4] 。<br>4 是数组中最高频元素，频数是 3 。<br>示例 2：</p><p>输入：nums &#x3D; [1,4,8,13], k &#x3D; 5<br>输出：2<br>解释：存在多种最优解决方案：</p><ul><li>对第一个元素执行 3 次递增操作，此时 nums &#x3D; [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。</li><li>对第二个元素执行 4 次递增操作，此时 nums &#x3D; [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。</li><li>对第三个元素执行 5 次递增操作，此时 nums &#x3D; [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。<br>示例 3：</li></ul><p>输入：nums &#x3D; [3,9,6], k &#x3D; 2<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105<br>1 &lt;&#x3D; k &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用滑动窗口法是最容易想到的，注意不一定是从第一个开始的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxFrequency</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    sort.Ints(nums)    n := <span class="hljs-built_in">len</span>(nums)    maxCnt := <span class="hljs-number">1</span>    sum :=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> l,r := <span class="hljs-number">0</span>,<span class="hljs-number">1</span>;r&lt;n;r++&#123;        sum += (r-l)*(nums[r]-nums[r<span class="hljs-number">-1</span>])        <span class="hljs-keyword">for</span> sum&gt;k&#123;            sum -= nums[r]-nums[l]            l++        &#125;        maxCnt = max(maxCnt, r-l+<span class="hljs-number">1</span>)    &#125;    <span class="hljs-keyword">return</span> maxCnt&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时172 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：9 MB, 在所有 Go 提交中击败了19.23%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>191. 位1的个数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a><font size=6px>位1的个数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><p>示例 1：</p><p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：</p><p>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：</p><p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p><p>提示：</p><p>输入必须是长度为 32 的 二进制串 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(logn),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(num <span class="hljs-type">uint32</span>)</span></span> (ones <span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">for</span> ; num &gt; <span class="hljs-number">0</span>; num &amp;= num - <span class="hljs-number">1</span> &#123;        ones++    &#125;    <span class="hljs-keyword">return</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了14.68%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>169. 多数元素</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><font size=6px>多数元素</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1：</p><p>输入：[3,2,3]<br>输出：3<br>示例 2：</p><p>输入：[2,2,1,1,1,2,2]<br>输出：2</p><p>进阶：</p><p>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用摩尔投票法，如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 <code>0</code>，从结果本身我们可以看出众数比其他数多。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    count := <span class="hljs-number">1</span>    cantidate := nums[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>  ;i&lt;<span class="hljs-built_in">len</span>(nums) ;i++&#123;        <span class="hljs-keyword">if</span> nums[i] == cantidate&#123;            count ++        &#125;<span class="hljs-keyword">else</span>&#123;            count --        &#125;        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>&#123;            count = <span class="hljs-number">1</span>            cantidate = nums[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> cantidate&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了98.28%的用户<br>   内存消耗：5.9 MB, 在所有 Go 提交中击败了98.28%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1984. Minimum Difference Between Highest and Lowest of K Scores</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1984.%20Minimum%20Difference%20Between%20Highest%20and%20Lowest%20of%20K%20Scores/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1984.%20Minimum%20Difference%20Between%20Highest%20and%20Lowest%20of%20K%20Scores/</url>
    
    <content type="html"><![CDATA[<h3 id="Minimum-Difference-Between-Highest-and-Lowest-of-K-Scores"><a href="#Minimum-Difference-Between-Highest-and-Lowest-of-K-Scores" class="headerlink" title="Minimum Difference Between Highest and Lowest of K Scores"></a><font size=6px>Minimum Difference Between Highest and Lowest of K Scores</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.</p><p>Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.</p><p>Return the minimum possible difference.</p><p>Example 1:</p><p>Input: nums &#x3D; [90], k &#x3D; 1<br>Output: 0<br>Explanation: There is one way to pick score(s) of one student:</p><ul><li>[90]. The difference between the highest and lowest score is 90 - 90 &#x3D; 0.<br>The minimum possible difference is 0.<br>Example 2:</li></ul><p>Input: nums &#x3D; [9,4,1,7], k &#x3D; 2<br>Output: 2<br>Explanation: There are six ways to pick score(s) of two students:</p><ul><li>[9,4,1,7]. The difference between the highest and lowest score is 9 - 4 &#x3D; 5.</li><li>[9,4,1,7]. The difference between the highest and lowest score is 9 - 1 &#x3D; 8.</li><li>[9,4,1,7]. The difference between the highest and lowest score is 9 - 7 &#x3D; 2.</li><li>[9,4,1,7]. The difference between the highest and lowest score is 4 - 1 &#x3D; 3.</li><li>[9,4,1,7]. The difference between the highest and lowest score is 7 - 4 &#x3D; 3.</li><li>[9,4,1,7]. The difference between the highest and lowest score is 7 - 1 &#x3D; 6.<br>The minimum possible difference is 2.</li></ul><p>Constraints:</p><p>1 &lt;&#x3D; k &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>排序一下就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumDifference</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    sort.Ints(nums)    minNum := <span class="hljs-number">999999</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n-k+<span class="hljs-number">1</span>;i++&#123;        minNum = min(minNum, nums[i+k<span class="hljs-number">-1</span>]-nums[i])    &#125;    <span class="hljs-keyword">return</span> minNum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b     &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了94.74%的用户<br>   内存消耗：5 MB, 在所有 Go 提交中击败了89.47%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>198. 打家劫舍</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><font size=6px>打家劫舍</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400<br>通过次数453,296提交次数866,676</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，递推方程    全球num[i] &#x3D; max(num[i-2],num[i-3])+nums[i]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> num []<span class="hljs-type">int</span>    num = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;=<span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;            res = max(res,nums[i])        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) ==<span class="hljs-number">3</span>&#123;            res = max(nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">2</span>],res)        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        num[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]        num[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>]        num[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">2</span>]+nums[<span class="hljs-number">0</span>]        res = max(num[<span class="hljs-number">0</span>],num[<span class="hljs-number">1</span>])        res = max(res,num[<span class="hljs-number">2</span>])        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">3</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;            num[i] = max(num[i<span class="hljs-number">-2</span>],num[i<span class="hljs-number">-3</span>])+nums[i]            res = max(res,num[i])        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">( a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.删除链表倒数第k个节点</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="删除链表倒数第k个节点"><a href="#删除链表倒数第k个节点" class="headerlink" title="删除链表倒数第k个节点"></a><font size=6px>删除链表倒数第k个节点</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>示例 2：</p><p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br>示例 3：</p><p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]</p><p>提示：</p><p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针，先快指针走n步，再快慢指针一起走，快指针下一个是nil的时候慢指针刚好是倒数第n个</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * type ListNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *ListNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> head    &#125;    fastNode,slowNdoe := head,head    <span class="hljs-keyword">for</span>  i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fastNode = fastNode.Next;    &#125;    <span class="hljs-keyword">if</span> fastNode == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> head.Next    &#125;    <span class="hljs-keyword">for</span> fastNode.Next != <span class="hljs-literal">nil</span>  &#123;        fastNode = fastNode.Next        slowNdoe = slowNdoe.Next    &#125;    slowNdoe.Next = slowNdoe.Next.Next<span class="hljs-keyword">return</span> head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>199. 二叉树的右视图</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a><font size=6px>二叉树的右视图</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例 1:</p><p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br>示例 2:</p><p>输入: [1,null,3]<br>输出: [1,3]<br>示例 3:</p><p>输入: []<br>输出: []</p><p>提示:</p><p>二叉树的节点个数的范围是 [0,100]<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用bfs来做，每一层取出最右边的那个节点的值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> queue,queue2 []*TreeNode    queue = <span class="hljs-built_in">append</span>(queue, root)    <span class="hljs-keyword">var</span> bfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>    bfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;        node := queue[<span class="hljs-number">0</span>]        queue = queue[<span class="hljs-number">1</span>:]        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span>&#123;            queue2 = <span class="hljs-built_in">append</span>(queue2, node.Left)        &#125;         <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span>&#123;            queue2 = <span class="hljs-built_in">append</span>(queue2, node.Right)        &#125;    &#125;    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue)!=<span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(queue2)!= <span class="hljs-number">0</span>&#123;        res = <span class="hljs-built_in">append</span>(res, queue[<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>].Val)        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>&#123;            bfs()        &#125;        queue = queue2        queue2 = []*TreeNode&#123;&#125;     &#125;            <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了90.94%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2000. 反转单词前缀</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2000.%20%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%89%8D%E7%BC%80/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2000.%20%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h3 id="反转单词前缀"><a href="#反转单词前缀" class="headerlink" title="反转单词前缀"></a><font size=6px>反转单词前缀</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。</p><p>例如，如果 word &#x3D; “abcdefd” 且 ch &#x3D; “d” ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。结果字符串将会是 “dcbaefd” 。<br>返回 结果字符串 。</p><p>示例 1：</p><p>输入：word &#x3D; “abcdefd”, ch &#x3D; “d”<br>输出：”dcbaefd”<br>解释：”d” 第一次出现在下标 3 。<br>反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 “dcbaefd” 。<br>示例 2：</p><p>输入：word &#x3D; “xyxzxe”, ch &#x3D; “z”<br>输出：”zxyxxe”<br>解释：”z” 第一次也是唯一一次出现是在下标 3 。<br>反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 “zxyxxe” 。<br>示例 3：</p><p>输入：word &#x3D; “abcd”, ch &#x3D; “z”<br>输出：”abcd”<br>解释：”z” 不存在于 word 中。<br>无需执行反转操作，结果字符串是 “abcd” 。</p><p>提示：</p><p>1 &lt;&#x3D; word.length &lt;&#x3D; 250<br>word 由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reversePrefix</span><span class="hljs-params">(word <span class="hljs-type">string</span>, ch <span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> temp []<span class="hljs-type">byte</span>       <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(word); i++&#123;        <span class="hljs-keyword">if</span> word[i] == ch&#123;            <span class="hljs-keyword">for</span> j:=i ;j&gt;=<span class="hljs-number">0</span>;j--&#123;                temp = <span class="hljs-built_in">append</span>(temp, word[j])            &#125;            word = word[i+<span class="hljs-number">1</span>:]            <span class="hljs-keyword">break</span>        &#125;    &#125;    word = <span class="hljs-type">string</span>(temp)+word    <span class="hljs-keyword">return</span> word&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了92.98%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2006. 差的绝对值为 K 的数对数目</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2006.%20%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%BA%20K%20%E7%9A%84%E6%95%B0%E5%AF%B9%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2006.%20%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%BA%20K%20%E7%9A%84%E6%95%B0%E5%AF%B9%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="差的绝对值为-K-的数对数目"><a href="#差的绝对值为-K-的数对数目" class="headerlink" title="差的绝对值为 K 的数对数目"></a><font size=6px>差的绝对值为 K 的数对数目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums 和一个整数 k ，请你返回数对 (i, j) 的数目，满足 i &lt; j 且 |nums[i] - nums[j]| &#x3D;&#x3D; k 。</p><p>|x| 的值定义为：</p><p>如果 x &gt;&#x3D; 0 ，那么值为 x 。<br>如果 x &lt; 0 ，那么值为 -x 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,2,1], k &#x3D; 1<br>输出：4<br>解释：差的绝对值为 1 的数对为：</p><ul><li>[1,2,2,1]</li><li>[1,2,2,1]</li><li>[1,2,2,1]</li><li>[1,2,2,1]<br>示例 2：</li></ul><p>输入：nums &#x3D; [1,3], k &#x3D; 3<br>输出：0<br>解释：没有任何数对差的绝对值为 3 。<br>示例 3：</p><p>输入：nums &#x3D; [3,2,1,5,4], k &#x3D; 2<br>输出：3<br>解释：差的绝对值为 2 的数对为：</p><ul><li>[3,2,1,5,4]</li><li>[3,2,1,5,4]</li><li>[3,2,1,5,4]</li></ul><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100<br>1 &lt;&#x3D; k &lt;&#x3D; 99</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用哈希表 +（num+k &#x3D; num2）</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countKDifference</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    ans := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,num := <span class="hljs-keyword">range</span> nums&#123;        ans += (mp[num-k] +mp[num+k])        mp[num]++    &#125;    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了97.00%的用户<br>   内存消耗：4 MB, 在所有 Go 提交中击败了41.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024. 考试的最大困扰度</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2024.%20%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2024.%20%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="考试的最大困扰度"><a href="#考试的最大困扰度" class="headerlink" title="考试的最大困扰度"></a><font size=6px>考试的最大困扰度</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一位老师正在出一场由 n 道判断题构成的考试，每道题的答案为 true （用 ‘T’ 表示）或者 false （用 ‘F’ 表示）。老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 true 或者连续出现 false）。</p><p>给你一个字符串 answerKey ，其中 answerKey[i] 是第 i 个问题的正确结果。除此以外，还给你一个整数 k ，表示你能进行以下操作的最多次数：</p><p>每次操作中，将问题的正确答案改为 ‘T’ 或者 ‘F’ （也就是将 answerKey[i] 改为 ‘T’ 或者 ‘F’ ）。<br>请你返回在不超过 k 次操作的情况下，最大 连续 ‘T’ 或者 ‘F’ 的数目。</p><p>示例 1：</p><p>输入：answerKey &#x3D; “TTFF”, k &#x3D; 2<br>输出：4<br>解释：我们可以将两个 ‘F’ 都变为 ‘T’ ，得到 answerKey &#x3D; “TTTT” 。<br>总共有四个连续的 ‘T’ 。<br>示例 2：</p><p>输入：answerKey &#x3D; “TFFT”, k &#x3D; 1<br>输出：3<br>解释：我们可以将最前面的 ‘T’ 换成 ‘F’ ，得到 answerKey &#x3D; “FFFT” 。<br>或者，我们可以将第二个 ‘T’ 换成 ‘F’ ，得到 answerKey &#x3D; “TFFF” 。<br>两种情况下，都有三个连续的 ‘F’ 。<br>示例 3：</p><p>输入：answerKey &#x3D; “TTFTTFTT”, k &#x3D; 1<br>输出：5<br>解释：我们可以将第一个 ‘F’ 换成 ‘T’ ，得到 answerKey &#x3D; “TTTTTFTT” 。<br>或者我们可以将第二个 ‘F’ 换成 ‘T’ ，得到 answerKey &#x3D; “TTFTTTTT” 。<br>两种情况下，都有五个连续的 ‘T’ 。</p><p>提示：</p><p>n &#x3D;&#x3D; answerKey.length<br>1 &lt;&#x3D; n &lt;&#x3D; 5 * 104<br>answerKey[i] 要么是 ‘T’ ，要么是 ‘F’<br>1 &lt;&#x3D; k &lt;&#x3D; n</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用滑动窗口法做会容易很多</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxConsecutiveAnswers</span><span class="hljs-params">(answerKey <span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    l,r := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    TNum,FNum := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    maxNUm := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> l&lt;=r &amp;&amp; r &lt;<span class="hljs-built_in">len</span>(answerKey)&#123;        <span class="hljs-keyword">if</span>(k &gt;= min(TNum,FNum))&#123;            <span class="hljs-keyword">if</span> answerKey[r] == <span class="hljs-string">&#x27;T&#x27;</span>&#123;                 TNum++            &#125;<span class="hljs-keyword">else</span>&#123;                FNum++            &#125;            <span class="hljs-comment">// 为了保证min(TNum,FNum)不大于k</span>            <span class="hljs-keyword">if</span> k &gt;= min(TNum,FNum)&#123;                maxNUm = max(maxNUm, TNum+FNum)            &#125;            r++        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span>(k &lt; min(TNum,FNum) &amp;&amp; l&lt;=r)&#123;                <span class="hljs-keyword">if</span> answerKey[l] == <span class="hljs-string">&#x27;T&#x27;</span>&#123;                    TNum--                &#125;<span class="hljs-keyword">else</span>&#123;                    FNum--                &#125;                l++            &#125;        &#125;            &#125;    <span class="hljs-keyword">return</span> maxNUm&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了96.77%的用户<br>   内存消耗：5 MB, 在所有 Go 提交中击败了67.74%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2028. 找出缺失的观测数据</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2028.%20%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2028.%20%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="找出缺失的观测数据"><a href="#找出缺失的观测数据" class="headerlink" title="找出缺失的观测数据"></a><font size=6px>找出缺失的观测数据</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>现有一份 n + m 次投掷单个 六面 骰子的观测数据，骰子的每个面从 1 到 6 编号。观测数据中缺失了 n 份，你手上只拿到剩余 m 次投掷的数据。幸好你有之前计算过的这 n + m 次投掷数据的 平均值 。</p><p>给你一个长度为 m 的整数数组 rolls ，其中 rolls[i] 是第 i 次观测的值。同时给你两个整数 mean 和 n 。</p><p>返回一个长度为 n 的数组，包含所有缺失的观测数据，且满足这 n + m 次投掷的 平均值 是 mean 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。</p><p>k 个数字的 平均值 为这些数字求和后再除以 k 。</p><p>注意 mean 是一个整数，所以 n + m 次投掷的总和需要被 n + m 整除。</p><p>示例 1：</p><p>输入：rolls &#x3D; [3,2,4,3], mean &#x3D; 4, n &#x3D; 2<br>输出：[6,6]<br>解释：所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) &#x2F; 6 &#x3D; 4 。<br>示例 2：</p><p>输入：rolls &#x3D; [1,5,6], mean &#x3D; 3, n &#x3D; 4<br>输出：[2,3,2,2]<br>解释：所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) &#x2F; 7 &#x3D; 3 。<br>示例 3：</p><p>输入：rolls &#x3D; [1,2,3,4], mean &#x3D; 6, n &#x3D; 4<br>输出：[]<br>解释：无论丢失的 4 次数据是什么，平均值都不可能是 6 。<br>示例 4：</p><p>输入：rolls &#x3D; [1], mean &#x3D; 3, n &#x3D; 1<br>输出：[5]<br>解释：所有 n + m 次投掷的平均值是 (1 + 5) &#x2F; 2 &#x3D; 3 。</p><p>提示：</p><p>m &#x3D;&#x3D; rolls.length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 105<br>1 &lt;&#x3D; rolls[i], mean &lt;&#x3D; 6</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>先求出平均数，然后如果不够就再每个加一直到满足条件。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">missingRolls</span><span class="hljs-params">(rolls []<span class="hljs-type">int</span>, mean <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    sum := <span class="hljs-number">0</span>    n_ := <span class="hljs-built_in">len</span>(rolls)    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> rolls&#123;        sum += v    &#125;    total := mean*(n_+n)    ave := <span class="hljs-type">float64</span>((total-sum)/n)    <span class="hljs-keyword">if</span> ave&gt;<span class="hljs-number">6</span> || ave &lt;=<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    sum_2 := <span class="hljs-type">int</span>(ave)*n    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        res = <span class="hljs-built_in">append</span>(res, <span class="hljs-type">int</span>(ave))            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> sum_2 == (total-sum)&#123;            <span class="hljs-keyword">return</span> res        &#125;        res[i]++        <span class="hljs-keyword">if</span> res[i]&gt;<span class="hljs-number">6</span> || res[i]&lt;=<span class="hljs-number">1</span>&#123;            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;        &#125;        sum_2++    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：140 ms, 在所有 Go 提交中击败了46.15%的用户<br>   内存消耗：8.4 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1791. 找出星型图的中心节点</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1791.%20%E6%89%BE%E5%87%BA%E6%98%9F%E5%9E%8B%E5%9B%BE%E7%9A%84%E4%B8%AD%E5%BF%83%E8%8A%82%E7%82%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1791.%20%E6%89%BE%E5%87%BA%E6%98%9F%E5%9E%8B%E5%9B%BE%E7%9A%84%E4%B8%AD%E5%BF%83%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="找出星型图的中心节点"><a href="#找出星型图的中心节点" class="headerlink" title="找出星型图的中心节点"></a><font size=6px>找出星型图的中心节点</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。</p><p>给你一个二维整数数组 edges ，其中 edges[i] &#x3D; [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。</p><p>示例 1：</p><p>输入：edges &#x3D; [[1,2],[2,3],[4,2]]<br>输出：2<br>解释：如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。<br>示例 2：</p><p>输入：edges &#x3D; [[1,2],[5,1],[1,3],[1,4]]<br>输出：1</p><p>提示：</p><p>3 &lt;&#x3D; n &lt;&#x3D; 105<br>edges.length &#x3D;&#x3D; n - 1<br>edges[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; ui, vi &lt;&#x3D; n<br>ui !&#x3D; vi<br>题目数据给出的 edges 表示一个有效的星型图</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找到频率最大的那个数就是中心节点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCenter</span><span class="hljs-params">(edges [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span>    res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">100001</span>)    maxNum := <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(edges);i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++&#123;            res[edges[i][j]]++            <span class="hljs-keyword">if</span> res[edges[i][j]]&gt;maxNum&#123;                maxNum = res[edges[i][j]]                ans = edges[i][j]            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：104 ms, 在所有 Go 提交中击败了98.78%的用户<br>   内存消耗：15.3 MB, 在所有 Go 提交中击败了46.34%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1567. 乘积为正数的最长子数组长度</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1567.%20%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1567.%20%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="乘积为正数的最长子数组长度"><a href="#乘积为正数的最长子数组长度" class="headerlink" title="乘积为正数的最长子数组长度"></a><font size=6px>乘积为正数的最长子数组长度</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。</p><p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p><p>请你返回乘积为正数的最长子数组长度。</p><p>示例  1：</p><p>输入：nums &#x3D; [1,-2,-3,4]<br>输出：4<br>解释：数组本身乘积就是正数，值为 24 。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,-2,-3,-4]<br>输出：3<br>解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。<br>注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。<br>示例 3：</p><p>输入：nums &#x3D; [-1,-2,-3,0,1]<br>输出：2<br>解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>分类讨论正负数两种情况</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMaxLen</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> dp1,dp2,res <span class="hljs-type">int</span>    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> nums[i] &gt;<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> dp2 &gt;<span class="hljs-number">0</span>&#123;                dp2 ++            &#125;            dp1 +=<span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[i] &lt;<span class="hljs-number">0</span>&#123;            a,b := dp1,dp2            <span class="hljs-keyword">if</span> b &gt;<span class="hljs-number">0</span> &#123;                dp1 = b+<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span> &#123;                dp1 = <span class="hljs-number">0</span>            &#125;            dp2 = a+<span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            dp1,dp2 = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>        &#125;        res = max(res,dp1)    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：92 ms, 在所有 Go 提交中击败了12.05%的用户<br>   内存消耗：9.7 MB, 在所有 Go 提交中击败了83.13%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2029. 石子游戏 IX</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2029.%20%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%20IX/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2029.%20%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%20IX/</url>
    
    <content type="html"><![CDATA[<h3 id="石子游戏-IX"><a href="#石子游戏-IX" class="headerlink" title="石子游戏 IX"></a><font size=6px>石子游戏 IX</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。</p><p>Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。</p><p>如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。<br>如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。<br>假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。</p><p>示例 1：</p><p>输入：stones &#x3D; [2,1]<br>输出：true<br>解释：游戏进行如下：</p><ul><li>回合 1：Alice 可以移除任意一个石子。</li><li>回合 2：Bob 移除剩下的石子。<br>已移除的石子的值总和为 1 + 2 &#x3D; 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。<br>示例 2：</li></ul><p>输入：stones &#x3D; [2]<br>输出：false<br>解释：Alice 会移除唯一一个石子，已移除石子的值总和为 2 。<br>由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。<br>示例 3：</p><p>输入：stones &#x3D; [5,1,2,4,3]<br>输出：false<br>解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：</p><ul><li>回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。</li><li>回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 &#x3D; 1 + 3 &#x3D; 4 。</li><li>回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 &#x3D; 1 + 3 + 4 &#x3D; 8 。</li><li>回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 &#x3D; 1 + 3 + 4 + 2 &#x3D; 10.</li><li>回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 &#x3D; 1 + 3 + 4 + 2 + 5 &#x3D; 15.<br>Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>s&#x3D;0 的石子数量为偶数：此时等价于没有 s &#x3D; 0s&#x3D;0 的石子，我们只需要关心 s &#x3D; 1s&#x3D;1 和 s &#x3D; 2s&#x3D;2 即可：</p><p>s &#x3D; 1s&#x3D;1 的石子数量为 00： 这意味着 A 开始选择的只能是 s &#x3D; 2s&#x3D;2，此时交给 B 的局面为「x &#x3D; 2x&#x3D;2、剩余石子只有 s &#x3D; 2s&#x3D;2」，此时 B 只能选 s &#x3D; 2s&#x3D;2 的石子，由于 x &#x3D; 2x&#x3D;2 且选择的石子 s &#x3D; 2s&#x3D;2，因此交由回 A 的局面为「x &#x3D; 1x&#x3D;1，剩余是在只有 s &#x3D; 2s&#x3D;2」，因此游戏继续的话 A 必败，同时如果在该过程的任何时刻石子被取完，也是 B 直接获胜，即 A 仍为必败；</p><p>s &#x3D; 2s&#x3D;2 的石子数量为 00：分析同理，A 只能选 s &#x3D; 1s&#x3D;1，此时交给 B 的局面为「x &#x3D; 1x&#x3D;1、剩余石子只有 s &#x3D; 1s&#x3D;1」，此时 B 只能选 s &#x3D; 1s&#x3D;1 的石子，由于 x &#x3D; 1x&#x3D;1 且选择的石子 s &#x3D; 1s&#x3D;1，因此交由回 A 的局面为「x &#x3D; 2x&#x3D;2，剩余是在只有 s &#x3D; 1s&#x3D;1」，因此游戏继续的话 A 必败，同时如果在该过程的任何时刻石子被取完，也是 B 直接获胜，即 A 仍为必败；</p><p>s &#x3D; 1s&#x3D;1 和 s &#x3D; 2s&#x3D;2 的石子数量均不为 00：A 选数量不是最多的一类石子，B 下一回合只能选择相同类型的石子（或是无从选择导致失败），然后游戏继续，最终 B 会先进入「只能凑成 33 的倍数」的局面导致失败，即 A 必胜。</p><p>s &#x3D; 0s&#x3D;0 的石子数量为奇数：此时等价于有一次换手机会，该换手机会必然应用在「对必败局面进行转移」才有意义，因此只有 s &#x3D; 1s&#x3D;1 和 s &#x3D; 2s&#x3D;2 的石子数量差大于 22，A 的先手优势不会因为存在换手机会而被转移：</p><p>两者数量差不超过 22：此时 B 可以利用「对方凑成 33 的倍数必败」规则和「优先使用 s &#x3D; 0s&#x3D;0 石子」权利来进入确保自己为必胜态：</p><p>举个 🌰，当 s &#x3D; 1s&#x3D;1 和 s &#x3D; 2s&#x3D;2 的石子数量相等，虽然有 s &#x3D; 0s&#x3D;0 的石子，A 先手，但是 A 的首个回合必然不能选 s &#x3D; 0s&#x3D;0，否则马上失败结束，因此 A 只能选 s &#x3D; 1s&#x3D;1 或 s &#x3D; 2s&#x3D;2，此时 B直接选择 s &#x3D; 0s&#x3D;0 的石子，交由给 A 的局面 xx 没有发生改变，A 只能选择与首个回合相同的 ss 游戏才能继续，因此局面会变为「B 先手、s &#x3D; 1s&#x3D;1 和 s &#x3D; 2s&#x3D;2 的石子数量差为 22」，游戏继续，最终 A 会先遇到「只能凑成 33 的倍数」的局面，即 B 必胜。</p><p>两者数量差不超过 2：此时无论 A 选择数量较少或较多的 s，B 都在第二回合马上使用 s &#x3D; 0 的石子进行换手，A 只能继续选与第一回合相同类型的的石子，游戏才能进行，最终 A 会先遇到「只能凑成 3 的倍数」或「石子被取完」的局面，即 B 必胜。</p><p>两者数量差超过 2 ：此时即使 A 只要确保第一次选择数量较多的 s，不管 B 是否使用「优先使用 s &#x3D; 0s&#x3D;0」的石子，A 都有足够次数数量多 ss 来抵消换手（或是在 B 放弃使用 s &#x3D; 0s&#x3D;0 之后马上使用），最终都是 B 最先遇到「只能凑成 33 的倍数」的局面，即 A 获胜。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stoneGameIX</span><span class="hljs-params">(stones []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> mode_0,mode_1,mode_2 <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> stones&#123;        <span class="hljs-keyword">if</span> v %<span class="hljs-number">3</span> == <span class="hljs-number">0</span>&#123;            mode_0 ++        &#125;        <span class="hljs-keyword">if</span> v %<span class="hljs-number">3</span> == <span class="hljs-number">1</span>&#123;            mode_1 ++        &#125;        <span class="hljs-keyword">if</span> v % <span class="hljs-number">3</span> ==<span class="hljs-number">2</span> &#123;            mode_2 ++        &#125;    &#125;    <span class="hljs-keyword">if</span> mode_0 % <span class="hljs-number">2</span> ==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> mode_1&gt;=<span class="hljs-number">1</span> &amp;&amp; mode_2 &gt;=<span class="hljs-number">1</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> abs(mode_1-mode_2)&gt;<span class="hljs-number">2</span>    &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a &lt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> -a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：8.9 MB, 在所有 Go 提交中击败了73.08%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2043. 简易银行系统</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2043.%20%E7%AE%80%E6%98%93%E9%93%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2043.%20%E7%AE%80%E6%98%93%E9%93%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="简易银行系统"><a href="#简易银行系统" class="headerlink" title="简易银行系统"></a><font size=6px>简易银行系统</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 n 个账户，编号从 1 到 n 。每个账号的初始余额存储在一个下标从 0 开始的整数数组 balance 中，其中第 (i + 1) 个账户的初始余额是 balance[i] 。</p><p>请你执行所有 有效的 交易。如果满足下面全部条件，则交易 有效 ：</p><p>指定的账户数量在 1 和 n 之间，且<br>取款或者转账需要的钱的总数 小于或者等于 账户余额。<br>实现 Bank 类：</p><p>Bank(long[] balance) 使用下标从 0 开始的整数数组 balance 初始化该对象。<br>boolean transfer(int account1, int account2, long money) 从编号为 account1 的账户向编号为 account2 的账户转帐 money 美元。如果交易成功，返回 true ，否则，返回 false 。<br>boolean deposit(int account, long money) 向编号为 account 的账户存款 money 美元。如果交易成功，返回 true ；否则，返回 false 。<br>boolean withdraw(int account, long money) 从编号为 account 的账户取款 money 美元。如果交易成功，返回 true ；否则，返回 false 。</p><p>示例：</p><p>输入：<br>[“Bank”, “withdraw”, “transfer”, “deposit”, “transfer”, “withdraw”]<br>[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]<br>输出：<br>[null, true, true, true, false, false]</p><p>解释：<br>Bank bank &#x3D; new Bank([10, 100, 20, 50, 30]);<br>bank.withdraw(3, 10);    &#x2F;&#x2F; 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。<br>                         &#x2F;&#x2F; 账户 3 余额为 $20 - $10 &#x3D; $10 。<br>bank.transfer(5, 1, 20); &#x2F;&#x2F; 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。<br>                         &#x2F;&#x2F; 账户 5 的余额为 $30 - $20 &#x3D; $10 ，账户 1 的余额为 $10 + $20 &#x3D; $30 。<br>bank.deposit(5, 20);     &#x2F;&#x2F; 返回 true ，可以向账户 5 存款 $20 。<br>                         &#x2F;&#x2F; 账户 5 的余额为 $10 + $20 &#x3D; $30 。<br>bank.transfer(3, 4, 15); &#x2F;&#x2F; 返回 false ，账户 3 的当前余额是 $10 。<br>                         &#x2F;&#x2F; 所以无法转账 $15 。<br>bank.withdraw(10, 50);   &#x2F;&#x2F; 返回 false ，交易无效，因为账户 10 并不存在。</p><p>提示：</p><p>n &#x3D;&#x3D; balance.length<br>1 &lt;&#x3D; n, account, account1, account2 &lt;&#x3D; 105<br>0 &lt;&#x3D; balance[i], money &lt;&#x3D; 1012<br>transfer, deposit, withdraw 三个函数，每个 最多调用 104 次</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>模拟就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Bank <span class="hljs-keyword">struct</span> &#123;    moneys []<span class="hljs-type">int64</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(balance []<span class="hljs-type">int64</span>)</span></span> Bank &#123;    balance = <span class="hljs-built_in">append</span>([]<span class="hljs-type">int64</span>&#123;<span class="hljs-number">0</span>&#125;, balance...)    <span class="hljs-keyword">return</span> Bank&#123;moneys: balance&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Bank)</span></span> Transfer(account1 <span class="hljs-type">int</span>, account2 <span class="hljs-type">int</span>, money <span class="hljs-type">int64</span>) <span class="hljs-type">bool</span> &#123;    n := <span class="hljs-built_in">len</span>(this.moneys)    <span class="hljs-keyword">if</span> account1 &gt;n || account2&gt;n || this.moneys[account1] &lt; money&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    this.moneys[account1] -= money    this.moneys[account2] += money    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Bank)</span></span> Deposit(account <span class="hljs-type">int</span>, money <span class="hljs-type">int64</span>) <span class="hljs-type">bool</span> &#123;    n := <span class="hljs-built_in">len</span>(this.moneys)    <span class="hljs-keyword">if</span> account &gt;n&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    this.moneys[account] += money    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Bank)</span></span> Withdraw(account <span class="hljs-type">int</span>, money <span class="hljs-type">int64</span>) <span class="hljs-type">bool</span> &#123;    n := <span class="hljs-built_in">len</span>(this.moneys)    <span class="hljs-keyword">if</span> account &gt;n || this.moneys[account]&lt; money&#123;         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    this.moneys[account] -= money    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your Bank object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor(balance);</span><span class="hljs-comment"> * param_1 := obj.Transfer(account1,account2,money);</span><span class="hljs-comment"> * param_2 := obj.Deposit(account,money);</span><span class="hljs-comment"> * param_3 := obj.Withdraw(account,money);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：324 ms, 在所有 Go 提交中击败了84.78%的用户<br>   内存消耗：33.1 MB, 在所有 Go 提交中击败了65.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2044. 统计按位或能得到最大值的子集数目</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2044.%20%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2044.%20%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="统计按位或能得到最大值的子集数目"><a href="#统计按位或能得到最大值的子集数目" class="headerlink" title="统计按位或能得到最大值的子集数目"></a><font size=6px>统计按位或能得到最大值的子集数目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。</p><p>如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。</p><p>对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR … OR a[a.length - 1]（下标从 0 开始）。</p><p>示例 1：</p><p>输入：nums &#x3D; [3,1]<br>输出：2<br>解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：</p><ul><li>[3]</li><li>[3,1]<br>示例 2：</li></ul><p>输入：nums &#x3D; [2,2,2]<br>输出：7<br>解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 &#x3D; 7 个子集。<br>示例 3：</p><p>输入：nums &#x3D; [3,2,1,5]<br>输出：6<br>解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：</p><ul><li>[3,5]</li><li>[3,1,5]</li><li>[3,2,5]</li><li>[3,2,1,5]</li><li>[2,5]</li><li>[2,1,5]</li></ul><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 16<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用dfs遍历所有情况,一个情况是不选这个数字，一个情况是选这个数字</p><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(2^<span class="hljs-params">n</span>)</span>,空间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span><span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countMaxOrSubsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    maxNum := <span class="hljs-number">0</span>    count := <span class="hljs-number">1</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start <span class="hljs-type">int</span>, sum <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start <span class="hljs-type">int</span>,sum <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> start == n&#123;            <span class="hljs-keyword">if</span> sum &gt; maxNum&#123;                maxNum = sum                count = <span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum == maxNum&#123;                count++            &#125;            <span class="hljs-keyword">return</span>         &#125;        dfs(start+<span class="hljs-number">1</span>, sum|nums[start])        dfs(start+<span class="hljs-number">1</span>, sum)    &#125;    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了65.85%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了95.12%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 两数相加</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><font size=6px>2. 两数相加</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 &#x3D; 807.<br>示例 2：</p><p>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]<br>示例 3：</p><p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p><p>提示：</p><p>每个链表中的节点数在范围 [1, 100] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9<br>题目数据保证列表表示的数字不含前导零</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>这题已经简化很多了，但是还是要考虑挺多情况，最重要的就是进位情况，弄一个新的链表用来存放两个链表的值，如果两个链表不等长，就把长的那个直接放在l3后面，最重要的这个时候要考虑连续进位的情况，记得用循环解决</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> l1.Next==<span class="hljs-literal">nil</span>&amp;&amp;l1.Val==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> l2    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2.Next==<span class="hljs-literal">nil</span>&amp;&amp;l2.Val==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> l1    &#125;    <span class="hljs-keyword">var</span> flag <span class="hljs-type">int</span>    l3 := &amp;ListNode&#123;&#125;    head :=l3    l3 .Val =l1.Val+l2.Val    <span class="hljs-keyword">if</span> l3.Val&gt;=<span class="hljs-number">10</span>&#123;        l3.Val %=<span class="hljs-number">10</span>        flag=<span class="hljs-number">1</span>    &#125;    l1 = l1.Next    l2 = l2.Next     <span class="hljs-keyword">for</span> l1!=<span class="hljs-literal">nil</span>&amp;&amp;l2 !=<span class="hljs-literal">nil</span>&#123;        node := &amp;ListNode&#123;&#125;        l3.Next=node        l3 = node        l3. Val  +=(l1.Val+l2.Val+flag)        <span class="hljs-keyword">if</span> l3.Val&gt;=<span class="hljs-number">10</span>&#123;            l3.Val %= <span class="hljs-number">10</span>            flag =<span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            flag = <span class="hljs-number">0</span>        &#125;        l1 = l1.Next        l2 = l2.Next    &#125;    <span class="hljs-comment">//l2和l1等长</span>    <span class="hljs-keyword">if</span> l2==<span class="hljs-literal">nil</span> &amp;&amp; l1 ==<span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span> &#123;            node := &amp;ListNode&#123;Val: <span class="hljs-number">1</span>&#125;            l3.Next = node        &#125;        <span class="hljs-comment">//l2长</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l1==<span class="hljs-literal">nil</span>&#123;        l3.Next = l2        <span class="hljs-keyword">if</span> flag==<span class="hljs-number">1</span>&#123;            l2.Val++            <span class="hljs-keyword">for</span> l2.Val&gt;=<span class="hljs-number">10</span>&#123;                <span class="hljs-keyword">if</span> l2.Next==<span class="hljs-literal">nil</span>&#123; <span class="hljs-comment">//连续进位情况</span>                    node := &amp;ListNode&#123;Val: <span class="hljs-number">1</span>&#125;                    l2.Val = <span class="hljs-number">0</span>                     l2.Next = node                    <span class="hljs-keyword">break</span>                &#125;                l2.Val %=<span class="hljs-number">10</span>                l2=l2.Next                l2.Val++            &#125;        &#125;        <span class="hljs-comment">//l1长</span>    &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> l2==<span class="hljs-literal">nil</span>&#123;        l3.Next = l1        <span class="hljs-keyword">if</span> flag ==<span class="hljs-number">1</span>&#123;            l1.Val++            <span class="hljs-keyword">for</span> l1.Val&gt;=<span class="hljs-number">10</span>&#123;                <span class="hljs-keyword">if</span> l1.Next == <span class="hljs-literal">nil</span>&#123;                    node := &amp;ListNode&#123;Val: <span class="hljs-number">1</span>&#125;<span class="hljs-comment">//连续进位情况</span>                    l1.Val=<span class="hljs-number">0</span>                    l1.Next= node                              <span class="hljs-keyword">break</span>                &#125;                l1.Val %=<span class="hljs-number">10</span>                l1=l1.Next                                l1.Val++            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了72.47%的用户<br>   内存消耗：4.6 MB, 在所有 Go 提交中击败了97.34%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2055. 蜡烛之间的盘子</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2055.%20%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2055.%20%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="蜡烛之间的盘子"><a href="#蜡烛之间的盘子" class="headerlink" title="蜡烛之间的盘子"></a><font size=6px>蜡烛之间的盘子</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 ‘<em>‘ 和 ‘|’ ，其中 ‘</em>‘ 表示一个 盘子 ，’|’ 表示一支 蜡烛 。</p><p>同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] &#x3D; [lefti, righti] 表示 子字符串 s[lefti…righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。</p><p>比方说，s &#x3D; “||<strong>||</strong>|<em>“ ，查询 [3, 8] ，表示的是子字符串 “</em>||**|” 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。<br>请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。</p><p>示例 1:</p><p>输入：s &#x3D; “<strong>|</strong>|***|”, queries &#x3D; [[2,5],[5,9]]<br>输出：[2,3]<br>解释：</p><ul><li>queries[0] 有两个盘子在蜡烛之间。</li><li>queries[1] 有三个盘子在蜡烛之间。<br>示例 2:</li></ul><p>输入：s &#x3D; “<em><strong>|</strong>|</em>****|<strong>||</strong>|*”, queries &#x3D; [[1,17],[4,5],[14,17],[5,11],[15,16]]<br>输出：[9,0,0,0,0]<br>解释：</p><ul><li>queries[0] 有 9 个盘子在蜡烛之间。</li><li>另一个查询没有盘子在蜡烛之间。</li></ul><p>提示：</p><p>3 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s 只包含字符 ‘*’ 和 ‘|’ 。<br>1 &lt;&#x3D; queries.length &lt;&#x3D; 105<br>queries[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; lefti &lt;&#x3D; righti &lt; s.length</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用前缀合思路做， 计算出每一个｜的*个数,并且算出星号最近的右边的和左边的｜就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">// 用前缀和思路做</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">platesBetweenCandles</span><span class="hljs-params">(s <span class="hljs-type">string</span>, queries [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span>&#123;    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s))    left := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(s))    right := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(s))    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">int</span>    cnt :=<span class="hljs-number">0</span>    <span class="hljs-comment">// 一次遍历出各个｜号中间有多少*</span>    l:=<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;|&#x27;</span>&#123;            l = i            res[l] = cnt            left[i] = i        &#125;<span class="hljs-keyword">else</span>&#123;            left[i] = l            cnt ++        &#125;    &#125;    r:=<span class="hljs-built_in">len</span>(s)    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;|&#x27;</span>&#123;            r = i            right[i] = i        &#125;<span class="hljs-keyword">else</span>&#123;            right[i] = r        &#125;    &#125;    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> queries&#123;        x := right[v[<span class="hljs-number">0</span>]]        y := left[v[<span class="hljs-number">1</span>]]        <span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;<span class="hljs-built_in">len</span>(s) &amp;&amp; x&lt;=y&#123;            ans = <span class="hljs-built_in">append</span>(ans,res[y]-res[x])        &#125;<span class="hljs-keyword">else</span>&#123;            ans = <span class="hljs-built_in">append</span>(ans,<span class="hljs-number">0</span>)        &#125;    &#125;    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2038. 如果相邻两个颜色均相同则删除当前颜色</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2038.%20%E5%A6%82%E6%9E%9C%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E5%9D%87%E7%9B%B8%E5%90%8C%E5%88%99%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E9%A2%9C%E8%89%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2038.%20%E5%A6%82%E6%9E%9C%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E5%9D%87%E7%9B%B8%E5%90%8C%E5%88%99%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E9%A2%9C%E8%89%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="如果相邻两个颜色均相同则删除当前颜色"><a href="#如果相邻两个颜色均相同则删除当前颜色" class="headerlink" title="如果相邻两个颜色均相同则删除当前颜色"></a><font size=6px>如果相邻两个颜色均相同则删除当前颜色</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>总共有 n 个颜色片段排成一列，每个颜色片段要么是 ‘A’ 要么是 ‘B’ 。给你一个长度为 n 的字符串 colors ，其中 colors[i] 表示第 i 个颜色片段的颜色。</p><p>Alice 和 Bob 在玩一个游戏，他们 轮流 从这个字符串中删除颜色。Alice 先手 。</p><p>如果一个颜色片段为 ‘A’ 且 相邻两个颜色 都是颜色 ‘A’ ，那么 Alice 可以删除该颜色片段。Alice 不可以 删除任何颜色 ‘B’ 片段。<br>如果一个颜色片段为 ‘B’ 且 相邻两个颜色 都是颜色 ‘B’ ，那么 Bob 可以删除该颜色片段。Bob 不可以 删除任何颜色 ‘A’ 片段。<br>Alice 和 Bob 不能 从字符串两端删除颜色片段。<br>如果其中一人无法继续操作，则该玩家 输 掉游戏且另一玩家 获胜 。<br>假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 true，否则 Bob 获胜，返回 false。</p><p>示例 1：</p><p>输入：colors &#x3D; “AAABABB”<br>输出：true<br>解释：<br>AAABABB -&gt; AABABB<br>Alice 先操作。<br>她删除从左数第二个 ‘A’ ，这也是唯一一个相邻颜色片段都是 ‘A’ 的 ‘A’ 。</p><p>现在轮到 Bob 操作。<br>Bob 无法执行任何操作，因为没有相邻位置都是 ‘B’ 的颜色片段 ‘B’ 。<br>因此，Alice 获胜，返回 true 。<br>示例 2：</p><p>输入：colors &#x3D; “AA”<br>输出：false<br>解释：<br>Alice 先操作。<br>只有 2 个 ‘A’ 且它们都在字符串的两端，所以她无法执行任何操作。<br>因此，Bob 获胜，返回 false 。<br>示例 3：</p><p>输入：colors &#x3D; “ABBBBBBBAAA”<br>输出：false<br>解释：<br>ABBBBBBBAAA -&gt; ABBBBBBBAA<br>Alice 先操作。<br>她唯一的选择是删除从右数起第二个 ‘A’ 。</p><p>ABBBBBBBAA -&gt; ABBBBBBAA<br>接下来轮到 Bob 操作。<br>他有许多选择，他可以选择任何一个 ‘B’ 删除。</p><p>然后轮到 Alice 操作，她无法删除任何片段。<br>所以 Bob 获胜，返回 false 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>只能说根本不用啥算法，算a能走几步，b能走几步，然后a&gt;b就true</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">winnerOfGame</span><span class="hljs-params">(colors <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    a,b := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(colors)<span class="hljs-number">-1</span>; i++&#123;        <span class="hljs-keyword">if</span> colors[i] == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; colors[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; colors[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;A&#x27;</span> &#123;            a++        &#125;        <span class="hljs-keyword">if</span> colors[i] == <span class="hljs-string">&#x27;B&#x27;</span> &amp;&amp; colors[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;B&#x27;</span> &amp;&amp; colors[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span> &#123;            b++        &#125;    &#125;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了90.91%的用户<br>   内存消耗：6.2 MB, 在所有 Go 提交中击败了72.73%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2049. 统计最高分的节点数目</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2049.%20%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2049.%20%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="统计最高分的节点数目"><a href="#统计最高分的节点数目" class="headerlink" title="统计最高分的节点数目"></a><font size=6px>统计最高分的节点数目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] &#x3D;&#x3D; -1 。</p><p>一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。</p><p>请你返回有 最高得分 节点的 数目 。</p><p>示例 1:</p><p>输入：parents &#x3D; [-1,2,0,2,0]<br>输出：3<br>解释：</p><ul><li>节点 0 的分数为：3 * 1 &#x3D; 3</li><li>节点 1 的分数为：4 &#x3D; 4</li><li>节点 2 的分数为：1 * 1 * 2 &#x3D; 2</li><li>节点 3 的分数为：4 &#x3D; 4</li><li>节点 4 的分数为：4 &#x3D; 4<br>最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。<br>示例 2：</li></ul><p>输入：parents &#x3D; [-1,2,0]<br>输出：2<br>解释：</p><ul><li>节点 0 的分数为：2 &#x3D; 2</li><li>节点 1 的分数为：2 &#x3D; 2</li><li>节点 2 的分数为：1 * 1 &#x3D; 1<br>最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。</li></ul><p>提示：</p><p>n &#x3D;&#x3D; parents.length<br>2 &lt;&#x3D; n &lt;&#x3D; 105<br>parents[0] &#x3D;&#x3D; -1<br>对于 i !&#x3D; 0 ，有 0 &lt;&#x3D; parents[i] &lt;&#x3D; n - 1<br>parents 表示一棵二叉树。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先用数组构建出树，并且用dfs计算出这个节点的左右子树的个数和父节点的个数，相乘就是结果。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countHighestScoreNodes</span><span class="hljs-params">(parents []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;n := <span class="hljs-built_in">len</span>(parents)children := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<span class="hljs-keyword">for</span> node := <span class="hljs-number">1</span>; node &lt; n; node++ &#123;p := parents[node]children[p] = <span class="hljs-built_in">append</span>(children[p], node)&#125;maxScore := <span class="hljs-number">0</span><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;score, size := <span class="hljs-number">1</span>, n<span class="hljs-number">-1</span><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> children[node] &#123;sz := dfs(ch)            <span class="hljs-comment">// score 分别乘以他的左右子树的个数</span>score *= szsize -= sz&#125;        <span class="hljs-comment">// score 乘它的父亲的个数</span><span class="hljs-keyword">if</span> node &gt; <span class="hljs-number">0</span> &#123;score *= size&#125;<span class="hljs-keyword">if</span> score == maxScore &#123;ans++&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt; maxScore &#123;maxScore = scoreans = <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">return</span> n - size&#125;dfs(<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：128 ms, 在所有 Go 提交中击败了89.66%的用户<br>   内存消耗：23.2 MB, 在所有 Go 提交中击败了55.17%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2047. 句子中的有效单词数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2047.%20%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2047.%20%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="句子中的有效单词数"><a href="#句子中的有效单词数" class="headerlink" title="句子中的有效单词数"></a><font size=6px>句子中的有效单词数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>句子仅由小写字母（’a’ 到 ‘z’）、数字（’0’ 到 ‘9’）、连字符（’-‘）、标点符号（’!’、’.’ 和 ‘,’）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。</p><p>如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：</p><p>仅由小写字母、连字符和&#x2F;或标点（不含数字）。<br>至多一个 连字符 ‘-‘ 。如果存在，连字符两侧应当都存在小写字母（”a-b” 是一个有效单词，但 “-ab” 和 “ab-“ 不是有效单词）。<br>至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。<br>这里给出几个有效单词的例子：”a-b.”、”afad”、”ba-c”、”a!” 和 “!” 。</p><p>给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。</p><p>示例 1：</p><p>输入：sentence &#x3D; “cat and  dog”<br>输出：3<br>解释：句子中的有效单词是 “cat”、”and” 和 “dog”<br>示例 2：</p><p>输入：sentence &#x3D; “!this  1-s b8d!”<br>输出：0<br>解释：句子中没有有效单词<br>“!this” 不是有效单词，因为它以一个标点开头<br>“1-s” 和 “b8d” 也不是有效单词，因为它们都包含数字<br>示例 3：</p><p>输入：sentence &#x3D; “alice and  bob are playing stone-game10”<br>输出：5<br>解释：句子中的有效单词是 “alice”、”and”、”bob”、”are” 和 “playing”<br>“stone-game10” 不是有效单词，因为它含有数字<br>示例 4：</p><p>输入：sentence &#x3D; “he bought 2 pencils, 3 erasers, and 1  pencil-sharpener.”<br>输出：6<br>解释：句子中的有效单词是 “he”、”bought”、”pencils,”、”erasers,”、”and” 和 “pencil-sharpener.”</p><p>提示：</p><p>1 &lt;&#x3D; sentence.length &lt;&#x3D; 1000<br>sentence 由小写英文字母、数字（0-9）、以及字符（’ ‘、’-‘、’!’、’.’ 和 ‘,’）组成<br>句子中至少有 1 个 token</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countValidWords</span><span class="hljs-params">(sentence <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    ss := strings.Split(sentence, <span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>        <span class="hljs-keyword">for</span> _,i := <span class="hljs-keyword">range</span> ss&#123;        <span class="hljs-keyword">if</span> iscorrect(i)&#123;            count ++        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">iscorrect</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span><span class="hljs-type">bool</span>&#123;    biaodian := []<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>&#125;    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot; &quot;</span> || s == <span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;     count_ := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">if</span> s[i] &gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;=<span class="hljs-string">&#x27;9&#x27;</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;-&#x27;</span>&#123;            count_ ++            <span class="hljs-keyword">if</span> count_&gt;=<span class="hljs-number">2</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span> || i==<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;                    &#125;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++&#123;            <span class="hljs-keyword">if</span> s[i] == biaodian[j]&#123;                                <span class="hljs-keyword">if</span> i != <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                &#125;                <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> &amp;&amp; s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.9 MB, 在所有 Go 提交中击败了42.33%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>206. 反转链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><h4 id="思路-无"><a href="#思路-无" class="headerlink" title="思路:无"></a>思路:无</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">var</span> head2  *ListNode=<span class="hljs-literal">nil</span>/    <span class="hljs-keyword">for</span> head!=<span class="hljs-literal">nil</span>&#123;        tmp:=head.Next        head.Next=head2        head2=head        head=tmp    &#125;    <span class="hljs-keyword">return</span> head2&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>207. 课程表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a><font size=6px>课程表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p><p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p><p>示例 1：</p><p>输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]<br>输出：true<br>解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。<br>示例 2：</p><p>输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]<br>输出：false<br>解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一个拓扑排序题，寻找有无循环，用dfs做比较合适，找到是否有循环，记得找完一个节点后visit[num ] &#x3D; 2</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    edge := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, numCourses)    visit := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)    <span class="hljs-keyword">var</span> flag <span class="hljs-type">bool</span>     flag = <span class="hljs-literal">false</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span>&#123;        visit[num] = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(edge[num]) ;i++&#123;            <span class="hljs-keyword">if</span> visit[edge[num][i]] ==<span class="hljs-number">0</span> &#123;                dfs(edge[num][i])            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> visit[edge[num][i]] ==<span class="hljs-number">1</span>&#123;                flag = <span class="hljs-literal">true</span>                 <span class="hljs-keyword">return</span>            &#125;        &#125;        visit[num ] = <span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">for</span> _, info := <span class="hljs-keyword">range</span> prerequisites&#123;        edge[info[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(edge[info[<span class="hljs-number">1</span>]], info[<span class="hljs-number">0</span>])    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;numCourses; i++&#123;        <span class="hljs-keyword">if</span> visit[i] == <span class="hljs-number">0</span>&#123;            dfs(i)        &#125;    &#125;    <span class="hljs-keyword">return</span> !flag&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了94.35%的用户<br>   内存消耗：6 MB, 在所有 Go 提交中击败了86.68%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>209. 长度最小的子数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/209.%20%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/209.%20%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><font size=6px>长度最小的子数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>示例 1：</p><p>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>示例 2：</p><p>输入：target &#x3D; 4, nums &#x3D; [1,4,4]<br>输出：1<br>示例 3：</p><p>输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; target &lt;&#x3D; 109<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><p>进阶：</p><p>如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>滑动窗口经典题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(s <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    ans := math.MaxInt32    start, end := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    sum := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> end &lt; n &#123;        sum += nums[end]        <span class="hljs-keyword">for</span> sum &gt;= s &#123;            ans = min(ans, end - start + <span class="hljs-number">1</span>)            sum -= nums[start]            start++        &#125;        end++    &#125;    <span class="hljs-keyword">if</span> ans == math.MaxInt32 &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> x &lt; y &#123;        <span class="hljs-keyword">return</span> x    &#125;    <span class="hljs-keyword">return</span> y&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了95.37%的用户<br>   内存消耗：3.6 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>208. Implement Trie (Prefix Tree)</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/208.%20Implement%20Trie%20(Prefix%20Tree)/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/208.%20Implement%20Trie%20(Prefix%20Tree)/</url>
    
    <content type="html"><![CDATA[<h3 id="Implement-Trie-Prefix-Tree"><a href="#Implement-Trie-Prefix-Tree" class="headerlink" title="Implement Trie (Prefix Tree)"></a><font size=6px>Implement Trie (Prefix Tree)</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p><p>Implement the Trie class:</p><p>Trie() Initializes the trie object.<br>void insert(String word) Inserts the string word into the trie.<br>boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.<br>boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.</p><p>Example 1:</p><p>Input<br>[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”]<br>[[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]<br>Output<br>[null, null, true, false, true, null, true]</p><p>Explanation<br>Trie trie &#x3D; new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   &#x2F;&#x2F; return True<br>trie.search(“app”);     &#x2F;&#x2F; return False<br>trie.startsWith(“app”); &#x2F;&#x2F; return True<br>trie.insert(“app”);<br>trie.search(“app”);     &#x2F;&#x2F; return True</p><p>Constraints:</p><p>1 &lt;&#x3D; word.length, prefix.length &lt;&#x3D; 2000<br>word and prefix consist only of lowercase English letters.<br>At most 3 * 104 calls in total will be made to insert, search, and startsWith.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>26叉树，知道了之后不难</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;    children [<span class="hljs-number">26</span>]*Trie    isEnd    <span class="hljs-type">bool</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie &#123;    <span class="hljs-keyword">return</span> Trie&#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>)  &#123;        trie := this        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(word); i++&#123;            <span class="hljs-keyword">if</span> trie.children[word[i]-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nil</span>&#123;                trie.children[word[i]-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-built_in">new</span>(Trie)            &#125;                        trie = trie.children[word[i]-<span class="hljs-string">&#x27;a&#x27;</span>]        &#125;        trie.isEnd = <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;    trie := this    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(word);i++&#123;        <span class="hljs-keyword">if</span> trie.children[word[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        trie = trie.children[word[i] - <span class="hljs-string">&#x27;a&#x27;</span>]    &#125;    <span class="hljs-keyword">return</span> trie.isEnd&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> StartsWith(prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;    trie := this    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(prefix);i++&#123;        <span class="hljs-keyword">if</span> trie.children[prefix[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        trie = trie.children[prefix[i] - <span class="hljs-string">&#x27;a&#x27;</span>]    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor();</span><span class="hljs-comment"> * obj.Insert(word);</span><span class="hljs-comment"> * param_2 := obj.Search(word);</span><span class="hljs-comment"> * param_3 := obj.StartsWith(prefix);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了96.45%的用户<br>   内存消耗：18 MB, 在所有 Go 提交中击败了21.89%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21. 合并两个有序链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例 1：</p><p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]<br>示例 2：</p><p>输入：l1 &#x3D; [], l2 &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：l1 &#x3D; [], l2 &#x3D; [0]<br>输出：[0]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> l1==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> l2    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> l1    &#125;    head,l3 := &amp;ListNode&#123;&#125;,&amp;ListNode&#123;&#125;    <span class="hljs-keyword">if</span> l1.Val&gt;l2.Val&#123;        head = l2    &#125;<span class="hljs-keyword">else</span>&#123;        head = l1    &#125;        <span class="hljs-keyword">for</span> l1!=<span class="hljs-literal">nil</span>&amp;&amp;l2!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> l1.Val &gt; l2.Val&#123;            l3.Next=l2            l3 = l2            l2 = l2.Next        &#125;<span class="hljs-keyword">else</span>&#123;            l3.Next=l1            l3 = l1            l1 = l1.Next        &#125;    &#125;    <span class="hljs-keyword">if</span> l1!=<span class="hljs-literal">nil</span>&#123;        l3.Next = l1    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2!=<span class="hljs-literal">nil</span>&#123;        l3.Next = l2    &#125;    <span class="hljs-keyword">return</span> head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.5 MB, 在所有 Go 提交中击败了82.71%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2100. 适合打劫银行的日子</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2100.%20%E9%80%82%E5%90%88%E6%89%93%E5%8A%AB%E9%93%B6%E8%A1%8C%E7%9A%84%E6%97%A5%E5%AD%90/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2100.%20%E9%80%82%E5%90%88%E6%89%93%E5%8A%AB%E9%93%B6%E8%A1%8C%E7%9A%84%E6%97%A5%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="适合打劫银行的日子"><a href="#适合打劫银行的日子" class="headerlink" title="适合打劫银行的日子"></a><font size=6px>适合打劫银行的日子</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你和一群强盗准备打劫银行。给你一个下标从 0 开始的整数数组 security ，其中 security[i] 是第 i 天执勤警卫的数量。日子从 0 开始编号。同时给你一个整数 time 。</p><p>如果第 i 天满足以下所有条件，我们称它为一个适合打劫银行的日子：</p><p>第 i 天前和后都分别至少有 time 天。<br>第 i 天前连续 time 天警卫数目都是非递增的。<br>第 i 天后连续 time 天警卫数目都是非递减的。<br>更正式的，第 i 天是一个合适打劫银行的日子当且仅当：security[i - time] &gt;&#x3D; security[i - time + 1] &gt;&#x3D; … &gt;&#x3D; security[i] &lt;&#x3D; … &lt;&#x3D; security[i + time - 1] &lt;&#x3D; security[i + time].</p><p>请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。</p><p>示例 1：</p><p>输入：security &#x3D; [5,3,3,3,5,6,2], time &#x3D; 2<br>输出：[2,3]<br>解释：<br>第 2 天，我们有 security[0] &gt;&#x3D; security[1] &gt;&#x3D; security[2] &lt;&#x3D; security[3] &lt;&#x3D; security[4] 。<br>第 3 天，我们有 security[1] &gt;&#x3D; security[2] &gt;&#x3D; security[3] &lt;&#x3D; security[4] &lt;&#x3D; security[5] 。<br>没有其他日子符合这个条件，所以日子 2 和 3 是适合打劫银行的日子。<br>示例 2：</p><p>输入：security &#x3D; [1,1,1,1,1], time &#x3D; 0<br>输出：[0,1,2,3,4]<br>解释：<br>因为 time 等于 0 ，所以每一天都是适合打劫银行的日子，所以返回每一天。<br>示例 3：</p><p>输入：security &#x3D; [1,2,3,4,5,6], time &#x3D; 2<br>输出：[]<br>解释：<br>没有任何一天的前 2 天警卫数目是非递增的。<br>所以没有适合打劫银行的日子，返回空数组。<br>示例 4：</p><p>输入：security &#x3D; [1], time &#x3D; 5<br>输出：[]<br>解释：<br>没有日子前面和后面有 5 天时间。<br>所以没有适合打劫银行的日子，返回空数组。</p><p>提示：</p><p>1 &lt;&#x3D; security.length &lt;&#x3D; 105<br>0 &lt;&#x3D; security[i], time &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用动态规划做，第一次遍历先求出这个树的前面的升序点个数，降序点个数，第二次遍历的时候求是否满足抢劫时间的时候判断这个点的升序个数和降序个数能不能满足。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goodDaysToRobBank</span><span class="hljs-params">(security []<span class="hljs-type">int</span>, time <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(security)    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> time ==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;            res = <span class="hljs-built_in">append</span>(res,i)        &#125;        <span class="hljs-keyword">return</span> res    &#125;    is_uporder := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    is_downorder := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> security[i] &gt;=security[i<span class="hljs-number">-1</span>]&#123;            is_uporder[i] = is_uporder[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">if</span>(security[i]&lt;=security[i<span class="hljs-number">-1</span>])&#123;            is_downorder[i] = is_downorder[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=time;i&lt;n-time;i++&#123;        <span class="hljs-keyword">if</span> is_downorder[i] &gt;=time &amp;&amp; is_uporder[i+time]&gt;=time&#123;            res = <span class="hljs-built_in">append</span>(res, i)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：100 ms, 在所有 Go 提交中击败了97.54%的用户<br>   内存消耗：9.9 MB, 在所有 Go 提交中击败了62.29%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>210. 课程表 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="课程表-II"><a href="#课程表-II" class="headerlink" title="课程表 II"></a><font size=6px>课程表 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] &#x3D; [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。</p><p>例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。<br>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。</p><p>示例 1：</p><p>输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]<br>输出：[0,1]<br>解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。<br>示例 2：</p><p>输入：numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]<br>输出：[0,2,1,3]<br>解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。<br>因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。<br>示例 3：</p><p>输入：numCourses &#x3D; 1, prerequisites &#x3D; []<br>输出：[0]</p><p>提示：<br>1 &lt;&#x3D; numCourses &lt;&#x3D; 2000<br>0 &lt;&#x3D; prerequisites.length &lt;&#x3D; numCourses * (numCourses - 1)<br>prerequisites[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; ai, bi &lt; numCourses<br>ai !&#x3D; bi<br>所有[ai, bi] 互不相同</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>+<span class="hljs-params">e</span>)</span>,空间复杂度<span class="hljs-constructor">O()</span></code></pre><p>用拓扑排序</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findOrder</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    indeg := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)    edge := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, numCourses)    <span class="hljs-keyword">for</span> _,prerequisite := <span class="hljs-keyword">range</span> prerequisites&#123;        edge[prerequisite[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(edge[prerequisite[<span class="hljs-number">1</span>]], prerequisite[<span class="hljs-number">0</span>])        indeg[prerequisite[<span class="hljs-number">0</span>]]++    &#125;    <span class="hljs-keyword">var</span> q []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> indeg&#123;        <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span>&#123;            q = <span class="hljs-built_in">append</span>(q, k)        &#125;    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) != <span class="hljs-number">0</span>&#123;        u := q[<span class="hljs-number">0</span>]        q = q[<span class="hljs-number">1</span>:]        res = <span class="hljs-built_in">append</span>(res, u)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(edge[u]);i++&#123;            indeg[edge[u][i]]--            <span class="hljs-keyword">if</span> indeg[edge[u][i]] == <span class="hljs-number">0</span>&#123;                q = <span class="hljs-built_in">append</span>(q, edge[u][i])            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) != numCourses&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了92.81%的用户<br>   内存消耗：6 MB, 在所有 Go 提交中击败了89.28%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2104. 子数组范围和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2104.%20%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2104.%20%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="子数组范围和"><a href="#子数组范围和" class="headerlink" title="子数组范围和"></a><font size=6px>子数组范围和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。</p><p>返回 nums 中 所有 子数组范围的 和 。</p><p>子数组是数组中一个连续 非空 的元素序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：4<br>解释：nums 的 6 个子数组如下所示：<br>[1]，范围 &#x3D; 最大 - 最小 &#x3D; 1 - 1 &#x3D; 0<br>[2]，范围 &#x3D; 2 - 2 &#x3D; 0<br>[3]，范围 &#x3D; 3 - 3 &#x3D; 0<br>[1,2]，范围 &#x3D; 2 - 1 &#x3D; 1<br>[2,3]，范围 &#x3D; 3 - 2 &#x3D; 1<br>[1,2,3]，范围 &#x3D; 3 - 1 &#x3D; 2<br>所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 &#x3D; 4<br>示例 2：</p><p>输入：nums &#x3D; [1,3,3]<br>输出：4<br>解释：nums 的 6 个子数组如下所示：<br>[1]，范围 &#x3D; 最大 - 最小 &#x3D; 1 - 1 &#x3D; 0<br>[3]，范围 &#x3D; 3 - 3 &#x3D; 0<br>[3]，范围 &#x3D; 3 - 3 &#x3D; 0<br>[1,3]，范围 &#x3D; 3 - 1 &#x3D; 2<br>[3,3]，范围 &#x3D; 3 - 3 &#x3D; 0<br>[1,3,3]，范围 &#x3D; 3 - 1 &#x3D; 2<br>所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 &#x3D; 4<br>示例 3：</p><p>输入：nums &#x3D; [4,-2,-3,4,1]<br>输出：59<br>解释：nums 中所有子数组范围的和是 59</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>进阶：你可以设计一种时间复杂度为 O(n) 的解决方案吗？</p><p>通过次数12,895提交次数21,164</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>暴力，yyds</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subArrayRanges</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">var</span> res <span class="hljs-type">int64</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++&#123;        minNum,maxNum := nums[i], nums[i]        <span class="hljs-keyword">for</span> j:=i+<span class="hljs-number">1</span>;j&lt;n;j++&#123;            minNum = min(minNum, nums[j])            maxNum = max(maxNum, nums[j])            res += <span class="hljs-type">int64</span>(maxNum-minNum)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了73.15%的用户<br>   内存消耗：4 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>215. 数组中的第K个最大元素</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><font size=6px>数组中的第K个最大元素</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k &#x3D; 2<br>输出: 5<br>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4<br>输出: 4<br>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以用堆排序做，第k个就是堆排序k次之后在顶点的那个数就是第k大的数字</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;        heapSize := <span class="hljs-built_in">len</span>(nums)        start := heapSize/ <span class="hljs-number">2</span>        <span class="hljs-comment">//制造初始大顶堆</span>        <span class="hljs-keyword">for</span> i:=start;i&gt;=<span class="hljs-number">0</span>;i--&#123;           MaxHeaPify(nums,i,heapSize)        &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k<span class="hljs-number">-1</span>;i++&#123;            nums[heapSize<span class="hljs-number">-1</span>] , nums[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>] , nums[heapSize<span class="hljs-number">-1</span>]            heapSize--            MaxHeaPify(nums,<span class="hljs-number">0</span>,heapSize)        &#125;    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MaxHeaPify</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>,i <span class="hljs-type">int</span>,heapSize <span class="hljs-type">int</span>)</span></span>  &#123;    l,r,largest := i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>,i    <span class="hljs-keyword">if</span> l&lt;heapSize &amp;&amp; nums[l] &gt; nums[largest]&#123;        largest = l    &#125;    <span class="hljs-keyword">if</span> r&lt;heapSize &amp;&amp;nums[r] &gt;nums[largest]&#123;        largest = r    &#125;    <span class="hljs-keyword">if</span> i !=largest&#123;        nums[i] ,nums[largest] = nums[largest] ,nums[i]        MaxHeaPify(nums,largest,heapSize)    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了85.94%的用户<br>   内存消耗：3.4 MB, 在所有 Go 提交中击败了89.56%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>213. 打家劫舍 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%202/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%202/</url>
    
    <content type="html"><![CDATA[<h3 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="打家劫舍 II"></a><font size=6px>打家劫舍 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 3：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：3</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划和1一样，首位最多只能有一个，所以判断两次就行，一次只有瘦，一次只有尾</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>])    &#125;    <span class="hljs-keyword">return</span> max(_rob(nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]), _rob(nums[<span class="hljs-number">1</span>:]))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]    &#125;    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]    dp[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;        dp[i] = max(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>])    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> x &gt; y &#123;        <span class="hljs-keyword">return</span> x    &#125;    <span class="hljs-keyword">return</span> y&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22. 括号生成</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><font size=6px>括号生成</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：[“()”]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 8<br>通过次数408,548提交次数528,598</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用dfs回溯法遍历所有可能</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(l,r <span class="hljs-type">int</span>,s <span class="hljs-type">string</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(l,r <span class="hljs-type">int</span>,s <span class="hljs-type">string</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> l ==n &amp;&amp; r == n&#123;            res = <span class="hljs-built_in">append</span>(res,s)            <span class="hljs-keyword">return</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l&gt;n || r &gt;n || r&gt;l&#123;            <span class="hljs-keyword">return</span>        &#125;        s = s+<span class="hljs-string">&quot;(&quot;</span>        dfs(l+<span class="hljs-number">1</span>,r,s)        s = s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]        s = s+<span class="hljs-string">&quot;)&quot;</span>        dfs(l,r+<span class="hljs-number">1</span>,s)        s = s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]    &#125;    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,s)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了10.59%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了52.39%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>225. 用队列实现栈</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a><font size=6px>用队列实现栈</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><p>示例：</p><p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p><p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False</p><p>提示：</p><p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>创建两个队列，第二个队列就是暂时保持的角色，队列只能前面出后面进</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;    queue1, queue2 []<span class="hljs-type">int</span>&#125;<span class="hljs-comment">/** Initialize your data structure here. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> (s MyStack) &#123;    <span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">/** Push element x onto stack. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;    s.queue2 = <span class="hljs-built_in">append</span>(s.queue2, x)    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(s.queue1) &gt; <span class="hljs-number">0</span> &#123;        s.queue2 = <span class="hljs-built_in">append</span>(s.queue2, s.queue1[<span class="hljs-number">0</span>])        s.queue1 = s.queue1[<span class="hljs-number">1</span>:]    &#125;    s.queue1, s.queue2 = s.queue2, s.queue1&#125;<span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;    v := s.queue1[<span class="hljs-number">0</span>]    s.queue1 = s.queue1[<span class="hljs-number">1</span>:]    <span class="hljs-keyword">return</span> v&#125;<span class="hljs-comment">/** Get the top element. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> s.queue1[<span class="hljs-number">0</span>]&#125;<span class="hljs-comment">/** Returns whether the stack is empty. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s.queue1) == <span class="hljs-number">0</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>221. 最大正方形</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/221.%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/221.%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><font size=6px>最大正方形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p>示例 1：</p><p>输入：matrix &#x3D; [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：4<br>示例 2：</p><p>输入：matrix &#x3D; [[“0”,”1”],[“1”,”0”]]<br>输出：1<br>示例 3：</p><p>输入：matrix &#x3D; [[“0”]]<br>输出：0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以使用动态规划降低时间复杂度。我们用 \textit{dp}(i, j)dp(i,j) 表示以 (i, j)(i,j) 为右下角，且只包含 11 的正方形的边长最大值。如果我们能计算出所有 \textit{dp}(i, j)dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 11 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 \textit{dp}dp 中的每个元素值呢？对于每个位置 (i, j)(i,j)，检查在矩阵中该位置的值：</p><p>如果该位置的值是 00，则 \textit{dp}(i, j) &#x3D; 0dp(i,j)&#x3D;0，因为当前位置不可能在由 11 组成的正方形中；</p><p>如果该位置的值是 11，则 \textit{dp}(i, j)dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 \textit{dp}dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 11，状态转移方程如下：</p><p>dp(i, j)&#x3D;min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1<br>dp(i,j)&#x3D;min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1</p><p>如果读者对这个状态转移方程感到不解，可以参考 1277. 统计全为 1 的正方形子矩阵的官方题解，其中给出了详细的证明。</p><p>此外，还需要考虑边界条件。如果 ii 和 jj 中至少有一个为 00，则以位置 (i, j)(i,j) 为右下角的最大正方形的边长只能是 11，因此 \textit{dp}(i, j) &#x3D; 1dp(i,j)&#x3D;1。</p><p><img src="https://assets.leetcode-cn.com/solution-static/221/221_fig1.png"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min1</span><span class="hljs-params">(a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span>,c <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> min <span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> a&lt;b&#123;        min=a    &#125;<span class="hljs-keyword">else</span>&#123;        min=b    &#125;    <span class="hljs-keyword">if</span> min&gt;c&#123;        min=c    &#125;    <span class="hljs-keyword">return</span> min&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> matrix==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span> =<span class="hljs-number">0</span>    row:=<span class="hljs-built_in">len</span>(matrix)    line:=<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])    <span class="hljs-keyword">var</span> arr[<span class="hljs-number">301</span>][<span class="hljs-number">301</span>]<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;row;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;line;j++&#123;            <span class="hljs-keyword">if</span> matrix[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>&#123;                arr[i][j]=<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&#123;                    <span class="hljs-keyword">if</span> arr[i<span class="hljs-number">-1</span>][j]&gt;=<span class="hljs-number">1</span>&amp;&amp;arr[i][j<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">1</span>&amp;&amp;arr[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">1</span>&#123;                        arr[i][j]=min1(arr[i<span class="hljs-number">-1</span>][j],arr[i][j<span class="hljs-number">-1</span>],arr[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span>                    &#125;                &#125;                <span class="hljs-keyword">if</span> max &lt;arr[i][j]&#123;                    max=arr[i][j]                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> max*max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了73.93%的用户<br>   内存消耗：3.9 MB, 在所有 Go 提交中击败了81.35%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>231. 2 的幂</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/231.%202%20%E7%9A%84%E5%B9%82/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/231.%202%20%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h3 id="2-的幂"><a href="#2-的幂" class="headerlink" title="2 的幂"></a><font size=6px>2 的幂</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p><p>如果存在一个整数 x 使得 n &#x3D;&#x3D; 2x ，则认为 n 是 2 的幂次方。</p><p>示例 1：</p><p>输入：n &#x3D; 1<br>输出：true<br>解释：20 &#x3D; 1<br>示例 2：</p><p>输入：n &#x3D; 16<br>输出：true<br>解释：24 &#x3D; 16<br>示例 3：</p><p>输入：n &#x3D; 3<br>输出：false<br>示例 4：</p><p>输入：n &#x3D; 4<br>输出：true<br>示例 5：</p><p>输入：n &#x3D; 5<br>输出：false</p><p>提示：</p><p>-231 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p><p>进阶：你能够不使用循环&#x2F;递归解决此问题吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; n&amp;(n<span class="hljs-number">-1</span>) == <span class="hljs-number">0</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了6.64%</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>232. 用栈实现队列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a><font size=6px>用栈实现队列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p><p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><p>示例 1：</p><p>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]</p><p>解释：<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false</p><p>提示：</p><p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用 100 次 push、pop、peek 和 empty<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</p><p>进阶：</p><p>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>第一个栈暂存，从第一个栈取出放入第二个栈，然后就有序了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;    inStack, outStack []<span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;    <span class="hljs-keyword">return</span> MyQueue&#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;    q.inStack = <span class="hljs-built_in">append</span>(q.inStack, x)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> in2out() &#123;    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q.inStack) &gt; <span class="hljs-number">0</span> &#123;        q.outStack = <span class="hljs-built_in">append</span>(q.outStack, q.inStack[<span class="hljs-built_in">len</span>(q.inStack)<span class="hljs-number">-1</span>])        q.inStack = q.inStack[:<span class="hljs-built_in">len</span>(q.inStack)<span class="hljs-number">-1</span>]    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span> &#123;        q.in2out()    &#125;    x := q.outStack[<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]    q.outStack = q.outStack[:<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]    <span class="hljs-keyword">return</span> x&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span> &#123;        q.in2out()    &#125;    <span class="hljs-keyword">return</span> q.outStack[<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q.inStack) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了90.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2316. 统计无向图中无法互相到达点对数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2316.%20%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E5%AF%B9%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2316.%20%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E5%AF%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="统计无向图中无法互相到达点对数"><a href="#统计无向图中无法互相到达点对数" class="headerlink" title="统计无向图中无法互相到达点对数"></a><font size=6px>统计无向图中无法互相到达点对数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] &#x3D; [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。</p><p>请你返回 无法互相到达 的不同 点对数目 。</p><p>示例 1：</p><p>输入：n &#x3D; 3, edges &#x3D; [[0,1],[0,2],[1,2]]<br>输出：0<br>解释：所有点都能互相到达，意味着没有点对无法互相到达，所以我们返回 0 。<br>示例 2：</p><p>输入：n &#x3D; 7, edges &#x3D; [[0,2],[0,5],[2,4],[1,6],[5,4]]<br>输出：14<br>解释：总共有 14 个点对互相无法到达：<br>[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]<br>所以我们返回 14 。</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 105<br>0 &lt;&#x3D; edges.length &lt;&#x3D; 2 * 105<br>edges[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; ai, bi &lt; n<br>ai !&#x3D; bi<br>不会有重复边。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>find函数就可以实现union</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>, edges [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;    p := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    cnt := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">var</span> res <span class="hljs-type">int64</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        p[i] = i    &#125;    <span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>    find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;        <span class="hljs-keyword">if</span> p[x] != x&#123;            p[x] = find(p[x])        &#125;        <span class="hljs-keyword">return</span> p[x]    &#125;    m := <span class="hljs-built_in">len</span>(edges)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">if</span> edges[i][<span class="hljs-number">0</span>] &gt; edges[i][<span class="hljs-number">1</span>]&#123;            edges[i][<span class="hljs-number">0</span>],edges[i][<span class="hljs-number">1</span>] = edges[i][<span class="hljs-number">1</span>],edges[i][<span class="hljs-number">0</span>]        &#125;        x,y := find(edges[i][<span class="hljs-number">0</span>]),find(edges[i][<span class="hljs-number">1</span>])        p[x] = y    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        cnt[find(p[i])] ++    &#125;    sum := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> p[i] == i&#123;            res += <span class="hljs-type">int64</span>(sum*cnt[i])            sum += cnt[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：244 ms, 在所有 Go 提交中击败了92.86%的用户<br>   内存消耗：23.6 MB, 在所有 Go 提交中击败了78.06%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>233. 数字 1 的个数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/233.%20%E6%95%B0%E5%AD%97%201%20%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/233.%20%E6%95%B0%E5%AD%97%201%20%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="数字-1-的个数"><a href="#数字-1-的个数" class="headerlink" title="数字 1 的个数"></a><font size=6px>数字 1 的个数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p><p>示例 1：</p><p>输入：n &#x3D; 13<br>输出：6<br>示例 2：</p><p>输入：n &#x3D; 0<br>输出：0</p><p>提示：</p><p>0 &lt;&#x3D; n &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">时间复杂度：O(n),空间复杂度O(nfunc countDigitOne(n <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    d := dgt(n)    <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j&lt;=d; j++&#123;        p := <span class="hljs-type">int</span>(math.Pow(<span class="hljs-number">10</span>,<span class="hljs-type">float64</span>(j<span class="hljs-number">-1</span>)))        l := n/p/<span class="hljs-number">10</span>        r := n % p        dj := n /p %<span class="hljs-number">10</span>        res +=   l*p        <span class="hljs-keyword">if</span> dj &gt;<span class="hljs-number">1</span>&#123;            res += p        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dj ==<span class="hljs-number">1</span>&#123;            res += r+<span class="hljs-number">1</span>        &#125;    &#125;        <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dgt</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">var</span> cnt <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> n != <span class="hljs-number">0</span>&#123;        cnt++        n/=<span class="hljs-number">10</span>    &#125;    <span class="hljs-keyword">return</span> cnt&#125;)</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了55.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>235. 二叉搜索树的最近公共祖先</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/235.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/235.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><font size=6px>二叉搜索树的最近公共祖先</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p>示例 1:</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>判断如果跟root比一大一小，那说明root就是答案</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val   int</span><span class="hljs-comment"> *     Left  *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<span class="hljs-keyword">if</span> (root.Val-p.Val) * (root.Val-q.Val) &lt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> root    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.Val-p.Val) * (root.Val-q.Val) &gt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> root.Val-p.Val &gt;<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.Left,p,q)        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Val-p.Val &lt;<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.Right,p,q)        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> root        &#125;    &#125;    <span class="hljs-keyword">return</span> root    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了79.81%的用户<br>   内存消耗：6.9 MB, 在所有 Go 提交中击败了55.06%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>238. 除自身以外数组的乘积</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/238.%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/238.%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><font size=6px>除自身以外数组的乘积</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p><p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p><p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,2,3,4]<br>输出: [24,12,8,6]<br>示例 2:</p><p>输入: nums &#x3D; [-1,1,0,-3,3]<br>输出: [0,0,9,0,0]</p><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-30 &lt;&#x3D; nums[i] &lt;&#x3D; 30<br>保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内</p><p>进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>结果是乘以左右的所有数字和乘以右边所有数字，构造两个数列，分别是从左往右的乘数结果和从右往左的乘数结果</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> l,r []<span class="hljs-type">int</span>    l,r = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums)),<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    l[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]     r[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] = nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        l[i] = l[i<span class="hljs-number">-1</span>] *nums[i]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        r[i] = r[i+<span class="hljs-number">1</span>] * nums[i]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>&#123;            nums[i] = r[<span class="hljs-number">1</span>]            <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">if</span> i== <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>&#123;            nums[i] = l[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>]            <span class="hljs-keyword">continue</span>        &#125;        nums[i] = l[i<span class="hljs-number">-1</span>] * r[i+<span class="hljs-number">1</span>]    &#125;    <span class="hljs-keyword">return</span> nums&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了82.65%的用户<br>   内存消耗：7.2 MB, 在所有 Go 提交中击败了98.41%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>241. 为运算表达式设计优先级</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/241.%20%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/241.%20%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="为运算表达式设计优先级"><a href="#为运算表达式设计优先级" class="headerlink" title="为运算表达式设计优先级"></a><font size=6px>为运算表达式设计优先级</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。</p><p>生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。</p><p>示例 1：</p><p>输入：expression &#x3D; “2-1-1”<br>输出：[0,2]<br>解释：<br>((2-1)-1) &#x3D; 0<br>(2-(1-1)) &#x3D; 2<br>示例 2：</p><p>输入：expression &#x3D; “2<em>3-4</em>5”<br>输出：[-34,-14,-10,-10,10]<br>解释：<br>(2*(3-(4<em>5))) &#x3D; -34<br>((2</em>3)-(4<em>5)) &#x3D; -14<br>((2</em>(3-4))<em>5) &#x3D; -10<br>(2</em>((3-4)<em>5)) &#x3D; -10<br>(((2</em>3)-4)*5) &#x3D; 10</p><p>提示：</p><p>1 &lt;&#x3D; expression.length &lt;&#x3D; 20<br>expression 由数字和算符 ‘+’、’-‘ 和 ‘*’ 组成。<br>输入表达式中的所有整数值在范围 [0, 99] </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(2^<span class="hljs-params">n</span>)</span></code></pre><p>分治应该是最简单和易于理解的方法了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(expression <span class="hljs-type">string</span>)</span></span> (res []<span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">if</span> isDigit(expression)&#123;        tmp,_ := strconv.Atoi(expression)        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;tmp&#125;    &#125;    <span class="hljs-keyword">for</span> index,c := <span class="hljs-keyword">range</span> expression&#123;        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span>&#123;            left := diffWaysToCompute(expression[:index])            right := diffWaysToCompute(expression[index+<span class="hljs-number">1</span>:])            <span class="hljs-keyword">for</span> _,l := <span class="hljs-keyword">range</span> left&#123;                <span class="hljs-keyword">for</span> _,r := <span class="hljs-keyword">range</span> right&#123;                    <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;+&#x27;</span>&#123;                        res = <span class="hljs-built_in">append</span>(res, l+r)                    &#125;                    <span class="hljs-keyword">if</span> c== <span class="hljs-string">&#x27;-&#x27;</span>&#123;                        res = <span class="hljs-built_in">append</span>(res, l-r)                    &#125;                    <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;*&#x27;</span>&#123;                        res = <span class="hljs-built_in">append</span>(res, l*r)                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-comment">// 判断是否为全数字</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isDigit</span><span class="hljs-params">(input <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    _, err := strconv.Atoi(input)    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了31.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>264. 丑数 2</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/264.%20%E4%B8%91%E6%95%B0%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/264.%20%E4%B8%91%E6%95%B0%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="丑数-II"><a href="#丑数-II" class="headerlink" title="丑数 II"></a><font size=6px>丑数 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p><p>丑数 就是只包含质因数 2、3 和&#x2F;或 5 的正整数。</p><p>示例 1：</p><p>输入：n &#x3D; 10<br>输出：12<br>解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：1<br>解释：1 通常被视为丑数。</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 1690</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>dp求三个值里面最小值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    p2,p3,p5 := <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n;i++&#123;        x2,x3,x5 := dp[p2]*<span class="hljs-number">2</span>,dp[p3]*<span class="hljs-number">3</span>,dp[p5]*<span class="hljs-number">5</span>        dp[i] = min(x2,min(x3,x5))        <span class="hljs-keyword">if</span> dp[i] == x2&#123;            p2++        &#125;        <span class="hljs-keyword">if</span> dp[i] == x3&#123;            p3++        &#125;        <span class="hljs-keyword">if</span> dp[i] == x5&#123;            p5++        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：4 MB, 在所有 Go 提交中击败了62.40%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>258. 各位相加</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/258.%20%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/258.%20%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="各位相加"><a href="#各位相加" class="headerlink" title="各位相加"></a><font size=6px>各位相加</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p><p>示例 1:</p><p>输入: num &#x3D; 38<br>输出: 2<br>解释: 各位相加的过程为：<br>38 –&gt; 3 + 8 –&gt; 11<br>11 –&gt; 1 + 1 –&gt; 2<br>由于 2 是一位数，所以返回 2。<br>示例 1:</p><p>输入: num &#x3D; 0<br>输出: 0</p><p>提示：</p><p>0 &lt;&#x3D; num &lt;&#x3D; 231 - 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>除了传统的单纯循环，还可以找规律。假如一个三位数’abc’，其值大小为s1 &#x3D; 100 * a + 10 * b + 1 * c，经过一次各位相加后，变为s2 &#x3D; a + b + c，减小的差值为(s1 -s2) &#x3D; 99 * a + 9 * b，差值可以被9整除，每一个循环都这样，缩小了9的倍数。当num小于9，即只有一位时，直接返回num，大于9时，如果能被9整除，则返回9（因为不可能返回0也不可能返回两位数及以上的值），如果不能被整除，就返回被9除的余数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addDigits</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> num&gt;<span class="hljs-number">9</span>&#123;        num = num %<span class="hljs-number">9</span>        <span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> num&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了37.93%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>279. 完全平方数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><font size=6px>完全平方数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例 1：</p><p>输入：n &#x3D; 12<br>输出：3<br>解释：12 &#x3D; 4 + 4 + 4<br>示例 2：</p><p>输入：n &#x3D; 13<br>输出：2<br>解释：13 &#x3D; 4 + 9</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划 d p[i] &#x3D; min(dp[i-j*j]……)+1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>       <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        minNum := <span class="hljs-number">9999</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;i&gt;=j*j;j++&#123;            minNum = min(minNum, dp[i-j*j])        &#125;        <span class="hljs-keyword">if</span> minNum!= <span class="hljs-number">9999</span>&#123;            dp[i] = minNum+<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-comment">// fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> dp[n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了86.13%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了90.94%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>287. 寻找重复数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a><font size=6px>寻找重复数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p><p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,4,2,2]<br>输出：2<br>示例 2：</p><p>输入：nums &#x3D; [3,1,3,4,2]<br>输出：3</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 105<br>nums.length &#x3D;&#x3D; n + 1<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; n<br>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</p><p>进阶：</p><p>如何证明 nums 中至少存在一个重复的数字?<br>你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>思路没怎么看懂，快慢指针</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    slow, fast := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> slow, fast = nums[slow], nums[nums[fast]]; slow != fast; slow, fast = nums[slow], nums[nums[fast]] &#123; &#125;    slow = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> slow != fast &#123;        slow = nums[slow]        fast = nums[fast]    &#125;    <span class="hljs-keyword">return</span> slow&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：80 ms, 在所有 Go 提交中击败了95.18%的用户<br>   内存消耗：8.3 MB, 在所有 Go 提交中击败了87.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>283. 移动零</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><font size=6px>移动零</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1:</p><p>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p><p>输入: nums &#x3D; [0]<br>输出: [0]</p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;=<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span>     &#125;    l, r, n := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">for</span> r &lt;n &#123;        <span class="hljs-keyword">if</span> nums[r] != <span class="hljs-number">0</span>&#123;            nums[l], nums[r] = nums[r], nums[l]            l++        &#125;        r++    &#125;    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了81.98%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了97.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>297. Serialize and Deserialize Binary Tree</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/297.%20Serialize%20and%20Deserialize%20Binary%20Tree/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/297.%20Serialize%20and%20Deserialize%20Binary%20Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="Serialize-and-Deserialize-Binary-Tree"><a href="#Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="Serialize and Deserialize Binary Tree"></a><font size=6px>Serialize and Deserialize Binary Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization&#x2F;deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p>Clarification: The input&#x2F;output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p>Example 1:</p><p>Input: root &#x3D; [1,2,3,null,null,4,5]<br>Output: [1,2,3,null,null,4,5]<br>Example 2:</p><p>Input: root &#x3D; []<br>Output: []</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [0, 104].<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用队列层次遍历一个二叉树变成string，再把string通过逗号分隔，再层次遍历成二叉树.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">struct</span> &#123;     &#125;   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Codec &#123;    <span class="hljs-keyword">return</span> Codec&#123;&#125;&#125;<span class="hljs-comment">// Serializes a tree to a single string.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> serialize(root *TreeNode) <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> queue []*TreeNode   <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;       <span class="hljs-keyword">return</span> s   &#125;   queue = <span class="hljs-built_in">append</span>(queue, root)    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>&#123;        node := queue[<span class="hljs-number">0</span>]        queue = queue[<span class="hljs-number">1</span>:]        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span>&#123;            s += <span class="hljs-string">&quot;,null&quot;</span>            <span class="hljs-keyword">continue</span>        &#125;                s += <span class="hljs-string">&quot;,&quot;</span>+strconv.Itoa(node.Val)        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, node.Left)        &#125;<span class="hljs-keyword">else</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, <span class="hljs-literal">nil</span>)        &#125;        <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, node.Right)        &#125;<span class="hljs-keyword">else</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, <span class="hljs-literal">nil</span>)        &#125;    &#125;   <span class="hljs-keyword">return</span> s[<span class="hljs-number">1</span>:]&#125;<span class="hljs-comment">// Deserializes your encoded data to tree.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> deserialize(data <span class="hljs-type">string</span>) *TreeNode &#123;        <span class="hljs-keyword">if</span> data == <span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-keyword">var</span> queue []*TreeNode    <span class="hljs-keyword">var</span> datas []<span class="hljs-type">string</span> = strings.Split(data,<span class="hljs-string">&quot;,&quot;</span>)    val,_ := strconv.Atoi(datas[<span class="hljs-number">0</span>])    root := &amp;TreeNode&#123;Val:val&#125;        queue = <span class="hljs-built_in">append</span>(queue, root)    index :=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> index&lt;<span class="hljs-built_in">len</span>(datas)&#123;        node := queue[<span class="hljs-number">0</span>]        queue = queue[<span class="hljs-number">1</span>:]        left := datas[index]        right := datas[index+<span class="hljs-number">1</span>]        <span class="hljs-keyword">if</span> left[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;n&#x27;</span>&#123;            Left, _ := strconv.Atoi(left)            node.Left = &amp;TreeNode&#123;Val:Left&#125;            queue = <span class="hljs-built_in">append</span>(queue, node.Left)        &#125;<span class="hljs-keyword">else</span>&#123;            node.Left = <span class="hljs-literal">nil</span>        &#125;        <span class="hljs-keyword">if</span> right[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;n&#x27;</span>&#123;            Right,_ := strconv.Atoi(right)            node.Right = &amp;TreeNode&#123;Val:Right&#125;            queue = <span class="hljs-built_in">append</span>(queue, node.Right)        &#125;<span class="hljs-keyword">else</span>&#123;            node.Right = <span class="hljs-literal">nil</span>        &#125;        index +=<span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">return</span> root&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your Codec object will be instantiated and called as such:</span><span class="hljs-comment"> * ser := Constructor();</span><span class="hljs-comment"> * deser := Constructor();</span><span class="hljs-comment"> * data := ser.serialize(root);</span><span class="hljs-comment"> * ans := deser.deserialize(data);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：116 ms, 在所有 Go 提交中击败了9.89%的用户<br>   内存消耗：10.8 MB, 在所有 Go 提交中击败了15.04%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30. 串联所有单词的子串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/30.%20%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/30.%20%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a><font size=6px>串联所有单词的子串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</p><p>示例 1：</p><p>输入：s &#x3D; “barfoothefoobarman”, words &#x3D; [“foo”,”bar”]<br>输出：[0,9]<br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。<br>示例 2：</p><p>输入：s &#x3D; “wordgoodgoodgoodbestword”, words &#x3D; [“word”,”good”,”best”,”word”]<br>输出：[]<br>示例 3：</p><p>输入：s &#x3D; “barfoofoobarthefoobarman”, words &#x3D; [“bar”,”foo”,”the”]<br>输出：[6,9,12]</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s 由小写英文字母组成<br>1 &lt;&#x3D; words.length &lt;&#x3D; 5000<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 30<br>words[i] 由小写英文字母组成<br>通过次数115,443提交次数305,855</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">ls</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span></code></pre><p>用滑动窗口法，把每一个单词当成一个字母做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>, words []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;    ls,m,n := <span class="hljs-built_in">len</span>(s),<span class="hljs-built_in">len</span>(words), <span class="hljs-built_in">len</span>(words[<span class="hljs-number">0</span>])    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n&amp;&amp; i&lt;= ls- m*n;i++&#123;        mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>; j&lt;m; j++&#123;            mp[s[i+j*n:i+(j+<span class="hljs-number">1</span>)*n]]++        &#125;        <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> words&#123;            mp[v]--            <span class="hljs-keyword">if</span> mp[v] == <span class="hljs-number">0</span>&#123;                <span class="hljs-built_in">delete</span>(mp,v)            &#125;        &#125;        <span class="hljs-keyword">for</span> start:=i; start&lt; ls - m*n+<span class="hljs-number">1</span>; start+=n&#123;            <span class="hljs-keyword">if</span> start != i&#123;                mp[s[start-n:start]]--                <span class="hljs-keyword">if</span> mp[s[start-n:start]] == <span class="hljs-number">0</span>&#123;                    <span class="hljs-built_in">delete</span>(mp,s[start-n:start])                &#125;                mp[s[start+m*n-n:start+m*n]]++                <span class="hljs-keyword">if</span> mp[s[start+m*n-n:start+m*n]] == <span class="hljs-number">0</span>&#123;                    <span class="hljs-built_in">delete</span>(mp,s[start+m*n-n:start+m*n])                &#125;            &#125;            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mp) == <span class="hljs-number">0</span>&#123;                res = <span class="hljs-built_in">append</span>(res, start)            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了72.86%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了42.65%</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>239. 滑动窗口最大值</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><font size=6px>滑动窗口最大值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7<br>示例 2：</p><p>输入：nums &#x3D; [1], k &#x3D; 1<br>输出：[1]</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>构建单调递减队列，</p><p>输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3<br>输出: [3,3,5,5,6,7]</p><p>解释过程中队列中都是具体的值，方便理解，具体见代码。<br>初始状态：L&#x3D;R&#x3D;0,队列:{}<br>i&#x3D;0,nums[0]&#x3D;1。队列为空,直接加入。队列：{1}<br>i&#x3D;1,nums[1]&#x3D;3。队尾值为1，3&gt;1，弹出队尾值，加入3。队列：{3}<br>i&#x3D;2,nums[2]&#x3D;-1。队尾值为3，-1&lt;3，直接加入。队列：{3,-1}。此时窗口已经形成，L&#x3D;0,R&#x3D;2，result&#x3D;[3]<br>i&#x3D;3,nums[3]&#x3D;-3。队尾值为-1，-3&lt;-1，直接加入。队列：{3,-1,-3}。队首3对应的下标为1，L&#x3D;1,R&#x3D;3，有效。result&#x3D;[3,3]<br>i&#x3D;4,nums[4]&#x3D;5。队尾值为-3，5&gt;-3，依次弹出后加入。队列：{5}。此时L&#x3D;2,R&#x3D;4，有效。result&#x3D;[3,3,5]<br>i&#x3D;5,nums[5]&#x3D;3。队尾值为5，3&lt;5，直接加入。队列：{5,3}。此时L&#x3D;3,R&#x3D;5，有效。result&#x3D;[3,3,5,5]<br>i&#x3D;6,nums[6]&#x3D;6。队尾值为3，6&gt;3，依次弹出后加入。队列：{6}。此时L&#x3D;4,R&#x3D;6，有效。result&#x3D;[3,3,5,5,6]<br>i&#x3D;7,nums[7]&#x3D;7。队尾值为6，7&gt;6，弹出队尾值后加入。队列：{7}。此时L&#x3D;5,R&#x3D;7，有效。result&#x3D;[3,3,5,5,6,7]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">var</span> queue []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    queue = <span class="hljs-built_in">append</span>(queue, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> ;i&lt;k;i++&#123;        <span class="hljs-keyword">for</span> j:= <span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span> ;j--&#123;            <span class="hljs-keyword">if</span> nums[queue[j]] &lt; nums[i]&#123;                queue = queue[:<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>]            &#125;<span class="hljs-keyword">else</span>&#123;                queue = <span class="hljs-built_in">append</span>(queue, i)                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue ) == <span class="hljs-number">0</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, i)        &#125;    &#125;    res = <span class="hljs-built_in">append</span>(res, nums[queue[<span class="hljs-number">0</span>]])    l,r := <span class="hljs-number">1</span>,k    <span class="hljs-keyword">for</span> r &lt; n&#123;        <span class="hljs-keyword">for</span> j:= <span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span> ;j--&#123;            <span class="hljs-keyword">if</span> nums[queue[j]] &lt; nums[r]&#123;                queue = queue[:<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>]            &#125;<span class="hljs-keyword">else</span>&#123;                queue = <span class="hljs-built_in">append</span>(queue, r)                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue ) == <span class="hljs-number">0</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, r)        &#125;        <span class="hljs-keyword">for</span> queue[<span class="hljs-number">0</span>] &lt; l&#123;            queue = queue[<span class="hljs-number">1</span>:]        &#125;        res = <span class="hljs-built_in">append</span>(res, nums[queue[<span class="hljs-number">0</span>]])        l++        r++    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：228 ms, 在所有 Go 提交中击败了32.94%的用户<br>   内存消耗：8.7 MB, 在所有 Go 提交中击败了99.72%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>307. 区域和检索 - 数组可修改</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/307.%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/307.%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="区域和检索-数组可修改"><a href="#区域和检索-数组可修改" class="headerlink" title="区域和检索 - 数组可修改"></a><font size=6px>区域和检索 - 数组可修改</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个数组 nums ，请你完成两类查询。</p><p>其中一类查询要求 更新 数组 nums 下标对应的值<br>另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left &lt;&#x3D; right<br>实现 NumArray 类：</p><p>NumArray(int[] nums) 用整数数组 nums 初始化对象<br>void update(int index, int val) 将 nums[index] 的值 更新 为 val<br>int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], …, nums[right]）</p><p>示例 1：</p><p>输入：<br>[“NumArray”, “sumRange”, “update”, “sumRange”]<br>[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]<br>输出：<br>[null, 9, null, 8]</p><p>解释：<br>NumArray numArray &#x3D; new NumArray([1, 3, 5]);<br>numArray.sumRange(0, 2); &#x2F;&#x2F; 返回 1 + 3 + 5 &#x3D; 9<br>numArray.update(1, 2);   &#x2F;&#x2F; nums &#x3D; [1,2,5]<br>numArray.sumRange(0, 2); &#x2F;&#x2F; 返回 1 + 2 + 5 &#x3D; 8</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-100 &lt;&#x3D; nums[i] &lt;&#x3D; 100<br>0 &lt;&#x3D; index &lt; nums.length<br>-100 &lt;&#x3D; val &lt;&#x3D; 100<br>0 &lt;&#x3D; left &lt;&#x3D; right &lt; nums.length<br>调用 pdate 和 sumRange 方法次数不大于 3 * 104 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">logn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">logn</span>)</span></code></pre><p>使用线段数做，构建线段树</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> NumArray []<span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;    n := <span class="hljs-built_in">len</span>(nums)    arr := <span class="hljs-built_in">make</span>(NumArray ,n*<span class="hljs-number">4</span>)    arr.build(nums,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>)    <span class="hljs-keyword">return</span> arr &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this NumArray)</span></span>build(nums []<span class="hljs-type">int</span>, node,s,e <span class="hljs-type">int</span>)&#123;    <span class="hljs-keyword">if</span> s == e&#123;        this[node] = nums[s]        <span class="hljs-keyword">return</span>     &#125;    m := s+(e-s)/<span class="hljs-number">2</span>    this.build(nums,node*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,s,m)    this.build(nums,node*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>,m+<span class="hljs-number">1</span>,e)    this[node] = this[node*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]+this[node*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this NumArray)</span></span>change(idx,val,node,s,e <span class="hljs-type">int</span>)&#123;    <span class="hljs-keyword">if</span> s == e&#123;        this[node] = val        <span class="hljs-keyword">return</span>    &#125;    m := s+(e-s)/<span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> idx &lt;= m&#123;        this.change(idx,val,node*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,s,m)    &#125;<span class="hljs-keyword">else</span>&#123;        this.change(idx,val,node*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>,m+<span class="hljs-number">1</span>,e)    &#125;    this[node] = this[node*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]+this[node*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this NumArray)</span></span> Update(index <span class="hljs-type">int</span>, val <span class="hljs-type">int</span>)  &#123;    this.change(index,val,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(this)/<span class="hljs-number">4</span><span class="hljs-number">-1</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(seg NumArray)</span></span> range_(left, right, node, s, e <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> left == s &amp;&amp; right == e &#123;        <span class="hljs-keyword">return</span> seg[node]    &#125;    m := s + (e-s)/<span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> right &lt;= m &#123;        <span class="hljs-keyword">return</span> seg.range_(left, right, node*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, s, m)    &#125;    <span class="hljs-keyword">if</span> left &gt; m &#123;        <span class="hljs-keyword">return</span> seg.range_(left, right, node*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>, m+<span class="hljs-number">1</span>, e)    &#125;    <span class="hljs-keyword">return</span> seg.range_(left, m, node*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, s, m) + seg.range_(m+<span class="hljs-number">1</span>, right, node*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>, m+<span class="hljs-number">1</span>, e)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> this.range_(left,right,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(this)/<span class="hljs-number">4</span><span class="hljs-number">-1</span>)&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor(nums);</span><span class="hljs-comment"> * obj.Update(index,val);</span><span class="hljs-comment"> * param_2 := obj.SumRange(left,right);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：508 ms, 在所有 Go 提交中击败了51.37%的用户<br>   内存消耗：23.5 MB, 在所有 Go 提交中击败了17.81%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>线段数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>309. 最佳买卖股票时机含冷冻期</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><font size=6px>最佳买卖股票时机含冷冻期</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: prices &#x3D; [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]<br>示例 2:</p><p>输入: prices &#x3D; [1]<br>输出: 0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用动态规划来做，</p><p>&#x2F;&#x2F; dp[0]是持有股票<br>&#x2F;&#x2F; dp[1]是在冷静期<br>&#x2F;&#x2F; dp[2]是不在冷静期也不持有股票</p><p>找出他们的递推公式</p><p>dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][2]-prices[i])   &#x2F;&#x2F; 持有股票的最佳策略是上一个价格买或者继续持有<br>        dp[i][1] &#x3D; dp[i-1][0] + prices[i]。&#x2F;&#x2F; 冷静期上上一个状态加上卖的钱<br>        dp[i][2] &#x3D; max(dp[i-1][1], dp[i-1][2])。&#x2F;&#x2F;不在冷静期的状态最好的情况是选取冷静期和不在冷静期的最大值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(prices)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    dp := <span class="hljs-built_in">make</span>([][<span class="hljs-number">3</span>]<span class="hljs-type">int</span>, n)    <span class="hljs-comment">// dp[0]是持有股票</span>    <span class="hljs-comment">// dp[1]是在冷静期</span>    <span class="hljs-comment">// dp[2]是不在冷静期也不持有股票</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i &lt;<span class="hljs-built_in">len</span>(prices);i++&#123;        dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]-prices[i])        dp[i][<span class="hljs-number">1</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + prices[i]        dp[i][<span class="hljs-number">2</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>])    &#125;    <span class="hljs-keyword">return</span> max(dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>], dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.3 MB, 在所有 Go 提交中击败了74.08%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>200. 岛屿数量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a><font size=6px>岛屿数量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1：</p><p>输入：grid &#x3D; [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：</p><p>输入：grid &#x3D; [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p><p>提示：</p><p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 300<br>grid[i][j] 的值为 ‘0’ 或 ‘1’</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典的dfs题，第一次到达就把flag置1，碰到一次下一次就不再重复碰</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> flag [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> move  =[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;    m,n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    flag = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(grid))    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i &lt; m;i++&#123;        flag[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span>        dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> flag[i][j] == <span class="hljs-number">1</span> || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        flag[i][j] = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++&#123;            x,y := move[k*<span class="hljs-number">2</span>] + i,move[k*<span class="hljs-number">2</span> +<span class="hljs-number">1</span>] + j            <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; flag[x][y] == <span class="hljs-number">0</span> &amp;&amp; grid[x][y] == <span class="hljs-string">&#x27;1&#x27;</span>&#123;                               dfs(x,y)            &#125;          &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j &lt;n; j++&#123;            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; flag[i][j] == <span class="hljs-number">0</span>&#123;                count ++                dfs(i,j)                            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了93.21%的用户<br>   内存消耗：5.1 MB, 在所有 Go 提交中击败了23.18%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>304. 二维区域和检索 - 矩阵不可变</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/304.%20%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/304.%20%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<h3 id="二维区域和检索-矩阵不可变"><a href="#二维区域和检索-矩阵不可变" class="headerlink" title="二维区域和检索 - 矩阵不可变"></a><font size=6px>二维区域和检索 - 矩阵不可变</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二维矩阵 matrix，以下类型的多个请求：</p><p>计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。<br>实现 NumMatrix 类：</p><p>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化<br>int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。</p><p>示例 1：</p><p>输入:<br>[“NumMatrix”,”sumRegion”,”sumRegion”,”sumRegion”]<br>[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]<br>输出:<br>[null, 8, 11, 12]</p><p>解释:<br>NumMatrix numMatrix &#x3D; new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);<br>numMatrix.sumRegion(2, 1, 4, 3); &#x2F;&#x2F; return 8 (红色矩形框的元素总和)<br>numMatrix.sumRegion(1, 1, 2, 2); &#x2F;&#x2F; return 11 (绿色矩形框的元素总和)<br>numMatrix.sumRegion(1, 2, 2, 4); &#x2F;&#x2F; return 12 (蓝色矩形框的元素总和)</p><p>提示：</p><p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>-105 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 105<br>0 &lt;&#x3D; row1 &lt;&#x3D; row2 &lt; m<br>0 &lt;&#x3D; col1 &lt;&#x3D; col2 &lt; n<br>最多调用 104 次 sumRegion 方法</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span></code></pre><p>用二维前缀和很容易做出来</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> NumMatrix <span class="hljs-keyword">struct</span> &#123;    nums [][]<span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> NumMatrix &#123;    m,n := <span class="hljs-built_in">len</span>(matrix),<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])    nums := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=m;i++&#123;        nums[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=n;j++&#123;            nums[i][j] = nums[i<span class="hljs-number">-1</span>][j]+ nums[i][j<span class="hljs-number">-1</span>] + matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] - nums[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]         &#125;    &#125;    <span class="hljs-keyword">return</span> NumMatrix&#123;nums:nums&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumMatrix)</span></span> SumRegion(row1 <span class="hljs-type">int</span>, col1 <span class="hljs-type">int</span>, row2 <span class="hljs-type">int</span>, col2 <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;    row1,row2,col1,col2 = row1+<span class="hljs-number">1</span>,row2+<span class="hljs-number">1</span>,col1+<span class="hljs-number">1</span>,col2+<span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> this.nums[row1<span class="hljs-number">-1</span>][col1<span class="hljs-number">-1</span>]+ this.nums[row2][col2] - this.nums[row2][col1<span class="hljs-number">-1</span>]- this.nums[row1<span class="hljs-number">-1</span>][col2]&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor(matrix);</span><span class="hljs-comment"> * param_1 := obj.SumRegion(row1,col1,row2,col2);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：564 ms, 在所有 Go 提交中击败了36.95%的用户<br>   内存消耗：15.9 MB, 在所有 Go 提交中击败了86.86%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31. 下一个排列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a><font size=6px>下一个排列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[1,3,2]<br>示例 2：</p><p>输入：nums &#x3D; [3,2,1]<br>输出：[1,2,3]<br>示例 3：</p><p>输入：nums &#x3D; [1,1,5]<br>输出：[1,5,1]<br>示例 4：</p><p>输入：nums &#x3D; [1]<br>输出：[1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p> 先从后往前找到第一个非降序的数字num[i]，再从后往前找到一个比第一个非降序的数字小的数，然后交换，交换完之后把第一个非降序的数字i+1到len（nums）进行倒叙排列。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123; <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;=<span class="hljs-number">1</span>&#123;     <span class="hljs-keyword">return</span>  &#125;  i,j,k := <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> i&gt;=<span class="hljs-number">0</span> &amp;&amp;nums[i] &gt;=nums[j] &#123;     i--     j-- &#125; <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-number">0</span>&#123;     <span class="hljs-keyword">for</span> nums[k] &lt;= nums[i]&#123;         k--     &#125;     nums[k], nums[i] = nums[i], nums[k] &#125;<span class="hljs-keyword">for</span> i,j = j,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i&lt;j; &#123;    nums[i],nums[j] = nums[j],nums[i]    i++    j-- &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>322. Coin Change</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/322.%20Coin%20Change/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/322.%20Coin%20Change/</url>
    
    <content type="html"><![CDATA[<h3 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a><font size=6px>Coin Change</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.</p><p>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>You may assume that you have an infinite number of each kind of coin.</p><p>Example 1:</p><p>Input: coins &#x3D; [1,2,5], amount &#x3D; 11<br>Output: 3<br>Explanation: 11 &#x3D; 5 + 5 + 1<br>Example 2:</p><p>Input: coins &#x3D; [2], amount &#x3D; 3<br>Output: -1<br>Example 3:</p><p>Input: coins &#x3D; [1], amount &#x3D; 0<br>Output: 0</p><p>Constraints:</p><p>1 &lt;&#x3D; coins.length &lt;&#x3D; 12<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; amount &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>背包问题，得出递推公式d p[n] &#x3D; min(dp[coins[0],coins[1]….])+1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;     n := <span class="hljs-built_in">len</span>(coins)    <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">int</span>    ans = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=amount;i++&#123;        minNum := <span class="hljs-number">99999</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            <span class="hljs-keyword">if</span> coins[j] &lt;= i &#123;                <span class="hljs-keyword">if</span> ans[i-coins[j]] == <span class="hljs-number">0</span> &amp;&amp; i != coins[j]&#123;                    <span class="hljs-keyword">continue</span>                &#125;                minNum = min(minNum, ans[i-coins[j]])             &#125;        &#125;        <span class="hljs-keyword">if</span> minNum != <span class="hljs-number">99999</span> &#123;            ans[i] = minNum+<span class="hljs-number">1</span>        &#125;    &#125;        <span class="hljs-keyword">if</span> ans[amount] == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;    <span class="hljs-keyword">return</span> ans[amount]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> b    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了55.09%的用户<br>   内存消耗：6.3 MB, 在所有 Go 提交中击败了93.82%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>310. 最小高度树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/310.%20%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/310.%20%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a><font size=6px>最小高度树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</p><p>给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] &#x3D; [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。</p><p>可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。</p><p>请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。</p><p>树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。</p><p>示例 1：</p><p>输入：n &#x3D; 4, edges &#x3D; [[1,0],[1,2],[1,3]]<br>输出：[1]<br>解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。<br>示例 2：</p><p>输入：n &#x3D; 6, edges &#x3D; [[3,0],[3,1],[3,2],[3,4],[5,4]]<br>输出：[3,4]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 2 * 104<br>edges.length &#x3D;&#x3D; n - 1<br>0 &lt;&#x3D; ai, bi &lt; n<br>ai !&#x3D; bi<br>所有 (ai, bi) 互不相同<br>给定的输入 保证 是一棵树，并且 不会有重复的边</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><p>深度优先搜索，第一次从0出发找到最长的序列，再从最长的节点终点便利到另一个终点，中间的一个或者两个节点的序号就是答案。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMinHeightTrees</span><span class="hljs-params">(n <span class="hljs-type">int</span>, edges [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>&#125;    &#125;    edge := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> edges&#123;        edge[v[<span class="hljs-number">0</span>]] = <span class="hljs-built_in">append</span>(edge[v[<span class="hljs-number">0</span>]],v[<span class="hljs-number">1</span>])        edge[v[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(edge[v[<span class="hljs-number">1</span>]],v[<span class="hljs-number">0</span>])    &#125;    maxDep,node := <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>    parents := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x ,pa,depth  <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x,pa,depth <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> depth &gt; maxDep&#123;            maxDep = depth            node = x        &#125;        parents[x] = pa        <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> edge[x]&#123;            <span class="hljs-keyword">if</span> v != pa&#123;                dfs(v,x,depth+<span class="hljs-number">1</span>)            &#125;        &#125;    &#125;    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)    maxDep = <span class="hljs-number">0</span>    dfs(node,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)    path := []<span class="hljs-type">int</span>&#123;&#125;    <span class="hljs-keyword">for</span> node != <span class="hljs-number">-1</span> &#123;        path = <span class="hljs-built_in">append</span>(path, node)        node = parents[node]    &#125;    m := <span class="hljs-built_in">len</span>(path)    <span class="hljs-keyword">if</span> m%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;path[m/<span class="hljs-number">2</span><span class="hljs-number">-1</span>], path[m/<span class="hljs-number">2</span>]&#125;    &#125;    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;path[m/<span class="hljs-number">2</span>]&#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：68 ms, 在所有 Go 提交中击败了70.25%的用户<br>   内存消耗：9.3 MB, 在所有 Go 提交中击败了73.55%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>338. 比特位计数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a><font size=6px>比特位计数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，对于 0 &lt;&#x3D; i &lt;&#x3D; n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：[0,1,1]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>示例 2：</p><p>输入：n &#x3D; 5<br>输出：[0,1,1,2,1,2]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>3 –&gt; 11<br>4 –&gt; 100<br>5 –&gt; 101</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countBits</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n ;i++&#123;        a := i        <span class="hljs-keyword">for</span> a!= <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> a%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>&#123;                count ++            &#125;            a /= <span class="hljs-number">2</span>        &#125;        res = <span class="hljs-built_in">append</span>(res, count)        count = <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了86.24%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了18.58%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>337. 打家劫舍 III</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/</url>
    
    <content type="html"><![CDATA[<h3 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a><font size=6px>打家劫舍 III</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。</p><p>除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><p>给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p><p>示例 1:</p><p>输入: root &#x3D; [3,2,3,null,3,null,1]<br>输出: 7<br>解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 &#x3D; 7<br>示例 2:</p><p>输入: root &#x3D; [3,4,5,1,3,null,1]<br>输出: 9<br>解释: 小偷一晚能够盗取的最高金额 4 + 5 &#x3D; 9</p><p>提示：</p><p>树的节点数在 [1, 104] 范围内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，两个map，一个f放本次本选中的最大值，g放本次未被选中的最大值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;        f,g := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*TreeNode]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*TreeNode]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)   <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>   dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;       <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;           <span class="hljs-keyword">return</span>        &#125;       dfs(root.Left)       dfs(root.Right)       f[root] = root.Val + g[root.Left] + g[root.Right]       g[root] = max(f[root.Left], g[root.Left] ) + max(f[root.Right], g[root.Right])   &#125;   dfs(root)    <span class="hljs-keyword">return</span> max(f[root], g[root])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.53%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了13.81%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>324. 摆动排序 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/324.%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/324.%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="摆动排序-II"><a href="#摆动排序-II" class="headerlink" title="摆动排序 II"></a><font size=6px>摆动排序 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。</p><p>你可以假设所有输入数组都可以得到满足题目要求的结果。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,5,1,1,6,4]<br>输出：[1,6,1,5,1,4]<br>解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。<br>示例 2：</p><p>输入：nums &#x3D; [1,3,2,2,3,1]<br>输出：[2,3,1,3,1,2]</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5 * 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 5000<br>题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>排序后分为小数和大数两个数组，然后降序穿插排序。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wiggleSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;    n := <span class="hljs-built_in">len</span>(nums)    sort.Ints(nums)    <span class="hljs-keyword">var</span> big,small,res []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> n %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;        small = nums[:n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]        big = nums[n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>:]    &#125;<span class="hljs-keyword">else</span>&#123;        small = nums[:n/<span class="hljs-number">2</span>]        big = nums[n/<span class="hljs-number">2</span>:]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++&#123;        res = <span class="hljs-built_in">append</span>(res,small[<span class="hljs-built_in">len</span>(small)-i<span class="hljs-number">-1</span>],big[<span class="hljs-built_in">len</span>(big)-i<span class="hljs-number">-1</span>])    &#125;    <span class="hljs-keyword">if</span> n %<span class="hljs-number">2</span> == <span class="hljs-number">1</span>&#123;        res = <span class="hljs-built_in">append</span>(res,small[<span class="hljs-number">0</span>])    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        nums[i] = res[i]    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了69.28%的用户<br>   内存消耗：6.4 MB, 在所有 Go 提交中击败了15.03%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><font size=6px>在排序数组中查找元素的第一个和最后一个位置</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p><p>示例 1：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p><p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>二分查找，找到后开始左、右找相同的数字</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> nums == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;    &#125;    l, r := <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> l&lt;=r&#123;        mid := (r+l)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> nums[mid] == target&#123;            l,r = mid<span class="hljs-number">-1</span>,mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> ;l&gt;=<span class="hljs-number">0</span>;l--&#123;                <span class="hljs-keyword">if</span> nums[l] != target&#123;                    <span class="hljs-keyword">break</span>                &#125;            &#125;            <span class="hljs-keyword">for</span> ;r&lt;<span class="hljs-built_in">len</span>(nums);r++&#123;                <span class="hljs-keyword">if</span> nums[r] != target&#123;                    <span class="hljs-keyword">break</span>                &#125;            &#125;            <span class="hljs-keyword">break</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)&#123;            r = mid<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid + <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> l&lt;r&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;l+<span class="hljs-number">1</span>,r<span class="hljs-number">-1</span>&#125;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了97.61%的用户<br>   内存消耗：3.8 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>347. Top K Frequent Elements</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/347.%20Top%20K%20Frequent%20Elements/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/347.%20Top%20K%20Frequent%20Elements/</url>
    
    <content type="html"><![CDATA[<h3 id="Top-K-Frequent-Elements"><a href="#Top-K-Frequent-Elements" class="headerlink" title="Top K Frequent Elements"></a><font size=6px>Top K Frequent Elements</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</p><p>Example 1:</p><p>Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>Output: [1,2]<br>Example 2:</p><p>Input: nums &#x3D; [1], k &#x3D; 1<br>Output: [1]</p><p>Constraints:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>k is in the range [1, the number of unique elements in the array].<br>It is guaranteed that the answer is unique.</p><p>Follow up: Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先排序，然后算出频繁次数构建结构体，结构体的频繁次数排序，最后得出结果</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Num <span class="hljs-keyword">struct</span> &#123;    n,f <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)    n := <span class="hljs-built_in">len</span>(nums)    sort.Ints(nums)    <span class="hljs-keyword">var</span> pairs []Num     pairs = <span class="hljs-built_in">append</span>(pairs, Num&#123;n:nums[<span class="hljs-number">0</span>],f:<span class="hljs-number">1</span>&#125;)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> nums[i] != nums[i<span class="hljs-number">-1</span>]&#123;            pairs = <span class="hljs-built_in">append</span>(pairs, Num&#123;n:nums[i],f:<span class="hljs-number">1</span>&#125;)        &#125;<span class="hljs-keyword">else</span>&#123;            pairs[<span class="hljs-built_in">len</span>(pairs)<span class="hljs-number">-1</span>].f++        &#125;    &#125;    sort.Slice(pairs,<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;        <span class="hljs-keyword">if</span> pairs[i].f  &gt; pairs[j].f&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;        res[i] = pairs[i].n    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了90.99%的用户<br>   内存消耗：4.9 MB, 在所有 Go 提交中击败了99.82%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>357. 统计各位数字都不同的数字个数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/357.%20%E7%BB%9F%E8%AE%A1%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E9%83%BD%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/357.%20%E7%BB%9F%E8%AE%A1%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E9%83%BD%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="统计各位数字都不同的数字个数"><a href="#统计各位数字都不同的数字个数" class="headerlink" title="统计各位数字都不同的数字个数"></a><font size=6px>统计各位数字都不同的数字个数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 &lt;&#x3D; x &lt; 10n 。</p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：91<br>解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x &lt; 100 范围内的所有数字。<br>示例 2：</p><p>输入：n &#x3D; 0<br>输出：1</p><p>提示：</p><p>0 &lt;&#x3D; n &lt;&#x3D; 8<br>通过次数32,806提交次数60,347</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(k),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>如果是3位数，那先计算3位数的个数，是9 * 9 * 8，再计算两位数是9 * 9，最后计算一位数，是10，位数大了一样的计算过程。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNumbersWithUniqueDigits</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> n ==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;    res := <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> n&gt;<span class="hljs-number">0</span>&#123;        tmp := <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">10</span>-n+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++&#123;            <span class="hljs-keyword">if</span> i == <span class="hljs-number">10</span>&#123;                tmp *= <span class="hljs-number">9</span>            &#125;<span class="hljs-keyword">else</span>&#123;                tmp *= i            &#125;                    &#125;        res += tmp        n--    &#125;        <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了61.36%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>377. 组合总和 Ⅳ</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/377.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/377.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a><font size=6px>组合总和 Ⅳ</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3], target &#x3D; 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。<br>示例 2：</p><p>输入：nums &#x3D; [9], target &#x3D; 3<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>nums 中的所有元素 互不相同<br>1 &lt;&#x3D; target &lt;&#x3D; 1000</p><p>进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用dp做，想明白amout在外层和n在外层的区别</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,target+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=target;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            <span class="hljs-keyword">if</span> nums[j] &lt;= i&#123;                dp[i] += dp[i-nums[j]]            &#125;        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> dp[target]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了43.40%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>380. O(1) 时间插入、删除和获取随机元素</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/380.%20O(1)%20%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/380.%20O(1)%20%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="O-1-时间插入、删除和获取随机元素"><a href="#O-1-时间插入、删除和获取随机元素" class="headerlink" title="O(1) 时间插入、删除和获取随机元素"></a><font size=6px>O(1) 时间插入、删除和获取随机元素</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现RandomizedSet 类：</p><p>RandomizedSet() 初始化 RandomizedSet 对象<br>bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。<br>bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。<br>int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。<br>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</p><p>示例：</p><p>输入<br>[“RandomizedSet”, “insert”, “remove”, “insert”, “getRandom”, “remove”, “insert”, “getRandom”]<br>[[], [1], [2], [2], [], [1], [2], []]<br>输出<br>[null, true, false, true, 2, true, false, 2]</p><p>解释<br>RandomizedSet randomizedSet &#x3D; new RandomizedSet();<br>randomizedSet.insert(1); &#x2F;&#x2F; 向集合中插入 1 。返回 true 表示 1 被成功地插入。<br>randomizedSet.remove(2); &#x2F;&#x2F; 返回 false ，表示集合中不存在 2 。<br>randomizedSet.insert(2); &#x2F;&#x2F; 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。<br>randomizedSet.getRandom(); &#x2F;&#x2F; getRandom 应随机返回 1 或 2 。<br>randomizedSet.remove(1); &#x2F;&#x2F; 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。<br>randomizedSet.insert(2); &#x2F;&#x2F; 2 已在集合中，所以返回 false 。<br>randomizedSet.getRandom(); &#x2F;&#x2F; 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</p><p>提示：</p><p>-231 &lt;&#x3D; val &lt;&#x3D; 231 - 1<br>最多调用 insert、remove 和 getRandom 函数 2 * 105 次<br>在调用 getRandom 方法时，数据结构中 至少存在一个 元素。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>使用hash和arr做，创建一个5*10000的arr，重点是删除操作，删除了target数之后最后一个数填进删除的target的idx中。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> RandomizedSet <span class="hljs-keyword">struct</span> &#123;    nums [<span class="hljs-number">200000</span>]<span class="hljs-type">int</span>    mp <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>    idx <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> RandomizedSet &#123;    randomizedSet := <span class="hljs-built_in">new</span>(RandomizedSet)    randomizedSet.mp = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> *randomizedSet&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *RandomizedSet)</span></span> Insert(val <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> _,ok := this.mp[val];ok&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;<span class="hljs-keyword">else</span>&#123;        this.nums[this.idx] = val        this.mp[val] = this.idx        this.idx++            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *RandomizedSet)</span></span> Remove(val <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> _,ok := this.mp[val];!ok&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;<span class="hljs-keyword">else</span>&#123;        i := this.mp[val]        this.mp[this.nums[this.idx<span class="hljs-number">-1</span>]] = i        this.nums[i] = this.nums[this.idx<span class="hljs-number">-1</span>]        this.idx--        <span class="hljs-built_in">delete</span>(this.mp,val)            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *RandomizedSet)</span></span> GetRandom() <span class="hljs-type">int</span> &#123;    i := rand.Intn(this.idx)    <span class="hljs-keyword">return</span> this.nums[i]&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your RandomizedSet object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor();</span><span class="hljs-comment"> * param_1 := obj.Insert(val);</span><span class="hljs-comment"> * param_2 := obj.Remove(val);</span><span class="hljs-comment"> * param_3 := obj.GetRandom();</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：152 ms, 在所有 Go 提交中击败了41.21%的用户<br>   内存消耗：59.8 MB, 在所有 Go 提交中击败了5.24%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>arr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>376. 摆动序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/376.%20%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/376.%20%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><font size=6px>376. 摆动序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。<br>示例 2：</p><p>输入：nums &#x3D; [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。<br>示例 3：</p><p>输入：nums &#x3D; [1,2,3,4,5,6,7,8,9]<br>输出：2</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>Dp,使用down和up队列记录升和降</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    up,down := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>),<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    up[<span class="hljs-number">0</span>],down[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> nums[i] &gt; nums[i<span class="hljs-number">-1</span>]&#123;            up[i] = max(up[i<span class="hljs-number">-1</span>],down[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span> )            down[i] = down[i<span class="hljs-number">-1</span>]        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[i] &lt; nums[i<span class="hljs-number">-1</span>]&#123;            up[i] = up[i<span class="hljs-number">-1</span>]            down[i] = max(down[i<span class="hljs-number">-1</span>], up[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)        &#125;<span class="hljs-keyword">else</span>&#123;            up[i] = up[i<span class="hljs-number">-1</span>]            down[i] = down[i<span class="hljs-number">-1</span>]        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(up,down)</span>    <span class="hljs-keyword">return</span> max(up[n<span class="hljs-number">-1</span>],down[n<span class="hljs-number">-1</span>])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了15.68%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>386. 字典序排数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/386.%20%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/386.%20%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="字典序排数"><a href="#字典序排数" class="headerlink" title="字典序排数"></a><font size=6px>字典序排数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。</p><p>你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。</p><p>示例 1：</p><p>输入：n &#x3D; 13<br>输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]<br>示例 2：</p><p>输入：n &#x3D; 2<br>输出：[1,2]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 5 * 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>Dfs 爆搜，每次都*10或者+1，只有这两种情况</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lexicalOrder</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> x &gt;n&#123;            <span class="hljs-keyword">return</span>         &#125;        res =<span class="hljs-built_in">append</span>(res, x)        dfs(x*<span class="hljs-number">10</span>)                <span class="hljs-keyword">if</span> x &gt;=<span class="hljs-number">10</span> &amp;&amp; x % <span class="hljs-number">10</span> &lt;=<span class="hljs-number">8</span> &#123;            dfs(x+<span class="hljs-number">1</span>)        &#125;            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++&#123;        dfs(i)    &#125;        <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了85.14%的用户<br>   内存消耗：6.4 MB, 在所有 Go 提交中击败了11.49%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>388. 文件的最长绝对路径</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/388.%20%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/388.%20%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="文件的最长绝对路径"><a href="#文件的最长绝对路径" class="headerlink" title="文件的最长绝对路径"></a><font size=6px>文件的最长绝对路径</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：</p><p>这里将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext 。</p><p>在文本格式中，如下所示(⟶表示制表符)：</p><p>dir<br>⟶ subdir1<br>⟶ ⟶ file1.ext<br>⟶ ⟶ subsubdir1<br>⟶ subdir2<br>⟶ ⟶ subsubdir2<br>⟶ ⟶ ⟶ file2.ext<br>如果是代码表示，上面的文件系统可以写为 “dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext” 。’\n’ 和 ‘\t’ 分别是换行符和制表符。</p><p>文件系统中的每个文件和文件夹都有一个唯一的 绝对路径 ，即必须打开才能到达文件&#x2F;目录所在位置的目录顺序，所有路径用 ‘&#x2F;‘ 连接。上面例子中，指向 file2.ext 的 绝对路径 是 “dir&#x2F;subdir2&#x2F;subsubdir2&#x2F;file2.ext” 。每个目录名由字母、数字和&#x2F;或空格组成，每个文件名遵循 name.extension 的格式，其中 name 和 extension由字母、数字和&#x2F;或空格组成。</p><p>给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向 文件 的 最长绝对路径 的长度 。 如果系统中没有文件，返回 0。</p><p>示例 1：</p><p>输入：input &#x3D; “dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext”<br>输出：20<br>解释：只有一个文件，绝对路径为 “dir&#x2F;subdir2&#x2F;file.ext” ，路径长度 20<br>示例 2：</p><p>输入：input &#x3D; “dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext”<br>输出：32<br>解释：存在两个文件：<br>“dir&#x2F;subdir1&#x2F;file1.ext” ，路径长度 21<br>“dir&#x2F;subdir2&#x2F;subsubdir2&#x2F;file2.ext” ，路径长度 32<br>返回 32 ，因为这是最长的路径<br>示例 3：</p><p>输入：input &#x3D; “a”<br>输出：0<br>解释：不存在任何文件<br>示例 4：</p><p>输入：input &#x3D; “file1.txt\nfile2.txt\nlongfile.txt”<br>输出：12<br>解释：根目录下有 3 个文件。<br>因为根目录中任何东西的绝对路径只是名称本身，所以答案是 “longfile.txt” ，路径长度为 12</p><p>提示：</p><p>1 &lt;&#x3D; input.length &lt;&#x3D; 104<br>input 可能包含小写或大写的英文字母，一个换行符 ‘\n’，一个制表符 ‘\t’，一个点 ‘.’，一个空格 ‘ ‘，和数字。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>先根据\n分割成string切片，然后根据\t数量确定层数，便利到一个文件后就便利每一层的字符长度</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthLongestPath</span><span class="hljs-params">(input <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    inputs := strings.Split(input,<span class="hljs-string">&quot;\n&quot;</span>)    maxRes := <span class="hljs-number">0</span>    depth := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">1000</span>)        <span class="hljs-keyword">for</span> _,word := <span class="hljs-keyword">range</span> inputs&#123;        idx := <span class="hljs-number">0</span>        isFile := <span class="hljs-literal">false</span>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">len</span>(word)<span class="hljs-number">-1</span>;i++&#123;                      <span class="hljs-keyword">if</span> <span class="hljs-type">string</span>(word[i:i+<span class="hljs-number">1</span>]) == <span class="hljs-string">&quot;\t&quot;</span> &#123;                idx += <span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> word[i] == <span class="hljs-string">&#x27;.&#x27;</span>&#123;                isFile = <span class="hljs-literal">true</span>            &#125;        &#125;        depth[idx] = word        <span class="hljs-keyword">if</span> isFile&#123;            res := <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=idx;i++&#123;                res += <span class="hljs-built_in">len</span>(depth[i])                res -= i            &#125;            maxRes = max(res+idx, maxRes)        &#125;    &#125;    <span class="hljs-keyword">return</span> maxRes&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了73.91%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>312. 戳气球</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/312.%20%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/312.%20%E6%88%B3%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h3 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><font size=6px>戳气球</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p><p>求所能获得硬币的最大数量。</p><p>示例 1：<br>输入：nums &#x3D; [3,1,5,8]<br>输出：167<br>解释：<br>nums &#x3D; [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; []<br>coins &#x3D;  3<em>1</em>5    +   3<em>5</em>8   +  1<em>3</em>8  + 1<em>8</em>1 &#x3D; 167<br>示例 2：</p><p>输入：nums &#x3D; [1,5]<br>输出：10</p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划做，区级dp，太难了我直接看解析了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">2</span>)    res[<span class="hljs-number">0</span>], res[n+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        res[i] = nums[i<span class="hljs-number">-1</span>]    &#125;    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n+<span class="hljs-number">2</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">2</span>;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">2</span>)    &#125;    <span class="hljs-keyword">for</span> i:=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">for</span> j:=i+<span class="hljs-number">2</span>;j&lt;=n+<span class="hljs-number">1</span>;j++&#123;            <span class="hljs-keyword">for</span> k:=i+<span class="hljs-number">1</span>;k&lt;j;k++&#123;                num := dp[i][k] + dp[k][j] + res[i]*res[j]*res[k]                dp[i][j] = max(dp[i][j], num)            &#125;        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n+<span class="hljs-number">1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：60 ms, 在所有 Go 提交中击败了76.44%的用户<br>   内存消耗：5.4 MB, 在所有 Go 提交中击败了27.56%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>398. 随机数索引</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/398.%20%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/398.%20%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h3 id="随机数索引"><a href="#随机数索引" class="headerlink" title="随机数索引"></a><font size=6px>随机数索引</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。</p><p>注意：<br>数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。</p><p>示例:</p><p>int[] nums &#x3D; new int[] {1,2,3,3,3};<br>Solution solution &#x3D; new Solution(nums);</p><p>&#x2F;&#x2F; pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。<br>solution.pick(3);</p><p>&#x2F;&#x2F; pick(1) 应该返回 0。因为只有nums[0]等于1。<br>solution.pick(1);</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>水塘抽样算法，是否取这个数不是靠本身而是靠后面的数是否取，每个元素的概率都是1&#x2F;k。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Solution []<span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> Solution &#123;    <span class="hljs-keyword">return</span> nums&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nums Solution)</span></span> Pick(target <span class="hljs-type">int</span>) (ans <span class="hljs-type">int</span>) &#123;    cnt := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i, num := <span class="hljs-keyword">range</span> nums &#123;        <span class="hljs-keyword">if</span> num == target &#123;            cnt++ <span class="hljs-comment">// 第 cnt 次遇到 target</span>            <span class="hljs-keyword">if</span> rand.Intn(cnt) == <span class="hljs-number">0</span> &#123;                ans = i            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：80 ms, 在所有 Go 提交中击败了65.41%的用户<br>   内存消耗：8.1 MB, 在所有 Go 提交中击败了79.70%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 寻找两个正序数组的中位数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><font size=6px>寻找两个正序数组的中位数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]<br>输出：2.00000<br>解释：合并数组 &#x3D; [1,2,3] ，中位数 2<br>示例 2：</p><p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]<br>输出：2.50000<br>解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5<br>示例 3：</p><p>输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]<br>输出：0.00000<br>示例 4：</p><p>输入：nums1 &#x3D; [], nums2 &#x3D; [1]<br>输出：1.00000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>最简单的思路</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;    flag := <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(nums1)+<span class="hljs-built_in">len</span>(nums2)) % <span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;        flag = <span class="hljs-number">0</span>    &#125;<span class="hljs-keyword">else</span>&#123;        flag = <span class="hljs-number">1</span>    &#125;    mid := (<span class="hljs-built_in">len</span>(nums1)+<span class="hljs-built_in">len</span>(nums2))/<span class="hljs-number">2</span>    nums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums1)+ <span class="hljs-built_in">len</span>(nums2))    <span class="hljs-keyword">var</span> i,j <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i ,j = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums1) &amp;&amp; j &lt;<span class="hljs-built_in">len</span>(nums2);&#123;        <span class="hljs-keyword">if</span> nums1[i] &lt; nums2[j]&#123;            nums[i+j] = nums1[i]            i++        &#125;<span class="hljs-keyword">else</span>&#123;            nums[i+j] = nums2[j]            j++        &#125;    &#125;    <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(nums1) &amp;&amp; j&lt;<span class="hljs-built_in">len</span>(nums2)&#123;        <span class="hljs-keyword">for</span> ;j&lt;<span class="hljs-built_in">len</span>(nums2);j++&#123;            nums[i+j] = nums2[j]        &#125;    &#125;    <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(nums2) &amp;&amp; i &lt;<span class="hljs-built_in">len</span>(nums1)&#123;        <span class="hljs-keyword">for</span> ;i&lt;<span class="hljs-built_in">len</span>(nums1);i++&#123;            nums[i+j] = nums1[i]        &#125;    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;     <span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(nums[mid])    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span>  (<span class="hljs-type">float64</span>(nums[mid])+<span class="hljs-type">float64</span>(nums[mid<span class="hljs-number">-1</span>]))/<span class="hljs-number">2</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了88.16%的用户<br>   内存消耗：5.4 MB, 在所有 Go 提交中击败了41.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>399. Evaluate Division</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/399.%20Evaluate%20Division/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/399.%20Evaluate%20Division/</url>
    
    <content type="html"><![CDATA[<h3 id="Evaluate-Division"><a href="#Evaluate-Division" class="headerlink" title="Evaluate Division"></a><font size=6px>Evaluate Division</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>ou are given an array of variable pairs equations and an array of real numbers values, where equations[i] &#x3D; [Ai, Bi] and values[i] represent the equation Ai &#x2F; Bi &#x3D; values[i]. Each Ai or Bi is a string that represents a single variable.</p><p>You are also given some queries, where queries[j] &#x3D; [Cj, Dj] represents the jth query where you must find the answer for Cj &#x2F; Dj &#x3D; ?.</p><p>Return the answers to all queries. If a single answer cannot be determined, return -1.0.</p><p>Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p><p>Example 1:</p><p>Input: equations &#x3D; [[“a”,”b”],[“b”,”c”]], values &#x3D; [2.0,3.0], queries &#x3D; [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]<br>Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]<br>Explanation:<br>Given: a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0<br>queries are: a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ?<br>return: [6.0, 0.5, -1.0, 1.0, -1.0 ]<br>Example 2:</p><p>Input: equations &#x3D; [[“a”,”b”],[“b”,”c”],[“bc”,”cd”]], values &#x3D; [1.5,2.5,5.0], queries &#x3D; [[“a”,”c”],[“c”,”b”],[“bc”,”cd”],[“cd”,”bc”]]<br>Output: [3.75000,0.40000,5.00000,0.20000]<br>Example 3:</p><p>Input: equations &#x3D; [[“a”,”b”]], values &#x3D; [0.5], queries &#x3D; [[“a”,”b”],[“b”,”a”],[“a”,”c”],[“x”,”y”]]<br>Output: [0.50000,2.00000,-1.00000,-1.00000]</p><p>Constraints:</p><p>1 &lt;&#x3D; equations.length &lt;&#x3D; 20<br>equations[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; Ai.length, Bi.length &lt;&#x3D; 5<br>values.length &#x3D;&#x3D; equations.length<br>0.0 &lt; values[i] &lt;&#x3D; 20.0<br>1 &lt;&#x3D; queries.length &lt;&#x3D; 20<br>queries[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; Cj.length, Dj.length &lt;&#x3D; 5<br>Ai, Bi, Cj, Dj consist of lower case English letters and digits.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以两种方法做，并查集和bfs，把a&#x2F;b &#x3D;2 看成 a-&gt;b &#x3D; 2,b-&gt;a &#x3D; 1&#x2F;2,用图的思想做。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcEquation</span><span class="hljs-params">(equations [][]<span class="hljs-type">string</span>, values []<span class="hljs-type">float64</span>, queries [][]<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">float64</span> &#123;        <span class="hljs-keyword">var</span> res []<span class="hljs-type">float64</span>    graph := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span>&#123;&#125;    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> equations&#123;        <span class="hljs-keyword">if</span> _,ok := graph[v[<span class="hljs-number">0</span>]];!ok&#123;            graph[v[<span class="hljs-number">0</span>]] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span>, <span class="hljs-number">0</span>)        &#125;        <span class="hljs-keyword">if</span> _,ok := graph[v[<span class="hljs-number">1</span>]];!ok&#123;            graph[v[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span>, <span class="hljs-number">0</span>)        &#125;        graph[v[<span class="hljs-number">0</span>]][v[<span class="hljs-number">1</span>]] = values[k]        graph[v[<span class="hljs-number">1</span>]][v[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>/values[k]        graph[v[<span class="hljs-number">0</span>]][v[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>        graph[v[<span class="hljs-number">1</span>]][v[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">var</span> calc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">string</span>, visit <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)</span></span><span class="hljs-type">float64</span>    calc = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a,b <span class="hljs-type">string</span>, visit <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)</span></span><span class="hljs-type">float64</span>&#123;        <span class="hljs-keyword">if</span> _,ok := graph[a];!ok&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;        <span class="hljs-keyword">if</span> _,ok := graph[b];!ok&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;        <span class="hljs-keyword">if</span> v,ok := graph[a][b];ok&#123;            <span class="hljs-keyword">return</span> v        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span> key,value := <span class="hljs-keyword">range</span> graph[a]&#123;                <span class="hljs-comment">// 防止重复</span>                <span class="hljs-keyword">if</span> _,ok := (visit)[key];ok&#123;                    <span class="hljs-keyword">continue</span>                &#125;                visit[a] = <span class="hljs-literal">true</span>                ans := calc(key,b,visit)                <span class="hljs-keyword">if</span> ans != <span class="hljs-number">-1</span>&#123;                    <span class="hljs-keyword">return</span> ans *value                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>            &#125;    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> queries&#123;        res = <span class="hljs-built_in">append</span>(res, calc(v[<span class="hljs-number">0</span>],v[<span class="hljs-number">1</span>], <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>&#123;&#125;))    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>406. Queue Reconstruction by Height</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/406.%20Queue%20Reconstruction%20by%20Height/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/406.%20Queue%20Reconstruction%20by%20Height/</url>
    
    <content type="html"><![CDATA[<h3 id="Queue-Reconstruction-by-Height"><a href="#Queue-Reconstruction-by-Height" class="headerlink" title="Queue Reconstruction by Height"></a><font size=6px>Queue Reconstruction by Height</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] &#x3D; [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.</p><p>Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] &#x3D; [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</p><p>Example 1:</p><p>Input: people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br>Explanation:<br>Person 0 has height 5 with no other people taller or the same height in front.<br>Person 1 has height 7 with no other people taller or the same height in front.<br>Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.<br>Person 3 has height 6 with one person taller or the same height in front, which is person 1.<br>Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.<br>Person 5 has height 7 with one person taller or the same height in front, which is person 1.<br>Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.<br>Example 2:</p><p>Input: people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p><p>Constraints:</p><p>1 &lt;&#x3D; people.length &lt;&#x3D; 2000<br>0 &lt;&#x3D; hi &lt;&#x3D; 106<br>0 &lt;&#x3D; ki &lt; people.length<br>It is guaranteed that the queue can be reconstructed.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先排序，身高从低到高，k从高到低。【4，2】代表前面有2个比他大的，在原来的序列找到比他大的两个就插入</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reconstructQueue</span><span class="hljs-params">(people [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    sort.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;        a,b := people[i], people[j]        <span class="hljs-keyword">if</span> a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &gt; b[<span class="hljs-number">1</span>]        &#125;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>]    &#125;)    ans  := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(people))    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> people&#123;        distance := p[<span class="hljs-number">1</span>] +<span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ans&#123;                    <span class="hljs-keyword">if</span> ans[i] == <span class="hljs-literal">nil</span>&#123;                    distance --                    <span class="hljs-keyword">if</span> distance ==<span class="hljs-number">0</span>&#123;                        ans[i] = p                    &#125;                &#125;            &#125;    &#125;    <span class="hljs-keyword">return</span> ans    &#125;    </code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了43.12%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了90.52%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>416. Partition Equal Subset Sum</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/416.%20Partition%20Equal%20Subset%20Sum/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/416.%20Partition%20Equal%20Subset%20Sum/</url>
    
    <content type="html"><![CDATA[<h3 id="Partition-Equal-Subset-Sum"><a href="#Partition-Equal-Subset-Sum" class="headerlink" title="Partition Equal Subset Sum"></a><font size=6px>Partition Equal Subset Sum</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p>Example 1:</p><p>Input: nums &#x3D; [1,5,11,5]<br>Output: true<br>Explanation: The array can be partitioned as [1, 5, 5] and [11].<br>Example 2:</p><p>Input: nums &#x3D; [1,2,3,5]<br>Output: false<br>Explanation: The array cannot be partitioned into equal sum subsets.</p><p>Constraints:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100<br>通过次数208,856提交次数407,742</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划题，把题目转化成01背包问题是关键，只有数字组合能达到sum的一半就算true</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    sum := <span class="hljs-number">0</span>    n := <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        sum += nums[i]    &#125;    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    sum /= <span class="hljs-number">2</span>    dp  := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, sum+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        num := nums[i]        <span class="hljs-keyword">for</span> j:=sum;j &gt;= num;j--&#123;            dp[j] |= dp[j - num]        &#125;    &#125;    <span class="hljs-keyword">if</span> dp[sum] == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了99.43%的用户<br>   内存消耗：3.2 MB, 在所有 Go 提交中击败了70.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>413. 等差数列划分</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/413.%20%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/413.%20%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="等差数列划分"><a href="#等差数列划分" class="headerlink" title="等差数列划分"></a><font size=6px>等差数列划分</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。<br>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。</p><p>子数组 是数组中的一个连续序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,4]<br>输出：3<br>解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。<br>示例 2：</p><p>输入：nums &#x3D; [1]<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>求等差数列有多长，累加就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    d,j := nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> nums[i]-nums[i<span class="hljs-number">-1</span>] == d&#123;            j++        &#125;<span class="hljs-keyword">else</span>&#123;            d,j = nums[i]-nums[i<span class="hljs-number">-1</span>],<span class="hljs-number">0</span>        &#125;        res += j            &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>427. 建立四叉树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/427.%20%E5%BB%BA%E7%AB%8B%E5%9B%9B%E5%8F%89%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/427.%20%E5%BB%BA%E7%AB%8B%E5%9B%9B%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="建立四叉树"><a href="#建立四叉树" class="headerlink" title="建立四叉树"></a><font size=6px>建立四叉树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 n * n 矩阵 grid ，矩阵由若干 0 和 1 组成。请你用四叉树表示该矩阵 grid 。</p><p>你需要返回能表示矩阵的 四叉树 的根结点。</p><p>注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。</p><p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p><p>val：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False；<br>isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 。<br>class Node {<br>    public boolean val;<br>    public boolean isLeaf;<br>    public Node topLeft;<br>    public Node topRight;<br>    public Node bottomLeft;<br>    public Node bottomRight;<br>}<br>我们可以按以下步骤为二维区域构建四叉树：</p><p>如果当前网格的值相同（即，全为 0 或者全为 1），将 isLeaf 设为 True ，将 val 设为网格相应的值，并将四个子节点都设为 Null 然后停止。<br>如果当前网格的值不同，将 isLeaf 设为 False， 将 val 设为任意值，然后如下图所示，将当前网格划分为四个子网格。<br>使用适当的子网格递归每个子节点。</p><p>如果你想了解更多关于四叉树的内容，可以参考 wiki 。</p><p>四叉树格式：</p><p>输出为使用层序遍历后四叉树的序列化形式，其中 null 表示路径终止符，其下面不存在节点。</p><p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 [isLeaf, val] 。</p><p>如果 isLeaf 或者 val 的值为 True ，则表示它在列表 [isLeaf, val] 中的值为 1 ；如果 isLeaf 或者 val 的值为 False ，则表示值为 0 。</p><p>示例 1：</p><p>输入：grid &#x3D; [[0,1],[1,0]]<br>输出：[[0,1],[1,0],[1,1],[1,1],[1,0]]<br>解释：此示例的解释如下：<br>请注意，在下面四叉树的图示中，0 表示 false，1 表示 True 。</p><p>示例 2：</p><p>输入：grid &#x3D; [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]<br>输出：[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]<br>解释：网格中的所有值都不相同。我们将网格划分为四个子网格。<br>topLeft，bottomLeft 和 bottomRight 均具有相同的值。<br>topRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。<br>解释如下图所示：</p><p>示例 3：</p><p>输入：grid &#x3D; [[1,1],[1,1]]<br>输出：[[1,1]]<br>示例 4：</p><p>输入：grid &#x3D; [[0]]<br>输出：[[1,0]]<br>示例 5：</p><p>输入：grid &#x3D; [[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]<br>输出：[[0,1],[1,1],[1,0],[1,0],[1,1]]</p><p>提示：</p><p>n &#x3D;&#x3D; grid.length &#x3D;&#x3D; grid[i].length<br>n &#x3D;&#x3D; 2^x 其中 0 &lt;&#x3D; x &lt;&#x3D; 6</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用递归dfs去求出每个区间的节点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a QuadTree node.</span><span class="hljs-comment"> * type Node struct &#123;</span><span class="hljs-comment"> *     Val bool</span><span class="hljs-comment"> *     IsLeaf bool</span><span class="hljs-comment"> *     TopLeft *Node</span><span class="hljs-comment"> *     TopRight *Node</span><span class="hljs-comment"> *     BottomLeft *Node</span><span class="hljs-comment"> *     BottomRight *Node</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">construct</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> *Node &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arr [][]<span class="hljs-type">int</span>,c0 <span class="hljs-type">int</span> ,c1 <span class="hljs-type">int</span>)</span></span>*Node    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arr [][]<span class="hljs-type">int</span>, c0 <span class="hljs-type">int</span> ,c1 <span class="hljs-type">int</span>)</span></span>*Node&#123;        m,n := <span class="hljs-built_in">len</span>(arr)/<span class="hljs-number">2</span>,(c0+c1)/<span class="hljs-number">2</span>        <span class="hljs-keyword">for</span> _,row := <span class="hljs-keyword">range</span> arr&#123;            <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> row[c0:c1]&#123;                <span class="hljs-keyword">if</span> v != arr[<span class="hljs-number">0</span>][c0]&#123;                    <span class="hljs-keyword">return</span> &amp;Node&#123;                        <span class="hljs-literal">true</span>,                        <span class="hljs-literal">false</span>,                        dfs(arr[:m],c0,n ),                        dfs(arr[:m],n,c1),                        dfs(arr[m:],c0,n),                        dfs(arr[m:],n,c1),                    &#125;                &#125;            &#125;        &#125;       <span class="hljs-keyword">return</span> &amp;Node&#123;Val: arr[<span class="hljs-number">0</span>][c0] == <span class="hljs-number">1</span>, IsLeaf: <span class="hljs-literal">true</span>&#125;    &#125;    <span class="hljs-keyword">return</span> dfs(grid,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(grid))&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了76.19%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了76.19%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>429. N 叉树的层序遍历</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/429.%20N%20%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/429.%20N%20%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="N-叉树的层序遍历"><a href="#N-叉树的层序遍历" class="headerlink" title="N 叉树的层序遍历"></a><font size=6px>N 叉树的层序遍历</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]<br>示例 2：</p><p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</p><p>提示：</p><p>树的高度不会超过 1000<br>树的节点总数在 [0, 10^4] 之间</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用dfs最容易写了，不用栈之类的东西</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a Node.</span><span class="hljs-comment"> * type Node struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Children []*Node</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *Node)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *Node,dep <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *Node,dep <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) &lt;= dep &#123;            res = <span class="hljs-built_in">append</span>(res, []<span class="hljs-type">int</span>&#123;&#125;)            res[dep] = <span class="hljs-built_in">append</span>(res[dep], root.Val)        &#125;<span class="hljs-keyword">else</span>&#123;            res[dep] = <span class="hljs-built_in">append</span>(res[dep], root.Val)        &#125;        <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> root.Children&#123;            dfs(v,dep+<span class="hljs-number">1</span>)        &#125;    &#125;   dfs(root,<span class="hljs-number">0</span>)   <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：4.1 MB, 在所有 Go 提交中击败了88.75%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>375. 猜数字大小 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/375.%20%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/375.%20%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="猜数字大小-II"><a href="#猜数字大小-II" class="headerlink" title="猜数字大小 II"></a><font size=6px>猜数字大小 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 1 到 n 之间选择一个数字。<br>你来猜我选了哪个数字。<br>如果你猜到正确的数字，就会 赢得游戏 。<br>如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。<br>每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。<br>给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。</p><p>示例 1：</p><p>输入：n &#x3D; 10<br>输出：16<br>解释：制胜策略如下：</p><ul><li>数字范围是 [1,10] 。你先猜测数字为 7 。<ul><li>如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。</li><li>如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。<ul><li>如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。</li><li>如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 &#x3D; $16 。</li><li>如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 &#x3D; $16 。</li></ul></li><li>如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。<ul><li>如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。</li><li>如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。<ul><li>如果这是我选中的数字，你的总费用为 $7 + $3 &#x3D; $10 。否则，你需要支付 $5 。</li><li>如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 &#x3D; $15 。</li><li>如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 &#x3D; $15 。</li></ul></li><li>如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。<ul><li>如果这是我选中的数字，你的总费用为 $7 + $3 &#x3D; $10 。否则，你需要支付 $1 。</li><li>如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 &#x3D; $11 。<br>  在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。<br>  示例 2：</li></ul></li></ul></li></ul></li></ul><p>输入：n &#x3D; 1<br>输出：0<br>解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。<br>示例 3：</p><p>输入：n &#x3D; 2<br>输出：1<br>解释：有两个可能的数字 1 和 2 。</p><ul><li>你可以先猜 1 。<ul><li>如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。</li><li>如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。<br>  最糟糕的情况下，你需要支付 $1 。</li></ul></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划做，推荐一个<a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/dong-tai-gui-hua-c-you-tu-jie-by-zhang-xiao-tong-2/">解析</a>，我是看他的，区间dp，dp【i】【j】是从i到j的最小花费</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoneyAmount</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n; i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span> ,n+<span class="hljs-number">1</span>)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;=n;j++&#123;            dp[i][j] = <span class="hljs-number">1e18</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n;i++&#123;        dp[i][i] = <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">for</span> j:=<span class="hljs-number">2</span>;j&lt;=n;j++&#123;        <span class="hljs-keyword">for</span> i:=j<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--&#123;            <span class="hljs-keyword">for</span>  k := i+<span class="hljs-number">1</span>; k&lt;=j<span class="hljs-number">-1</span>;k++&#123;                dp[i][j] = min(dp[i][j],k+ max(dp[i][k<span class="hljs-number">-1</span>], dp[k+<span class="hljs-number">1</span>][j]))            &#125;            dp[i][j]=min(dp[i][j],i+dp[i+<span class="hljs-number">1</span>][j]);            dp[i][j]=min(dp[i][j],j+dp[i][j<span class="hljs-number">-1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了62.50%的用户<br>   内存消耗：4.6 MB, 在所有 Go 提交中击败了71.43%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>437. 路径总和 III</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/</url>
    
    <content type="html"><![CDATA[<h3 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a><font size=6px>路径总和 III</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>示例 1：</p><p>输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8<br>输出：3<br>解释：和等于 8 的路径有 3 条，如图所示。<br>示例 2：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：3</p><p>提示:</p><p>二叉树的节点个数的范围是 [0,1000]<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把遍历每个结点，并把每个节点当作根节点进行dfs遍历，时间会比较久。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    ans := <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span> root.Val == targetSum&#123;        ans ++    &#125;    ans += dfs(root.Left, targetSum-root.Val)    ans +=dfs(root.Right, targetSum-root.Val)    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    res := dfs(root, targetSum)    res += pathSum(root.Left, targetSum)    res += pathSum(root.Right, targetSum)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：28 ms, 在所有 Go 提交中击败了29.36%的用户<br>   内存消耗：4 MB, 在所有 Go 提交中击败了91.28%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>438. 找到字符串中所有字母异位词</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><font size=6px>找到字符串中所有字母异位词</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p>示例 1:</p><p>输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。<br> 示例 2:</p><p>输入: s &#x3D; “abab”, p &#x3D; “ab”<br>输出: [0,1,2]<br>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p><p>提示:</p><p>1 &lt;&#x3D; s.length, p.length &lt;&#x3D; 3 * 104<br>s 和 p 仅包含小写字母</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>就把数字放进map里面，遇到一次就减去这个字母的频数一次，直到map里面所有数字都是0就代表是字母异味词。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findAnagrams</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p) &gt;<span class="hljs-built_in">len</span>(s)&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(p);i++&#123;        m[p[i]] ++    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(p);i++&#123;        m[s[i]]--    &#125;    <span class="hljs-keyword">var</span> check <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><span class="hljs-type">bool</span>    check = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><span class="hljs-type">bool</span>&#123;        <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> m&#123;            <span class="hljs-keyword">if</span> v != <span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">if</span> check()&#123;        res = <span class="hljs-built_in">append</span>(res,<span class="hljs-number">0</span>)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(s)-<span class="hljs-built_in">len</span>(p);i++&#123;        m[s[i<span class="hljs-number">-1</span>]] ++        m[s[i+<span class="hljs-built_in">len</span>(p)<span class="hljs-number">-1</span>]]--        <span class="hljs-keyword">if</span> check()&#123;            res = <span class="hljs-built_in">append</span>(res, i)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了31.08%的用户<br>   内存消耗：5 MB, 在所有 Go 提交中击败了91.62%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>440. 字典序的第K小数字</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/440.%20%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/440.%20%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="字典序的第K小数字"><a href="#字典序的第K小数字" class="headerlink" title="字典序的第K小数字"></a><font size=6px>字典序的第K小数字</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。</p><p>示例 1:</p><p>输入: n &#x3D; 13, k &#x3D; 2<br>输出: 10<br>解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。<br>示例 2:</p><p>输入: n &#x3D; 1, k &#x3D; 1<br>输出: 1</p><p>提示:</p><p>1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>从1到9依次计算，就是得到以1为开始数字，计算出以1开头的数字的个数，如果k比这个大就k-&#x3D;cnt，如果不大就i*10开始依次计算。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count</span><span class="hljs-params">(n ,cur <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    l,r := cur,cur    cnt := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> l &lt;= n&#123;        cnt += min(n, r)-l+<span class="hljs-number">1</span>        l *= <span class="hljs-number">10</span>        r = r*<span class="hljs-number">10</span> +<span class="hljs-number">9</span>    &#125;    <span class="hljs-keyword">return</span> cnt&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findKthNumber</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    i :=<span class="hljs-number">1</span>    k--    <span class="hljs-keyword">for</span> k&gt;<span class="hljs-number">0</span>&#123;        cnt := count(n, i)                <span class="hljs-keyword">if</span> cnt &lt;=k&#123;            i++            k -= cnt        &#125;<span class="hljs-keyword">else</span>&#123;            i *= <span class="hljs-number">10</span>            k--        &#125;    &#125;    <span class="hljs-keyword">return</span> i&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了46.43%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>442. 数组中重复的数据</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/442.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/442.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="数组中重复的数据"><a href="#数组中重复的数据" class="headerlink" title="数组中重复的数据"></a><font size=6px>数组中重复的数据</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。</p><p>你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,3,2,7,8,2,3,1]<br>输出：[2,3]<br>示例 2：</p><p>输入：nums &#x3D; [1,1,2]<br>输出：[1]<br>示例 3：</p><p>输入：nums &#x3D; [1]<br>输出：[]</p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; n<br>nums 中的每个元素出现 一次 或 两次</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>数字出现的范围是1到n是关键信息</p><p>我们也可以给 \textit{nums}[i]nums[i] 加上「负号」表示数 i+1i+1 已经出现过一次。具体地，我们首先对数组进行一次遍历。当遍历到位置 ii 时，我们考虑 \textit{nums}[\textit{nums}[i] - 1]nums[nums[i]−1] 的正负性：</p><p>如果 \textit{nums}[\textit{nums}[i] - 1]nums[nums[i]−1] 是正数，说明 \textit{nums}[i]nums[i] 还没有出现过，我们将 \textit{nums}[\textit{nums}[i] - 1]nums[nums[i]−1] 加上负号；</p><p>如果 \textit{nums}[\textit{nums}[i] - 1]nums[nums[i]−1] 是负数，说明 \textit{nums}[i]nums[i] 已经出现过一次，我们将 \textit{nums}[i]nums[i] 放入答案。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDuplicates</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> nums&#123;        <span class="hljs-keyword">if</span> v &lt;<span class="hljs-number">0</span>&#123;            v = -v        &#125;        <span class="hljs-keyword">if</span> nums[v<span class="hljs-number">-1</span>]&lt;<span class="hljs-number">0</span>&#123;            res = <span class="hljs-built_in">append</span>(res, v)        &#125;<span class="hljs-keyword">else</span>&#123;            nums[v<span class="hljs-number">-1</span>] = -nums[v<span class="hljs-number">-1</span>]        &#125;            &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：40 ms, 在所有 Go 提交中击败了87.72%的用户<br>   内存消耗：7.5 MB, 在所有 Go 提交中击败了63.16%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>448. 找到所有数组中消失的数字</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a><font size=6px>找到所有数组中消失的数字</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,3,2,7,8,2,3,1]<br>输出：[5,6]<br>示例 2：</p><p>输入：nums &#x3D; [1,1]<br>输出：[2]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">for</span> _,i := <span class="hljs-keyword">range</span> nums&#123;        nums[(i<span class="hljs-number">-1</span>) % n] += n    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> k,i := <span class="hljs-keyword">range</span> nums&#123;        <span class="hljs-keyword">if</span> i &lt;= n&#123;            res = <span class="hljs-built_in">append</span>(res, k+<span class="hljs-number">1</span>)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：7.8 MB, 在所有 Go 提交中击败了34.89%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>45. 跳跃游戏 2</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/45.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/45.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><font size=6px>跳跃游戏</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p>示例 1:</p><p>输入: nums &#x3D; [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>示例 2:</p><p>输入: nums &#x3D; [2,3,0,1,4]<br>输出: 2</p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>维护一个最大能到达距离</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    length := <span class="hljs-built_in">len</span>(nums)    end := <span class="hljs-number">0</span>    maxPosition := <span class="hljs-number">0</span>    steps := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; i++ &#123;        maxPosition = max(maxPosition, i + nums[i])        <span class="hljs-keyword">if</span> i == end &#123;            end = maxPosition            steps++        &#125;    &#125;    <span class="hljs-keyword">return</span> steps&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> x &gt; y &#123;        <span class="hljs-keyword">return</span> x    &#125;    <span class="hljs-keyword">return</span> y&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了97.29%的用户<br>   内存消耗：5.8 MB, 在所有 Go 提交中击败了73.14%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>450. 删除二叉搜索树中的节点</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/450.%20%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/450.%20%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a><font size=6px>删除二叉搜索树中的节点</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点；<br>如果找到了，删除它。</p><p>示例 1:</p><p>输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。</p><p>示例 2:</p><p>输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0<br>输出: [5,3,6,2,4,null,7]<br>解释: 二叉树不包含值为 0 的节点<br>示例 3:</p><p>输入: root &#x3D; [], key &#x3D; 0<br>输出: []</p><p>提示:</p><p>节点数的范围 [0, 104].<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>节点值唯一<br>root 是合法的二叉搜索树<br>-105 &lt;&#x3D; key &lt;&#x3D; 105</p><p>进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(logn),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用递归做，想清楚了难度不是特别大</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(root *TreeNode, key <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;    <span class="hljs-keyword">switch</span> &#123;    <span class="hljs-keyword">case</span> root == <span class="hljs-literal">nil</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    <span class="hljs-keyword">case</span> root.Val &gt; key:        root.Left = deleteNode(root.Left, key)    <span class="hljs-keyword">case</span> root.Val &lt; key:        root.Right = deleteNode(root.Right, key)    <span class="hljs-keyword">case</span> root.Left == <span class="hljs-literal">nil</span> || root.Right == <span class="hljs-literal">nil</span>:        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">return</span> root.Left        &#125;        <span class="hljs-keyword">return</span> root.Right    <span class="hljs-keyword">default</span>:        successor := root.Right        <span class="hljs-keyword">for</span> successor.Left != <span class="hljs-literal">nil</span> &#123;            successor = successor.Left        &#125;        successor.Right = deleteNode(root.Right, successor.Val)        successor.Left = root.Left        <span class="hljs-keyword">return</span> successor    &#125;    <span class="hljs-keyword">return</span> root&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了68.22%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了63.60%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>461. 汉明距离</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a><font size=6px>汉明距离</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p><p>示例 1：</p><p>输入：x &#x3D; 1, y &#x3D; 4<br>输出：2<br>解释：<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑<br>上面的箭头指出了对应二进制位不同的位置。<br>示例 2：</p><p>输入：x &#x3D; 3, y &#x3D; 1<br>输出：1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> x != <span class="hljs-number">0</span> &amp;&amp; y != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> x %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span> &amp;&amp; y %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;            count++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> &amp;&amp; y %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;            count++        &#125;        x /=<span class="hljs-number">2</span>        y/= <span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">for</span> x != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> x %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;            count++        &#125;        x/=<span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">for</span> y != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> y %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;            count++        &#125;        y/=<span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>468. 验证IP地址</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/468.%20%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/468.%20%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h3 id="验证IP地址"><a href="#验证IP地址" class="headerlink" title="验证IP地址"></a><font size=6px>验证IP地址</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 “IPv4” ；如果是有效的 IPv6 地址，返回 “IPv6” ；如果不是上述类型的 IP 地址，返回 “Neither” 。</p><p>有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 &lt;&#x3D; xi &lt;&#x3D; 255 且 xi 不能包含 前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “<a href="mailto:&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#56;&#x40;&#x31;&#x2e;&#x31;">&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#56;&#x40;&#x31;&#x2e;&#x31;</a>” 为无效IPv4地址。</p><p>一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中:</p><p>1 &lt;&#x3D; xi.length &lt;&#x3D; 4<br>xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( ‘a’ 到 ‘f’ )和大写英文字母( ‘A’ 到 ‘F’ )。<br>在 xi 中允许前导零。<br>例如 “2001:0db8:85a3:0000:0000:8a2e:0370:7334” 和 “2001:db8:85a3:0:0:8A2E:0370:7334” 是有效的 IPv6 地址，而 “2001:0db8:85a3::8A2E:037j:7334” 和 “02001:0db8:85a3:0000:0000:8a2e:0370:7334” 是无效的 IPv6 地址。</p><p>示例 1：</p><p>输入：queryIP &#x3D; “172.16.254.1”<br>输出：”IPv4”<br>解释：有效的 IPv4 地址，返回 “IPv4”<br>示例 2：</p><p>输入：queryIP &#x3D; “2001:0db8:85a3:0:0:8A2E:0370:7334”<br>输出：”IPv6”<br>解释：有效的 IPv6 地址，返回 “IPv6”<br>示例 3：</p><p>输入：queryIP &#x3D; “256.256.256.256”<br>输出：”Neither”<br>解释：既不是 IPv4 地址，又不是 IPv6 地址</p><p>提示：</p><p>queryIP 仅由英文字母，数字，字符 ‘.’ 和 ‘:’ 组成。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>边界情况检查题，ipv6配合正则可以很简洁的写出来。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validIPAddress</span><span class="hljs-params">(IP <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> validIPv4Address(IP) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IPv4&quot;</span>&#125;<span class="hljs-keyword">if</span> validIPv6Address(IP) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IPv6&quot;</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validIPv4Address</span><span class="hljs-params">(IP <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;strArr := strings.Split(IP, <span class="hljs-string">&quot;.&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(strArr) != <span class="hljs-number">4</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">for</span> _, str := <span class="hljs-keyword">range</span> strArr &#123;<span class="hljs-keyword">if</span> num, err := strconv.Atoi(str); err != <span class="hljs-literal">nil</span> || num &gt; <span class="hljs-number">255</span> || num &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> strconv.Itoa(num) != str &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validIPv6Address</span><span class="hljs-params">(IP <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span>&#123;    strArr := strings.Split(IP,<span class="hljs-string">&quot;:&quot;</span>)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(strArr) != <span class="hljs-number">8</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    re := regexp.MustCompile(  <span class="hljs-string">`^([0-9]|[a-f]|[A-F])+$`</span>)    <span class="hljs-keyword">for</span> _,str := <span class="hljs-keyword">range</span>(strArr)&#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(str)==<span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(str)&gt;<span class="hljs-number">4</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !re.MatchString(str)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.3 MB, 在所有 Go 提交中击败了10.31%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>473. 火柴拼正方形</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/473.%20%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/473.%20%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="火柴拼正方形"><a href="#火柴拼正方形" class="headerlink" title="火柴拼正方形"></a><font size=6px>火柴拼正方形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。</p><p>如果你能使这个正方形，则返回 true ，否则返回 false 。</p><p>示例 1:</p><p>输入: matchsticks &#x3D; [1,1,2,2,2]<br>输出: true<br>解释: 能拼成一个边长为2的正方形，每边两根火柴。<br>示例 2:</p><p>输入: matchsticks &#x3D; [3,3,3,3,4]<br>输出: false<br>解释: 不能用所有火柴拼成一个正方形。</p><p>提示:</p><p>1 &lt;&#x3D; matchsticks.length &lt;&#x3D; 15<br>1 &lt;&#x3D; matchsticks[i] &lt;&#x3D; 108</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(4^<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用dfs爆搜，用降序防止超时。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makesquare</span><span class="hljs-params">(matchsticks []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    totalLen := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> matchsticks&#123;        totalLen += v    &#125;    <span class="hljs-keyword">if</span> totalLen% <span class="hljs-number">4</span> != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    sort.Sort(sort.Reverse(sort.IntSlice(matchsticks))) <span class="hljs-comment">// 减少搜索量</span>        edges := [<span class="hljs-number">4</span>]<span class="hljs-type">int</span>&#123;&#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(idx <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;        <span class="hljs-keyword">if</span> idx == <span class="hljs-built_in">len</span>(matchsticks) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> edges &#123;            edges[i] += matchsticks[idx]            <span class="hljs-keyword">if</span> edges[i] &lt;= totalLen/<span class="hljs-number">4</span> &amp;&amp; dfs(idx+<span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>            &#125;            edges[i] -= matchsticks[idx]        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：36 ms, 在所有 Go 提交中击败了45.31%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了53.91%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>462. 最少移动次数使数组元素相等 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/462.%20%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/462.%20%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="最少移动次数使数组元素相等-II"><a href="#最少移动次数使数组元素相等-II" class="headerlink" title="最少移动次数使数组元素相等 II"></a><font size=6px>最少移动次数使数组元素相等 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最少移动数。</p><p>在一步操作中，你可以使数组中的一个元素加 1 或者减 1 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：2<br>解释：<br>只需要两步操作（每步操作指南使一个元素加 1 或减 1）：<br>[1,2,3]  &#x3D;&gt;  [2,2,3]  &#x3D;&gt;  [2,2,2]<br>示例 2：</p><p>输入：nums &#x3D; [1,10,2,9]<br>输出：16</p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(nlogn),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>[1,2,10] res &#x3D; (10 - 2) + (2 - 1) &#x3D; 10 - 1<br>[1,i,10] res &#x3D; (10 - i) + (i - 1) &#x3D; 10 - 1<br>当数组长度为偶数时，根据奇数的结论，只能转换为两个数的区间范围内任何一个数 i<br>[1,10] res &#x3D; (10 - i) + (i - 1) &#x3D; 10 - 1<br>总结可知： res &#x3D; right - left</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minMoves2</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    sort.Ints(nums)    l,r := <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    res := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> l&lt;r&#123;        res += nums[r]-nums[l]        l++        r--    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了86.67%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>479. 最大回文数乘积</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/479.%20%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E6%95%B0%E4%B9%98%E7%A7%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/479.%20%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E6%95%B0%E4%B9%98%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="最大回文数乘积"><a href="#最大回文数乘积" class="headerlink" title="最大回文数乘积"></a><font size=6px>最大回文数乘积</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数 n ，返回 可表示为两个 n 位整数乘积的 最大回文整数 。因为答案可能非常大，所以返回它对 1337 取余 。</p><p>示例 1:</p><p>输入：n &#x3D; 2<br>输出：987<br>解释：99 x 91 &#x3D; 9009, 9009 % 1337 &#x3D; 987<br>示例 2:</p><p>输入： n &#x3D; 1<br>输出： 9</p><p>提示:</p><p>1 &lt;&#x3D; n &lt;&#x3D; 8<br>通过次数11,300提交次数19,314</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>有技巧的暴力，回文数只需要知道半边就行，从大到小然后判断这个回文数是否能够被整除，如果整除就说明是答案。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestPalindrome</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>    &#125;    upper := <span class="hljs-type">int</span>(math.Pow10(n)) - <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> left := upper; ; left-- &#123; <span class="hljs-comment">// 枚举回文数的左半部分</span>        p := left        <span class="hljs-keyword">for</span> x := left; x &gt; <span class="hljs-number">0</span>; x /= <span class="hljs-number">10</span> &#123;            p = p*<span class="hljs-number">10</span> + x%<span class="hljs-number">10</span> <span class="hljs-comment">// 翻转左半部分到其自身末尾，构造回文数 p</span>        &#125;        <span class="hljs-keyword">for</span> x := upper; x*x &gt;= p; x-- &#123;            <span class="hljs-keyword">if</span> p%x == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// x 是 p 的因子</span>                <span class="hljs-keyword">return</span> p % <span class="hljs-number">1337</span>            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：84 ms, 在所有 Go 提交中击败了90.91%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了63.64%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>49. Group Anagrams</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/49.%20Group%20Anagrams/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/49.%20Group%20Anagrams/</url>
    
    <content type="html"><![CDATA[<h3 id="Group-Anagrams"><a href="#Group-Anagrams" class="headerlink" title="Group Anagrams"></a><font size=6px>Group Anagrams</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.</p><p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p>Example 1:</p><p>Input: strs &#x3D; [“eat”,”tea”,”tan”,”ate”,”nat”,”bat”]<br>Output: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>Example 2:</p><p>Input: strs &#x3D; [“”]<br>Output: [[“”]]<br>Example 3:</p><p>Input: strs &#x3D; [“a”]<br>Output: [[“a”]]</p><p>Constraints:</p><p>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] consists of lowercase English letters.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用哈希表，之后把哈希表连接成数字</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">string</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(strs) &lt;= <span class="hljs-number">1</span>&#123;        res = <span class="hljs-built_in">append</span>(res, strs)        <span class="hljs-keyword">return</span> res    &#125;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int64</span>][]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">var</span> num <span class="hljs-type">int64</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> strs&#123;        freq := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int64</span>, <span class="hljs-number">27</span>)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(v);i++&#123;            freq[v[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++        &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++&#123;            num = num*<span class="hljs-number">10</span> +freq[i]        &#125;        mp[num] = <span class="hljs-built_in">append</span>(mp[num], v)        num = <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> mp&#123;        res = <span class="hljs-built_in">append</span>(res, v)    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了99.78%的用户<br>   内存消耗：7 MB, 在所有 Go 提交中击败了98.23%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>494. Target Sum</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/494.%20Target%20Sum/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/494.%20Target%20Sum/</url>
    
    <content type="html"><![CDATA[<h3 id="Target-Sum"><a href="#Target-Sum" class="headerlink" title="Target Sum"></a><font size=6px>Target Sum</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given an integer array nums and an integer target.</p><p>You want to build an expression out of nums by adding one of the symbols ‘+’ and ‘-‘ before each integer in nums and then concatenate all the integers.</p><p>For example, if nums &#x3D; [2, 1], you can add a ‘+’ before 2 and a ‘-‘ before 1 and concatenate them to build the expression “+2-1”.<br>Return the number of different expressions that you can build, which evaluates to target.</p><p>Example 1:</p><p>Input: nums &#x3D; [1,1,1,1,1], target &#x3D; 3<br>Output: 5<br>Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.<br>-1 + 1 + 1 + 1 + 1 &#x3D; 3<br>+1 - 1 + 1 + 1 + 1 &#x3D; 3<br>+1 + 1 - 1 + 1 + 1 &#x3D; 3<br>+1 + 1 + 1 - 1 + 1 &#x3D; 3<br>+1 + 1 + 1 + 1 - 1 &#x3D; 3<br>Example 2:</p><p>Input: nums &#x3D; [1], target &#x3D; 1<br>Output: 1</p><p>Constraints:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 20<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>0 &lt;&#x3D; sum(nums[i]) &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; target &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>我用dfs做，做起来简单，但是效率低，用动态规划做会比较好</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sum, index <span class="hljs-type">int</span>)</span></span>     count := <span class="hljs-number">0</span>    n := <span class="hljs-built_in">len</span>(nums)    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sum, index <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> sum == target &amp;&amp; index == n&#123;            count++            <span class="hljs-keyword">return</span>         &#125;        <span class="hljs-keyword">if</span> index &gt;= n &#123;            <span class="hljs-keyword">return</span>         &#125;        dfs(sum+nums[index],index+<span class="hljs-number">1</span>)        dfs(sum+<span class="hljs-number">-1</span>*nums[index],index+<span class="hljs-number">1</span>)    &#125;    dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：644 ms, 在所有 Go 提交中击败了23.74%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了98.67%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>498. 对角线遍历</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/498.%20%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/498.%20%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="对角线遍历"><a href="#对角线遍历" class="headerlink" title="对角线遍历"></a><font size=6px>对角线遍历</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p><p>示例 1：</p><p>输入：mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,4,7,5,3,6,8,9]<br>示例 2：</p><p>输入：mat &#x3D; [[1,2],[3,4]]<br>输出：[1,2,3,4]</p><p>提示：</p><p>m &#x3D;&#x3D; mat.length<br>n &#x3D;&#x3D; mat[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 104<br>1 &lt;&#x3D; m * n &lt;&#x3D; 104<br>-105 &lt;&#x3D; mat[i][j] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><p>模拟法做，模拟对角线遍历</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDiagonalOrder</span><span class="hljs-params">(mat [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(mat),<span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])    k := <span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> res,tmp []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;=i &amp;&amp; j&lt;m;j++&#123;            <span class="hljs-keyword">if</span> i-j &gt;=<span class="hljs-number">0</span> &#123;                tmp = <span class="hljs-built_in">append</span>(tmp, mat[j][i-j])            &#125;                    &#125;                <span class="hljs-keyword">if</span> k %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;            tmp = reverse(tmp)        &#125;        res = <span class="hljs-built_in">append</span>(res,tmp...)        k++        tmp = []<span class="hljs-type">int</span>&#123;&#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;=m-i<span class="hljs-number">-1</span>  ;j++&#123;            <span class="hljs-keyword">if</span> n-j<span class="hljs-number">-1</span> &gt;=<span class="hljs-number">0</span>&#123;                tmp = <span class="hljs-built_in">append</span>(tmp, mat[i+j][n-j<span class="hljs-number">-1</span>])            &#125;                    &#125;        <span class="hljs-keyword">if</span> k %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;            tmp = reverse(tmp)        &#125;        k++        res = <span class="hljs-built_in">append</span>(res,tmp...)        tmp = []<span class="hljs-type">int</span>&#123;&#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span>[]<span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(a)/<span class="hljs-number">2</span>;i++&#123;        a[i],a[<span class="hljs-built_in">len</span>(a)-i<span class="hljs-number">-1</span>] = a[<span class="hljs-built_in">len</span>(a)-i<span class="hljs-number">-1</span>], a[i]    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：80 ms, 在所有 Go 提交中击败了13.79%的用户<br>   内存消耗：6.6 MB, 在所有 Go 提交中击败了90.18%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 最长回文子串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><font size=6px>最长回文子串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：</p><p>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p><p>输入：s &#x3D; “cbbd”<br>输出：”bb”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅由数字和英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    n := <span class="hljs-built_in">len</span>(s)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span> ;i&lt;=n;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n+<span class="hljs-number">1</span>)        dp[i][i] = <span class="hljs-literal">true</span>    &#125;    res := <span class="hljs-type">string</span>(s[<span class="hljs-number">0</span>])    <span class="hljs-keyword">for</span> L:=<span class="hljs-number">2</span>; L&lt;=n;L++&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;n; i++&#123;            j := L + i <span class="hljs-number">-1</span>            <span class="hljs-keyword">if</span> j&gt;=n&#123;                <span class="hljs-keyword">continue</span>             &#125;            <span class="hljs-keyword">if</span> s[i] == s[j]&#123;                <span class="hljs-keyword">if</span> j<span class="hljs-number">-1</span> == i&#123;                    dp[i][j] = <span class="hljs-literal">true</span>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>  dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] == <span class="hljs-literal">true</span>&#123;                    dp[i][j] = <span class="hljs-literal">true</span>                &#125;            &#125;            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-literal">true</span>&#123;                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) &lt; j-i+<span class="hljs-number">1</span>&#123;                    res = s[i:j+<span class="hljs-number">1</span>]                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：88 ms, 在所有 Go 提交中击败了37.51%的用户<br>   内存消耗：6.7 MB, 在所有 Go 提交中击败了43.11%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>50. Pow(x, n)</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/50.%20Pow(x,%20n)/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/50.%20Pow(x,%20n)/</url>
    
    <content type="html"><![CDATA[<h3 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a><font size=6px>Pow(x, n)</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。</p><p>示例 1：</p><p>输入：x &#x3D; 2.00000, n &#x3D; 10<br>输出：1024.00000<br>示例 2：</p><p>输入：x &#x3D; 2.10000, n &#x3D; 3<br>输出：9.26100<br>示例 3：</p><p>输入：x &#x3D; 2.00000, n &#x3D; -2<br>输出：0.25000<br>解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</p><p>提示：</p><p>-100.0 &lt; x &lt; 100.0<br>-231 &lt;&#x3D; n &lt;&#x3D; 231-1<br>-104 &lt;&#x3D; xn &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">logn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">logn</span>)</span></code></pre><p>用二分思想做pow</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myPow</span><span class="hljs-params">(x <span class="hljs-type">float64</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;    <span class="hljs-keyword">if</span> n&gt;=<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> quickMul(x,n)    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / quickMul(x,-n)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickMul</span><span class="hljs-params">(x <span class="hljs-type">float64</span>,n <span class="hljs-type">int</span>)</span></span><span class="hljs-type">float64</span>&#123;    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;    y := quickMul(x,n/<span class="hljs-number">2</span>)    <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> y*y*x    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> y*y    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了99.91%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>513. 找树左下角的值</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/513.%20%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/513.%20%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a><font size=6px>找树左下角的值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p>示例 1:</p><p>输入: root &#x3D; [2,1,3]<br>输出: 1<br>示例 2:</p><p>输入: [1,2,3,4,null,5,6,null,null,7]<br>输出: 7</p><p>提示:</p><p>二叉树的节点个数的范围是 [1,104]<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>深搜</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> (curVal <span class="hljs-type">int</span>) &#123;    curHeight := <span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode, <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, height <span class="hljs-type">int</span>)</span></span> &#123;        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">return</span>        &#125;        height++        dfs(node.Left, height)        dfs(node.Right, height)        <span class="hljs-keyword">if</span> height &gt; curHeight &#123;            curHeight = height            curVal = node.Val        &#125;    &#125;    dfs(root, <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了89.17%的用户<br>   内存消耗：5.1 MB, 在所有 Go 提交中击败了63.48%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>504. 七进制数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/504.%20%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/504.%20%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="七进制数"><a href="#七进制数" class="headerlink" title="七进制数"></a><font size=6px>七进制数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。</p><p>示例 1:</p><p>输入: num &#x3D; 100<br>输出: “202”<br>示例 2:</p><p>输入: num &#x3D; -7<br>输出: “-10”</p><p>提示：</p><p>-107 &lt;&#x3D; num &lt;&#x3D; 107</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertToBase7</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> flag <span class="hljs-type">bool</span>    <span class="hljs-keyword">if</span> num &lt;<span class="hljs-number">0</span>&#123;        flag = <span class="hljs-literal">true</span>        num = -num    &#125;    <span class="hljs-keyword">if</span> num==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>    &#125;    <span class="hljs-keyword">for</span> num !=<span class="hljs-number">0</span>&#123;        res = strconv.Itoa(num%<span class="hljs-number">7</span>)+res        num /=<span class="hljs-number">7</span>    &#125;    <span class="hljs-keyword">if</span> flag&#123;        res = <span class="hljs-string">&quot;-&quot;</span>+res    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>508. 出现次数最多的子树元素和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/508.%20%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/508.%20%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="出现次数最多的子树元素和"><a href="#出现次数最多的子树元素和" class="headerlink" title="出现次数最多的子树元素和"></a><font size=6px>出现次数最多的子树元素和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二叉树的根结点 root ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p><p>一个结点的 「子树元素和」 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p><p>示例 1：</p><p>输入: root &#x3D; [5,2,-3]<br>输出: [2,-3,4]<br>示例 2：</p><p>输入: root &#x3D; [5,2,-5]<br>输出: [2]</p><p>提示:</p><p>节点数在 [1, 104] 范围内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>后续遍历求出每个父节点的值，加入map中，看最大值是哪些。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findFrequentTreeSum</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> tail <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    tail = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>        &#125;        tail(root.Left)        tail(root.Right)        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span>&#123;            root.Val += root.Left.Val        &#125;        <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span>&#123;            root.Val += root.Right.Val        &#125;        mp[root.Val]++    &#125;    tail(root)    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> mp&#123;        <span class="hljs-keyword">if</span> v &gt; max&#123;            max = v            res = []<span class="hljs-type">int</span>&#123;&#125;            res = <span class="hljs-built_in">append</span>(res, k)        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v == max&#123;            res = <span class="hljs-built_in">append</span>(res, k)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.23%的用户<br>   内存消耗：6.6 MB, 在所有 Go 提交中击败了21.15%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>394. 字符串解码</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a><font size=6px>字符串解码</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>示例 1：</p><p>输入：s &#x3D; “3[a]2[bc]”<br>输出：”aaabcbc”<br>示例 2：</p><p>输入：s &#x3D; “3[a2[c]]”<br>输出：”accaccacc”<br>示例 3：</p><p>输入：s &#x3D; “2[abc]3[cd]ef”<br>输出：”abcabccdcdcdef”<br>示例 4：</p><p>输入：s &#x3D; “abc3[cd]xyz”<br>输出：”abccdcdcdxyz”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 30<br>s 由小写英文字母、数字和方括号 ‘[]’ 组成<br>s 保证是一个 有效 的输入。<br>s 中所有整数的取值范围为 [1, 300]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用递归思路做，碰到【就进行递归，碰到】就退出递归</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    i = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> run(s)&#125;<span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    res := <span class="hljs-string">&quot;&quot;</span>    num := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;        <span class="hljs-keyword">if</span> s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;            num = num*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> &#123;            res += <span class="hljs-type">string</span>(s[i])        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;[&#x27;</span> &#123;            i++            tmp := run(s)            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; num; j++ &#123;                res += tmp            &#125;            num = <span class="hljs-number">0</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了35.95%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>518. 零钱兑换 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/518.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/518.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a><font size=6px>零钱兑换 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p>示例 1：</p><p>输入：amount &#x3D; 5, coins &#x3D; [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5&#x3D;5<br>5&#x3D;2+2+1<br>5&#x3D;2+1+1+1<br>5&#x3D;1+1+1+1+1<br>示例 2：</p><p>输入：amount &#x3D; 3, coins &#x3D; [2]<br>输出：0<br>解释：只用面额 2 的硬币不能凑成总金额 3 。<br>示例 3：</p><p>输入：amount &#x3D; 10, coins &#x3D; [10]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; coins.length &lt;&#x3D; 300<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 5000<br>coins 中的所有值 互不相同<br>0 &lt;&#x3D; amount &lt;&#x3D; 5000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>dp做法，累加d p[j-conin[i]]就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(amount <span class="hljs-type">int</span>, coins []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(coins)    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,amount+<span class="hljs-number">1</span>)    <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">for</span> j:=coins[i];j&lt;=amount;j++&#123;            dp[j] += dp[j- coins[i]]        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> dp[amount]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了31.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>516. 最长回文子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/516.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/516.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a><font size=6px>最长回文子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p>示例 1：</p><p>输入：s &#x3D; “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。<br>示例 2：</p><p>输入：s &#x3D; “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” 。</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><p>动态规划做，[i,j]是从i到j位的最大回文数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(s)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)        dp[i][i] = <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> L :=<span class="hljs-number">2</span>;L&lt;=n;L++&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;            j := i+L <span class="hljs-number">-1</span>            <span class="hljs-keyword">if</span> j&gt;=n&#123;                <span class="hljs-keyword">continue</span>            &#125;            <span class="hljs-keyword">if</span> s[i] == s[j]&#123;                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>            &#125;<span class="hljs-keyword">else</span>&#123;                dp[i][j] = max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>])            &#125;        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：28 ms, 在所有 Go 提交中击败了58.88%的用户<br>   内存消耗：17 MB, 在所有 Go 提交中击败了75.61%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>521. 最长特殊序列 Ⅰ</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/521.%20%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97%20%E2%85%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/521.%20%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97%20%E2%85%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="最长特殊序列-Ⅰ"><a href="#最长特殊序列-Ⅰ" class="headerlink" title="最长特殊序列 Ⅰ"></a><font size=6px>最长特殊序列 Ⅰ</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你两个字符串 a 和 b，请返回 这两个字符串中 最长的特殊序列  的长度。如果不存在，则返回 -1 。</p><p>「最长特殊序列」 定义如下：该序列为 某字符串独有的最长子序列（即不能是其他字符串的子序列） 。</p><p>字符串 s 的子序列是在从 s 中删除任意数量的字符后可以获得的字符串。</p><p>例如，”abc” 是 “aebdc” 的子序列，因为删除 “aebdc” 中斜体加粗的字符可以得到 “abc” 。 “aebdc” 的子序列还包括 “aebdc” 、 “aeb” 和 “” (空字符串)。</p><p>示例 1：</p><p>输入: a &#x3D; “aba”, b &#x3D; “cdc”<br>输出: 3<br>解释: 最长特殊序列可为 “aba” (或 “cdc”)，两者均为自身的子序列且不是对方的子序列。<br>示例 2：</p><p>输入：a &#x3D; “aaa”, b &#x3D; “bbb”<br>输出：3<br>解释: 最长特殊序列是 “aaa” 和 “bbb” 。<br>示例 3：</p><p>输入：a &#x3D; “aaa”, b &#x3D; “aaa”<br>输出：-1<br>解释: 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。</p><p>提示：</p><p>1 &lt;&#x3D; a.length, b.length &lt;&#x3D; 100<br>a 和 b 由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>题目难度都在读懂题目上面了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLUSlength</span><span class="hljs-params">(a <span class="hljs-type">string</span>, b <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a!=b&#123;        <span class="hljs-keyword">return</span> max(<span class="hljs-built_in">len</span>(a),<span class="hljs-built_in">len</span>(b))    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了18.87%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>515. 在每个树行中找最大值</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/515.%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/515.%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a><font size=6px>在每个树行中找最大值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><p>示例1：</p><p>输入: root &#x3D; [1,3,2,5,3,null,9]<br>输出: [1,3,9]<br>示例2：</p><p>输入: root &#x3D; [1,2,3]<br>输出: [1,3]</p><p>提示：</p><p>二叉树的节点个数的范围是 [0,104]<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">logn</span> <span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>层次遍历然后排序</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestValues</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> temp,num []*TreeNode    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;    &#125;    temp = <span class="hljs-built_in">append</span>(temp, root)     <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(temp) &gt; <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> temp&#123;            <span class="hljs-keyword">if</span> v.Left != <span class="hljs-literal">nil</span>&#123;                num = <span class="hljs-built_in">append</span>(num, v.Left)            &#125;            <span class="hljs-keyword">if</span> v.Right != <span class="hljs-literal">nil</span>&#123;                num = <span class="hljs-built_in">append</span>(num, v.Right)            &#125;        &#125;        sort.Slice(temp, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;            <span class="hljs-keyword">return</span> temp[i].Val &gt;temp[j].Val        &#125;)        res = <span class="hljs-built_in">append</span>(res, temp[<span class="hljs-number">0</span>].Val)        temp = num        num = []*TreeNode&#123;&#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.21%的用户<br>   内存消耗：5.5 MB, 在所有 Go 提交中击败了70.60%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>522. 最长特殊序列 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/522.%20%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/522.%20%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="最长特殊序列-II"><a href="#最长特殊序列-II" class="headerlink" title="最长特殊序列 II"></a><font size=6px>最长特殊序列 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定字符串列表 strs ，返回其中 最长的特殊序列 。如果最长特殊序列不存在，返回 -1 。</p><p>特殊序列 定义如下：该序列为某字符串 独有的子序列（即不能是其他字符串的子序列）。</p><p> s 的 子序列可以通过删去字符串 s 中的某些字符实现。</p><p>例如，”abc” 是 “aebdc” 的子序列，因为您可以删除”aebdc”中的下划线字符来得到 “abc” 。”aebdc”的子序列还包括”aebdc”、 “aeb” 和 “” (空字符串)。</p><p>示例 1：</p><p>输入: strs &#x3D; [“aba”,”cdc”,”eae”]<br>输出: 3<br>示例 2:</p><p>输入: strs &#x3D; [“aaa”,”aaa”,”aa”]<br>输出: -1</p><p>提示:</p><p>2 &lt;&#x3D; strs.length &lt;&#x3D; 50<br>1 &lt;&#x3D; strs[i].length &lt;&#x3D; 10<br>strs[i] 只包含小写英文字母</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2<span class="hljs-operator">*</span><span class="hljs-params">l</span>)</span>,空间复杂度<span class="hljs-constructor">O(1)</span></code></pre><p>双层循环判断是否有相同的子序列。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSubseq</span><span class="hljs-params">(s, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    ptS := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> ptT := <span class="hljs-keyword">range</span> t &#123;        <span class="hljs-keyword">if</span> s[ptS] == t[ptT] &#123;            <span class="hljs-keyword">if</span> ptS++; ptS == <span class="hljs-built_in">len</span>(s) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLUSlength</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    ans := <span class="hljs-number">-1</span>next:    <span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> strs &#123;        <span class="hljs-keyword">for</span> j, t := <span class="hljs-keyword">range</span> strs &#123;            <span class="hljs-keyword">if</span> i != j &amp;&amp; isSubseq(s, t) &#123;                <span class="hljs-keyword">continue</span> next            &#125;        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &gt; ans &#123;            ans = <span class="hljs-built_in">len</span>(s)        &#125;    &#125;    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了70.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>537. 复数乘法</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/537.%20%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/537.%20%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="复数乘法"><a href="#复数乘法" class="headerlink" title="复数乘法"></a><font size=6px>复数乘法</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>复数 可以用字符串表示，遵循 “实部+虚部i” 的形式，并满足下述条件：</p><p>实部 是一个整数，取值范围是 [-100, 100]<br>虚部 也是一个整数，取值范围是 [-100, 100]<br>i2 &#x3D;&#x3D; -1<br>给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。</p><p>示例 1：</p><p>输入：num1 &#x3D; “1+1i”, num2 &#x3D; “1+1i”<br>输出：”0+2i”<br>解释：(1 + i) * (1 + i) &#x3D; 1 + i2 + 2 * i &#x3D; 2i ，你需要将它转换为 0+2i 的形式。<br>示例 2：</p><p>输入：num1 &#x3D; “1+-1i”, num2 &#x3D; “1+-1i”<br>输出：”0+-2i”<br>解释：(1 - i) * (1 - i) &#x3D; 1 + i2 - 2 * i &#x3D; -2i ，你需要将它转换为 0+-2i 的形式。 </p><p>提示：</p><p>num1 和 num2 都是有效的复数表示。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>简单题，模拟就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">complexNumberMultiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">string</span>    num1s := strings.Split(num1,<span class="hljs-string">&quot;+&quot;</span>)    num2s := strings.Split(num2,<span class="hljs-string">&quot;+&quot;</span>)    num1s_1,_ := strconv.Atoi(num1s[<span class="hljs-number">0</span>])    num2s_1,_ := strconv.Atoi(num2s[<span class="hljs-number">0</span>])    num1s_2,_ := strconv.Atoi(num1s[<span class="hljs-number">1</span>][:<span class="hljs-built_in">len</span>(num1s[<span class="hljs-number">1</span>])<span class="hljs-number">-1</span>])     num2s_2,_ := strconv.Atoi(num2s[<span class="hljs-number">1</span>][:<span class="hljs-built_in">len</span>(num2s[<span class="hljs-number">1</span>])<span class="hljs-number">-1</span>])     a := strconv.Itoa(num1s_1*num2s_1-num1s_2*num2s_2)    b := strconv.Itoa(num1s_1*num2s_2+num1s_2*num2s_1)    res =  a+ <span class="hljs-string">&quot;+&quot;</span>+b+<span class="hljs-string">&quot;i&quot;</span>    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了94.74%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>538. Convert BST to Greater Tree</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/538.%20Convert%20BST%20to%20Greater%20Tree/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/538.%20Convert%20BST%20to%20Greater%20Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="Convert-BST-to-Greater-Tree"><a href="#Convert-BST-to-Greater-Tree" class="headerlink" title="Convert BST to Greater Tree"></a><font size=6px>Convert BST to Greater Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p><p>As a reminder, a binary search tree is a tree that satisfies these constraints:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p><p>Example 1:</p><p>Input: root &#x3D; [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]<br>Example 2:</p><p>Input: root &#x3D; [0,null,1]<br>Output: [1,null,1]</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [0, 104].<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>All the values in the tree are unique.<br>root is guaranteed to be a valid binary search tree.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>dfs 搜索，右中左序列就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertBST</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    <span class="hljs-keyword">var</span> maxNum <span class="hljs-type">int</span>     dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        dfs(root.Right)        root.Val += maxNum        maxNum = root.Val        dfs(root.Left)            &#125;dfs(root)<span class="hljs-keyword">return</span> root&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了79.69%的用户<br>   内存消耗：6.6 MB, 在所有 Go 提交中击败了96.11%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>54. 螺旋矩阵</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/54.%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/54.%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a><font size=6px>螺旋矩阵</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><p>示例 1：</p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p><p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p>提示：</p><p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(matrix) != <span class="hljs-number">0</span>&#123;        res = <span class="hljs-built_in">append</span>(res,matrix[<span class="hljs-number">0</span>]...)        matrix = matrix[<span class="hljs-number">1</span>:]        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">break</span>        &#125;        m,n := <span class="hljs-built_in">len</span>(matrix),<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])        tmp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;                <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;                    tmp[j] = <span class="hljs-built_in">append</span>(tmp[j],matrix[i][n-j<span class="hljs-number">-1</span>])                &#125;            &#125;            matrix = tmp                <span class="hljs-comment">//fmt.Println(matrix)</span>    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了32.33%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>540. Single Element in a Sorted Array</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/540.%20Single%20Element%20in%20a%20Sorted%20Array/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/540.%20Single%20Element%20in%20a%20Sorted%20Array/</url>
    
    <content type="html"><![CDATA[<h3 id="Single-Element-in-a-Sorted-Array"><a href="#Single-Element-in-a-Sorted-Array" class="headerlink" title="Single Element in a Sorted Array"></a><font size=6px>Single Element in a Sorted Array</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</p><p>Return the single element that appears only once.</p><p>Your solution must run in O(log n) time and O(1) space.</p><p>Example 1:</p><p>Input: nums &#x3D; [1,1,2,3,3,4,4,8,8]<br>Output: 2<br>Example 2:</p><p>Input: nums &#x3D; [3,3,7,7,10,11,11]<br>Output: 10</p><p>Constraints:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用二分搜索做，看第二个相同数字的下标是奇数还是偶数就可以判断</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]    &#125;    l,r := <span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> l&lt;=r&#123;        mid := (l+r)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> mid&lt;n<span class="hljs-number">-1</span>&#123;            <span class="hljs-keyword">if</span> nums[mid] == nums[mid+<span class="hljs-number">1</span>]&#123;                mid++            &#125;        &#125;        <span class="hljs-keyword">if</span> mid % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;            r = mid<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid+<span class="hljs-number">1</span>        &#125;    &#125;        <span class="hljs-keyword">return</span> nums[l]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了73.93%的用户<br>   内存消耗：7.8 MB, 在所有 Go 提交中击败了86.32%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>543. 二叉树的直径</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/543.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/543.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a><font size=6px>二叉树的直径</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>Dfs 递归判断，每一次都需要判断最大直径是否比已经找寻的最大直径大</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><span class="hljs-type">int</span>    ans := <span class="hljs-number">0</span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><span class="hljs-type">int</span>&#123;        <span class="hljs-keyword">if</span>  root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;        L := dfs(root.Left)        R :=dfs(root.Right)        ans = max(ans, L+R)        <span class="hljs-keyword">return</span> max(L,R) +<span class="hljs-number">1</span>    &#125;    dfs(root)    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a &gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了91.28%的用户<br>   内存消耗：4.2 MB, 在所有 Go 提交中击败了92.36%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>535. TinyURL 的加密与解密</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/535.%20TinyURL%20%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/535.%20TinyURL%20%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="TinyURL-的加密与解密"><a href="#TinyURL-的加密与解密" class="headerlink" title="TinyURL 的加密与解密"></a><font size=6px>TinyURL 的加密与解密</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>TinyURL是一种URL简化服务， 比如：当你输入一个URL <a href="https://leetcode.com/problems/design-tinyurl">https://leetcode.com/problems/design-tinyurl</a> 时，它将返回一个简化的URL <a href="http://tinyurl.com/4e9iAk">http://tinyurl.com/4e9iAk</a>.</p><p>要求：设计一个 TinyURL 的加密 encode 和解密 decode 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。</p><p>通过次数17,869提交次数21,114</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用map，每次都给一个链接递增的数字就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">struct</span> &#123;    m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Codec &#123;    <span class="hljs-keyword">return</span> Codec&#123;m: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;&#125;&#125;<span class="hljs-comment">// Encodes a URL to a shortened URL.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> encode(longUrl <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;    code:=strconv.Itoa(<span class="hljs-built_in">len</span>(this.m)+<span class="hljs-number">1</span>)    this.m[code]=longUrl    <span class="hljs-keyword">return</span> code&#125;<span class="hljs-comment">// Decodes a shortened URL to its original URL.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> decode(shortUrl <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">return</span> this.m[shortUrl]&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your Codec object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor();</span><span class="hljs-comment"> * url := obj.encode(longUrl);</span><span class="hljs-comment"> * ans := obj.decode(url);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.3 MB, 在所有 Go 提交中击败了82.50%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>55. 跳跃游戏</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/55.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/55.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><font size=6px>跳跃游戏</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br>示例 2：</p><p>输入：nums &#x3D; [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从后往前遍历，能到的就为true</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    isarrive := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))    isarrive[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] = <span class="hljs-literal">true</span>    <span class="hljs-keyword">for</span> i:= <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span> ;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">for</span> j:=nums[i];j&gt;<span class="hljs-number">0</span>;j--&#123;            <span class="hljs-keyword">if</span> j+i&lt;<span class="hljs-built_in">len</span>(nums) &amp;&amp; isarrive[j+i] == <span class="hljs-literal">true</span>&#123;                isarrive[i] = <span class="hljs-literal">true</span>                <span class="hljs-keyword">break</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> isarrive[<span class="hljs-number">0</span>] == <span class="hljs-literal">true</span> &amp;&amp; isarrive[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]==<span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：760 ms, 在所有 Go 提交中击败了5.05%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p><h3 id="方法二，动态维护最大可到达区间"><a href="#方法二，动态维护最大可到达区间" class="headerlink" title="方法二，动态维护最大可到达区间"></a>方法二，动态维护最大可到达区间</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    maxJump := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums) &amp;&amp; i&lt;=maxJump;i++&#123;        maxJump = max(maxJump, nums[i]+i)    &#125;    <span class="hljs-keyword">return</span> maxJump&gt;= <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><p>执行用时：48 ms, 在所有 Go 提交中击败了87.34%的用户</p><p>内存消耗：6.7 MB, 在所有 Go 提交中击败了51.02%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>554. 砖墙</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/554.%20%E7%A0%96%E5%A2%99/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/554.%20%E7%A0%96%E5%A2%99/</url>
    
    <content type="html"><![CDATA[<h3 id="砖墙"><a href="#砖墙" class="headerlink" title="砖墙"></a><font size=6px>砖墙</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</p><p>你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</p><p>给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。</p><p>示例 1：</p><p>输入：wall &#x3D; [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]<br>输出：2<br>示例 2：</p><p>输入：wall &#x3D; [[1],[1],[1]]<br>输出：3</p><p>提示：</p><p>n &#x3D;&#x3D; wall.length<br>1 &lt;&#x3D; n &lt;&#x3D; 104<br>1 &lt;&#x3D; wall[i].length &lt;&#x3D; 104<br>1 &lt;&#x3D; sum(wall[i].length) &lt;&#x3D; 2 * 104<br>对于每一行 i ，sum(wall[i]) 是相同的<br>1 &lt;&#x3D; wall[i][j] &lt;&#x3D; 231 - 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>把间隙都放到map里面做，找到做多的间隙就是答案</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leastBricks</span><span class="hljs-params">(wall [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(wall)    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        sum :=<span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(wall[i])<span class="hljs-number">-1</span>; j++&#123;            sum += wall[i][j]            mp[sum]++        &#125;    &#125;    maxv := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> mp&#123;        <span class="hljs-keyword">if</span> maxv&lt;v&#123;            maxv = v        &#125;    &#125;    <span class="hljs-keyword">return</span> n-maxv&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：7.3 MB, 在所有 Go 提交中击败了40.82%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>556. 下一个更大元素 III</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/556.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20III/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/556.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20III/</url>
    
    <content type="html"><![CDATA[<h3 id="下一个更大元素-III"><a href="#下一个更大元素-III" class="headerlink" title="下一个更大元素 III"></a><font size=6px>下一个更大元素 III</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。</p><p>注意 ，返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样返回 -1 。</p><p>示例 1：</p><p>输入：n &#x3D; 12<br>输出：21<br>示例 2：</p><p>输入：n &#x3D; 21<br>输出：-1</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>从后往前找，找到第一个不符合降序的数字，然后这个数字和从后往前第一个大于他的数字交换，最后将最后一部分升序排列，挺复杂的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> n != <span class="hljs-number">0</span>&#123;        ans = <span class="hljs-built_in">append</span>(ans, n %<span class="hljs-number">10</span>)        n/= <span class="hljs-number">10</span>    &#125;    i,j := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span> (ans)<span class="hljs-number">-1</span>;i++&#123;        <span class="hljs-keyword">if</span> ans[i] &gt;ans[i+<span class="hljs-number">1</span>]&#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;    <span class="hljs-keyword">for</span> j =<span class="hljs-number">0</span>;j&lt;i+<span class="hljs-number">1</span>;j++&#123;        <span class="hljs-keyword">if</span> ans[j]&gt;ans[i+<span class="hljs-number">1</span>]&#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    ans[i+<span class="hljs-number">1</span>], ans[j] = ans[j], ans[i+<span class="hljs-number">1</span>]    res := <span class="hljs-number">0</span>    temp := ans[:i+<span class="hljs-number">1</span>]    ans = ans[i+<span class="hljs-number">1</span>:]    sort.Ints(temp)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(temp)/<span class="hljs-number">2</span>;i++&#123;        temp[i], temp[<span class="hljs-built_in">len</span>(temp)-i<span class="hljs-number">-1</span>] = temp[<span class="hljs-built_in">len</span>(temp)-i<span class="hljs-number">-1</span>],temp[i]    &#125;    ans = <span class="hljs-built_in">append</span>(temp, ans...)    <span class="hljs-keyword">for</span> i = <span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i-- &#123;        res = res*<span class="hljs-number">10</span> + ans[i]    &#125;    <span class="hljs-keyword">if</span> res &gt; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)<span class="hljs-number">-1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了57.61%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>553. 最优除法</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/553.%20%E6%9C%80%E4%BC%98%E9%99%A4%E6%B3%95/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/553.%20%E6%9C%80%E4%BC%98%E9%99%A4%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="最优除法"><a href="#最优除法" class="headerlink" title="最优除法"></a><font size=6px>最优除法</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -&gt; 2 &#x2F; 3 &#x2F; 4 。</p><p>但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。</p><p>示例：</p><p>输入: [1000,100,10,2]<br>输出: “1000&#x2F;(100&#x2F;10&#x2F;2)”<br>解释:<br>1000&#x2F;(100&#x2F;10&#x2F;2) &#x3D; 1000&#x2F;((100&#x2F;10)&#x2F;2) &#x3D; 200<br>但是，以下加粗的括号 “1000&#x2F;((100&#x2F;10)&#x2F;2)” 是冗余的，<br>因为他们并不影响操作的优先级，所以你需要返回 “1000&#x2F;(100&#x2F;10&#x2F;2)”。</p><p>其他用例:<br>1000&#x2F;(100&#x2F;10)&#x2F;2 &#x3D; 50<br>1000&#x2F;(100&#x2F;(10&#x2F;2)) &#x3D; 50<br>1000&#x2F;100&#x2F;10&#x2F;2 &#x3D; 0.5<br>1000&#x2F;100&#x2F;(10&#x2F;2) &#x3D; 2<br>说明:</p><p>输入数组的长度在 [1, 10] 之间。<br>数组中每个元素的大小都在 [2, 1000] 之间。<br>每个测试用例只有一个最优除法解。<br>通过次数6,961提交次数11,341</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一串 &gt;&#x3D;1的数字相除，怎么除才能得到最小的答案呢？</p><p>答案就是从头除到尾，因为这样会导致分子越来越小，从而答案越来越小。</p><p>如果你局部先除，那么会导致分母变小，从而导致答案变大。</p><p>所以这道题，最终的解法就是，第一个 &#x2F; (第二个&#x2F;第三个….第n个)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">optimalDivision</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;        <span class="hljs-keyword">return</span> strconv.Itoa(nums[<span class="hljs-number">0</span>])    &#125;    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d/%d&quot;</span>, nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])    &#125;    ans := &amp;strings.Builder&#123;&#125;    ans.WriteString(fmt.Sprintf(<span class="hljs-string">&quot;%d/(%d&quot;</span>, nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]))    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums[<span class="hljs-number">2</span>:] &#123;        ans.WriteByte(<span class="hljs-string">&#x27;/&#x27;</span>)        ans.WriteString(strconv.Itoa(num))    &#125;    ans.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)    <span class="hljs-keyword">return</span> ans.String()&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>565. 数组嵌套</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/565.%20%E6%95%B0%E7%BB%84%E5%B5%8C%E5%A5%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/565.%20%E6%95%B0%E7%BB%84%E5%B5%8C%E5%A5%97/</url>
    
    <content type="html"><![CDATA[<h3 id="数组嵌套"><a href="#数组嵌套" class="headerlink" title="数组嵌套"></a><font size=6px>数组嵌套</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] &#x3D; {A[i], A[A[i]], A[A[A[i]]], … }且遵守以下的规则。</p><p>假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]… 以此类推，不断添加直到S出现重复的元素。</p><p>示例 1:</p><p>输入: A &#x3D; [5,4,0,3,1,6,2]<br>输出: 4<br>解释:<br>A[0] &#x3D; 5, A[1] &#x3D; 4, A[2] &#x3D; 0, A[3] &#x3D; 3, A[4] &#x3D; 1, A[5] &#x3D; 6, A[6] &#x3D; 2.</p><p>其中一种最长的 S[K]:<br>S[0] &#x3D; {A[0], A[5], A[6], A[2]} &#x3D; {5, 6, 2, 0}</p><p>提示：</p><p>N是[1, 20,000]之间的整数。<br>A中不含有重复的元素。<br>A中的元素大小在[0, N-1]之间。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用dp来做，用递归dp</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">arrayNesting</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> dp <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,start,i <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>    dp = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,start,i <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;        <span class="hljs-keyword">if</span> nums[i] == start&#123;            arr[i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">if</span> arr[i] !=<span class="hljs-number">0</span> &#123;            <span class="hljs-keyword">return</span> arr[i]        &#125;<span class="hljs-keyword">else</span>&#123;            arr[i] = dp(arr,start,nums[i])+<span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> arr[i]        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        arr[i] = dp(arr,i,i)        <span class="hljs-keyword">if</span> res &lt; arr[i]&#123;            res = arr[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：124 ms, 在所有 Go 提交中击败了33.33%的用户<br>   内存消耗：15.9 MB, 在所有 Go 提交中击败了9.52%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>560. 和为 K 的子数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/560.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/560.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><font size=6px>和为 K 的子数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,1], k &#x3D; 2<br>输出：2<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3], k &#x3D; 3<br>输出：2</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>-107 &lt;&#x3D; k &lt;&#x3D; 107</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>Pre[i] &#x3D; pre[i-1] + nums[i]</p><p>可以转化成 pre[i] - k &#x3D; pre[j]，我们要求的就是j是多少，配合map可以以O（n）的复杂度解决</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>    m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    count, pre := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">len</span>(nums); i++&#123;        pre += nums[i]        <span class="hljs-keyword">if</span> _,ok := m[pre-k];ok&#123;            count += m[pre-k]        &#125;        m[pre] += <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：36 ms, 在所有 Go 提交中击败了96.01%的用户<br>   内存消耗：7.5 MB, 在所有 Go 提交中击败了45.67%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>581. 最短无序连续子数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a><font size=6px>最短无序连续子数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 最短 子数组，并输出它的长度。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,6,4,8,10,9,15]<br>输出：5<br>解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3,4]<br>输出：0<br>示例 3：</p><p>输入：nums &#x3D; [1]<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>排序一遍，找出不在有序位置第一个和最后一个位置，减一下就是答案</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    sortNum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    <span class="hljs-built_in">copy</span>(sortNum, nums)    sort.Ints(sortNum)    numFlag := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> nums[i] == sortNum[i]&#123;            numFlag[i] = <span class="hljs-literal">true</span>        &#125;    &#125;    l, r := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> numFlag[i] == <span class="hljs-literal">false</span>&#123;            l = i            <span class="hljs-keyword">break</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>;i&gt;= <span class="hljs-number">0</span> ;i--&#123;        <span class="hljs-keyword">if</span> numFlag[i] == <span class="hljs-literal">false</span>&#123;            r = i            <span class="hljs-keyword">break</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> r ==<span class="hljs-number">0</span>&amp;&amp; l==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">return</span> r-l+<span class="hljs-number">1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了84.01%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了37.67%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>589. N 叉树的前序遍历</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/589.%20N%20%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/589.%20N%20%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="N-叉树的前序遍历"><a href="#N-叉树的前序遍历" class="headerlink" title="N 叉树的前序遍历"></a><font size=6px>N 叉树的前序遍历</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 n 叉树的根节点  root ，返回 其节点值的 前序遍历 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：[1,3,5,6,2,4]<br>示例 2：</p><p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]</p><p>提示：</p><p>节点总数在范围 [0, 104]内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>n 叉树的高度小于或等于 1000</p><p>进阶：递归法很简单，你可以使用迭代法完成此题吗?</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>人生苦短，我用递归</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorder</span><span class="hljs-params">(root *Node)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> res    &#125;    res = <span class="hljs-built_in">append</span>(res, root.Val)    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(root.Children);i++&#123;        res = <span class="hljs-built_in">append</span>(res,preorder(root.Children[i])...)    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：6 MB, 在所有 Go 提交中击败了12.66%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>59. 螺旋矩阵 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/59.%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/59.%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a><font size=6px>螺旋矩阵 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：[[1,2,3],[8,9,4],[7,6,5]]<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：[[1]]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 20</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>模拟</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;<span class="hljs-keyword">var</span> dirs = []pair&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125; <span class="hljs-comment">// 右下左上</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateMatrix</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    matrix := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;        matrix[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    &#125;    row, col, dirIdx := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n*n; i++ &#123;        matrix[row][col] = i        dir := dirs[dirIdx]        <span class="hljs-keyword">if</span> r, c := row+dir.x, col+dir.y; r &lt; <span class="hljs-number">0</span> || r &gt;= n || c &lt; <span class="hljs-number">0</span> || c &gt;= n || matrix[r][c] &gt; <span class="hljs-number">0</span> &#123;            dirIdx = (dirIdx + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> <span class="hljs-comment">// 顺时针旋转至下一个方向</span>            dir = dirs[dirIdx]        &#125;        row += dir.x        col += dir.y    &#125;    <span class="hljs-keyword">return</span> matrix&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了95.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>591. 标签验证器</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/591.%20%E6%A0%87%E7%AD%BE%E9%AA%8C%E8%AF%81%E5%99%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/591.%20%E6%A0%87%E7%AD%BE%E9%AA%8C%E8%AF%81%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="标签验证器"><a href="#标签验证器" class="headerlink" title="标签验证器"></a><font size=6px>标签验证器</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：</p><p>代码必须被合法的闭合标签包围。否则，代码是无效的。<br>闭合标签（不一定合法）要严格符合格式：<TAG_NAME>TAG_CONTENT</TAG_NAME>。其中，<TAG_NAME>是起始标签，</TAG_NAME>是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是合法的。<br>合法的 TAG_NAME 仅含有大写字母，长度在范围 [1,9] 之间。否则，该 TAG_NAME 是不合法的。<br>合法的 TAG_CONTENT 可以包含其他合法的闭合标签，cdata （请参考规则7）和任意字符（注意参考规则1）除了不匹配的&lt;、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，TAG_CONTENT 是不合法的。<br>一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。<br>一个&lt;，如果你找不到一个后续的&gt;与之匹配，是不合法的。并且当你找到一个&lt;或&lt;&#x2F;时，所有直到下一个&gt;的前的字符，都应当被解析为 TAG_NAME（不一定合法）。<br>cdata 有如下格式：<![CDATA[CDATA_CONTENT]]>。CDATA_CONTENT 的范围被定义成 <![CDATA[ 和后续的第一个 ]]>之间的字符。<br>CDATA_CONTENT 可以包含任意字符。cdata 的功能是阻止验证器解析CDATA_CONTENT，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为常规字符。<br>合法代码的例子:</p><p>输入: “<DIV>This is the first line <![CDATA[<div>]]></DIV>“</p><p>输出: True</p><p>解释: </p><p>代码被包含在了闭合的标签内： <DIV> 和 </DIV> 。</p><p>TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 </p><p>即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。</p><p>所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。</p><p>输入: “<DIV>&gt;&gt;  ![cdata[]] <![CDATA[<div>]>]]>]]&gt;&gt;]</DIV>“</p><p>输出: True</p><p>解释:</p><p>我们首先将代码分割为： start_tag|tag_content|end_tag 。</p><p>start_tag -&gt; “<DIV>“</p><p>end_tag -&gt; “</DIV>“</p><p>tag_content 也可被分割为： text1|cdata|text2 。</p><p>text1 -&gt; “&gt;&gt;  ![cdata[]] “</p><p>cdata -&gt; “<![CDATA[<div>]>]]>“ ，其中 CDATA_CONTENT 为 “<div>]&gt;”</p><p>text2 -&gt; “]]&gt;&gt;]”</p><p>start_tag 不是 “<DIV>&gt;&gt;” 的原因参照规则 6 。<br>cdata 不是 “<![CDATA[<div>]>]]>]]&gt;” 的原因参照规则 7 。<br>不合法代码的例子:</p><p>输入: “<A>  <B> </A>   </B>“<br>输出: False<br>解释: 不合法。如果 “<A>“ 是闭合的，那么 “<B>“ 一定是不匹配的，反之亦然。</p><p>输入: “<DIV>  div tag is not closed  <DIV>“<br>输出: False</p><p>输入: “<DIV>  unmatched &lt;  </DIV>“<br>输出: False</p><p>输入: “<DIV> closed tags with invalid tag name  <b>123</b> </DIV>“<br>输出: False</p><p>输入: “<DIV> unmatched tags with invalid tag name  &lt;&#x2F;1234567890&gt; and &lt;CDATA[[]]&gt;  </DIV>“<br>输出: False</p><p>输入: “<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>“<br>输出: False<br>注意:</p><p>为简明起见，你可以假设输入的代码（包括提到的任意字符）只包含数字, 字母, ‘&lt;’,’&gt;’,’&#x2F;‘,’!’,’[‘,’]’和’ ‘。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>正则表达式yyds</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">class Solution:    def isValid(self, code: str) -&gt; <span class="hljs-type">bool</span>:        code = re.sub(r<span class="hljs-string">&#x27;&lt;!\[CDATA\[.*?\]\]&gt;|t&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, code)        prev = None        while code != prev:            prev = code            code = re.sub(r<span class="hljs-string">&#x27;&lt;([A-Z]&#123;1,9&#125;)&gt;[^&lt;]*&lt;/\1&gt;&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, code)        <span class="hljs-keyword">return</span> code == <span class="hljs-string">&#x27;t&#x27;</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：36 ms, 在所有 Python3 提交中击败了70.91%的用户<br>   内存消耗：15 MB, 在所有 Python3 提交中击败了70.91%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>599. 两个列表的最小索引总和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/599.%20%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/599.%20%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="599-两个列表的最小索引总和"><a href="#599-两个列表的最小索引总和" class="headerlink" title="599. 两个列表的最小索引总和"></a><font size=6px><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/">599. 两个列表的最小索引总和</a></font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p><p>你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。</p><p>示例 1:</p><p>输入: list1 &#x3D; [“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]，list2 &#x3D; [“Piatti”, “The Grill at Torrey Pines”, “Hungry Hunter Steakhouse”, “Shogun”]<br>输出: [“Shogun”]<br>解释: 他们唯一共同喜爱的餐厅是“Shogun”。<br>示例 2:</p><p>输入:list1 &#x3D; [“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]，list2 &#x3D; [“KFC”, “Shogun”, “Burger King”]<br>输出: [“Shogun”]<br>解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。</p><p>提示:</p><p>1 &lt;&#x3D; list1.length, list2.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; list1[i].length, list2[i].length &lt;&#x3D; 30<br>list1[i] 和 list2[i] 由空格 ‘ ‘ 和英文字母组成。<br>list1 的所有字符串都是 唯一 的。<br>list2 中的所有字符串都是 唯一 的。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用map做，list1遍历一次，list2遍历一次</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRestaurant</span><span class="hljs-params">(list1 []<span class="hljs-type">string</span>, list2 []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> list1&#123;        mp[v] = k+<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> list2&#123;        <span class="hljs-keyword">if</span> _,ok := mp[v];ok&#123;            res = <span class="hljs-built_in">append</span>(res, v)            mp[v] += k        &#125;    &#125;    minRes := <span class="hljs-number">999999</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> res&#123;        minRes = min(minRes, mp[v])    &#125;    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> res&#123;        <span class="hljs-keyword">if</span> minRes == mp[v]&#123;            ans = <span class="hljs-built_in">append</span>(ans, v)        &#125;    &#125;    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span> <span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了86.21%的用户<br>   内存消耗：7.1 MB, 在所有 Go 提交中击败了57.47%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>593. 有效的正方形</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/593.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/593.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="有效的正方形"><a href="#有效的正方形" class="headerlink" title="有效的正方形"></a><font size=6px>有效的正方形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定2D空间中四个点的坐标 p1, p2, p3 和 p4，如果这四个点构成一个正方形，则返回 true 。</p><p>点的坐标 pi 表示为 [xi, yi] 。输入 不是 按任何顺序给出的。</p><p>一个 有效的正方形 有四条等边和四个等角(90度角)。</p><p>示例 1:</p><p>输入: p1 &#x3D; [0,0], p2 &#x3D; [1,1], p3 &#x3D; [1,0], p4 &#x3D; [0,1]<br>输出: True<br>示例 2:</p><p>输入：p1 &#x3D; [0,0], p2 &#x3D; [1,1], p3 &#x3D; [1,0], p4 &#x3D; [0,12]<br>输出：false<br>示例 3:</p><p>输入：p1 &#x3D; [1,0], p2 &#x3D; [-1,0], p3 &#x3D; [0,1], p4 &#x3D; [0,-1]<br>输出：true</p><p>提示:</p><p>p1.length &#x3D;&#x3D; p2.length &#x3D;&#x3D; p3.length &#x3D;&#x3D; p4.length &#x3D;&#x3D; 2<br>-104 &lt;&#x3D; xi, yi &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>求任意三个点是不是等腰直角三角形</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validSquare</span><span class="hljs-params">(p1 []<span class="hljs-type">int</span>, p2 []<span class="hljs-type">int</span>, p3 []<span class="hljs-type">int</span>, p4 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;   <span class="hljs-keyword">return</span>  isRightTriangle(p1,p2,p3)&amp;&amp; isRightTriangle(p1,p2,p4) &amp;&amp; isRightTriangle(p1,p3,p4)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isRightTriangle</span><span class="hljs-params">(p1 []<span class="hljs-type">int</span>, p2 []<span class="hljs-type">int</span>, p3 []<span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;    d1 := (p1[<span class="hljs-number">0</span>] - p2[<span class="hljs-number">0</span>]) * (p1[<span class="hljs-number">0</span>] - p2[<span class="hljs-number">0</span>]) + (p1[<span class="hljs-number">1</span>] - p2[<span class="hljs-number">1</span>]) * (p1[<span class="hljs-number">1</span>] - p2[<span class="hljs-number">1</span>])    d2 := (p2[<span class="hljs-number">0</span>] - p3[<span class="hljs-number">0</span>]) * (p2[<span class="hljs-number">0</span>] - p3[<span class="hljs-number">0</span>]) + (p2[<span class="hljs-number">1</span>] - p3[<span class="hljs-number">1</span>]) * (p2[<span class="hljs-number">1</span>] - p3[<span class="hljs-number">1</span>])    d3 := (p3[<span class="hljs-number">0</span>] - p1[<span class="hljs-number">0</span>]) * (p3[<span class="hljs-number">0</span>] - p1[<span class="hljs-number">0</span>]) + (p3[<span class="hljs-number">1</span>] - p1[<span class="hljs-number">1</span>]) * (p3[<span class="hljs-number">1</span>] - p1[<span class="hljs-number">1</span>])     <span class="hljs-keyword">if</span> d1 &gt; d2 &amp;&amp; d2 == d3 &amp;&amp; d2 + d3 == d1 ||            d2 &gt; d1 &amp;&amp; d1 == d3 &amp;&amp; d1 + d3 == d2 ||            d3 &gt; d1 &amp;&amp; d1 == d2 &amp;&amp; d1 + d2 == d3&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了96.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. Z 字形变换</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/6.%20Z%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/6.%20Z%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="Z-字形变换"><a href="#Z-字形变换" class="headerlink" title="Z 字形变换"></a><font size=6px>Z 字形变换</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>示例 1：</p><p>输入：s &#x3D; “PAYPALISHIRING”, numRows &#x3D; 3<br>输出：”PAHNAPLSIIGYIR”<br>示例 2：<br>输入：s &#x3D; “PAYPALISHIRING”, numRows &#x3D; 4<br>输出：”PINALSIGYAHRPI”<br>解释：<br>P     I    N<br>A   L S  I G<br>Y A   H R<br>P     I<br>示例 3：</p><p>输入：s &#x3D; “A”, numRows &#x3D; 1<br>输出：”A”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 由英文字母（小写和大写）、’,’ 和 ‘.’ 组成<br>1 &lt;&#x3D; numRows &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>直接模拟法做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convert</span><span class="hljs-params">(s <span class="hljs-type">string</span>, numRows <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> numRows == <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> s&#125;<span class="hljs-keyword">var</span> ans [][]<span class="hljs-type">byte</span><span class="hljs-keyword">var</span> res <span class="hljs-type">string</span>ans = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">byte</span>, numRows)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i += <span class="hljs-number">2</span>*numRows - <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">for</span> j := i; j &lt; i+numRows &amp;&amp; j &lt; <span class="hljs-built_in">len</span>(s); j++ &#123;ans[j%(<span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span>)] = <span class="hljs-built_in">append</span>(ans[j%(<span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span>)], s[j])&#125;<span class="hljs-comment">// z中间部分</span><span class="hljs-keyword">for</span> j := i + numRows; j &lt; i+<span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span> &amp;&amp; j &lt; <span class="hljs-built_in">len</span>(s); j++ &#123;ans[<span class="hljs-number">2</span>*numRows-(j%(<span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span>))<span class="hljs-number">-2</span>] = <span class="hljs-built_in">append</span>(ans[<span class="hljs-number">2</span>*numRows-(j%(<span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span>))<span class="hljs-number">-2</span>], s[j])&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(ans); i++ &#123;res += <span class="hljs-type">string</span>(ans[i])&#125;<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了74.10%的用户<br>   内存消耗：6.9 MB, 在所有 Go 提交中击败了36.24%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>564. 寻找最近的回文数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/564.%20%E5%AF%BB%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/564.%20%E5%AF%BB%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="寻找最近的回文数"><a href="#寻找最近的回文数" class="headerlink" title="寻找最近的回文数"></a><font size=6px>寻找最近的回文数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个表示整数的字符串 n ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。</p><p>“最近的”定义为两个整数差的绝对值最小。</p><p>示例 1:</p><p>输入: n &#x3D; “123”<br>输出: “121”<br>示例 2:</p><p>输入: n &#x3D; “1”<br>输出: “0”<br>解释: 0 和 2是最近的回文，但我们返回最小的，也就是 0。</p><p>提示:</p><p>1 &lt;&#x3D; n.length &lt;&#x3D; 18<br>n 只由数字组成<br>n 不含前导 0<br>n 代表在 [1, 1018 - 1] 范围内的整数<br>通过次数11,931提交次数45,674</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>例如对于 abcdeabcde 来说，最近的回文数值的前三位可能是 abcabc、abc+1abc+1 和 abc-1abc−1 三者之一，其他位置的数值随着前三位的确定而唯一确定。还有特殊的情况得9999和10001里面选一个最接近的数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nearestPalindromic</span><span class="hljs-params">(n <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    m := <span class="hljs-built_in">len</span>(n)    <span class="hljs-keyword">if</span> m == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(n[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>)    &#125;    candidates := []<span class="hljs-type">int</span>&#123;<span class="hljs-type">int</span>(math.Pow10(m<span class="hljs-number">-1</span>)) - <span class="hljs-number">1</span>, <span class="hljs-type">int</span>(math.Pow10(m)) + <span class="hljs-number">1</span>&#125;    selfPrefix, _ := strconv.Atoi(n[:(m+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>])    <span class="hljs-keyword">for</span> _,x := <span class="hljs-keyword">range</span> []<span class="hljs-type">int</span>&#123;selfPrefix,selfPrefix+<span class="hljs-number">1</span>,selfPrefix<span class="hljs-number">-1</span>&#125; &#123;        y := x        <span class="hljs-keyword">if</span> m % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>&#123;            y /= <span class="hljs-number">10</span>        &#125;        <span class="hljs-keyword">for</span> ;y&gt;<span class="hljs-number">0</span>;y/=<span class="hljs-number">10</span>&#123;            x = x*<span class="hljs-number">10</span> + y %<span class="hljs-number">10</span>        &#125;        candidates = <span class="hljs-built_in">append</span>(candidates, x)    &#125;    ans := <span class="hljs-number">-1</span>    num,_ := strconv.Atoi(n)    <span class="hljs-keyword">for</span> _,x := <span class="hljs-keyword">range</span> candidates&#123;        <span class="hljs-keyword">if</span> x != num &amp;&amp; (ans == <span class="hljs-number">-1</span> ||  abs(ans-num) &gt; abs(x - num) || (abs(ans-num) == abs(x - num) &amp;&amp; x &lt; ans)) &#123;            ans = x        &#125;    &#125;    <span class="hljs-keyword">return</span> strconv.Itoa(ans)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> n &lt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> -n    &#125;    <span class="hljs-keyword">return</span> n&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了11.11%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了88.89%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>61. 旋转链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/61.%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/61.%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a><font size=6px>旋转链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[4,5,1,2,3]<br>示例 2：</p><p>输入：head &#x3D; [0,1,2], k &#x3D; 4<br>输出：[2,0,1]</p><p>提示：</p><p>链表中节点的数目在范围 [0, 500] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>0 &lt;&#x3D; k &lt;&#x3D; 2 * 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>用快慢指针找到倒数第k个</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * type ListNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *ListNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotateRight</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> head    &#125;    tmp := head    i := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> tmp!= <span class="hljs-literal">nil</span>&#123;        i++        tmp = tmp.Next    &#125;    k = k%i    <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> head    &#125;    slow,quick := head,head    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;        quick = quick.Next    &#125;    <span class="hljs-keyword">for</span> quick.Next != <span class="hljs-literal">nil</span>&#123;        quick = quick.Next        slow = slow.Next    &#125;    next := slow.Next    slow.Next = <span class="hljs-literal">nil</span>    quick.Next = head    <span class="hljs-keyword">return</span> next&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了60.78%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>622. 设计循环队列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/622.%20%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/622.%20%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="设计循环队列"><a href="#设计循环队列" class="headerlink" title="设计循环队列"></a><font size=6px>设计循环队列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p>你的实现应该支持如下操作：</p><p>MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>Front: 从队首获取元素。如果队列为空，返回 -1 。<br>Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>isEmpty(): 检查循环队列是否为空。<br>isFull(): 检查循环队列是否已满。</p><p>示例：</p><p>MyCircularQueue circularQueue &#x3D; new MyCircularQueue(3); &#x2F;&#x2F; 设置长度为 3<br>circularQueue.enQueue(1);  &#x2F;&#x2F; 返回 true<br>circularQueue.enQueue(2);  &#x2F;&#x2F; 返回 true<br>circularQueue.enQueue(3);  &#x2F;&#x2F; 返回 true<br>circularQueue.enQueue(4);  &#x2F;&#x2F; 返回 false，队列已满<br>circularQueue.Rear();  &#x2F;&#x2F; 返回 3<br>circularQueue.isFull();  &#x2F;&#x2F; 返回 true<br>circularQueue.deQueue();  &#x2F;&#x2F; 返回 true<br>circularQueue.enQueue(4);  &#x2F;&#x2F; 返回 true<br>circularQueue.Rear();  &#x2F;&#x2F; 返回 4</p><p>提示：</p><p>所有的值都在 0 至 1000 的范围内；<br>操作数将在 1 至 1000 的范围内；<br>请不要使用内置的队列库。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用数组做，挺没意思的吧</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> MyCircularQueue <span class="hljs-keyword">struct</span> &#123;    front, rear <span class="hljs-type">int</span>    elements    []<span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-type">int</span>)</span></span> MyCircularQueue &#123;    <span class="hljs-keyword">return</span> MyCircularQueue&#123;elements: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k+<span class="hljs-number">1</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyCircularQueue)</span></span> EnQueue(value <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> q.IsFull() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    q.elements[q.rear] = value    q.rear = (q.rear + <span class="hljs-number">1</span>) % <span class="hljs-built_in">len</span>(q.elements)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyCircularQueue)</span></span> DeQueue() <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> q.IsEmpty() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    q.front = (q.front + <span class="hljs-number">1</span>) % <span class="hljs-built_in">len</span>(q.elements)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q MyCircularQueue)</span></span> Front() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> q.IsEmpty() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;    <span class="hljs-keyword">return</span> q.elements[q.front]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q MyCircularQueue)</span></span> Rear() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> q.IsEmpty() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;    <span class="hljs-keyword">return</span> q.elements[(q.rear<span class="hljs-number">-1</span>+<span class="hljs-built_in">len</span>(q.elements))%<span class="hljs-built_in">len</span>(q.elements)]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q MyCircularQueue)</span></span> IsEmpty() <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">return</span> q.rear == q.front&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q MyCircularQueue)</span></span> IsFull() <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">return</span> (q.rear+<span class="hljs-number">1</span>)%<span class="hljs-built_in">len</span>(q.elements) == q.front&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了96.65%的用户<br>   内存消耗：6.7 MB, 在所有 Go 提交中击败了41.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>617. Merge Two Binary Trees</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/617.%20Merge%20Two%20Binary%20Trees/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/617.%20Merge%20Two%20Binary%20Trees/</url>
    
    <content type="html"><![CDATA[<h3 id="Merge-Two-Binary-Trees"><a href="#Merge-Two-Binary-Trees" class="headerlink" title="Merge Two Binary Trees"></a><font size=6px>Merge Two Binary Trees</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given two binary trees root1 and root2.</p><p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p><p>Return the merged tree.</p><p>Note: The merging process must start from the root nodes of both trees.</p><p>Example 1:</p><p>Input: root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]<br>Output: [3,4,5,5,4,null,7]<br>Example 2:</p><p>Input: root1 &#x3D; [1], root2 &#x3D; [1,2]<br>Output: [2,2]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>dfs题，递归合成二叉树</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTrees</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root1, root2 *TreeNode)</span></span>*TreeNode    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root1, root2 *TreeNode)</span></span>*TreeNode&#123;        <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span> || root2 == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span>&#123;                <span class="hljs-keyword">return</span> root2            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> root1            &#125;        &#125;        root1.Val += root2.Val        root1.Left = dfs(root1.Left, root2.Left)        root1.Right = dfs(root1.Right, root2.Right)                <span class="hljs-keyword">return</span> root1    &#125;    <span class="hljs-keyword">return</span> dfs(root1, root2)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了95.45%的用户<br>   内存消耗：6.7 MB, 在所有 Go 提交中击败了91.63%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>621. 任务调度器</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/621.%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/621.%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a><font size=6px>任务调度器</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 最短时间 。</p><p>示例 1：</p><p>输入：tasks &#x3D; [“A”,”A”,”A”,”B”,”B”,”B”], n &#x3D; 2<br>输出：8<br>解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B<br>     在本示例中，两个相同类型任务之间必须间隔长度为 n &#x3D; 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。<br>示例 2：</p><p>输入：tasks &#x3D; [“A”,”A”,”A”,”B”,”B”,”B”], n &#x3D; 0<br>输出：6<br>解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n &#x3D; 0<br>[“A”,”A”,”A”,”B”,”B”,”B”]<br>[“A”,”B”,”A”,”B”,”A”,”B”]<br>[“B”,”B”,”B”,”A”,”A”,”A”]<br>…<br>诸如此类<br>示例 3：</p><p>输入：tasks &#x3D; [“A”,”A”,”A”,”A”,”A”,”A”,”B”,”C”,”D”,”E”,”F”,”G”], n &#x3D; 2<br>输出：16<br>解释：一种可能的解决方案是：<br>     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A</p><p>提示：</p><p>1 &lt;&#x3D; task.length &lt;&#x3D; 104<br>tasks[i] 是大写英文字母<br>n 的取值范围为 [0, 100]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用桶思想<strong>总排队时间 &#x3D; (桶个数 - 1) * (n + 1) + 最后一桶的任务数</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(tasks []<span class="hljs-type">byte</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    words := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)    count := <span class="hljs-number">1</span>    words_count:=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(tasks); i++&#123;        <span class="hljs-keyword">if</span> words[tasks[i]-<span class="hljs-string">&#x27;A&#x27;</span>] == <span class="hljs-number">0</span>&#123;            words_count++        &#125;        words[tasks[i]-<span class="hljs-string">&#x27;A&#x27;</span>]++    &#125;    sort.Slice(words, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;        <span class="hljs-keyword">if</span> words[i] &gt; words[j]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(words);i++&#123;        <span class="hljs-keyword">if</span> words[i] != words[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">break</span>        &#125;        count++    &#125;    <span class="hljs-keyword">return</span> max(<span class="hljs-built_in">len</span>(tasks), count+(n+<span class="hljs-number">1</span>)* (words[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>))    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了92.34%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>63. 不同路径 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a><font size=6px>不同路径 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>示例 1：</p><p>输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2<br>解释：3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br>示例 2：</li></ol><p>输入：obstacleGrid &#x3D; [[0,1],[0,0]]<br>输出：1</p><p>提示：</p><p>m &#x3D;&#x3D; obstacleGrid.length<br>n &#x3D;&#x3D; obstacleGrid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>obstacleGrid[i][j] 为 0 或 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span></code></pre><p>动态规划题，只需要考虑如果是障碍物的话置为0就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(obstacleGrid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(obstacleGrid),<span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,m+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j&lt;=n; j++&#123;               <span class="hljs-keyword">if</span> obstacleGrid[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>&#123;                dp[i][j] = <span class="hljs-number">0</span>            &#125;<span class="hljs-keyword">else</span>&#123;                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>]            &#125;                    &#125;    &#125;    <span class="hljs-comment">//fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> dp[m][n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了12.46%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>636. 函数的独占时间</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/636.%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/636.%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="函数的独占时间"><a href="#函数的独占时间" class="headerlink" title="函数的独占时间"></a><font size=6px>函数的独占时间</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于  0 和 n-1 之间的唯一标识符。</p><p>函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。</p><p>给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 “{function_id}:{“start” | “end”}:{timestamp}” 进行格式化的字符串。例如，”0:start:3” 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 “1:end:2” 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。</p><p>函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 &#x3D; 3 。</p><p>以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。</p><p>示例 1：</p><p>输入：n &#x3D; 2, logs &#x3D; [“0:start:0”,”1:start:2”,”1:end:5”,”0:end:6”]<br>输出：[3,4]<br>解释：<br>函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。<br>函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。<br>函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。<br>所以函数 0 总共执行 2 + 1 &#x3D; 3 个单位时间，函数 1 总共执行 4 个单位时间。<br>示例 2：</p><p>输入：n &#x3D; 1, logs &#x3D; [“0:start:0”,”0:start:2”,”0:end:5”,”0:start:6”,”0:end:6”,”0:end:7”]<br>输出：[8]<br>解释：<br>函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。<br>函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。<br>函数 0（初始调用）恢复执行，并立刻再次调用它自身。<br>函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。<br>函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。<br>所以函数 0 总共执行 2 + 4 + 1 + 1 &#x3D; 8 个单位时间。<br>示例 3：</p><p>输入：n &#x3D; 2, logs &#x3D; [“0:start:0”,”0:start:2”,”0:end:5”,”1:start:6”,”1:end:6”,”0:end:7”]<br>输出：[7,1]<br>解释：<br>函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。<br>函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。<br>函数 0（初始调用）恢复执行，并立刻调用函数 1 。<br>函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。<br>函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。<br>所以函数 0 总共执行 2 + 4 + 1 &#x3D; 7 个单位时间，函数 1 总共执行 1 个单位时间。<br>示例 4：</p><p>输入：n &#x3D; 2, logs &#x3D; [“0:start:0”,”0:start:2”,”0:end:5”,”1:start:7”,”1:end:7”,”0:end:8”]<br>输出：[8,1]<br>示例 5：</p><p>输入：n &#x3D; 1, logs &#x3D; [“0:start:0”,”0:end:0”]<br>输出：[1]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 100<br>1 &lt;&#x3D; logs.length &lt;&#x3D; 500<br>0 &lt;&#x3D; function_id &lt; n<br>0 &lt;&#x3D; timestamp &lt;&#x3D; 109<br>两个开始事件不会在同一时间戳发生<br>两个结束事件不会在同一时间戳发生<br>每道函数都有一个对应 “start” 日志的 “end” 日志</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(N)</code></pre><p>简单栈应用题，timestamp得注意</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exclusiveTime</span><span class="hljs-params">(n <span class="hljs-type">int</span>, logs []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    <span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123; idx, timestamp <span class="hljs-type">int</span> &#125;    st := []pair&#123;&#125;    <span class="hljs-keyword">for</span> _, log := <span class="hljs-keyword">range</span> logs &#123;        sp := strings.Split(log, <span class="hljs-string">&quot;:&quot;</span>)        idx, _ := strconv.Atoi(sp[<span class="hljs-number">0</span>])        timestamp, _ := strconv.Atoi(sp[<span class="hljs-number">2</span>])        <span class="hljs-keyword">if</span> sp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;s&#x27;</span> &#123;            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(st) != <span class="hljs-number">0</span>&#123;                ans[st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>].idx] += timestamp - st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>].timestamp                st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>].timestamp = timestamp            &#125;            st = <span class="hljs-built_in">append</span>(st, pair&#123;idx,timestamp&#125;)        &#125; <span class="hljs-keyword">else</span> &#123;            p := st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>]            st = st[:<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>]            ans[idx] += timestamp - p.timestamp +<span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(st)&gt;<span class="hljs-number">0</span>&#123;                st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>].timestamp = timestamp+<span class="hljs-number">1</span>            &#125;        &#125;           &#125;    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了69.57%的用户<br>   内存消耗：6.2 MB, 在所有 Go 提交中击败了26.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>606. 根据二叉树创建字符串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/606.%20%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/606.%20%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="根据二叉树创建字符串"><a href="#根据二叉树创建字符串" class="headerlink" title="根据二叉树创建字符串"></a><font size=6px>根据二叉树创建字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p><p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p><p>示例 1:</p><p>输入: 二叉树: [1,2,3,4]<br>       1<br>     &#x2F;   <br>    2     3<br>   &#x2F;<br>  4     </p><p>输出: “1(2(4))(3)”</p><p>解释: 原本将是“1(2(4)())(3())”，<br>在你省略所有不必要的空括号对之后，<br>它将是“1(2(4))(3)”。<br>示例 2:</p><p>输入: 二叉树: [1,2,3,null,4]<br>       1<br>     &#x2F;   <br>    2     3<br>     \<br>      4 </p><p>输出: “1(2()(4))(3)”</p><p>解释: 和第一个示例相似，<br>除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>前序遍历，然后判断左孩子为空和右孩子为空两种情况特殊处理，用递归最简单了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tree2str</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">string</span> &#123;    res := <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> strconv.Itoa(root.Val)    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right != <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> strconv.Itoa(root.Val)+<span class="hljs-string">&quot;()(&quot;</span>+tree2str(root.Right)+<span class="hljs-string">&quot;)&quot;</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> strconv.Itoa(root.Val)+<span class="hljs-string">&quot;(&quot;</span>+tree2str(root.Left)+<span class="hljs-string">&quot;)&quot;</span>    &#125;    res += strconv.Itoa(root.Val) + <span class="hljs-string">&quot;(&quot;</span>+tree2str(root.Left) + <span class="hljs-string">&quot;)(&quot;</span> +tree2str(root.Right) + <span class="hljs-string">&quot;)&quot;</span>    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了87.40%的用户<br>   内存消耗：7.4 MB, 在所有 Go 提交中击败了59.06%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>648. 单词替换</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/648.%20%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/648.%20%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="单词替换"><a href="#单词替换" class="headerlink" title="单词替换"></a><font size=6px>单词替换</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p><p>现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p><p>你需要输出替换之后的句子。</p><p>示例 1：</p><p>输入：dictionary &#x3D; [“cat”,”bat”,”rat”], sentence &#x3D; “the cattle was rattled by the battery”<br>输出：”the cat was rat by the bat”<br>示例 2：</p><p>输入：dictionary &#x3D; [“a”,”b”,”c”], sentence &#x3D; “aadsfasf absbs bbab cadsfafs”<br>输出：”a a b c”</p><p>提示：</p><p>1 &lt;&#x3D; dictionary.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; dictionary[i].length &lt;&#x3D; 100<br>dictionary[i] 仅由小写字母组成。<br>1 &lt;&#x3D; sentence.length &lt;&#x3D; 10^6<br>sentence 仅由小写字母和空格组成。<br>sentence 中单词的总量在范围 [1, 1000] 内。<br>sentence 中每个单词的长度在范围 [1, 1000] 内。<br>sentence 中单词之间由一个空格隔开。<br>sentence 没有前导或尾随空格。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用map存储，然后遍历每一个单词看有没有，虽然效率不怎么样但是简单粗暴</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">replaceWords</span><span class="hljs-params">(dictionary []<span class="hljs-type">string</span>, sentence <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>,<span class="hljs-number">0</span>)    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> dictionary&#123;        mp[v] = <span class="hljs-literal">true</span>    &#125;    words := strings.Split(sentence,<span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-comment">//fmt.Println(words)</span>    <span class="hljs-keyword">for</span> _,word := <span class="hljs-keyword">range</span> words&#123;        flag := <span class="hljs-literal">false</span>        tmp := <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> word&#123;            tmp += <span class="hljs-type">string</span>(word[i])            <span class="hljs-keyword">if</span> mp[tmp] == <span class="hljs-literal">true</span>&#123;                flag = <span class="hljs-literal">true</span>                res = <span class="hljs-built_in">append</span>(res,tmp)                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">false</span>&#123;            res = <span class="hljs-built_in">append</span>(res,tmp)        &#125;    &#125;    <span class="hljs-keyword">return</span> strings.Join(res,<span class="hljs-string">&quot; &quot;</span>)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：80 ms, 在所有 Go 提交中击败了14.17%的用户<br>   内存消耗：11 MB, 在所有 Go 提交中击败了66.93%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>640. 求解方程</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/640.%20%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/640.%20%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="求解方程"><a href="#求解方程" class="headerlink" title="求解方程"></a><font size=6px>求解方程</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>求解一个给定的方程，将x以字符串 “x&#x3D;#value” 的形式返回。该方程仅包含 ‘+’ ， ‘-‘ 操作，变量 x 和其对应系数。</p><p>如果方程没有解，请返回 “No solution” 。如果方程有无限解，则返回 “Infinite solutions” 。</p><p>题目保证，如果方程中只有一个解，则 ‘x’ 的值是一个整数。</p><p>示例 1：</p><p>输入: equation &#x3D; “x+5-3+x&#x3D;6+x-2”<br>输出: “x&#x3D;2”<br>示例 2:</p><p>输入: equation &#x3D; “x&#x3D;x”<br>输出: “Infinite solutions”<br>示例 3:</p><p>输入: equation &#x3D; “2x&#x3D;x”<br>输出: “x&#x3D;0”</p><p>提示:</p><p>3 &lt;&#x3D; equation.length &lt;&#x3D; 1000<br>equation 只有一个 ‘&#x3D;’.<br>equation 方程由整数组成，其绝对值在 [0, 100] 范围内，不含前导零和变量 ‘x’ 。 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>模拟题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveEquation</span><span class="hljs-params">(equation <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    factor, val := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    i, n, sign := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(equation), <span class="hljs-number">1</span> <span class="hljs-comment">// 等式左边默认系数为正</span>    <span class="hljs-keyword">for</span> i &lt; n &#123;        <span class="hljs-keyword">if</span> equation[i] == <span class="hljs-string">&#x27;=&#x27;</span> &#123;            sign = <span class="hljs-number">-1</span> <span class="hljs-comment">// 等式右边默认系数为负</span>            i++            <span class="hljs-keyword">continue</span>        &#125;        s := sign        <span class="hljs-keyword">if</span> equation[i] == <span class="hljs-string">&#x27;+&#x27;</span> &#123; <span class="hljs-comment">// 去掉前面的符号</span>            i++        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> equation[i] == <span class="hljs-string">&#x27;-&#x27;</span> &#123;            s = -s            i++        &#125;        num, valid := <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>        <span class="hljs-keyword">for</span> i &lt; n &amp;&amp; unicode.IsDigit(<span class="hljs-type">rune</span>(equation[i])) &#123;            valid = <span class="hljs-literal">true</span>            num = num*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(equation[i]-<span class="hljs-string">&#x27;0&#x27;</span>)            i++        &#125;        <span class="hljs-keyword">if</span> i &lt; n &amp;&amp; equation[i] == <span class="hljs-string">&#x27;x&#x27;</span> &#123; <span class="hljs-comment">// 变量</span>            <span class="hljs-keyword">if</span> valid &#123;                s *= num            &#125;            factor += s            i++        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 数值</span>            val += s * num        &#125;    &#125;    <span class="hljs-keyword">if</span> factor == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">if</span> val == <span class="hljs-number">0</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Infinite solutions&quot;</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No solution&quot;</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;x=&quot;</span> + strconv.Itoa(-val/factor)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了61.90%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>653. 两数之和 IV - 输入 BST</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/653.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20IV%20-%20%E8%BE%93%E5%85%A5%20BST/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/653.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20IV%20-%20%E8%BE%93%E5%85%A5%20BST/</url>
    
    <content type="html"><![CDATA[<h3 id="两数之和-IV-输入-BST"><a href="#两数之和-IV-输入-BST" class="headerlink" title="两数之和 IV - 输入 BST"></a><font size=6px>两数之和 IV - 输入 BST</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p><p>示例 1：</p><p>输入: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 9<br>输出: true<br>示例 2：</p><p>输入: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 28<br>输出: false</p><p>提示:</p><p>二叉树的节点个数的范围是  [1, 104].<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>root 为二叉搜索树<br>-105 &lt;&#x3D; k &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>中序遍历之后把数字放入数组，然后遍历数组看符不符合条件</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(root *TreeNode, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> inorder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    inorder = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        inorder(root.Left)        res = <span class="hljs-built_in">append</span>(res, root.Val)        inorder(root.Right)    &#125;    inorder(root)    l,r := <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(res)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> l&lt;r&#123;        <span class="hljs-keyword">if</span> res[l]+res[r] == k&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> res[l]+res[r]&lt;k&#123;            l++        &#125;<span class="hljs-keyword">else</span>&#123;            r--        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了52.82%的用户<br>   内存消耗：7.2 MB, 在所有 Go 提交中击败了76.06%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>661. 图片平滑器</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/661.%20%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/661.%20%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="图片平滑器"><a href="#图片平滑器" class="headerlink" title="图片平滑器"></a><font size=6px>图片平滑器</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>图像平滑器 是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。</p><p>每个单元格的  平均灰度 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。</p><p>如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。</p><p>给你一个表示图像灰度的 m x n 整数矩阵 img ，返回对图像的每个单元格平滑处理后的图像 。</p><p>示例 1:</p><p>输入:img &#x3D; [[1,1,1],[1,0,1],[1,1,1]]<br>输出:[[0, 0, 0],[0, 0, 0], [0, 0, 0]]<br>解释:<br>对于点 (0,0), (0,2), (2,0), (2,2): 平均(3&#x2F;4) &#x3D; 平均(0.75) &#x3D; 0<br>对于点 (0,1), (1,0), (1,2), (2,1): 平均(5&#x2F;6) &#x3D; 平均(0.83333333) &#x3D; 0<br>对于点 (1,1): 平均(8&#x2F;9) &#x3D; 平均(0.88888889) &#x3D; 0<br>示例 2:</p><p>输入: img &#x3D; [[100,200,100],[200,50,200],[100,200,100]]<br>输出: [[137,141,137],[141,138,141],[137,141,137]]<br>解释:<br>对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)&#x2F;4) &#x3D; floor(137.5) &#x3D; 137<br>对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)&#x2F;6) &#x3D; floor(141.666667) &#x3D; 141<br>对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)&#x2F;9) &#x3D; floor(138.888889) &#x3D; 138</p><p>提示:</p><p>m &#x3D;&#x3D; img.length<br>n &#x3D;&#x3D; img[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; img[i][j] &lt;&#x3D; 255</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n2),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>每次都计算一个格子周边8个加上自己9个的平均值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">imageSmoother</span><span class="hljs-params">(img [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    move := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;    m ,n := <span class="hljs-built_in">len</span>(img), <span class="hljs-built_in">len</span>(img[<span class="hljs-number">0</span>])    res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m; i++&#123;        res[i] =  <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n; j++&#123;            count :=<span class="hljs-number">1</span>            sum := img[i][j]            <span class="hljs-keyword">for</span>  k:=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">8</span>;k++&#123;                x := i + move[k*<span class="hljs-number">2</span>]                y := j + move[k*<span class="hljs-number">2</span> +<span class="hljs-number">1</span>]                <span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;n&#123;                    count ++                    sum += img[x][y]                &#125;            &#125;            res[i][j] = sum/count        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>688. 骑士在棋盘上的概率</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/688.%20%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/688.%20%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<h3 id="骑士在棋盘上的概率"><a href="#骑士在棋盘上的概率" class="headerlink" title="骑士在棋盘上的概率"></a><font size=6px>骑士在棋盘上的概率</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。</p><p>象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。</p><p>每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。</p><p>骑士继续移动，直到它走了 k 步或离开了棋盘。</p><p>返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用动态规划做最省力了，dp[i][j][p] +&#x3D; dp[i-1][x][y]&#x2F;8，这个位置的概率等于周围8个的概率分别处以8再相加。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">var</span> dirs = []<span class="hljs-keyword">struct</span>&#123; i, j <span class="hljs-type">int</span> &#125;&#123;&#123;<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">knightProbability</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>, row <span class="hljs-type">int</span>, column <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;    <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;    dp := <span class="hljs-built_in">make</span>([][][]<span class="hljs-type">float64</span>, k+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=k;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">float64</span>, n)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>; j&lt;n;j++&#123;            dp[i][j] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">float64</span>, n)            <span class="hljs-keyword">for</span> p:=<span class="hljs-number">0</span>; p&lt;n; p++&#123;                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>&#123;                    dp[i][j][p] = <span class="hljs-number">1</span>                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> dirs&#123;                        x := j+v.i                        y := p+v.j                        <span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp;y &lt;n&#123;                            dp[i][j][p] += dp[i<span class="hljs-number">-1</span>][x][y]/<span class="hljs-number">8</span>                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[k][row][column]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了77.42%的用户<br>   内存消耗：3.6 MB, 在所有 Go 提交中击败了70.97%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>682. 棒球比赛</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/682.%20%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/682.%20%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="棒球比赛"><a href="#棒球比赛" class="headerlink" title="棒球比赛"></a><font size=6px>棒球比赛</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p><p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：</p><p>整数 x - 表示本回合新获得分数 x<br>“+” - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。<br>“D” - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。<br>“C” - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。<br>请你返回记录中所有得分的总和。</p><p>示例 1：</p><p>输入：ops &#x3D; [“5”,”2”,”C”,”D”,”+”]<br>输出：30<br>解释：<br>“5” - 记录加 5 ，记录现在是 [5]<br>“2” - 记录加 2 ，记录现在是 [5, 2]<br>“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5].<br>“D” - 记录加 2 * 5 &#x3D; 10 ，记录现在是 [5, 10].<br>“+” - 记录加 5 + 10 &#x3D; 15 ，记录现在是 [5, 10, 15].<br>所有得分的总和 5 + 10 + 15 &#x3D; 30<br>示例 2：</p><p>输入：ops &#x3D; [“5”,”-2”,”4”,”C”,”D”,”9”,”+”,”+”]<br>输出：27<br>解释：<br>“5” - 记录加 5 ，记录现在是 [5]<br>“-2” - 记录加 -2 ，记录现在是 [5, -2]<br>“4” - 记录加 4 ，记录现在是 [5, -2, 4]<br>“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]<br>“D” - 记录加 2 * -2 &#x3D; -4 ，记录现在是 [5, -2, -4]<br>“9” - 记录加 9 ，记录现在是 [5, -2, -4, 9]<br>“+” - 记录加 -4 + 9 &#x3D; 5 ，记录现在是 [5, -2, -4, 9, 5]<br>“+” - 记录加 9 + 5 &#x3D; 14 ，记录现在是 [5, -2, -4, 9, 5, 14]<br>所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 &#x3D; 27<br>示例 3：</p><p>输入：ops &#x3D; [“1”]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; ops.length &lt;&#x3D; 1000<br>ops[i] 为 “C”、”D”、”+”，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104]<br>对于 “+” 操作，题目数据保证记录此操作时前面总是存在两个有效的分数<br>对于 “C” 和 “D” 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>硬模拟</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calPoints</span><span class="hljs-params">(ops []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> ops&#123;        <span class="hljs-keyword">if</span> (v[<span class="hljs-number">0</span>]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; v[<span class="hljs-number">0</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) || v[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>&#123;            value,_ := strconv.Atoi(v)            ans = <span class="hljs-built_in">append</span>(ans, value)        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;C&#x27;</span>&#123;            ans = ans[:<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-1</span>]        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>&#123;            ans = <span class="hljs-built_in">append</span>(ans, ans[<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-1</span>]+ans[<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-2</span>])        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;D&#x27;</span>&#123;            ans = <span class="hljs-built_in">append</span>(ans, ans[<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>)        &#125;    &#125;    res := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> ans&#123;        res += v    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.5 MB, 在所有 Go 提交中击败了78.38%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>692. 前K个高频单词</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="前K个高频单词"><a href="#前K个高频单词" class="headerlink" title="前K个高频单词"></a><font size=6px>前K个高频单词</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。</p><p>示例 1：</p><p>输入: words &#x3D; [“i”, “love”, “leetcode”, “i”, “love”, “coding”], k &#x3D; 2<br>输出: [“i”, “love”]<br>解析: “i” 和 “love” 为出现次数最多的两个单词，均为2次。<br>    注意，按字母顺序 “i” 在 “love” 之前。<br>示例 2：</p><p>输入: [“the”, “day”, “is”, “sunny”, “the”, “the”, “the”, “sunny”, “is”, “is”], k &#x3D; 4<br>输出: [“the”, “is”, “sunny”, “day”]<br>解析: “the”, “is”, “sunny” 和 “day” 是出现次数最多的四个单词，<br>    出现次数依次为 4, 3, 2 和 1 次。</p><p>注意：</p><p>1 &lt;&#x3D; words.length &lt;&#x3D; 500<br>1 &lt;&#x3D; words[i] &lt;&#x3D; 10<br>words[i] 由小写英文字母组成。<br>k 的取值范围是 [1, 不同 words[i] 的数量]</p><p>进阶：尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(nlogk),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>用堆排序，做到nlogk</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123;    s <span class="hljs-type">string</span>    c <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;    sort.Strings(words)    fmt.Println(words)    <span class="hljs-keyword">var</span> pairs []pair    pairs = <span class="hljs-built_in">append</span>(pairs, pair&#123;words[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>&#125;)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(words);i++&#123;        <span class="hljs-keyword">if</span> words[i] == words[i<span class="hljs-number">-1</span>]&#123;            pairs[<span class="hljs-built_in">len</span>(pairs)<span class="hljs-number">-1</span>].c++        &#125;<span class="hljs-keyword">else</span>&#123;            pairs = <span class="hljs-built_in">append</span>(pairs, pair&#123;words[i], <span class="hljs-number">1</span>&#125;)        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(pairs)</span>    <span class="hljs-keyword">return</span> headsort(pairs, k)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">headsort</span><span class="hljs-params">(pairs []pair, k <span class="hljs-type">int</span>)</span></span>[]<span class="hljs-type">string</span>&#123;    n := <span class="hljs-built_in">len</span>(pairs)    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> i:=n/<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">0</span>; i--&#123;        headsortMax(pairs, i,n)    &#125;    <span class="hljs-comment">//fmt.Println(pairs)</span>    res = <span class="hljs-built_in">append</span>(res, pairs[<span class="hljs-number">0</span>].s)    pairs[<span class="hljs-number">0</span>],pairs[n<span class="hljs-number">-1</span>] = pairs[n<span class="hljs-number">-1</span>], pairs[<span class="hljs-number">0</span>]    n--    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;k;i++&#123;        headsortMax(pairs, <span class="hljs-number">0</span>,n)        res = <span class="hljs-built_in">append</span>(res, pairs[<span class="hljs-number">0</span>].s)        pairs[<span class="hljs-number">0</span>],pairs[n<span class="hljs-number">-1</span>] = pairs[n<span class="hljs-number">-1</span>], pairs[<span class="hljs-number">0</span>]        n--    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">headsortMax</span> <span class="hljs-params">(pairs []pair, i <span class="hljs-type">int</span>,n <span class="hljs-type">int</span>)</span></span>&#123;    maxi := i    <span class="hljs-keyword">for</span>&#123;        <span class="hljs-keyword">if</span> i*<span class="hljs-number">2</span> &lt;n &amp;&amp; ((pairs[i*<span class="hljs-number">2</span>].c &gt; pairs[maxi].c) || (pairs[i*<span class="hljs-number">2</span>].c == pairs[maxi].c &amp;&amp; pairs[i*<span class="hljs-number">2</span>].s &lt; pairs[maxi].s))&#123;            maxi = i*<span class="hljs-number">2</span>        &#125;        <span class="hljs-keyword">if</span> i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;n &amp;&amp; ((pairs[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].c &gt; pairs[maxi].c) || (pairs[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].c == pairs[maxi].c &amp;&amp; pairs[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].s &lt; pairs[maxi].s))&#123;            maxi = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">if</span> maxi != i&#123;            pairs[i],pairs[maxi] = pairs[maxi], pairs[i]            i = maxi        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了20.87%的用户<br>   内存消耗：4.3 MB, 在所有 Go 提交中击败了45.48%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>693. 交替位二进制数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/693.%20%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/693.%20%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="交替位二进制数"><a href="#交替位二进制数" class="headerlink" title="交替位二进制数"></a><font size=6px>交替位二进制数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p><p>示例 1：</p><p>输入：n &#x3D; 5<br>输出：true<br>解释：5 的二进制表示是：101<br>示例 2：</p><p>输入：n &#x3D; 7<br>输出：false<br>解释：7 的二进制表示是：111.<br>示例 3：</p><p>输入：n &#x3D; 11<br>输出：false<br>解释：11 的二进制表示是：1011.</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(logn),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasAlternatingBits</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> flag <span class="hljs-type">bool</span>    <span class="hljs-keyword">if</span> n &amp;<span class="hljs-number">1</span> == <span class="hljs-number">1</span>&#123;        flag = <span class="hljs-literal">true</span>    &#125;<span class="hljs-keyword">else</span>&#123;        flag = <span class="hljs-literal">false</span>    &#125;    n/=<span class="hljs-number">2</span>    <span class="hljs-keyword">for</span> n != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> n %<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; flag == <span class="hljs-literal">false</span>&#123;            flag = <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; flag == <span class="hljs-literal">true</span>&#123;            flag = <span class="hljs-literal">false</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        n/=<span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了82.19%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>647. 回文子串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/647.%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/647.%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><font size=6px>回文子串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><p>输入：s &#x3D; “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”<br>示例 2：</p><p>输入：s &#x3D; “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用马拉车算法，时间复杂度o（n），动态维护左边界和右边界</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;   n := <span class="hljs-built_in">len</span>(s)   t := <span class="hljs-string">&quot;$#&quot;</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;n; i++&#123;        t+=<span class="hljs-type">string</span>(s[i])+<span class="hljs-string">&quot;#&quot;</span>    &#125;    n = <span class="hljs-built_in">len</span>(t)    t+=<span class="hljs-string">&quot;!&quot;</span>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    iMax,rMax,ans := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> rMax &gt;=i&#123;            dp[i] = min(rMax-i+<span class="hljs-number">1</span>, dp[iMax*<span class="hljs-number">2</span>-i])        &#125;<span class="hljs-keyword">else</span>&#123;            dp[i] = <span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">for</span> t[dp[i]+i] == t[i-dp[i]]&#123;            dp[i] = dp[i]+<span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">if</span> i+dp[i] <span class="hljs-number">-1</span> &gt;rMax&#123;            iMax = i            rMax = dp[i]+i<span class="hljs-number">-1</span>        &#125;        ans += dp[i]/<span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a , b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：4.7 MB, 在所有 Go 提交中击败了10.15%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>713. 乘积小于 K 的子数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/713.%20%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/713.%20%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="乘积小于-K-的子数组"><a href="#乘积小于-K-的子数组" class="headerlink" title="乘积小于 K 的子数组"></a><font size=6px>乘积小于 K 的子数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。</p><p>示例 1：</p><p>输入：nums &#x3D; [10,5,2,6], k &#x3D; 100<br>输出：8<br>解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。<br>需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3], k &#x3D; 0<br>输出：0</p><p>提示: </p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>0 &lt;&#x3D; k &lt;&#x3D; 106</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用滑动窗口法求数量</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSubarrayProductLessThanK</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    sum := <span class="hljs-number">1</span>    arr := <span class="hljs-number">0</span>    i := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> j,v := <span class="hljs-keyword">range</span> nums&#123;        sum *= v        <span class="hljs-keyword">for</span> ;i&lt;=j &amp;&amp; sum &gt;= k;i++&#123;            sum /= nums[i]        &#125;        arr += j-i +<span class="hljs-number">1</span>            &#125;    <span class="hljs-keyword">return</span> arr&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：64 ms, 在所有 Go 提交中击败了92.84%的用户<br>   内存消耗：7.2 MB, 在所有 Go 提交中击败了83.70%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>710. 黑名单中的随机数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/710.%20%E9%BB%91%E5%90%8D%E5%8D%95%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/710.%20%E9%BB%91%E5%90%8D%E5%8D%95%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="黑名单中的随机数"><a href="#黑名单中的随机数" class="headerlink" title="黑名单中的随机数"></a><font size=6px>黑名单中的随机数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数 n 和一个 无重复 黑名单整数数组 blacklist 。设计一种算法，从 [0, n - 1] 范围内的任意整数中选取一个 未加入 黑名单 blacklist 的整数。任何在上述范围内且不在黑名单 blacklist 中的整数都应该有 同等的可能性 被返回。</p><p>优化你的算法，使它最小化调用语言 内置 随机函数的次数。</p><p>实现 Solution 类:</p><p>Solution(int n, int[] blacklist) 初始化整数 n 和被加入黑名单 blacklist 的整数<br>int pick() 返回一个范围为 [0, n - 1] 且不在黑名单 blacklist 中的随机整数</p><p>示例 1：</p><p>输入<br>[“Solution”, “pick”, “pick”, “pick”, “pick”, “pick”, “pick”, “pick”]<br>[[7, [2, 3, 5]], [], [], [], [], [], [], []]<br>输出<br>[null, 0, 4, 1, 6, 1, 0, 4]</p><p>解释<br>Solution solution &#x3D; new Solution(7, [2, 3, 5]);<br>solution.pick(); &#x2F;&#x2F; 返回0，任何[0,1,4,6]的整数都可以。注意，对于每一个pick的调用，<br>                 &#x2F;&#x2F; 0、1、4和6的返回概率必须相等(即概率为1&#x2F;4)。<br>solution.pick(); &#x2F;&#x2F; 返回 4<br>solution.pick(); &#x2F;&#x2F; 返回 1<br>solution.pick(); &#x2F;&#x2F; 返回 6<br>solution.pick(); &#x2F;&#x2F; 返回 1<br>solution.pick(); &#x2F;&#x2F; 返回 0<br>solution.pick(); &#x2F;&#x2F; 返回 4</p><p>提示:</p><p>1 &lt;&#x3D; n &lt;&#x3D; 109<br>0 &lt;&#x3D; blacklist.length &lt;&#x3D; min(105, n - 1)<br>0 &lt;&#x3D; blacklist[i] &lt; n<br>blacklist 中所有值都 不同<br> pick 最多被调用 2 * 104 次</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用映射，把n-m的黑数映射到后面</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Solution <span class="hljs-keyword">struct</span> &#123;    bound <span class="hljs-type">int</span>    b2w <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>, blacklist []<span class="hljs-type">int</span>)</span></span> Solution &#123;    black := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>,<span class="hljs-number">0</span>)    m := <span class="hljs-built_in">len</span>(blacklist)    bound := n-m    <span class="hljs-keyword">for</span> _,v :=<span class="hljs-keyword">range</span> blacklist&#123;        <span class="hljs-keyword">if</span> v &gt;= bound&#123;            black[v] = <span class="hljs-literal">true</span>        &#125;    &#125;    w := bound    b2w := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, m-<span class="hljs-built_in">len</span>(black))    <span class="hljs-keyword">for</span> _,b := <span class="hljs-keyword">range</span> blacklist&#123;        <span class="hljs-keyword">if</span> b &lt; bound&#123;            <span class="hljs-keyword">for</span> black[w]&#123;                w++            &#125;            b2w[b] = w            w++        &#125;    &#125;    <span class="hljs-keyword">return</span> Solution&#123;bound,b2w&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Solution)</span></span> Pick() <span class="hljs-type">int</span> &#123;    x := rand.Intn(this.bound)     <span class="hljs-keyword">if</span> this.b2w[x] &gt; <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">return</span> this.b2w[x]    &#125;    <span class="hljs-keyword">return</span> x&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor(n, blacklist);</span><span class="hljs-comment"> * param_1 := obj.Pick();</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：92 ms, 在所有 Go 提交中击败了92.31%的用户<br>   内存消耗：11.7 MB, 在所有 Go 提交中击败了38.46%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>72. 编辑距离</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><font size=6px>编辑距离</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>示例 1：</p><p>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)<br>示例 2：</p><p>输入：word1 &#x3D; “intention”, word2 &#x3D; “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><p>提示：</p><p>0 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 500<br>word1 和 word2 由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第一眼 看就是动态规划题，递推公式推导是比较左边+1，上边+1，左上+check(字母是否相同)三个的最小值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(word1),<span class="hljs-built_in">len</span>(word2)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=m;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)        dp[i][<span class="hljs-number">0</span>] = i    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n;i++&#123;        dp[<span class="hljs-number">0</span>][i] = i    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=n;j++&#123;            left := dp[i<span class="hljs-number">-1</span>][j] +<span class="hljs-number">1</span>            top := dp[i][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>            pre := dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]  + check(word1[i<span class="hljs-number">-1</span>],word2[j<span class="hljs-number">-1</span>])            dp[i][j] = min(left,min(top, pre))        &#125;    &#125;      <span class="hljs-keyword">return</span> dp[m][n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(a,b <span class="hljs-type">byte</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a == b&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了81.82%的用户<br>   内存消耗：5.4 MB, 在所有 Go 提交中击败了94.24%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>728. 自除数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/728.%20%E8%87%AA%E9%99%A4%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/728.%20%E8%87%AA%E9%99%A4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="自除数"><a href="#自除数" class="headerlink" title="自除数"></a><font size=6px>自除数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>自除数 是指可以被它包含的每一位数整除的数。</p><p>例如，128 是一个 自除数 ，因为 128 % 1 &#x3D;&#x3D; 0，128 % 2 &#x3D;&#x3D; 0，128 % 8 &#x3D;&#x3D; 0。<br>自除数 不允许包含 0 。</p><p>给定两个整数 left 和 right ，返回一个列表，列表的元素是范围 [left, right] 内所有的 自除数 。</p><p>示例 1：</p><p>输入：left &#x3D; 1, right &#x3D; 22<br>输出：[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]<br>示例 2:</p><p>输入：left &#x3D; 47, right &#x3D; 85<br>输出：[48,55,66,77]</p><p>提示：</p><p>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; 104<br>通过次数38,103提交次数50,927</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(位数<span class="hljs-operator">*</span>（<span class="hljs-params">right</span>-<span class="hljs-params">left</span>）)</span></code></pre><p>模拟即可</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selfDividingNumbers</span><span class="hljs-params">(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=left;i&lt;=right;i++&#123;        <span class="hljs-keyword">if</span> check(i)&#123;            res = <span class="hljs-built_in">append</span>(res,i)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">var</span> tmp []<span class="hljs-type">int</span>    tmp_num := num    <span class="hljs-keyword">for</span> tmp_num != <span class="hljs-number">0</span>&#123;        tmp = <span class="hljs-built_in">append</span>(tmp,tmp_num%<span class="hljs-number">10</span>)        tmp_num /= <span class="hljs-number">10</span>    &#125;      <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> tmp&#123;        <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>        &#125;        <span class="hljs-keyword">if</span> num % v != <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：4.1 MB, 在所有 Go 提交中击败了6.15%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>720. 词典中最长的单词</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/720.%20%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/720.%20%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="词典中最长的单词"><a href="#词典中最长的单词" class="headerlink" title="词典中最长的单词"></a><font size=6px>词典中最长的单词</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。</p><p>若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。</p><p>示例 1：</p><p>输入：words &#x3D; [“w”,”wo”,”wor”,”worl”, “world”]<br>输出：”world”<br>解释： 单词”world”可由”w”, “wo”, “wor”, 和 “worl”逐步添加一个字母组成。<br>示例 2：</p><p>输入：words &#x3D; [“a”, “banana”, “app”, “appl”, “ap”, “apply”, “apple”]<br>输出：”apple”<br>解释：”apply” 和 “apple” 都能由词典中的单词组成。但是 “apple” 的字典序小于 “apply” </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>时间复杂度n，空间复杂度n</p><p>先排序，使用map，判断前一个字符串在不在map里面，如果在就把这个也放进map。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestWord</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    sort.Strings(words)    n := <span class="hljs-built_in">len</span>(words)    res := <span class="hljs-string">&quot;&quot;</span>    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(words[i]) == <span class="hljs-number">1</span>&#123;            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res)&lt; <span class="hljs-built_in">len</span>(words[i])&#123;                res = words[i]            &#125;            mp[words[i]] = <span class="hljs-number">1</span>        &#125; <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> mp[words[i][:<span class="hljs-built_in">len</span>(words[i])<span class="hljs-number">-1</span>]] == <span class="hljs-number">1</span>&#123;                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) &lt; <span class="hljs-built_in">len</span>(words[i])&#123;                    res = words[i]                &#125;                mp[words[i]] = <span class="hljs-number">1</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了82.88%的用户<br>   内存消耗：6.4 MB, 在所有 Go 提交中击败了90.99%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>714. 买卖股票的最佳时机含手续费</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/714.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/714.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><font size=6px>买卖股票的最佳时机含手续费</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>示例 1：</p><p>输入：prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2<br>输出：8<br>解释：能够达到的最大利润:<br>在此处买入 prices[0] &#x3D; 1<br>在此处卖出 prices[3] &#x3D; 8<br>在此处买入 prices[4] &#x3D; 4<br>在此处卖出 prices[5] &#x3D; 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8<br>示例 2：</p><p>输入：prices &#x3D; [1,3,7,5,10,3], fee &#x3D; 3<br>输出：6</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>有两个状态，持有股票和无股票，动态规划做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>, fee <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(prices)    dp := <span class="hljs-built_in">make</span>([][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]-prices[i])        dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+prices[i]-fee)    &#125;    <span class="hljs-keyword">return</span> max(dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：72 ms, 在所有 Go 提交中击败了83.90%的用户<br>   内存消耗：6.9 MB, 在所有 Go 提交中击败了99.07%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>730. 统计不同回文子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/730.%20%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/730.%20%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="统计不同回文子序列"><a href="#统计不同回文子序列" class="headerlink" title="统计不同回文子序列"></a><font size=6px>统计不同回文子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串 s，返回 s 中不同的非空「回文子序列」个数 。</p><p>通过从 s 中删除 0 个或多个字符来获得子序列。</p><p>如果一个字符序列与它反转后的字符序列一致，那么它是「回文字符序列」。</p><p>如果有某个 i , 满足 ai !&#x3D; bi ，则两个序列 a1, a2, … 和 b1, b2, … 不同。</p><p>注意：</p><p>结果可能很大，你需要对 109 + 7 取模 。</p><p>示例 1：</p><p>输入：s &#x3D; ‘bccb’<br>输出：6<br>解释：6 个不同的非空回文子字符序列分别为：’b’, ‘c’, ‘bb’, ‘cc’, ‘bcb’, ‘bccb’。<br>注意：’bcb’ 虽然出现两次但仅计数一次。<br>示例 2：</p><p>输入：s &#x3D; ‘abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba’<br>输出：104860361<br>解释：共有 3104860382 个不同的非空回文子序列，104860361 对 109 + 7 取模后的值。</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s[i] 仅包含 ‘a’, ‘b’, ‘c’ 或 ‘d’ </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>三维dp</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPalindromicSubsequences</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">const</span> mod <span class="hljs-type">int</span> = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>    n := <span class="hljs-built_in">len</span>(s)    dp := [<span class="hljs-number">4</span>][][]<span class="hljs-type">int</span>&#123;&#125;    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;        dp[i] = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> dp[i] &#123;            dp[i][j] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)        &#125;    &#125;    <span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s &#123;        dp[c-<span class="hljs-string">&#x27;a&#x27;</span>][i][i] = <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> size :=<span class="hljs-number">2</span>; size&lt;=n;size++&#123;        <span class="hljs-keyword">for</span> i,j := <span class="hljs-number">0</span>,size<span class="hljs-number">-1</span>;j&lt;n;i++&#123;            <span class="hljs-keyword">for</span> k,c := <span class="hljs-number">0</span>,<span class="hljs-type">byte</span>(<span class="hljs-string">&#x27;a&#x27;</span>);k&lt;<span class="hljs-number">4</span>;k++&#123;                <span class="hljs-keyword">if</span> s[i]==c &amp;&amp; s[j] != c&#123;                    dp[k][i][j] = dp[k][i][j<span class="hljs-number">-1</span>]                &#125;                <span class="hljs-keyword">if</span> s[i]!=c &amp;&amp; s[j] == c&#123;                     dp[k][i][j] = dp[k][i+<span class="hljs-number">1</span>][j]                &#125;                <span class="hljs-keyword">if</span> s[i]!=c &amp;&amp; s[j] != c&#123;                    dp[k][i][j] = dp[k][i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]                &#125;                <span class="hljs-keyword">if</span> s[i] == c &amp;&amp; s[j] == c&#123;                    dp[k][i][j] = (<span class="hljs-number">2</span> + dp[<span class="hljs-number">0</span>][i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + dp[<span class="hljs-number">1</span>][i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + dp[<span class="hljs-number">2</span>][i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + dp[<span class="hljs-number">3</span>][i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]) % mod                &#125;                c++            &#125;            j++        &#125;    &#125;    <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dp &#123;        ans += d[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]    &#125;    <span class="hljs-keyword">return</span> ans % mod&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：92 ms, 在所有 Go 提交中击败了45.75%的用户<br>   内存消耗：64.6 MB, 在所有 Go 提交中击败了39.13%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>739. 每日温度</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/739.%20Daily%20Temperatures/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/739.%20Daily%20Temperatures/</url>
    
    <content type="html"><![CDATA[<h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><font size=6px>每日温度</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>示例 1:</p><p>输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]<br>示例 2:</p><p>输入: temperatures &#x3D; [30,40,50,60]<br>输出: [1,1,1,0]<br>示例 3:</p><p>输入: temperatures &#x3D; [30,60,90]<br>输出: [1,1,0]</p><p>提示：</p><p>1 &lt;&#x3D; temperatures.length &lt;&#x3D; 105<br>30 &lt;&#x3D; temperatures[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从后往前动态规划，从后一个开始找第一个比他大的，每次跳后一个数的第一个比他大的数的跳数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(temperatures []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    j := <span class="hljs-number">0</span>    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(temperatures))    num[<span class="hljs-built_in">len</span>(temperatures)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:= <span class="hljs-built_in">len</span>(temperatures)<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">if</span> temperatures[i] &lt; temperatures[i+<span class="hljs-number">1</span>]&#123;            num[i] = <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            j = i+<span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(temperatures) &amp;&amp; num[j] != <span class="hljs-number">0</span>&#123;                j = num[j]+j                <span class="hljs-keyword">if</span> temperatures[j] &gt; temperatures[i]&#123;                    num[i] = j-i                    <span class="hljs-keyword">break</span>                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> num&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：128 ms, 在所有 Go 提交中击败了82.30%的用户<br>   内存消耗：10 MB, 在所有 Go 提交中击败了6.86%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>717. 1比特与2比特字符</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/717.%201%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/717.%201%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="1比特与2比特字符"><a href="#1比特与2比特字符" class="headerlink" title="1比特与2比特字符"></a><font size=6px>1比特与2比特字符</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有两种特殊字符：</p><p>第一种字符可以用一个比特 0 来表示<br>第二种字符可以用两个比特(10 或 11)来表示、<br>给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。</p><p>示例 1:</p><p>输入: bits &#x3D; [1, 0, 0]<br>输出: true<br>解释: 唯一的编码方式是一个两比特字符和一个一比特字符。<br>所以最后一个字符是一比特字符。<br>示例 2:</p><p>输入: bits &#x3D; [1, 1, 1, 0]<br>输出: false<br>解释: 唯一的编码方式是两比特字符和两比特字符。<br>所以最后一个字符不是一比特字符。</p><p>提示:</p><p>1 &lt;&#x3D; bits.length &lt;&#x3D; 1000<br>bits[i] &#x3D;&#x3D; 0 or 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>遇到1肯定会吃掉下一个0或者1，判断能不能访问最后一个0就可以解出这道题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isOneBitCharacter</span><span class="hljs-params">(bits []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(bits) == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">var</span> i <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(bits);&#123;        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(bits)<span class="hljs-number">-1</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">if</span> bits[i] == <span class="hljs-number">1</span>&#123;            i+=<span class="hljs-number">2</span>        &#125;<span class="hljs-keyword">else</span>&#123;            i ++        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了55.93%的用户<br>   内存消耗：2.6 MB, 在所有 Go 提交中击败了93.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>729. 我的日程安排表 I</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/729.%20%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8%20I/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/729.%20%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8%20I/</url>
    
    <content type="html"><![CDATA[<h3 id="我的日程安排表-I"><a href="#我的日程安排表-I" class="headerlink" title="我的日程安排表 I"></a><font size=6px>我的日程安排表 I</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。</p><p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。</p><p>日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start &lt;&#x3D; x &lt; end 。</p><p>实现 MyCalendar 类：</p><p>MyCalendar() 初始化日历对象。<br>boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true 。否则，返回 false 并且不要将该日程安排添加到日历中。</p><p>示例：</p><p>输入：<br>[“MyCalendar”, “book”, “book”, “book”]<br>[[], [10, 20], [15, 25], [20, 30]]<br>输出：<br>[null, true, false, true]</p><p>解释：<br>MyCalendar myCalendar &#x3D; new MyCalendar();<br>myCalendar.book(10, 20); &#x2F;&#x2F; return True<br>myCalendar.book(15, 25); &#x2F;&#x2F; return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。<br>myCalendar.book(20, 30); &#x2F;&#x2F; return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。</p><p>提示：</p><p>0 &lt;&#x3D; start &lt; end &lt;&#x3D; 109<br>每个测试用例，调用 book 方法的次数最多不超过 1000 次。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用朴素的二分查找</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> MyCalendar <span class="hljs-keyword">struct</span> &#123;    calendar [][]<span class="hljs-type">int</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyCalendar &#123;    <span class="hljs-keyword">return</span> MyCalendar&#123;calendar:[][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;&#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCalendar)</span></span> Book(start <span class="hljs-type">int</span>, end <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;    n := <span class="hljs-built_in">len</span>(this.calendar)    <span class="hljs-keyword">if</span> start &gt;this.calendar[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]&#123;        <span class="hljs-keyword">if</span> start &gt;= this.calendar[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]&#123;            this.calendar = <span class="hljs-built_in">append</span>(this.calendar,[]<span class="hljs-type">int</span>&#123;start,end&#125;)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;<span class="hljs-keyword">else</span>&#123;        sidx := this.erfen(start)        <span class="hljs-keyword">if</span> sidx == <span class="hljs-number">-1</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        <span class="hljs-comment">//fmt.Println(start,end,this.calendar[sidx],this.calendar[sidx+1])</span>        <span class="hljs-keyword">if</span> this.calendar[sidx][<span class="hljs-number">1</span>] &lt;= start &amp;&amp; this.calendar[sidx+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt;=end&#123;            this.calendar = <span class="hljs-built_in">append</span>(this.calendar[:sidx+<span class="hljs-number">1</span>],<span class="hljs-built_in">append</span>([][]<span class="hljs-type">int</span>&#123;&#123;start,end&#125;&#125;,this.calendar[sidx+<span class="hljs-number">1</span>:]...)...)                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCalendar)</span></span> erfen(start <span class="hljs-type">int</span>)<span class="hljs-type">int</span>&#123;    l,r := <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(this.calendar)    <span class="hljs-comment">// fmt.Printf(&quot;%d. &quot;,start)</span>    <span class="hljs-comment">// fmt.Println(this.calendar)</span>    <span class="hljs-keyword">for</span> l&lt;=r&#123;        m := (l+r) / <span class="hljs-number">2</span>;                <span class="hljs-keyword">if</span> start == this.calendar[m][<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> start &gt;this.calendar[m][<span class="hljs-number">0</span>]&#123;            l = m+<span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            r = m<span class="hljs-number">-1</span>        &#125;    &#125;    <span class="hljs-comment">//fmt.Println( l,r)</span>    <span class="hljs-keyword">return</span> r&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MyCalendar object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor();</span><span class="hljs-comment"> * param_1 := obj.Book(start,end);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：88 ms, 在所有 Go 提交中击败了32.34%的用户<br>   内存消耗：7.6 MB, 在所有 Go 提交中击败了20.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>740. 删除并获得点数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/740.%20%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/740.%20%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="删除并获得点数"><a href="#删除并获得点数" class="headerlink" title="删除并获得点数"></a><font size=6px>删除并获得点数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p><p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><p>示例 1：</p><p>输入：nums &#x3D; [3,4,2]<br>输出：6<br>解释：<br>删除 4 获得 4 个点数，因此 3 也被删除。<br>之后，删除 2 获得 2 个点数。总共获得 6 个点数。<br>示例 2：</p><p>输入：nums &#x3D; [2,2,3,3,3,4]<br>输出：9<br>解释：<br>删除 3 获得 3 个点数，接着要删除两个 2 和 4 。<br>之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。<br>总共获得 9 个点数。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span><span class="hljs-operator">*</span><span class="hljs-params">m</span>)</span></code></pre><p>代码写的太丑了不想说思路啦，就是dp</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteAndEarn</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        mp[nums[i]]++    &#125;    nums2 := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> mp&#123;        nums2 =<span class="hljs-built_in">append</span>(nums2,[]<span class="hljs-type">int</span>&#123;k,v&#125;)    &#125;    sort.Slice(nums2,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;        <span class="hljs-keyword">return</span> nums2[i][<span class="hljs-number">0</span>]&lt;nums2[j][<span class="hljs-number">0</span>]    &#125;)    n2 := <span class="hljs-built_in">len</span>(nums2)    dp := <span class="hljs-built_in">make</span>([][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = nums2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]*nums2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n2;i++&#123;        <span class="hljs-keyword">if</span> nums2[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span> == nums2[i][<span class="hljs-number">0</span>]&#123;            dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+nums2[i][<span class="hljs-number">0</span>]*nums2[i][<span class="hljs-number">1</span>])            dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])        &#125;<span class="hljs-keyword">else</span>&#123;            dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])+nums2[i][<span class="hljs-number">0</span>]*nums2[i][<span class="hljs-number">1</span>]            dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])        &#125;    &#125;    <span class="hljs-keyword">return</span> max(dp[n2<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[n2<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了12.78%的用户<br>   内存消耗：6.3 MB, 在所有 Go 提交中击败了7.93%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>735. 行星碰撞</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/735.%20%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/735.%20%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E/</url>
    
    <content type="html"><![CDATA[<h3 id="行星碰撞"><a href="#行星碰撞" class="headerlink" title="行星碰撞"></a><font size=6px>行星碰撞</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 asteroids，表示在同一行的行星。</p><p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p><p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p><p>示例 1：</p><p>输入：asteroids &#x3D; [5,10,-5]<br>输出：[5,10]<br>解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。<br>示例 2：</p><p>输入：asteroids &#x3D; [8,-8]<br>输出：[]<br>解释：8 和 -8 碰撞后，两者都发生爆炸。<br>示例 3：</p><p>输入：asteroids &#x3D; [10,2,-5]<br>输出：[10]<br>解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。</p><p>提示：</p><p>2 &lt;&#x3D; asteroids.length &lt;&#x3D; 104<br>-1000 &lt;&#x3D; asteroids[i] &lt;&#x3D; 1000<br>asteroids[i] !&#x3D; 0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>用数组栈模拟</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asteroidCollision</span><span class="hljs-params">(asteroids []<span class="hljs-type">int</span>)</span></span> (st []<span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">for</span> _, aster := <span class="hljs-keyword">range</span> asteroids &#123;        alive := <span class="hljs-literal">true</span>        <span class="hljs-keyword">for</span> alive &amp;&amp; aster &lt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(st) &gt; <span class="hljs-number">0</span> &amp;&amp; st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> &#123;            alive = st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>] &lt; -aster <span class="hljs-comment">// aster 是否存在</span>            <span class="hljs-keyword">if</span> st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>] &lt;= -aster &#123;   <span class="hljs-comment">// 栈顶行星爆炸</span>                st = st[:<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>]            &#125;        &#125;        <span class="hljs-keyword">if</span> alive &#123;            st = <span class="hljs-built_in">append</span>(st, aster)        &#125;    &#125;    <span class="hljs-keyword">return</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了20.00%的用户<br>   内存消耗：4.4 MB, 在所有 Go 提交中击败了57.50%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>745. 前缀和后缀搜索</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/745.%20%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/745.%20%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="前缀和后缀搜索"><a href="#前缀和后缀搜索" class="headerlink" title="前缀和后缀搜索"></a><font size=6px>前缀和后缀搜索</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词。</p><p>实现 WordFilter 类：</p><p>WordFilter(string[] words) 使用词典中的单词 words 初始化对象。<br>f(string pref, string suff) 返回词典中具有前缀 prefix 和后缀 suff 的单词的下标。如果存在不止一个满足要求的下标，返回其中 最大的下标 。如果不存在这样的单词，返回 -1 。</p><p>示例：</p><p>输入<br>[“WordFilter”, “f”]<br>[[[“apple”]], [“a”, “e”]]<br>输出<br>[null, 0]<br>解释<br>WordFilter wordFilter &#x3D; new WordFilter([“apple”]);<br>wordFilter.f(“a”, “e”); &#x2F;&#x2F; 返回 0 ，因为下标为 0 的单词：前缀 prefix &#x3D; “a” 且 后缀 suff &#x3D; “e” 。</p><p>提示：</p><p>1 &lt;&#x3D; words.length &lt;&#x3D; 104<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 7<br>1 &lt;&#x3D; pref.length, suff.length &lt;&#x3D; 7<br>words[i]、pref 和 suff 仅由小写英文字母组成<br>最多对函数 f 执行 104 次调用</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n^<span class="hljs-number">3</span>),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>用哈希做，暴力简单</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> WordFilter <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> WordFilter &#123;    wf := WordFilter&#123;&#125;    <span class="hljs-keyword">for</span> i,word := <span class="hljs-keyword">range</span> words&#123;        <span class="hljs-keyword">for</span> j,n := <span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(word);j&lt;=n;j++&#123;            <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;n;k++&#123;                wf[word[:j]+<span class="hljs-string">&quot;#&quot;</span>+word[k:]] = i            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> wf&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this WordFilter)</span></span> F(pref <span class="hljs-type">string</span>, suff <span class="hljs-type">string</span>) <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> i,ok := this[pref+<span class="hljs-string">&quot;#&quot;</span>+suff];ok&#123;        <span class="hljs-keyword">return</span> i    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;   <span class="hljs-comment">/**</span><span class="hljs-comment"> * Your WordFilter object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor(words);</span><span class="hljs-comment"> * param_1 := obj.F(pref,suff);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：780 ms, 在所有 Go 提交中击败了20.00%的用户<br>   内存消耗：30 MB, 在所有 Go 提交中击败了52.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>744. 寻找比目标字母大的最小字母</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/744.%20%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/744.%20%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="寻找比目标字母大的最小字母"><a href="#寻找比目标字母大的最小字母" class="headerlink" title="寻找比目标字母大的最小字母"></a><font size=6px>寻找比目标字母大的最小字母</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。</p><p>在比较时，字母是依序循环出现的。举个例子：</p><p>如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’</p><p>示例 1：</p><p>输入: letters &#x3D; [“c”, “f”, “j”]，target &#x3D; “a”<br>输出: “c”<br>示例 2:</p><p>输入: letters &#x3D; [“c”,”f”,”j”], target &#x3D; “c”<br>输出: “f”<br>示例 3:</p><p>输入: letters &#x3D; [“c”,”f”,”j”], target &#x3D; “d”<br>输出: “f”</p><p>提示：</p><p>2 &lt;&#x3D; letters.length &lt;&#x3D; 104<br>letters[i] 是一个小写字母<br>letters 按非递减顺序排序<br>letters 最少包含两个不同的字母<br>target 是一个小写字母</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(logn),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>二分，双百</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextGreatestLetter</span><span class="hljs-params">(letters []<span class="hljs-type">byte</span>, target <span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">byte</span> &#123;    n := <span class="hljs-built_in">len</span>(letters)    l,r := <span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>    idx := n*<span class="hljs-number">2</span>    <span class="hljs-keyword">for</span> l&lt;=r&#123;        mid := (r+l)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> check(letters,target,mid) &#123;            idx = min(idx,mid)            r = mid<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid+<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> letters[idx % n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(letters []<span class="hljs-type">byte</span>, target <span class="hljs-type">byte</span>, mid <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">if</span> letters[mid]&gt;target&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a , b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.5 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>746. 使用最小花费爬楼梯</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><font size=6px>使用最小花费爬楼梯</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p>示例 1：</p><p>输入：cost &#x3D; [10,15,20]<br>输出：15<br>解释：你将从下标为 1 的台阶开始。</p><ul><li>支付 15 ，向上爬两个台阶，到达楼梯顶部。<br>总花费为 15 。<br>示例 2：</li></ul><p>输入：cost &#x3D; [1,100,1,1,1,100,1,1,100,1]<br>输出：6<br>解释：你将从下标为 0 的台阶开始。</p><ul><li>支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</li><li>支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</li><li>支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</li><li>支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</li><li>支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</li><li>支付 1 ，向上爬一个台阶，到达楼梯顶部。<br>总花费为 6 。</li></ul><p>提示：</p><p>2 &lt;&#x3D; cost.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; cost[i] &lt;&#x3D; 999</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;        n := <span class="hljs-built_in">len</span>(cost)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;n;i++&#123;        cost[i] += min(cost[i<span class="hljs-number">-1</span>],cost[i<span class="hljs-number">-2</span>])    &#125;    <span class="hljs-keyword">return</span> min(cost[n<span class="hljs-number">-1</span>],cost[n<span class="hljs-number">-2</span>])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了84.17%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>75. 颜色分类</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><font size=6px>颜色分类</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]<br>示例 2：</p><p>输入：nums &#x3D; [2,0,1]<br>输出：[0,1,2]</p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>nums[i] 为 0、1 或 2</p><p>进阶：</p><p>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>把2放后面，0放前面</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;    n := <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    p0 := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n;i++&#123;        <span class="hljs-keyword">for</span> i&lt;n &amp;&amp; nums[i] ==<span class="hljs-number">2</span>&#123;            nums[i],nums[n] = nums[n], nums[i]            n--        &#125;        <span class="hljs-keyword">for</span> p0 &lt;i &amp;&amp; nums[i] == <span class="hljs-number">0</span>&#123;            nums[p0],nums[i] = nums[i],nums[p0]            p0++        &#125;    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了99.79%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>76. 最小覆盖子串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/76.%20%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/76.%20%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><font size=6px>最小覆盖子串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：</p><p>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”<br>示例 2：</p><p>输入：s &#x3D; “a”, t &#x3D; “a”<br>输出：”a”<br>示例 3:</p><p>输入: s &#x3D; “a”, t &#x3D; “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p><p>提示：</p><p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 105<br>s 和 t 由英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用滑动窗口法来做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    l,r := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    minl, minr := <span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>    lens := <span class="hljs-number">999999</span>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    cnt := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">var</span> checked <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span>    <span class="hljs-comment">// 判断是不是字母都齐了</span>    checked = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span>&#123;        <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m&#123;            <span class="hljs-keyword">if</span> cnt[k] &lt; v&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(t); i++&#123;        m[t[i]] += <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span>  ;r &lt;<span class="hljs-built_in">len</span>(s) ;r++&#123;        <span class="hljs-keyword">if</span> m[s[r]] &gt;<span class="hljs-number">0</span>&#123;            cnt[s[r]] ++        &#125;        <span class="hljs-keyword">for</span> checked() &amp;&amp; l&lt;=r&#123;            <span class="hljs-keyword">if</span> r-l +<span class="hljs-number">1</span> &lt;lens&#123;                lens = r-l+<span class="hljs-number">1</span>                minl, minr = l,l+lens            &#125;            <span class="hljs-keyword">if</span> _,ok := m[s[l]];ok&#123;                cnt[s[l]]--            &#125;            l++        &#125;    &#125;    <span class="hljs-keyword">if</span> minl == <span class="hljs-number">-1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>    &#125;    <span class="hljs-keyword">return</span> s[minl:minr]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：108 ms, 在所有 Go 提交中击败了32.41%的用户<br>   内存消耗：2.7 MB, 在所有 Go 提交中击败了98.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>743. 网络延迟时间</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/743.%20%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/743.%20%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="网络延迟时间"><a href="#网络延迟时间" class="headerlink" title="网络延迟时间"></a><font size=6px>网络延迟时间</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个网络节点，标记为 1 到 n。</p><p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] &#x3D; (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p><p>示例 1：</p><p>输入：times &#x3D; [[2,1,1],[2,3,1],[3,4,1]], n &#x3D; 4, k &#x3D; 2<br>输出：2<br>示例 2：</p><p>输入：times &#x3D; [[1,2,1]], n &#x3D; 2, k &#x3D; 1<br>输出：1<br>示例 3：</p><p>输入：times &#x3D; [[1,2,1]], n &#x3D; 2, k &#x3D; 2<br>输出：-1</p><p>提示：</p><p>1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 100<br>1 &lt;&#x3D; times.length &lt;&#x3D; 6000<br>times[i].length &#x3D;&#x3D; 3<br>1 &lt;&#x3D; ui, vi &lt;&#x3D; n<br>ui !&#x3D; vi<br>0 &lt;&#x3D; wi &lt;&#x3D; 100<br>所有 (ui, vi) 对都 互不相同（即，不含重复边）</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><p>dijkstra算法的应用</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(times [][]<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    INF := <span class="hljs-number">999999</span>    g := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n ;i++&#123;        g[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;=n;j++&#123;            g[i][j] = INF        &#125;    &#125;    st := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>,n+<span class="hljs-number">1</span>)    dist := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> _,time := <span class="hljs-keyword">range</span> times&#123;        g[time[<span class="hljs-number">0</span>]][time[<span class="hljs-number">1</span>]] = time[<span class="hljs-number">2</span>]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        dist[i] = INF    &#125;    dist[k] = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        t := <span class="hljs-number">-1</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j&lt;=n; j++&#123;            <span class="hljs-keyword">if</span> !st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])&#123;                t = j            &#125;        &#125;        st[t] = <span class="hljs-literal">true</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j&lt;=n; j++&#123;            dist[j] = min(dist[j], dist[t] + g[t][j])        &#125;    &#125;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        res = max(res, dist[i])    &#125;    <span class="hljs-keyword">if</span> res == INF&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;        <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了98.78%的用户<br>   内存消耗：7.1 MB, 在所有 Go 提交中击败了91.46%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>768. 最多能完成排序的块 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/769.%20%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/769.%20%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最多能完成排序的块-II"><a href="#最多能完成排序的块-II" class="headerlink" title="最多能完成排序的块 II"></a><font size=6px>最多能完成排序的块 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。</p><p>arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p><p>我们最多能将数组分成多少块？</p><p>示例 1:</p><p>输入: arr &#x3D; [5,4,3,2,1]<br>输出: 1<br>解释:<br>将数组分成2块或者更多块，都无法得到所需的结果。<br>例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。<br>示例 2:</p><p>输入: arr &#x3D; [2,1,3,4,4]<br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。<br>然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。<br>注意:</p><p>arr的长度在[1, 2000]之间。<br>arr[i]的大小在[0, 10**8]之间。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>使用单调栈，特殊的一点在删除单调栈数字的时候，需要先保存最上面的一个删除下面几个</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxChunksToSorted</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> _,x := <span class="hljs-keyword">range</span> arr&#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack) <span class="hljs-number">-1</span>] &lt;=x &#123;            stack = <span class="hljs-built_in">append</span>(stack, x)        &#125;<span class="hljs-keyword">else</span>&#123;            y := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) != <span class="hljs-number">0</span> &amp;&amp; stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span> ]&gt;x&#123;                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            &#125;            stack = <span class="hljs-built_in">append</span>(stack, y)        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了96.15%的用户<br>   内存消耗：3.6 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>741. 摘樱桃</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/741.%20%E6%91%98%E6%A8%B1%E6%A1%83/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/741.%20%E6%91%98%E6%A8%B1%E6%A1%83/</url>
    
    <content type="html"><![CDATA[<h3 id="摘樱桃"><a href="#摘樱桃" class="headerlink" title="摘樱桃"></a><font size=6px>摘樱桃</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：</p><p>0 表示这个格子是空的，所以你可以穿过它。<br>1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。<br>-1 表示这个格子里有荆棘，挡着你的路。<br>你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：</p><p>从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；<br>当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；<br>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；<br>如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。<br>示例 1:</p><p>输入: grid &#x3D;<br>[[0, 1, -1],<br> [1, 0, -1],<br> [1, 1,  1]]<br>输出: 5<br>解释：<br>玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。<br>在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。<br>接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。<br>在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。<br>说明:</p><p>grid 是一个 N * N 的二维数组，N的取值范围是1 &lt;&#x3D; N &lt;&#x3D; 50。<br>每一个 grid[i][j] 都是集合 {-1, 0, 1}其中的一个数。<br>可以保证起点 grid[0][0] 和终点 grid[N-1][N-1] 的值都不会是 -1。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^3)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^3)</span></code></pre><p>是我遇到的线性dp里面最难的题目，需要三维考虑，x1+y1 &#x3D; x2+y2 &#x3D; k</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cherryPickup</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(grid)    dp := <span class="hljs-built_in">make</span>([][][]<span class="hljs-type">int</span>, n*<span class="hljs-number">2</span> - <span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt; n *<span class="hljs-number">2</span><span class="hljs-number">-1</span>;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j &lt; n; j++&#123;            dp[i][j] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)            <span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> dp[i][j] &#123;                dp[i][j][k] = math.MinInt32            &#125;        &#125;    &#125;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> k:=<span class="hljs-number">1</span>; k&lt; <span class="hljs-number">2</span>*n - <span class="hljs-number">1</span>; k++&#123;        <span class="hljs-keyword">for</span> x1 := max(<span class="hljs-number">0</span>, k - n +<span class="hljs-number">1</span>); x1 &lt;=min(n<span class="hljs-number">-1</span>, k);x1++&#123;            y1 := k - x1            <span class="hljs-keyword">if</span> grid[x1][y1] == <span class="hljs-number">-1</span>&#123;                <span class="hljs-keyword">continue</span>            &#125;            <span class="hljs-keyword">for</span> x2 := x1; x2 &lt;=min(n<span class="hljs-number">-1</span>,k); x2++&#123;                y2 := k - x2                <span class="hljs-keyword">if</span> grid[x2][y2] == <span class="hljs-number">-1</span>&#123;                    <span class="hljs-keyword">continue</span>                &#125;                res := dp[k<span class="hljs-number">-1</span>][x1][x2]                <span class="hljs-keyword">if</span> x1 &gt;<span class="hljs-number">0</span>&#123;                    res = max(res, dp[k<span class="hljs-number">-1</span>][x1<span class="hljs-number">-1</span>][x2])                &#125;                <span class="hljs-keyword">if</span> x2 &gt;<span class="hljs-number">0</span>&#123;                    res = max(res, dp[k<span class="hljs-number">-1</span>][x1][x2<span class="hljs-number">-1</span>])                &#125;                <span class="hljs-keyword">if</span> x1 &gt;<span class="hljs-number">0</span> &amp;&amp; x2 &gt;<span class="hljs-number">0</span>&#123;                    res = max(res, dp[k<span class="hljs-number">-1</span>][x1<span class="hljs-number">-1</span>][x2<span class="hljs-number">-1</span>])                &#125;                res += grid[x1][y1]                <span class="hljs-keyword">if</span> x1 != x2&#123;                    res += grid[x2][y2]                &#125;                dp[k][x1][x2] = res            &#125;        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> max(dp[<span class="hljs-number">2</span>*n<span class="hljs-number">-2</span>][n<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>], <span class="hljs-number">0</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了71.72%的用户<br>   内存消耗：7.3 MB, 在所有 Go 提交中击败了50.94%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>768. 最多能完成排序的块 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/768.%20%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/768.%20%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="最多能完成排序的块-II"><a href="#最多能完成排序的块-II" class="headerlink" title="最多能完成排序的块 II"></a><font size=6px>最多能完成排序的块 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。</p><p>arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p><p>我们最多能将数组分成多少块？</p><p>示例 1:</p><p>输入: arr &#x3D; [5,4,3,2,1]<br>输出: 1<br>解释:<br>将数组分成2块或者更多块，都无法得到所需的结果。<br>例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。<br>示例 2:</p><p>输入: arr &#x3D; [2,1,3,4,4]<br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。<br>然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。<br>注意:</p><p>arr的长度在[1, 2000]之间。<br>arr[i]的大小在[0, 10**8]之间。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>使用单调栈，特殊的一点在删除单调栈数字的时候，需要先保存最上面的一个删除下面几个</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxChunksToSorted</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> _,x := <span class="hljs-keyword">range</span> arr&#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack) <span class="hljs-number">-1</span>] &lt;=x &#123;            stack = <span class="hljs-built_in">append</span>(stack, x)        &#125;<span class="hljs-keyword">else</span>&#123;            y := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) != <span class="hljs-number">0</span> &amp;&amp; stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span> ]&gt;x&#123;                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            &#125;            stack = <span class="hljs-built_in">append</span>(stack, y)        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了96.15%的用户<br>   内存消耗：3.6 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>762. 二进制表示中质数个计算置位</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/762.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/762.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="二进制表示中质数个计算置位"><a href="#二进制表示中质数个计算置位" class="headerlink" title="二进制表示中质数个计算置位"></a><font size=6px>二进制表示中质数个计算置位</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你两个整数 left 和 right ，在闭区间 [left, right] 范围内，统计并返回 计算置位位数为质数 的整数个数。</p><p>计算置位位数 就是二进制表示中 1 的个数。</p><p>例如， 21 的二进制表示 10101 有 3 个计算置位。</p><p>示例 1：</p><p>输入：left &#x3D; 6, right &#x3D; 10<br>输出：4<br>解释：<br>6 -&gt; 110 (2 个计算置位，2 是质数)<br>7 -&gt; 111 (3 个计算置位，3 是质数)<br>9 -&gt; 1001 (2 个计算置位，2 是质数)<br>10-&gt; 1010 (2 个计算置位，2 是质数)<br>共计 4 个计算置位为质数的数字。<br>示例 2：</p><p>输入：left &#x3D; 10, right &#x3D; 15<br>输出：5<br>解释：<br>10 -&gt; 1010 (2 个计算置位, 2 是质数)<br>11 -&gt; 1011 (3 个计算置位, 3 是质数)<br>12 -&gt; 1100 (2 个计算置位, 2 是质数)<br>13 -&gt; 1101 (3 个计算置位, 3 是质数)<br>14 -&gt; 1110 (3 个计算置位, 3 是质数)<br>15 -&gt; 1111 (4 个计算置位, 4 不是质数)<br>共计 5 个计算置位为质数的数字。</p><p>提示：</p><p>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; 106<br>0 &lt;&#x3D; right - left &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>模拟</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPrimeSetBits</span><span class="hljs-params">(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    res := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=left;i&lt;=right;i++&#123;        tmp := i        cnt := <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> tmp !=<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> tmp %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;                cnt ++            &#125;            tmp /=<span class="hljs-number">2</span>        &#125;        <span class="hljs-keyword">if</span> check(cnt)&#123;            res++        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> num &lt;=<span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=num/<span class="hljs-number">2</span>;i++&#123;        <span class="hljs-keyword">if</span> num %i ==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了27.69%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了95.38%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>780. 到达终点</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/780.%20%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/780.%20%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="到达终点"><a href="#到达终点" class="headerlink" title="到达终点"></a><font size=6px>到达终点</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。</p><p>从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。</p><p>示例 1:</p><p>输入: sx &#x3D; 1, sy &#x3D; 1, tx &#x3D; 3, ty &#x3D; 5<br>输出: true<br>解释:<br>可以通过以下一系列转换从起点转换到终点：<br>(1, 1) -&gt; (1, 2)<br>(1, 2) -&gt; (3, 2)<br>(3, 2) -&gt; (3, 5)<br>示例 2:</p><p>输入: sx &#x3D; 1, sy &#x3D; 1, tx &#x3D; 2, ty &#x3D; 2<br>输出: false<br>示例 3:</p><p>输入: sx &#x3D; 1, sy &#x3D; 1, tx &#x3D; 1, ty &#x3D; 1<br>输出: true</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>逆序思考，x&#x3D;x+y， 可以逆序转化成x &#x3D; x-y 来思考</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reachingPoints</span><span class="hljs-params">(sx <span class="hljs-type">int</span>, sy <span class="hljs-type">int</span>, tx <span class="hljs-type">int</span>, ty <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">for</span> sx &lt;tx &amp;&amp; sy &lt;ty&#123;        <span class="hljs-keyword">if</span> tx&lt;ty&#123;            ty %= tx        &#125;<span class="hljs-keyword">else</span>&#123;            tx %= ty        &#125;    &#125;    <span class="hljs-keyword">if</span> sx &gt;tx || sy &gt;ty&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> sx == tx&#123;               <span class="hljs-keyword">return</span> (ty-sy) % tx ==<span class="hljs-number">0</span>    &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> (tx-sx) % ty ==<span class="hljs-number">0</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>798. 得分最高的最小轮调</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/798.%20%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BD%AE%E8%B0%83/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/798.%20%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BD%AE%E8%B0%83/</url>
    
    <content type="html"><![CDATA[<h3 id="得分最高的最小轮调"><a href="#得分最高的最小轮调" class="headerlink" title="得分最高的最小轮调"></a><font size=6px>得分最高的最小轮调</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个数组 nums，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 [nums[k], nums[k + 1], … nums[nums.length - 1], nums[0], nums[1], …, nums[k-1]] 的形式。此后，任何值小于或等于其索引的项都可以记作一分。</p><p>例如，数组为 nums &#x3D; [2,4,1,3,0]，我们按 k &#x3D; 2 进行轮调后，它将变成 [1,3,0,2,4]。这将记为 3 分，因为 1 &gt; 0 [不计分]、3 &gt; 1 [不计分]、0 &lt;&#x3D; 2 [计 1 分]、2 &lt;&#x3D; 3 [计 1 分]，4 &lt;&#x3D; 4 [计 1 分]。<br>在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最小的下标 k 。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,3,1,4,0]<br>输出：3<br>解释：<br>下面列出了每个 k 的得分：<br>k &#x3D; 0,  nums &#x3D; [2,3,1,4,0],    score 2<br>k &#x3D; 1,  nums &#x3D; [3,1,4,0,2],    score 3<br>k &#x3D; 2,  nums &#x3D; [1,4,0,2,3],    score 3<br>k &#x3D; 3,  nums &#x3D; [4,0,2,3,1],    score 4<br>k &#x3D; 4,  nums &#x3D; [0,2,3,1,4],    score 3<br>所以我们应当选择 k &#x3D; 3，得分最高。<br>示例 2：</p><p>输入：nums &#x3D; [1,3,0,2,4]<br>输出：0<br>解释：<br>nums 无论怎么变化总是有 3 分。<br>所以我们将选择最小的 k，即 0。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i] &lt; nums.length</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用差分数组做，我看了一早上题解才看懂20多行的代码，太笨啦呜呜呜</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bestRotation</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n:= <span class="hljs-built_in">len</span>(nums)    diffs := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">for</span> i,num := <span class="hljs-keyword">range</span> nums&#123;        low := (i+<span class="hljs-number">1</span>) %n        high := (i -num+n+<span class="hljs-number">1</span>)%n        diffs[low]++        diffs[high]--        <span class="hljs-keyword">if</span>(high &lt;= low)&#123;            diffs[<span class="hljs-number">0</span>]++        &#125;    &#125; score, maxScore, idx := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i, diff := <span class="hljs-keyword">range</span> diffs &#123;        score += diff        <span class="hljs-keyword">if</span> score &gt; maxScore &#123;            maxScore, idx = score, i        &#125;    &#125;    <span class="hljs-keyword">return</span> idx&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：96 ms, 在所有 Go 提交中击败了66.67%的用户<br>   内存消耗：9.2 MB, 在所有 Go 提交中击败了91.67%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>79. 单词搜索</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a><font size=6px>单词搜索</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例 1：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”<br>输出：true<br>示例 2：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “SEE”<br>输出：true<br>示例 3：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCB”<br>输出：false</p><p>提示：</p><p>m &#x3D;&#x3D; board.length<br>n &#x3D; board[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 6<br>1 &lt;&#x3D; word.length &lt;&#x3D; 15<br>board 和 word 仅由大小写英文字母组成</p><p>进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典dfs题，visit访问时要置1，最后访问完后重新置0</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    m,n := <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])     visit := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(board))    valid := <span class="hljs-literal">false</span>    move := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(board); i++&#123;        visit[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(board[i]))    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num, x,y <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(count,x,y <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> count == <span class="hljs-built_in">len</span>(word)&#123;            valid = <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">if</span> valid&#123;            <span class="hljs-keyword">return</span>         &#125;        visit[x][y] = <span class="hljs-literal">true</span>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>;i++&#123;            new_x := x+move[i*<span class="hljs-number">2</span>]            new_y := y+move[i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> new_x &gt;= <span class="hljs-number">0</span> &amp;&amp; new_x &lt; m &amp;&amp; new_y &gt;=<span class="hljs-number">0</span> &amp;&amp; new_y &lt;n &amp;&amp; visit[new_x][new_y] == <span class="hljs-literal">false</span> &amp;&amp; board[new_x][new_y ] == word[count]&#123;                                dfs(count+<span class="hljs-number">1</span>, new_x,new_y)            &#125;        &#125;        visit[x][y] = <span class="hljs-literal">false</span>    &#125;        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(board); i++&#123;        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j&lt;<span class="hljs-built_in">len</span>(board[i]); j++&#123;            count := <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> board[i][j] == word[<span class="hljs-number">0</span>] &amp;&amp; !valid&#123;                                dfs(count, i, j)            &#125;                    &#125;     &#125;    <span class="hljs-keyword">return</span> valid&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：92 ms, 在所有 Go 提交中击败了59.42%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了91.92%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>796. 旋转字符串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/796.%20%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/796.%20%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="旋转字符串"><a href="#旋转字符串" class="headerlink" title="旋转字符串"></a><font size=6px>旋转字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。</p><p>s 的 旋转操作 就是将 s 最左边的字符移动到最右边。 </p><p>例如, 若 s &#x3D; ‘abcde’，在旋转一次之后结果就是’bcdea’ 。</p><p>示例 1:</p><p>输入: s &#x3D; “abcde”, goal &#x3D; “cdeab”<br>输出: true<br>示例 2:</p><p>输入: s &#x3D; “abcde”, goal &#x3D; “abced”<br>输出: false</p><p>提示:</p><p>1 &lt;&#x3D; s.length, goal.length &lt;&#x3D; 100<br>s 和 goal 由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>模拟，旋转len（s）次</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotateString</span><span class="hljs-params">(s <span class="hljs-type">string</span>, goal <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">if</span> s == goal&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;        a := s[<span class="hljs-number">0</span>]        s = s[<span class="hljs-number">1</span>:]+<span class="hljs-type">string</span>(a)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了29.36%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>804. 唯一摩尔斯密码词</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/804.%20%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/804.%20%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="唯一摩尔斯密码词"><a href="#唯一摩尔斯密码词" class="headerlink" title="唯一摩尔斯密码词"></a><font size=6px>唯一摩尔斯密码词</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如:</p><p>‘a’ 对应 “.-“ ，<br>‘b’ 对应 “-…” ，<br>‘c’ 对应 “-.-.” ，以此类推。<br>为了方便，所有 26 个英文字母的摩尔斯密码表如下：</p><p>[“.-“,”-…”,”-.-.”,”-..”,”.”,”..-.”,”–.”,”….”,”..”,”.—“,”-.-“,”.-..”,”–”,”-.”,”—“,”.–.”,”–.-“,”.-.”,”…”,”-“,”..-“,”…-“,”.–”,”-..-“,”-.–”,”–..”]<br>给你一个字符串数组 words ，每个单词可以写成每个字母对应摩尔斯密码的组合。</p><p>例如，”cab” 可以写成 “-.-..–…” ，(即 “-.-.” + “.-“ + “-…” 字符串的结合)。我们将这样一个连接过程称作 单词翻译 。<br>对 words 中所有单词进行单词翻译，返回不同 单词翻译 的数量。</p><p>示例 1：</p><p>输入: words &#x3D; [“gin”, “zen”, “gig”, “msg”]<br>输出: 2<br>解释:<br>各单词翻译如下:<br>“gin” -&gt; “–…-.”<br>“zen” -&gt; “–…-.”<br>“gig” -&gt; “–…–.”<br>“msg” -&gt; “–…–.”</p><p>共有 2 种不同翻译, “–…-.” 和 “–…–.”.<br>示例 2：</p><p>输入：words &#x3D; [“a”]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; words.length &lt;&#x3D; 100<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 12<br>words[i] 由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用map做很容易</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniqueMorseRepresentations</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;       dictionary := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;.-&quot;</span>,<span class="hljs-string">&quot;-...&quot;</span>,<span class="hljs-string">&quot;-.-.&quot;</span>,<span class="hljs-string">&quot;-..&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;..-.&quot;</span>,<span class="hljs-string">&quot;--.&quot;</span>,<span class="hljs-string">&quot;....&quot;</span>,<span class="hljs-string">&quot;..&quot;</span>,<span class="hljs-string">&quot;.---&quot;</span>,<span class="hljs-string">&quot;-.-&quot;</span>,<span class="hljs-string">&quot;.-..&quot;</span>,<span class="hljs-string">&quot;--&quot;</span>,<span class="hljs-string">&quot;-.&quot;</span>,<span class="hljs-string">&quot;---&quot;</span>,<span class="hljs-string">&quot;.--.&quot;</span>,<span class="hljs-string">&quot;--.-&quot;</span>,<span class="hljs-string">&quot;.-.&quot;</span>,<span class="hljs-string">&quot;...&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;..-&quot;</span>,<span class="hljs-string">&quot;...-&quot;</span>,<span class="hljs-string">&quot;.--&quot;</span>,<span class="hljs-string">&quot;-..-&quot;</span>,<span class="hljs-string">&quot;-.--&quot;</span>,<span class="hljs-string">&quot;--..&quot;</span>&#125;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>,<span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> _,words := <span class="hljs-keyword">range</span> words&#123;        s := <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-keyword">for</span> _,word := <span class="hljs-keyword">range</span> words&#123;            s += dictionary[word-<span class="hljs-string">&#x27;a&#x27;</span>]        &#125;        mp[s] = <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(mp)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了93.10%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>810. 黑板异或游戏</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/810.%20%E9%BB%91%E6%9D%BF%E5%BC%82%E6%88%96%E6%B8%B8%E6%88%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/810.%20%E9%BB%91%E6%9D%BF%E5%BC%82%E6%88%96%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="黑板异或游戏"><a href="#黑板异或游戏" class="headerlink" title="黑板异或游戏"></a><font size=6px>黑板异或游戏</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>黑板上写着一个非负整数数组 nums[i] 。</p><p>Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。</p><p>并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0 ，这个玩家获胜。</p><p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。</p><p>示例 1：</p><p>输入: nums &#x3D; [1,1,2]<br>输出: false<br>解释:<br>Alice 有两个选择: 擦掉数字 1 或 2。<br>如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 &#x3D; 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。<br>如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 &#x3D; 0。Alice 仍然会输掉游戏。<br>示例 2:</p><p>输入: nums &#x3D; [0,1]<br>输出: true<br>示例 3:</p><p>输入: nums &#x3D; [1,2,3]<br>输出: true</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums[i] &lt; 216</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用数学推导做，偶数必赢，奇数除非一开始就是0否则输</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">xorGame</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    xor := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;        xor ^= num    &#125;    <span class="hljs-keyword">return</span> xor == <span class="hljs-number">0</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了96.39%的用户<br>   内存消耗：3.7 MB, 在所有 Go 提交中击败了75.90%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>806. 写字符串需要的行数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/806.%20%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E8%A1%8C%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/806.%20%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E8%A1%8C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="写字符串需要的行数"><a href="#写字符串需要的行数" class="headerlink" title="写字符串需要的行数"></a><font size=6px>写字符串需要的行数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 widths ，这个数组 widths[0] 代表 ‘a’ 需要的单位， widths[1] 代表 ‘b’ 需要的单位，…， widths[25] 代表 ‘z’ 需要的单位。</p><p>现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。</p><p>示例 1:<br>输入:<br>widths &#x3D; [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]<br>S &#x3D; “abcdefghijklmnopqrstuvwxyz”<br>输出: [3, 60]<br>解释:<br>所有的字符拥有相同的占用单位10。所以书写所有的26个字母，<br>我们需要2个整行和占用60个单位的一行。<br>示例 2:<br>输入:<br>widths &#x3D; [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]<br>S &#x3D; “bbbcccdddaaa”<br>输出: [2, 4]<br>解释:<br>除去字母’a’所有的字符都是相同的单位10，并且字符串 “bbbcccdddaa” 将会覆盖 9 * 10 + 2 * 4 &#x3D; 98 个单位.<br>最后一个字母 ‘a’ 将会被写到第二行，因为第一行只剩下2个单位了。<br>所以，这个答案是2行，第二行有4个单位宽度。</p><p>注:</p><p>字符串 S 的长度在 [1, 1000] 的范围。<br>S 只包含小写字母。<br>widths 是长度为 26的数组。<br>widths[i] 值的范围在 [2, 10]。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>模拟即可</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfLines</span><span class="hljs-params">(widths []<span class="hljs-type">int</span>, s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;    hight,width :=<span class="hljs-number">1</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s&#123;        width += widths[v-<span class="hljs-string">&#x27;a&#x27;</span>]        <span class="hljs-keyword">if</span> width&gt;<span class="hljs-number">100</span>&#123;            width = <span class="hljs-number">0</span>            width += widths[v-<span class="hljs-string">&#x27;a&#x27;</span>]            hight++        &#125;    &#125;    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;hight,width&#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>819. 最常见的单词</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/819.%20%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/819.%20%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="最常见的单词"><a href="#最常见的单词" class="headerlink" title="最常见的单词"></a><font size=6px>最常见的单词</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。</p><p>题目保证至少有一个词不在禁用列表中，而且答案唯一。</p><p>禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。</p><p>示例：</p><p>输入:<br>paragraph &#x3D; “Bob hit a ball, the hit BALL flew far after it was hit.”<br>banned &#x3D; [“hit”]<br>输出: “ball”<br>解释:<br>“hit” 出现了3次，但它是一个禁用的单词。<br>“ball” 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。<br>注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 “ball,”），<br>“hit”不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。</p><p>提示：</p><p>1 &lt;&#x3D; 段落长度 &lt;&#x3D; 1000<br>0 &lt;&#x3D; 禁用单词个数 &lt;&#x3D; 100<br>1 &lt;&#x3D; 禁用单词长度 &lt;&#x3D; 10<br>答案是唯一的, 且都是小写字母 (即使在 paragraph 里是大写的，即使是一些特定的名词，答案都是小写的。)<br>paragraph 只包含字母、空格和下列标点符号!?’,;.<br>不存在没有连字符或者带有连字符的单词。<br>单词里只包含字母，不会出现省略号或者其他标点符号。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>先全部转化成小写字母， 使用map存储，如果在ban里面就把他们的频率设为0.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mostCommonWord</span><span class="hljs-params">(paragraph <span class="hljs-type">string</span>, banned []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    mp1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">var</span> words <span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> paragraph&#123;        <span class="hljs-keyword">if</span> v &gt;=<span class="hljs-string">&#x27;a&#x27;</span>  &amp;&amp; v &lt;= <span class="hljs-string">&#x27;z&#x27;</span>&#123;            words += <span class="hljs-type">string</span>(v)        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>&#123;            words += <span class="hljs-type">string</span>(v+<span class="hljs-number">32</span>)        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> words != <span class="hljs-string">&quot;&quot;</span>&#123;            mp1[words]++            words = <span class="hljs-string">&quot;&quot;</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> words != <span class="hljs-string">&quot;&quot;</span>&#123;        mp1[words]++    &#125;    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> banned&#123;        mp1[v] = <span class="hljs-number">0</span>    &#125;    maxNum,maxWords := <span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> mp1&#123;        <span class="hljs-keyword">if</span> v &gt;maxNum&#123;            maxNum = v            maxWords = k        &#125;    &#125;    <span class="hljs-keyword">return</span> maxWords&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了91.57%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>78. 子集</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/78.%20%E5%AD%90%E9%9B%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/78.%20%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a><font size=6px>子集</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p><p>输入：nums &#x3D; [0]<br>输出：[[],[0]]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典d f s</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> temp []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>        <span class="hljs-keyword">if</span> nums == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> res    &#125;    <span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(temp []<span class="hljs-type">int</span>, idx <span class="hljs-type">int</span>)</span></span>    f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(temp []<span class="hljs-type">int</span>, idx <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> idx &gt; <span class="hljs-built_in">len</span>(nums)&#123;            <span class="hljs-keyword">return</span>         &#125;        copy_temp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span> , <span class="hljs-built_in">len</span>(temp))        <span class="hljs-built_in">copy</span>(copy_temp, temp)        res = <span class="hljs-built_in">append</span>(res, copy_temp)        <span class="hljs-keyword">for</span> i:=idx;i&lt; <span class="hljs-built_in">len</span>(nums); i++&#123;            temp = <span class="hljs-built_in">append</span>(temp, nums[i])            f(temp, i+<span class="hljs-number">1</span>)            temp = temp[:<span class="hljs-built_in">len</span>(temp)<span class="hljs-number">-1</span>]        &#125;    &#125;    f(temp, <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>821. 字符的最短距离</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/821.%20%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/821.%20%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="字符的最短距离"><a href="#字符的最短距离" class="headerlink" title="字符的最短距离"></a><font size=6px>字符的最短距离</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。</p><p>返回一个整数数组 answer ，其中 answer.length &#x3D;&#x3D; s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。</p><p>两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。</p><p>示例 1：</p><p>输入：s &#x3D; “loveleetcode”, c &#x3D; “e”<br>输出：[3,2,1,0,1,0,0,1,2,2,1,0]<br>解释：字符 ‘e’ 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。<br>距下标 0 最近的 ‘e’ 出现在下标 3 ，所以距离为 abs(0 - 3) &#x3D; 3 。<br>距下标 1 最近的 ‘e’ 出现在下标 3 ，所以距离为 abs(1 - 3) &#x3D; 2 。<br>对于下标 4 ，出现在下标 3 和下标 5 处的 ‘e’ 都离它最近，但距离是一样的 abs(4 - 3) &#x3D;&#x3D; abs(4 - 5) &#x3D; 1 。<br>距下标 8 最近的 ‘e’ 出现在下标 6 ，所以距离为 abs(8 - 6) &#x3D; 2 。<br>示例 2：</p><p>输入：s &#x3D; “aaab”, c &#x3D; “b”<br>输出：[3,2,1,0]</p><p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s[i] 和 c 均为小写英文字母<br>题目数据保证 c 在 s 中至少出现一次</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>使用双指针法，动态维护pre和next，插入一个哨兵99999防止讨论边界情况</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shortestToChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>, c <span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> wordIdx []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> k,_ := <span class="hljs-keyword">range</span> s&#123;        <span class="hljs-keyword">if</span> s[k] == c&#123;            wordIdx = <span class="hljs-built_in">append</span>(wordIdx, k)        &#125;    &#125;    wordIdx = <span class="hljs-built_in">append</span>(wordIdx,<span class="hljs-number">999999</span>)    pre,next := <span class="hljs-number">0</span>,<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> k,_ := <span class="hljs-keyword">range</span> s&#123;        <span class="hljs-keyword">if</span> abs(wordIdx[pre]-k) &lt; abs(wordIdx[next] -k)&#123;            res = <span class="hljs-built_in">append</span>(res, abs(wordIdx[pre]-k))        &#125;<span class="hljs-keyword">else</span>&#123;            res = <span class="hljs-built_in">append</span>(res, abs(wordIdx[next] -k))            pre = next            next += <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> -a    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了37.04%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>838. 推多米诺</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/838.%20%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/838.%20%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="推多米诺"><a href="#推多米诺" class="headerlink" title="推多米诺"></a><font size=6px>推多米诺</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。</p><p>每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。</p><p>如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。</p><p>就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。</p><p>给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中：</p><p>dominoes[i] &#x3D; ‘L’，表示第 i 张多米诺骨牌被推向左侧，<br>dominoes[i] &#x3D; ‘R’，表示第 i 张多米诺骨牌被推向右侧，<br>dominoes[i] &#x3D; ‘.’，表示没有推动第 i 张多米诺骨牌。<br>返回表示最终状态的字符串。</p><p>示例 1：</p><p>输入：dominoes &#x3D; “RR.L”<br>输出：”RR.L”<br>解释：第一张多米诺骨牌没有给第二张施加额外的力。<br>示例 2：</p><p>输入：dominoes &#x3D; “.L.R…LR..L..”<br>输出：”LL.RR.LLRRLL..”</p><p>提示：</p><p>n &#x3D;&#x3D; dominoes.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用一种很简单巧妙的替换思路来做，一看就懂</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pushDominoes</span><span class="hljs-params">(dominoes <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    old := <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">for</span> old != dominoes&#123;        old = dominoes        dominoes =  strings.Replace(dominoes,<span class="hljs-string">&quot;R.L&quot;</span>,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-number">-1</span>)        dominoes = strings.Replace(dominoes,<span class="hljs-string">&quot;.L&quot;</span>,<span class="hljs-string">&quot;LL&quot;</span>,<span class="hljs-number">-1</span>)        dominoes = strings.Replace(dominoes,<span class="hljs-string">&quot;R.&quot;</span>,<span class="hljs-string">&quot;RR&quot;</span>,<span class="hljs-number">-1</span>)        dominoes = strings.Replace(dominoes,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;R.L&quot;</span>,<span class="hljs-number">-1</span>)    &#125;    <span class="hljs-keyword">return</span> dominoes&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：112 ms, 在所有 Go 提交中击败了6.67%的用户<br>   内存消耗：6.9 MB, 在所有 Go 提交中击败了46.67%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>824. 山羊拉丁文</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/824.%20%E5%B1%B1%E7%BE%8A%E6%8B%89%E4%B8%81%E6%96%87/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/824.%20%E5%B1%B1%E7%BE%8A%E6%8B%89%E4%B8%81%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h3 id="山羊拉丁文"><a href="#山羊拉丁文" class="headerlink" title="山羊拉丁文"></a><font size=6px>山羊拉丁文</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个由若干单词组成的句子 sentence ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。</p><p>请你将句子转换为 “山羊拉丁文（Goat Latin）”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。山羊拉丁文的规则如下：</p><p>如果单词以元音开头（’a’, ‘e’, ‘i’, ‘o’, ‘u’），在单词后添加”ma”。<br>例如，单词 “apple” 变为 “applema” 。<br>如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加”ma”。<br>例如，单词 “goat” 变为 “oatgma” 。<br>根据单词在句子中的索引，在单词最后添加与索引相同数量的字母’a’，索引从 1 开始。<br>例如，在第一个单词后添加 “a” ，在第二个单词后添加 “aa” ，以此类推。<br>返回将 sentence 转换为山羊拉丁文后的句子。</p><p>示例 1：</p><p>输入：sentence &#x3D; “I speak Goat Latin”<br>输出：”Imaa peaksmaaa oatGmaaaa atinLmaaaaa”<br>示例 2：</p><p>输入：sentence &#x3D; “The quick brown fox jumped over the lazy dog”<br>输出：”heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa”</p><p>提示：</p><p>1 &lt;&#x3D; sentence.length &lt;&#x3D; 150<br>sentence 由英文字母和空格组成<br>sentence 不含前导或尾随空格<br>sentence 中的所有单词由单个空格分隔</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>使用split分割后用join连接即可</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toGoatLatin</span><span class="hljs-params">(sentence <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    words := strings.Split(sentence, <span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">for</span> k,word := <span class="hljs-keyword">range</span> words&#123;        <span class="hljs-keyword">if</span> word[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;a&#x27;</span>||word[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;e&#x27;</span>||word[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;i&#x27;</span>||word[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;o&#x27;</span>||word[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;u&#x27;</span>||word[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span>||word[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;E&#x27;</span>||word[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>||word[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>||word[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;U&#x27;</span>&#123;            word+=<span class="hljs-string">&quot;ma&quot;</span>        &#125;<span class="hljs-keyword">else</span>&#123;            w := word[<span class="hljs-number">0</span>]            word = word[<span class="hljs-number">1</span>:]            word += <span class="hljs-type">string</span>(w)+<span class="hljs-string">&quot;ma&quot;</span>        &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=k;i++&#123;                word += <span class="hljs-string">&quot;a&quot;</span>        &#125;        words[k] = word    &#125;    fmt.Println(words)    <span class="hljs-keyword">return</span> strings.Join(words,<span class="hljs-string">&quot; &quot;</span>)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.3 MB, 在所有 Go 提交中击败了30.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>873. 最长的斐波那契子序列的长度</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/873.%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/873.%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="最长的斐波那契子序列的长度"><a href="#最长的斐波那契子序列的长度" class="headerlink" title="最长的斐波那契子序列的长度"></a><font size=6px>最长的斐波那契子序列的长度</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><p>n &gt;&#x3D; 3<br>对于所有 i + 2 &lt;&#x3D; n，都有 X_i + X_{i+1} &#x3D; X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p><p>示例 1：</p><p>输入: arr &#x3D; [1,2,3,4,5,6,7,8]<br>输出: 5<br>解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。<br>示例 2：</p><p>输入: arr &#x3D; [1,3,7,11,12,14,18]<br>输出: 3<br>解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</p><p>提示：</p><p>3 &lt;&#x3D; arr.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; arr[i] &lt; arr[i + 1] &lt;&#x3D; 10^9</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><p>用二维dp做，dpi j代表以i和j结尾的斐波那契数列。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;       n := <span class="hljs-built_in">len</span>(arr)     mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;        mp[arr[i]] = i    &#125;    <span class="hljs-keyword">for</span> i,v := <span class="hljs-keyword">range</span> arr&#123;        <span class="hljs-keyword">for</span> j:=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j]*<span class="hljs-number">2</span> &gt;v;j--&#123;            <span class="hljs-keyword">if</span> k,ok := mp[v-arr[j]];ok&#123;                dp[j][i] = max(<span class="hljs-number">3</span>,dp[k][j]+<span class="hljs-number">1</span>)                res = max(res,dp[j][i])            &#125;        &#125;    &#125;   <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：240 ms, 在所有 Go 提交中击败了18.18%的用户<br>   内存消耗：17.5 MB, 在所有 Go 提交中击败了53.25%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>868. 二进制间距</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/868.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%B4%E8%B7%9D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/868.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%B4%E8%B7%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="二进制间距"><a href="#二进制间距" class="headerlink" title="二进制间距"></a><font size=6px>二进制间距</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。</p><p>如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，”1001” 中的两个 1 的距离为 3 。</p><p>示例 1：</p><p>输入：n &#x3D; 22<br>输出：2<br>解释：22 的二进制是 “10110” 。<br>在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。<br>第一对相邻的 1 中，两个 1 之间的距离为 2 。<br>第二对相邻的 1 中，两个 1 之间的距离为 1 。<br>答案取两个距离之中最大的，也就是 2 。<br>示例 2：</p><p>输入：n &#x3D; 8<br>输出：0<br>解释：8 的二进制是 “1000” 。<br>在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。<br>示例 3：</p><p>输入：n &#x3D; 5<br>输出：2<br>解释：5 的二进制是 “101” 。</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(logk),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用一个pre来存储上一个1的位置</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binaryGap</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    res,pre := <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>    k :=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> n!=<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> n %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;            <span class="hljs-keyword">if</span> pre!= <span class="hljs-number">-1</span>&#123;                res = max(res, k-pre)            &#125;            pre = k        &#125;        k++        n /= <span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了78.57%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>875. 爱吃香蕉的珂珂</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/875.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/875.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url>
    
    <content type="html"><![CDATA[<h3 id="爱吃香蕉的珂珂"><a href="#爱吃香蕉的珂珂" class="headerlink" title="爱吃香蕉的珂珂"></a><font size=6px>爱吃香蕉的珂珂</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p><p>示例 1：</p><p>输入：piles &#x3D; [3,6,7,11], h &#x3D; 8<br>输出：4<br>示例 2：</p><p>输入：piles &#x3D; [30,11,23,4,20], h &#x3D; 5<br>输出：30<br>示例 3：</p><p>输入：piles &#x3D; [30,11,23,4,20], h &#x3D; 6<br>输出：23</p><p>提示：</p><p>1 &lt;&#x3D; piles.length &lt;&#x3D; 104<br>piles.length &lt;&#x3D; h &lt;&#x3D; 109<br>1 &lt;&#x3D; piles[i] &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogm</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>简单二分答案题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(piles []<span class="hljs-type">int</span>, h <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    min,max := <span class="hljs-number">1</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> _, pile := <span class="hljs-keyword">range</span> piles &#123;        <span class="hljs-keyword">if</span> pile &gt; max &#123;            max = pile        &#125;    &#125;    <span class="hljs-keyword">for</span> min&lt;=max&#123;        mid = (min + max)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> erfen(piles,mid,h)&#123;            max = mid<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            min = mid+<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> min&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">erfen</span><span class="hljs-params">(piles []<span class="hljs-type">int</span>,k <span class="hljs-type">int</span>,h <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">var</span> spend <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span>  i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(piles);i++&#123;        spend += (piles[i]+k<span class="hljs-number">-1</span>)/k    &#125;    <span class="hljs-keyword">if</span> spend&lt;=h &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：32 ms, 在所有 Go 提交中击败了44.15%的用户<br>   内存消耗：6.4 MB, 在所有 Go 提交中击败了79.65%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>884. 两句话中的不常见单词</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/884.%20%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/884.%20%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="两句话中的不常见单词"><a href="#两句话中的不常见单词" class="headerlink" title="两句话中的不常见单词"></a><font size=6px>两句话中的不常见单词</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。</p><p>如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。</p><p>给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。</p><p>示例 1：</p><p>输入：s1 &#x3D; “this apple is sweet”, s2 &#x3D; “this apple is sour”<br>输出：[“sweet”,”sour”]<br>示例 2：</p><p>输入：s1 &#x3D; “apple apple”, s2 &#x3D; “banana”<br>输出：[“banana”]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用map来做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uncommonFromSentences</span><span class="hljs-params">(s1 <span class="hljs-type">string</span>, s2 <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    s1_s := strings.Split(s1,<span class="hljs-string">&quot; &quot;</span>)    s2_s := strings.Split(s2, <span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1_s);i++&#123;        m[s1_s[i]] +=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s2_s);i++&#123;        m[s2_s[i]] +=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m&#123;        <span class="hljs-keyword">if</span> v ==<span class="hljs-number">1</span>&#123;            res = <span class="hljs-built_in">append</span>(res, k)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>883. 三维形体投影面积</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/883.%20%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E6%8A%95%E5%BD%B1%E9%9D%A2%E7%A7%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/883.%20%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E6%8A%95%E5%BD%B1%E9%9D%A2%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="三维形体投影面积"><a href="#三维形体投影面积" class="headerlink" title="三维形体投影面积"></a><font size=6px>三维形体投影面积</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在 n x n 的网格 grid 中，我们放置了一些与 x，y，z 三轴对齐的 1 x 1 x 1 立方体。</p><p>每个值 v &#x3D; grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。</p><p>现在，我们查看这些立方体在 xy 、yz 和 zx 平面上的投影。</p><p>投影 就像影子，将 三维 形体映射到一个 二维 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。</p><p>返回 所有三个投影的总面积 。</p><p>示例 1：</p><p>输入：[[1,2],[3,4]]<br>输出：17<br>解释：这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。<br>示例 2:</p><p>输入：grid &#x3D; [[2]]<br>输出：5<br>示例 3：</p><p>输入：[[1,0],[0,2]]<br>输出：8</p><p>提示：</p><p>n &#x3D;&#x3D; grid.length &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 50<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 50</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>求一行最大值和一列最大值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">projectionArea</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    left,right,top := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i,row := <span class="hljs-keyword">range</span> grid&#123;                        maxNum1,maxNum2 := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> j,v := <span class="hljs-keyword">range</span> row&#123;            <span class="hljs-keyword">if</span> v !=<span class="hljs-number">0</span>&#123;                top++            &#125;            maxNum1 = max(maxNum1,v)            maxNum2 = max(maxNum2, grid[j][i])        &#125;        left += maxNum1        right += maxNum2    &#125;    <span class="hljs-keyword">return</span> left+right+top    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span> <span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了90.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>890. 查找和替换模式</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/890.%20%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/890.%20%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="查找和替换模式"><a href="#查找和替换模式" class="headerlink" title="查找和替换模式"></a><font size=6px>查找和替换模式</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你有一个单词列表 words 和一个模式  pattern，你想知道 words 中的哪些单词与模式匹配。</p><p>如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。</p><p>（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）</p><p>返回 words 中与给定模式匹配的单词列表。</p><p>你可以按任何顺序返回答案。</p><p>示例：</p><p>输入：words &#x3D; [“abc”,”deq”,”mee”,”aqq”,”dkd”,”ccc”], pattern &#x3D; “abb”<br>输出：[“mee”,”aqq”]<br>解释：<br>“mee” 与模式匹配，因为存在排列 {a -&gt; m, b -&gt; e, …}。<br>“ccc” 与模式不匹配，因为 {a -&gt; c, b -&gt; c, …} 不是排列。<br>因为 a 和 b 映射到同一个字母。</p><p>提示：</p><p>1 &lt;&#x3D; words.length &lt;&#x3D; 50<br>1 &lt;&#x3D; pattern.length &#x3D; words[i].length &lt;&#x3D; 20</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>每次双层循环判断是否格式相同</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findAndReplacePattern</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> _,word := <span class="hljs-keyword">range</span> words&#123;        flag := <span class="hljs-literal">false</span>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(word);i++&#123;            <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;<span class="hljs-built_in">len</span>(word);j++&#123;                <span class="hljs-keyword">if</span> !(pattern[i] == pattern[j]) ==  (word[i] == word[j])&#123;                    flag = <span class="hljs-literal">true</span>                    <span class="hljs-keyword">break</span>                &#125;            &#125;                    &#125;        <span class="hljs-keyword">if</span> !flag&#123;            res = <span class="hljs-built_in">append</span>(res, word)        &#125;    &#125;    <span class="hljs-keyword">return</span> res    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>88. 合并两个有序数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><font size=6px>合并两个有序数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br>示例 2：</p><p>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br>示例 3：</p><p>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p><p>提示：</p><p>nums1.length &#x3D;&#x3D; m + n<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 200<br>1 &lt;&#x3D; m + n &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">m</span>+<span class="hljs-params">n</span> <span class="hljs-operator">*</span><span class="hljs-params">logn</span>)</span>,空间复杂度<span class="hljs-constructor">O(1)</span></code></pre><p>我的时间复杂度不是O（m+n），排序过了，就是如果nums1比nums2大，就交换，然后把nums2排序一下。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, m <span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span>  &#123;    l, r := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> l&lt;m &amp;&amp; r &lt;n&#123;        <span class="hljs-keyword">if</span> nums1[l] &lt;= nums2[r]&#123;            l++        &#125;<span class="hljs-keyword">else</span>&#123;            nums1[l], nums2[r] = nums2[r], nums1[l]            sort.Ints(nums2)            l++        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(nums1,nums2)</span>    <span class="hljs-keyword">for</span> l:=m;l&lt;m+n;l++&#123;        nums1[l] = nums2[r]        r++    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了52.20%的用户</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code class="hljs smali">// 从后往前才是正解func merge(nums1 []int, m int, nums2 []int, n int) &#123;    for p1, p2, tail<span class="hljs-keyword"> :</span>= m-1, n-1, m+n-1; p1 &gt;= 0 || p2 &gt;= 0; tail-- &#123;        var cur<span class="hljs-built_in"> int</span><span class="hljs-built_in"></span>       <span class="hljs-built_in"> if </span>p1 == -1 &#123;            cur = nums2[p2]            p2--        &#125; else<span class="hljs-built_in"> if </span>p2 == -1 &#123;            cur = nums1[p1]            p1--        &#125; else<span class="hljs-built_in"> if </span>nums1[p1] &gt; nums2[p2] &#123;            cur = nums1[p1]            p1--        &#125; else &#123;            cur = nums2[p2]            p2--        &#125;        nums1[tail] = cur    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>899. 有序队列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/899.%20%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/899.%20%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="有序队列"><a href="#有序队列" class="headerlink" title="有序队列"></a><font size=6px>有序队列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串 s 和一个整数 k 。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。</p><p>返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串 。</p><p>示例 1：</p><p>输入：s &#x3D; “cba”, k &#x3D; 1<br>输出：”acb”<br>解释：<br>在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。<br>在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。<br>示例 2：</p><p>输入：s &#x3D; “baaca”, k &#x3D; 3<br>输出：”aaabc”<br>解释：<br>在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。<br>在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。</p><p>提示：</p><p>1 &lt;&#x3D; k &lt;&#x3D; S.length &lt;&#x3D; 1000<br>s 只由小写字母组成。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>可以证明，如果k》&#x3D;2，那就升序就是最小，如果k&#x3D;&#x3D;1，那就顺序遍历一遍找到最小值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">orderlyQueue</span><span class="hljs-params">(s <span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> &#123;        ans := s        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;            s = s[<span class="hljs-number">1</span>:] + s[:<span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> s &lt; ans &#123;                ans = s            &#125;        &#125;        <span class="hljs-keyword">return</span> ans    &#125;    t := []<span class="hljs-type">byte</span>(s)    sort.Slice(t, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> t[i] &lt; t[j] &#125;)    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(t)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.3 MB, 在所有 Go 提交中击败了80.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>91. 解码方法</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/91.%20%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/91.%20%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a><font size=6px>解码方法</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><p>示例 1：</p><p>输入：s &#x3D; “12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2：</p><p>输入：s &#x3D; “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。<br>示例 3：</p><p>输入：s &#x3D; “0”<br>输出：0<br>解释：没有字符映射到以 0 开头的数字。<br>含有 0 的有效映射是 ‘J’ -&gt; “10” 和 ‘T’-&gt; “20” 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含数字，并且可能包含前导零。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>dp判断是否是0很重要，因为没有前导0。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(s)    f := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;        <span class="hljs-keyword">if</span> s[i<span class="hljs-number">-1</span>] != <span class="hljs-string">&#x27;0&#x27;</span> &#123;            f[i] += f[i<span class="hljs-number">-1</span>]        &#125;        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">1</span> &amp;&amp; s[i<span class="hljs-number">-2</span>] != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ((s[i<span class="hljs-number">-2</span>]-<span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span>+(s[i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>) &#123;            f[i] += f[i<span class="hljs-number">-2</span>]        &#125;    &#125;    <span class="hljs-keyword">return</span> f[n]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了28.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>908. 最小差值 I</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/908.%20%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%20I/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/908.%20%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%20I/</url>
    
    <content type="html"><![CDATA[<h3 id="最小差值-I"><a href="#最小差值-I" class="headerlink" title="最小差值 I"></a><font size=6px>最小差值 I</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums，和一个整数 k 。</p><p>在一个操作中，您可以选择 0 &lt;&#x3D; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。</p><p>nums 的 分数 是 nums 中最大和最小元素的差值。 </p><p>在对  nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1], k &#x3D; 0<br>输出：0<br>解释：分数是 max(nums) - min(nums) &#x3D; 1 - 1 &#x3D; 0。<br>示例 2：</p><p>输入：nums &#x3D; [0,10], k &#x3D; 2<br>输出：6<br>解释：将 nums 改为 [2,8]。分数是 max(nums) - min(nums) &#x3D; 8 - 2 &#x3D; 6。<br>示例 3：</p><p>输入：nums &#x3D; [1,3,6], k &#x3D; 3<br>输出：0<br>解释：将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) &#x3D; 4 - 4 &#x3D; 0。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>0 &lt;&#x3D; k &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">smallestRangeI</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    minNum, maxNum := nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums[<span class="hljs-number">1</span>:] &#123;        <span class="hljs-keyword">if</span> num &lt; minNum &#123;            minNum = num        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> num &gt; maxNum &#123;            maxNum = num        &#125;    &#125;    ans := maxNum - minNum - <span class="hljs-number">2</span>*k    <span class="hljs-keyword">if</span> ans &gt; <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">return</span> ans    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了84.21%的用户<br>   内存消耗：5.9 MB, 在所有 Go 提交中击败了92.98%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>918. 环形子数组的最大和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/918.%20%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/918.%20%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="环形子数组的最大和"><a href="#环形子数组的最大和" class="headerlink" title="环形子数组的最大和"></a><font size=6px>环形子数组的最大和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。</p><p>环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。</p><p>子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], …, nums[j] ，不存在 i &lt;&#x3D; k1, k2 &lt;&#x3D; j 其中 k1 % n &#x3D;&#x3D; k2 % n 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,-2,3,-2]<br>输出：3<br>解释：从子数组 [3] 得到最大和 3<br>示例 2：</p><p>输入：nums &#x3D; [5,-3,5]<br>输出：10<br>解释：从子数组 [5,5] 得到最大和 5 + 5 &#x3D; 10<br>示例 3：</p><p>输入：nums &#x3D; [3,-2,2,-3]<br>输出：3<br>解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3</p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 3 * 104<br>-3 * 104 &lt;&#x3D; nums[i] &lt;&#x3D; 3 * 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>用滑动数组来做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    nums = <span class="hljs-built_in">append</span>(nums,nums...)    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-comment">//fmt.Println(nums)</span>    sum,res := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i,j:=<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;i&lt;=j &amp;&amp; j&lt;n;&#123;        <span class="hljs-keyword">for</span> j&lt;n  &amp;&amp;sum+nums[j]&gt;<span class="hljs-number">0</span>  &#123;            <span class="hljs-keyword">if</span> j-i&gt;=n/<span class="hljs-number">2</span>&#123;                i++                j = i                sum = <span class="hljs-number">0</span>            &#125;<span class="hljs-keyword">else</span>&#123;                sum += nums[j]                res = max(res,sum)                j++            &#125;        &#125;        j++        i = j        sum = <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">if</span> res ==<span class="hljs-number">0</span>&#123;        res = <span class="hljs-number">-1e9</span>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>  ;i++&#123;            res = max(res,nums[i])        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：1400 ms, 在所有 Go 提交中击败了5.38%的用户<br>   内存消耗：7.2 MB, 在所有 Go 提交中击败了71.54%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>917. 仅仅反转字母</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/917.%20%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/917.%20%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="917-仅仅反转字母"><a href="#917-仅仅反转字母" class="headerlink" title="917. 仅仅反转字母"></a><font size=6px>917. 仅仅反转字母</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 s ，根据下述规则反转字符串：</p><p>所有非英文字母保留在原有位置。<br>所有英文字母（小写或大写）位置反转。<br>返回反转后的 s 。</p><p>示例 1：</p><p>输入：s &#x3D; “ab-cd”<br>输出：”dc-ba”<br>示例 2：</p><p>输入：s &#x3D; “a-bC-dEf-ghIj”<br>输出：”j-Ih-gfE-dCba”<br>示例 3：</p><p>输入：s &#x3D; “Test1ng-Leet&#x3D;code-Q!”<br>输出：”Qedo1ct-eeLg&#x3D;ntse-T!”</p><p>提示</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 仅由 ASCII 值在范围 [33, 122]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>创建两个数组，一个放非字母的index，另一个放字母，放字母的逆序输出，放非字母的原索引地址输出</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> str []<span class="hljs-type">byte</span>    <span class="hljs-keyword">var</span> biaodianIndex []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">byte</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">if</span> (s[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)|| (s[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)&#123;            str = <span class="hljs-built_in">append</span>(str,s[i])        &#125;<span class="hljs-keyword">else</span>&#123;            biaodianIndex = <span class="hljs-built_in">append</span>(biaodianIndex, i)        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s); i++&#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(biaodianIndex)&gt;<span class="hljs-number">0</span> &amp;&amp; biaodianIndex[<span class="hljs-number">0</span>] == i&#123;            res = <span class="hljs-built_in">append</span>(res, s[biaodianIndex[<span class="hljs-number">0</span>]])            biaodianIndex = biaodianIndex[<span class="hljs-number">1</span>:]        &#125;<span class="hljs-keyword">else</span>&#123;            res = <span class="hljs-built_in">append</span>(res, str[<span class="hljs-built_in">len</span>(str)<span class="hljs-number">-1</span>])            str = str[:<span class="hljs-built_in">len</span>(str)<span class="hljs-number">-1</span>]        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(res)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了56.52%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>92. 反转链表 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a><font size=6px>反转链表 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4<br>输出：[1,4,3,2,5]<br>示例 2：</p><p>输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1<br>输出：[5]</p><p>提示：</p><p>链表中节点数目为 n<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>-500 &lt;&#x3D; Node.val &lt;&#x3D; 500<br>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; n</p><p>进阶： 你可以使用一趟扫描完成反转吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>开头增加一个head2，就可以不讨论left是不是1的情况</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * type ListNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *ListNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> left == right&#123;        <span class="hljs-keyword">return</span> head    &#125;    head2 := <span class="hljs-built_in">new</span>(ListNode)    head2.Next = head    left++    right++    <span class="hljs-keyword">var</span> pre1,pre2,next1,next2 *ListNode    tmp := head2    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;right;i++&#123;        <span class="hljs-keyword">if</span> i == left<span class="hljs-number">-2</span>&#123;            pre1 = tmp            pre2 = tmp.Next        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i== right<span class="hljs-number">-1</span>&#123;            next1 = tmp        &#125;        tmp = tmp.Next    &#125;    next2 = tmp    pre1.Next = <span class="hljs-literal">nil</span>    next1.Next = <span class="hljs-literal">nil</span>    next := merge(pre2)    pre1.Next = next    <span class="hljs-keyword">for</span> next.Next != <span class="hljs-literal">nil</span>&#123;        next = next.Next    &#125;    next.Next = next2    <span class="hljs-keyword">return</span> head2.Next&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(head *ListNode)</span></span>*ListNode&#123;    <span class="hljs-keyword">var</span> head2 *ListNode    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span>&#123;                tmp := head.Next        head.Next = head2        head2 = head        head = tmp    &#125;    <span class="hljs-keyword">return</span> head2&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了73.90%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>905. 按奇偶排序数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/905.%20%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/905.%20%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="按奇偶排序数组"><a href="#按奇偶排序数组" class="headerlink" title="按奇偶排序数组"></a><font size=6px>按奇偶排序数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums，将 nums 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。</p><p>返回满足此条件的 任一数组 作为答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [3,1,2,4]<br>输出：[2,4,3,1]<br>解释：[4,2,3,1]、[2,4,1,3] 和 [4,2,1,3] 也会被视作正确答案。<br>示例 2：</p><p>输入：nums &#x3D; [0]<br>输出：[0]</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 5000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>双指针法</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortArrayByParity</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    l,r := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    n :=<span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">for</span> ;r &lt;n;&#123;        <span class="hljs-keyword">if</span> nums[r] %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;            nums[l],nums[r] = nums[r],nums[l]            l++        &#125;        r++    &#125;    <span class="hljs-keyword">return</span> nums&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了76.16%的用户<br>   内存消耗：4.6 MB, 在所有 Go 提交中击败了73.51%</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>919. 完全二叉树插入器</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/919.%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/919.%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="完全二叉树插入器"><a href="#完全二叉树插入器" class="headerlink" title="完全二叉树插入器"></a><font size=6px>完全二叉树插入器</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p><p>设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。</p><p>实现 CBTInserter 类:</p><p>CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；<br>CBTInserter.insert(int v)  向树中插入一个值为 Node.val &#x3D;&#x3D; val的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值；<br>CBTInserter.get_root() 将返回树的头节点。</p><p>示例 1：</p><p>输入<br>[“CBTInserter”, “insert”, “insert”, “get_root”]<br>[[[1, 2]], [3], [4], []]<br>输出<br>[null, 1, 2, [1, 2, 3, 4]]</p><p>解释<br>CBTInserter cBTInserter &#x3D; new CBTInserter([1, 2]);<br>cBTInserter.insert(3);  &#x2F;&#x2F; 返回 1<br>cBTInserter.insert(4);  &#x2F;&#x2F; 返回 2<br>cBTInserter.get_root(); &#x2F;&#x2F; 返回 [1, 2, 3, 4]</p><p>提示：</p><p>树中节点数量范围为 [1, 1000]<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 5000<br>root 是完全二叉树<br>0 &lt;&#x3D; val &lt;&#x3D; 5000<br>每个测试用例最多调用 insert 和 get_root 操作 104 次</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>第一次用bfs把叶子节点都放进来</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> CBTInserter <span class="hljs-keyword">struct</span> &#123;    root      *TreeNode    candidate []*TreeNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(root *TreeNode)</span></span> CBTInserter &#123;    q := []*TreeNode&#123;root&#125;    candidate := []*TreeNode&#123;&#125;    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;        node := q[<span class="hljs-number">0</span>]        q = q[<span class="hljs-number">1</span>:]        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;            q = <span class="hljs-built_in">append</span>(q, node.Left)        &#125;        <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;            q = <span class="hljs-built_in">append</span>(q, node.Right)        &#125;        <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> || node.Right == <span class="hljs-literal">nil</span> &#123;            candidate = <span class="hljs-built_in">append</span>(candidate, node)        &#125;    &#125;    <span class="hljs-keyword">return</span> CBTInserter&#123;root, candidate&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CBTInserter)</span></span> Insert(val <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;    child := &amp;TreeNode&#123;Val: val&#125;    node := c.candidate[<span class="hljs-number">0</span>]    <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &#123;        node.Left = child    &#125; <span class="hljs-keyword">else</span> &#123;        node.Right = child        c.candidate = c.candidate[<span class="hljs-number">1</span>:]    &#125;    c.candidate = appnd(c.candidate, child)    <span class="hljs-keyword">return</span> node.Val&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CBTInserter)</span></span> Get_root() *TreeNode &#123;    <span class="hljs-keyword">return</span> c.root&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了70.27%的用户<br>   内存消耗：6.6 MB, 在所有 Go 提交中击败了24.32%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>929. 独特的电子邮件地址</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/929.%20%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/929.%20%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h3 id="独特的电子邮件地址"><a href="#独特的电子邮件地址" class="headerlink" title="独特的电子邮件地址"></a><font size=6px>独特的电子邮件地址</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>每个 有效电子邮件地址 都由一个 本地名 和一个 域名 组成，以 ‘@’ 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个 ‘.’ 或 ‘+’ 。</p><p>例如，在 <a href="mailto:&#x61;&#x6c;&#105;&#x63;&#x65;&#x40;&#x6c;&#101;&#x65;&#116;&#99;&#111;&#x64;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#x61;&#x6c;&#105;&#x63;&#x65;&#x40;&#x6c;&#101;&#x65;&#116;&#99;&#111;&#x64;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>中， alice 是 本地名 ，而 leetcode.com 是 域名 。<br>如果在电子邮件地址的 本地名 部分中的某些字符之间添加句点（’.’），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 不适用于域名 。</p><p>例如，”<a href="mailto:&#97;&#x6c;&#105;&#99;&#x65;&#46;&#122;&#x40;&#x6c;&#101;&#101;&#116;&#x63;&#x6f;&#100;&#x65;&#x2e;&#99;&#111;&#x6d;">&#97;&#x6c;&#105;&#99;&#x65;&#46;&#122;&#x40;&#x6c;&#101;&#101;&#116;&#x63;&#x6f;&#100;&#x65;&#x2e;&#99;&#111;&#x6d;</a>” 和 “<a href="mailto:&#97;&#108;&#105;&#x63;&#x65;&#122;&#64;&#108;&#101;&#101;&#116;&#99;&#x6f;&#x64;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#97;&#108;&#105;&#x63;&#x65;&#122;&#64;&#108;&#101;&#101;&#116;&#99;&#x6f;&#x64;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a>” 会转发到同一电子邮件地址。<br>如果在 本地名 中添加加号（’+’），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 不适用于域名 。</p><p>例如 <a href="mailto:&#109;&#46;&#121;&#43;&#110;&#x61;&#x6d;&#101;&#x40;&#x65;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;">&#109;&#46;&#121;&#43;&#110;&#x61;&#x6d;&#101;&#x40;&#x65;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;</a> 将转发到 <a href="mailto:&#x6d;&#x79;&#64;&#x65;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;">&#x6d;&#x79;&#64;&#x65;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;</a>。<br>可以同时使用这两个规则。</p><p>给你一个字符串数组 emails，我们会向每个 emails[i] 发送一封电子邮件。返回实际收到邮件的不同地址数目。</p><p>示例 1：</p><p>输入：emails &#x3D; [“<a href="mailto:&#116;&#101;&#x73;&#x74;&#x2e;&#x65;&#109;&#x61;&#x69;&#x6c;&#x2b;&#x61;&#108;&#x65;&#x78;&#64;&#108;&#101;&#x65;&#x74;&#99;&#111;&#100;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#116;&#101;&#x73;&#x74;&#x2e;&#x65;&#109;&#x61;&#x69;&#x6c;&#x2b;&#x61;&#108;&#x65;&#x78;&#64;&#108;&#101;&#x65;&#x74;&#99;&#111;&#100;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a>“,”<a href="mailto:&#116;&#101;&#115;&#116;&#46;&#101;&#46;&#109;&#97;&#x69;&#x6c;&#x2b;&#98;&#111;&#x62;&#46;&#x63;&#97;&#x74;&#x68;&#121;&#x40;&#x6c;&#x65;&#x65;&#x74;&#99;&#x6f;&#100;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#116;&#101;&#115;&#116;&#46;&#101;&#46;&#109;&#97;&#x69;&#x6c;&#x2b;&#98;&#111;&#x62;&#46;&#x63;&#97;&#x74;&#x68;&#121;&#x40;&#x6c;&#x65;&#x65;&#x74;&#99;&#x6f;&#100;&#x65;&#x2e;&#x63;&#111;&#x6d;</a>“,”<a href="mailto:&#x74;&#x65;&#115;&#116;&#x65;&#x6d;&#97;&#x69;&#x6c;&#x2b;&#100;&#x61;&#x76;&#x69;&#100;&#x40;&#108;&#101;&#x65;&#46;&#116;&#x63;&#x6f;&#x64;&#101;&#x2e;&#99;&#111;&#x6d;">&#x74;&#x65;&#115;&#116;&#x65;&#x6d;&#97;&#x69;&#x6c;&#x2b;&#100;&#x61;&#x76;&#x69;&#100;&#x40;&#108;&#101;&#x65;&#46;&#116;&#x63;&#x6f;&#x64;&#101;&#x2e;&#99;&#111;&#x6d;</a>“]<br>输出：2<br>解释：实际收到邮件的是 “<a href="mailto:&#x74;&#101;&#115;&#x74;&#x65;&#x6d;&#x61;&#105;&#108;&#64;&#x6c;&#101;&#101;&#116;&#99;&#x6f;&#100;&#101;&#46;&#x63;&#111;&#x6d;">&#x74;&#101;&#115;&#x74;&#x65;&#x6d;&#x61;&#105;&#108;&#64;&#x6c;&#101;&#101;&#116;&#99;&#x6f;&#100;&#101;&#46;&#x63;&#111;&#x6d;</a>“ 和 “<a href="mailto:&#116;&#x65;&#115;&#116;&#101;&#x6d;&#97;&#x69;&#x6c;&#64;&#x6c;&#101;&#101;&#x2e;&#116;&#x63;&#111;&#100;&#x65;&#46;&#99;&#111;&#x6d;">&#116;&#x65;&#115;&#116;&#101;&#x6d;&#97;&#x69;&#x6c;&#64;&#x6c;&#101;&#101;&#x2e;&#116;&#x63;&#111;&#100;&#x65;&#46;&#99;&#111;&#x6d;</a>“。<br>示例 2：</p><p>输入：emails &#x3D; [“<a href="mailto:&#97;&#64;&#x6c;&#101;&#101;&#x74;&#x63;&#111;&#x64;&#x65;&#46;&#99;&#x6f;&#109;">&#97;&#64;&#x6c;&#101;&#101;&#x74;&#x63;&#111;&#x64;&#x65;&#46;&#99;&#x6f;&#109;</a>“,”<a href="mailto:&#x62;&#x40;&#108;&#x65;&#x65;&#116;&#x63;&#111;&#x64;&#x65;&#x2e;&#x63;&#111;&#109;">&#x62;&#x40;&#108;&#x65;&#x65;&#116;&#x63;&#111;&#x64;&#x65;&#x2e;&#x63;&#111;&#109;</a>“,”<a href="mailto:&#x63;&#64;&#108;&#101;&#x65;&#x74;&#x63;&#x6f;&#x64;&#101;&#46;&#99;&#111;&#x6d;">&#x63;&#64;&#108;&#101;&#x65;&#x74;&#x63;&#x6f;&#x64;&#101;&#46;&#99;&#111;&#x6d;</a>“]<br>输出：3</p><p>提示：</p><p>1 &lt;&#x3D; emails.length &lt;&#x3D; 100<br>1 &lt;&#x3D; emails[i].length &lt;&#x3D; 100<br>emails[i] 由小写英文字母、’+’、’.’ 和 ‘@’ 组成<br>每个 emails[i] 都包含有且仅有一个 ‘@’ 字符<br>所有本地名和域名都不为空<br>本地名不会以 ‘+’ 字符作为开头</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>善用strings.Split和strings.Replace就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strings&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numUniqueEmails</span><span class="hljs-params">(emails []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    mp  := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> _,email := <span class="hljs-keyword">range</span> emails&#123;        s := strings.Split(email, <span class="hljs-string">&quot;@&quot;</span>)        s[<span class="hljs-number">0</span>] = strings.Replace(s[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">-1</span>)        s2 := strings.Split(s[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;+&quot;</span>)        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s2[<span class="hljs-number">0</span>]) != <span class="hljs-built_in">len</span>(s[<span class="hljs-number">0</span>])&#123;            s[<span class="hljs-number">0</span>] = s2[<span class="hljs-number">0</span>]        &#125;        mp[s[<span class="hljs-number">0</span>]+<span class="hljs-string">&quot;@&quot;</span>+s[<span class="hljs-number">1</span>]] = <span class="hljs-literal">true</span>    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(mp)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了58.49%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了37.74%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>933. 最近的请求次数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/933.%20%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/933.%20%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="最近的请求次数"><a href="#最近的请求次数" class="headerlink" title="最近的请求次数"></a><font size=6px>最近的请求次数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p><p>请你实现 RecentCounter 类：</p><p>RecentCounter() 初始化计数器，请求数为 0 。<br>int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。<br>保证 每次对 ping 的调用都使用比之前更大的 t 值。</p><p>示例 1：</p><p>输入：<br>[“RecentCounter”, “ping”, “ping”, “ping”, “ping”]<br>[[], [1], [100], [3001], [3002]]<br>输出：<br>[null, 1, 2, 3, 3]</p><p>解释：<br>RecentCounter recentCounter &#x3D; new RecentCounter();<br>recentCounter.ping(1);     &#x2F;&#x2F; requests &#x3D; [1]，范围是 [-2999,1]，返回 1<br>recentCounter.ping(100);   &#x2F;&#x2F; requests &#x3D; [1, 100]，范围是 [-2900,100]，返回 2<br>recentCounter.ping(3001);  &#x2F;&#x2F; requests &#x3D; [1, 100, 3001]，范围是 [1,3001]，返回 3<br>recentCounter.ping(3002);  &#x2F;&#x2F; requests &#x3D; [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3</p><p>提示：</p><p>1 &lt;&#x3D; t &lt;&#x3D; 109<br>保证每次对 ping 调用所使用的 t 值都 严格递增<br>至多调用 ping 方法 104 次</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>双指针法，用滑动区间来做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> RecentCounter <span class="hljs-keyword">struct</span> &#123;    l,r <span class="hljs-type">int</span>    num []<span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> RecentCounter &#123;    <span class="hljs-keyword">return</span> RecentCounter&#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *RecentCounter)</span></span> Ping(t <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;    this.num = <span class="hljs-built_in">append</span>(this.num, t)    <span class="hljs-keyword">for</span> this.num[this.r] - this.num[this.l] &gt;<span class="hljs-number">3000</span>&#123;        this.l++    &#125;   this.r++        <span class="hljs-keyword">return</span> this.r-this.l    &#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your RecentCounter object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor();</span><span class="hljs-comment"> * param_1 := obj.Ping(t);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：108 ms, 在所有 Go 提交中击败了37.58%的用户<br>   内存消耗：8 MB, 在所有 Go 提交中击败了79.87%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>942. 增减字符串匹配</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/942.%20%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/942.%20%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="增减字符串匹配"><a href="#增减字符串匹配" class="headerlink" title="增减字符串匹配"></a><font size=6px>增减字符串匹配</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:</p><p>如果 perm[i] &lt; perm[i + 1] ，那么 s[i] &#x3D;&#x3D; ‘I’<br>如果 perm[i] &gt; perm[i + 1] ，那么 s[i] &#x3D;&#x3D; ‘D’<br>给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列perm，则返回其中 任何一个 。</p><p>示例 1：</p><p>输入：s &#x3D; “IDID”<br>输出：[0,4,1,3,2]<br>示例 2：</p><p>输入：s &#x3D; “III”<br>输出：[0,1,2,3]<br>示例 3：</p><p>输入：s &#x3D; “DDI”<br>输出：[3,2,0,1]</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s 只包含字符 “I” 或 “D”</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>左右指针，然后直接开始贪心</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diStringMatch</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;    l,r := <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>)     k := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s&#123;        <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;I&#x27;</span>&#123;            res[k] = l            l++        &#125;<span class="hljs-keyword">else</span>&#123;            res[k] = r            r--        &#125;        k++    &#125;    res[k] = l    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了14.71%的用户<br>   内存消耗：4.9 MB, 在所有 Go 提交中击败了77.94%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>944. 删列造序</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/944.%20%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/944.%20%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="删列造序"><a href="#删列造序" class="headerlink" title="删列造序"></a><font size=6px>删列造序</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你由 n 个小写字母字符串组成的数组 strs，其中每个字符串长度相等。</p><p>这些字符串可以每个一行，排成一个网格。例如，strs &#x3D; [“abc”, “bce”, “cae”] 可以排列为：</p><p>abc<br>bce<br>cae<br>你需要找出并删除 不是按字典序升序排列的 列。在上面的例子（下标从 0 开始）中，列 0（’a’, ‘b’, ‘c’）和列 2（’c’, ‘e’, ‘e’）都是按升序排列的，而列 1（’b’, ‘c’, ‘a’）不是，所以要删除列 1 。</p><p>返回你需要删除的列数。</p><p>示例 1：</p><p>输入：strs &#x3D; [“cba”,”daf”,”ghi”]<br>输出：1<br>解释：网格示意如下：<br>  cba<br>  daf<br>  ghi<br>列 0 和列 2 按升序排列，但列 1 不是，所以只需要删除列 1 。<br>示例 2：</p><p>输入：strs &#x3D; [“a”,”b”]<br>输出：0<br>解释：网格示意如下：<br>  a<br>  b<br>只有列 0 这一列，且已经按升序排列，所以不用删除任何列。<br>示例 3：</p><p>输入：strs &#x3D; [“zyx”,”wvu”,”tsr”]<br>输出：3<br>解释：网格示意如下：<br>  zyx<br>  wvu<br>  tsr<br>所有 3 列都是非升序排列的，所以都要删除。</p><p>提示：</p><p>n &#x3D;&#x3D; strs.length<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>1 &lt;&#x3D; strs[i].length &lt;&#x3D; 1000<br>strs[i] 由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(1)</span></code></pre><p>按列遍历</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDeletionSize</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> pre <span class="hljs-type">byte</span>     res := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(strs[<span class="hljs-number">0</span>]);i++&#123;                <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(strs);j++&#123;            <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>&#123;                pre = strs[j][i]            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span> pre &gt; strs[j][i]&#123;                    res ++                    <span class="hljs-keyword">break</span>                &#125;<span class="hljs-keyword">else</span>&#123;                    pre = strs[j][i]                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了90.91%的用户<br>   内存消耗：6.3 MB, 在所有 Go 提交中击败了20.45%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>96. Unique Binary Search Trees</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/96.%20Unique%20Binary%20Search%20Trees/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/96.%20Unique%20Binary%20Search%20Trees/</url>
    
    <content type="html"><![CDATA[<h3 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a><font size=6px>Unique Binary Search Trees</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given an integer n, return the number of structurally unique BST’s (binary search trees) which has exactly n nodes of unique values from 1 to n.</p><p>Example 1:</p><p>Input: n &#x3D; 3<br>Output: 5<br>Example 2:</p><p>Input: n &#x3D; 1<br>Output: 1</p><p>Constraints:</p><p>1 &lt;&#x3D; n &lt;&#x3D; 19</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>数学题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    res[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>; i&lt;=n ;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j&lt;=i;j++&#123;            res[i] += res[j<span class="hljs-number">-1</span>] * res[i-j]        &#125;    &#125;    <span class="hljs-keyword">return</span> res[n]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了87.51%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>937. 重新排列日志文件</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/937.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/937.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="重新排列日志文件"><a href="#重新排列日志文件" class="headerlink" title="重新排列日志文件"></a><font size=6px>重新排列日志文件</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个日志数组 logs。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 标识符 。</p><p>有两种不同类型的日志：</p><p>字母日志：除标识符之外，所有字均由小写字母组成<br>数字日志：除标识符之外，所有字均由数字组成<br>请按下述规则将日志重新排序：</p><p>所有 字母日志 都排在 数字日志 之前。<br>字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。<br>数字日志 应该保留原来的相对顺序。<br>返回日志的最终顺序。</p><p>示例 1：</p><p>输入：logs &#x3D; [“dig1 8 1 5 1”,”let1 art can”,”dig2 3 6”,”let2 own kit dig”,”let3 art zero”]<br>输出：[“let1 art can”,”let3 art zero”,”let2 own kit dig”,”dig1 8 1 5 1”,”dig2 3 6”]<br>解释：<br>字母日志的内容都不同，所以顺序为 “art can”, “art zero”, “own kit dig” 。<br>数字日志保留原来的相对顺序 “dig1 8 1 5 1”, “dig2 3 6” 。<br>示例 2：</p><p>输入：logs &#x3D; [“a1 9 2 3 1”,”g1 act car”,”zo4 4 7”,”ab1 off key dog”,”a8 act zoo”]<br>输出：[“g1 act car”,”a8 act zoo”,”ab1 off key dog”,”a1 9 2 3 1”,”zo4 4 7”]</p><p>提示：</p><p>1 &lt;&#x3D; logs.length &lt;&#x3D; 100<br>3 &lt;&#x3D; logs[i].length &lt;&#x3D; 100<br>logs[i] 中，字与字之间都用 单个 空格分隔<br>题目数据保证 logs[i] 都有一个标识符，并且在标识符之后至少存在一个字</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>把logs拆成两个strings数组，然后排序就简单很多</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reorderLogFiles</span><span class="hljs-params">(logs []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> num []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> s []<span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> logs&#123;        x := strings.Split(v, <span class="hljs-string">&quot; &quot;</span>)        <span class="hljs-keyword">if</span> x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&#123;            num = <span class="hljs-built_in">append</span>(num, v)        &#125; <span class="hljs-keyword">else</span>&#123;            s = <span class="hljs-built_in">append</span>(s, v)        &#125;    &#125;    sort.Slice(s, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i ,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;        x,y := strings.Split(s[i], <span class="hljs-string">&quot; &quot;</span>), strings.Split(s[j], <span class="hljs-string">&quot; &quot;</span>)        a,b := strings.Join(x[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot; &quot;</span>), strings.Join(y[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot; &quot;</span>)        <span class="hljs-keyword">if</span> a==b&#123;            <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>]&lt;y[<span class="hljs-number">0</span>]        &#125;        <span class="hljs-keyword">return</span> a&lt;b    &#125;)    s = <span class="hljs-built_in">append</span>(s, num...)    <span class="hljs-keyword">return</span> s&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了83.33%的用户<br>   内存消耗：5.8 MB, 在所有 Go 提交中击败了16.67%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>954. 二倍数对数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/954.%20%E4%BA%8C%E5%80%8D%E6%95%B0%E5%AF%B9%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/954.%20%E4%BA%8C%E5%80%8D%E6%95%B0%E5%AF%B9%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="二倍数对数组"><a href="#二倍数对数组" class="headerlink" title="二倍数对数组"></a><font size=6px>二倍数对数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个长度为偶数的整数数组 arr，只有对 arr 进行重组后可以满足 “对于每个 0 &lt;&#x3D; i &lt; len(arr) &#x2F; 2，都有 arr[2 * i + 1] &#x3D; 2 * arr[2 * i]” 时，返回 true；否则，返回 false。</p><p>示例 1：</p><p>输入：arr &#x3D; [3,1,3,6]<br>输出：false<br>示例 2：</p><p>输入：arr &#x3D; [2,1,2,6]<br>输出：false<br>示例 3：</p><p>输入：arr &#x3D; [4,-2,2,-4]<br>输出：true<br>解释：可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]</p><p>提示：</p><p>0 &lt;&#x3D; arr.length &lt;&#x3D; 3 * 104<br>arr.length 是偶数<br>-105 &lt;&#x3D; arr[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>这个代码考察的是是不是所有数都是配对的，有两倍关系，所以负数降序，正书升序，然后拼接在一起判断每个数有没有两倍关系的数字。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canReorderDoubled</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">var</span> arr1,arr2 []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> arr&#123;        mp[v]++        <span class="hljs-keyword">if</span> v &lt;<span class="hljs-number">0</span>&#123;            arr1 = <span class="hljs-built_in">append</span>(arr1, v)        &#125;<span class="hljs-keyword">else</span>&#123;            arr2 = <span class="hljs-built_in">append</span>(arr2,v)        &#125;    &#125;      sort.Slice(arr1, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> arr1[i]&gt;arr1[j] &#125;)      sort.Ints(arr2)    arr1 = <span class="hljs-built_in">append</span>(arr1,arr2...)    count := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> arr1&#123;        <span class="hljs-keyword">if</span> mp[v] &gt;<span class="hljs-number">0</span> &amp;&amp; mp[<span class="hljs-number">2</span> * v] &gt;<span class="hljs-number">0</span>  &#123;            <span class="hljs-keyword">if</span>(v == <span class="hljs-number">0</span> &amp;&amp; mp[v]&gt;=<span class="hljs-number">2</span>) || v != <span class="hljs-number">0</span>&#123;                count++                mp[v]--                mp[<span class="hljs-number">2</span> * v]--            &#125;<span class="hljs-keyword">else</span>&#123;                mp[v]--            &#125;                    &#125;    &#125;    <span class="hljs-keyword">if</span> count&lt; <span class="hljs-built_in">len</span>(arr)/<span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：96 ms, 在所有 Go 提交中击败了44.83%的用户<br>   内存消耗：7.1 MB, 在所有 Go 提交中击败了68.97%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>974. 和可被 K 整除的子数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/974.%20%E5%92%8C%E5%8F%AF%E8%A2%AB%20K%20%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/974.%20%E5%92%8C%E5%8F%AF%E8%A2%AB%20K%20%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="和可被-K-整除的子数组"><a href="#和可被-K-整除的子数组" class="headerlink" title="和可被 K 整除的子数组"></a><font size=6px>和可被 K 整除的子数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的（连续、非空） 子数组 的数目。</p><p>子数组 是数组的 连续 部分。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,5,0,-2,-3,1], k &#x3D; 5<br>输出：7<br>解释：<br>有 7 个子数组满足其元素之和可被 k &#x3D; 5 整除：<br>[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]<br>示例 2:</p><p>输入: nums &#x3D; [5], k &#x3D; 9<br>输出: 0</p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>2 &lt;&#x3D; k &lt;&#x3D; 104<br>通过次数43,404提交次数92,342</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>使用map来优化前缀和的时间复杂度，注意点是防止前缀和为负值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraysDivByK</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    sum ,res := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>        mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    mp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;n;i++&#123;        sum += nums[i]        res += mp[((sum %k)+k)%k]        mp[((sum %k)+k)%k]++    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：40 ms, 在所有 Go 提交中击败了89.63%的用户<br>   内存消耗：6.7 MB, 在所有 Go 提交中击败了49.63%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>969. 煎饼排序</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/969.%20%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/969.%20%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="煎饼排序"><a href="#煎饼排序" class="headerlink" title="煎饼排序"></a><font size=6px>煎饼排序</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。</p><p>一次煎饼翻转的执行过程如下：</p><p>选择一个整数 k ，1 &lt;&#x3D; k &lt;&#x3D; arr.length<br>反转子数组 arr[0…k-1]（下标从 0 开始）<br>例如，arr &#x3D; [3,2,1,4] ，选择 k &#x3D; 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr &#x3D; [1,2,3,4] 。</p><p>以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。</p><p>示例 1：</p><p>输入：[3,2,4,1]<br>输出：[4,2,4,3]<br>解释：<br>我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。<br>初始状态 arr &#x3D; [3, 2, 4, 1]<br>第一次翻转后（k &#x3D; 4）：arr &#x3D; [1, 4, 2, 3]<br>第二次翻转后（k &#x3D; 2）：arr &#x3D; [4, 1, 2, 3]<br>第三次翻转后（k &#x3D; 4）：arr &#x3D; [3, 2, 1, 4]<br>第四次翻转后（k &#x3D; 3）：arr &#x3D; [1, 2, 3, 4]，此时已完成排序。<br>示例 2：</p><p>输入：[1,2,3]<br>输出：[]<br>解释：<br>输入已经排序，因此不需要翻转任何内容。<br>请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。</p><p>提示：</p><p>1 &lt;&#x3D; arr.length &lt;&#x3D; 100<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; arr.length<br>arr 中的所有整数互不相同（即，arr 是从 1 到 arr.length 整数的一个排列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先把最大的数字翻转到第一个，然后再整个数组翻转，持续n次然后数字就有序看</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pancakeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(arr)    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> reverse <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span> <span class="hljs-type">int</span>)</span></span>    reverse =<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span> <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>/<span class="hljs-number">2</span>;i++&#123;            arr[i],arr[<span class="hljs-built_in">len</span>-i<span class="hljs-number">-1</span>] = arr[<span class="hljs-built_in">len</span>-i<span class="hljs-number">-1</span>],arr[i]        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n; i++&#123;        numLen := n-i;        maxIndex := <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;numLen; j++&#123;            <span class="hljs-keyword">if</span> arr[maxIndex] &lt; arr[j]&#123;                maxIndex = j            &#125;        &#125;        reverse(arr, maxIndex+<span class="hljs-number">1</span>)                reverse(arr,numLen)        res = <span class="hljs-built_in">append</span>(res,maxIndex+<span class="hljs-number">1</span>,numLen)    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了86.11%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题 01.05. 一次编辑</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.05.%20%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.05.%20%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h3 id="一次编辑"><a href="#一次编辑" class="headerlink" title="一次编辑"></a><font size=6px>一次编辑</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p><p>示例 1:</p><p>输入:<br>first &#x3D; “pale”<br>second &#x3D; “ple”<br>输出: True</p><p>示例 2:</p><p>输入:<br>first &#x3D; “pales”<br>second &#x3D; “pal”<br>输出: False</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>不是动态规划，只要条件判断就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">oneEditAway</span><span class="hljs-params">(first <span class="hljs-type">string</span>, second <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    dif := <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span> first == second&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(first) == <span class="hljs-built_in">len</span>(second)&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(first);i++&#123;            <span class="hljs-keyword">if</span> first[i] != second[i]&#123;                dif++            &#125;        &#125;        <span class="hljs-keyword">if</span> dif &gt;=<span class="hljs-number">2</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-type">int</span>(math.Abs(<span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(first)-<span class="hljs-built_in">len</span>(second)))) &gt;=<span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">// 确保first长</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(second)&gt;<span class="hljs-built_in">len</span>(first)&#123;            first,second = second, first        &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(first);i++&#123;            tmp := <span class="hljs-type">string</span>(first[<span class="hljs-number">0</span>:i])+<span class="hljs-type">string</span>(first[i+<span class="hljs-number">1</span>:])            <span class="hljs-keyword">if</span> tmp == second&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.3 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题 17.11. 单词距离</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.11.%20%E5%8D%95%E8%AF%8D%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.11.%20%E5%8D%95%E8%AF%8D%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="单词距离"><a href="#单词距离" class="headerlink" title="单词距离"></a><font size=6px>单词距离</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?</p><p>示例：</p><p>输入：words &#x3D; [“I”,”am”,”a”,”student”,”from”,”a”,”university”,”in”,”a”,”city”], word1 &#x3D; “a”, word2 &#x3D; “student”<br>输出：1<br>提示：</p><p>words.length &lt;&#x3D; 100000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>把两个单词的坐标放入数组中，然后用双指针做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findClosest</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> a,b []<span class="hljs-type">int</span>    res := <span class="hljs-number">99999</span>    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> words&#123;        <span class="hljs-keyword">if</span> v == word1&#123;            a= <span class="hljs-built_in">append</span>(a, k)        &#125;        <span class="hljs-keyword">if</span> v == word2&#123;            b = <span class="hljs-built_in">append</span>(b,k)        &#125;    &#125;    n1,n2 := <span class="hljs-built_in">len</span>(a),<span class="hljs-built_in">len</span>(b)    l,r := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> l&lt; n1 &amp;&amp; r &lt; n2&#123;        <span class="hljs-keyword">if</span> a[l]&gt;b[r]&#123;            res = min(res, a[l]-b[r])            r++        &#125;<span class="hljs-keyword">else</span>&#123;            res = min(res, b[r]-a[l])            l++        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：64 ms, 在所有 Go 提交中击败了98.57%的用户<br>   内存消耗：11.2 MB, 在所有 Go 提交中击败了95.71%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>590. N 叉树的后序遍历</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/590.%20N%20%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/590.%20N%20%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="N-叉树的后序遍历"><a href="#N-叉树的后序遍历" class="headerlink" title="N 叉树的后序遍历"></a><font size=6px>N 叉树的后序遍历</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：[5,6,3,2,4,1]<br>示例 2：</p><p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]</p><p>提示：</p><p>节点总数在范围 [0, 104] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>n 叉树的高度小于或等于 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>后序遍历就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorder</span><span class="hljs-params">(root *Node)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> res    &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(root.Children);i++&#123;        res = <span class="hljs-built_in">append</span>(res,postorder(root.Children[i])...)    &#125;    res = <span class="hljs-built_in">append</span>(res,root.Val)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了17.51%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98. 验证二叉搜索树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><font size=6px>验证二叉搜索树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：</p><p>输入：root &#x3D; [2,1,3]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。</p><p>提示：</p><p>树中节点数目范围在[1, 104] 内<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>二叉树中序遍历是升序的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        f(root.Left)        res = <span class="hljs-built_in">append</span>(res, root.Val)        f(root.Right)    &#125;    f(root)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(res); i++&#123;        <span class="hljs-keyword">if</span> res[i<span class="hljs-number">-1</span>] &gt;= res[i]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.42%的用户<br>   内存消耗：5.9 MB, 在所有 Go 提交中击败了12.03%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>110. 平衡二叉树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><font size=6px>平衡二叉树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [1,2,2,3,3,null,null,4,4]<br>输出：false<br>示例 3：</p><p>输入：root &#x3D; []<br>输出：true</p><p>提示：</p><p>树中的节点数在范围 [0, 5000] 内<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>自底向上判断，判断这个结点的两个子结点的高度差是否大于1，大于1就说明不是平衡二叉树</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> root ==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span> heigth(root)&gt;=<span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heigth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    leftheight := heigth(root.Left)    rightheight := heigth(root.Right)    <span class="hljs-keyword">if</span> abs(leftheight-rightheight)&gt;=<span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-9999</span>    &#125;    <span class="hljs-keyword">return</span> max(leftheight,rightheight)+<span class="hljs-number">1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a&lt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>*a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了85.62%的用户<br>   内存消耗：5.7 MB, 在所有 Go 提交中击败了99.51%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>120. 三角形最小路径和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><font size=6px>三角形最小路径和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p><p>示例 1：</p><p>输入：triangle &#x3D; [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br>  3 4<br> 6 5 7<br>4 1 8 3<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。<br>示例 2：</p><p>输入：triangle &#x3D; [[-10]]<br>输出：-10</p><p>提示：</p><p>1 &lt;&#x3D; triangle.length &lt;&#x3D; 200<br>triangle[0].length &#x3D;&#x3D; 1<br>triangle[i].length &#x3D;&#x3D; triangle[i - 1].length + 1<br>-104 &lt;&#x3D; triangle[i][j] &lt;&#x3D; 104</p><p>进阶：</p><p>你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>这个就是一个数塔问题，要从下往上计算，从倒数第二层开始，开始算倒数第二层和最后一层的最小路径合，带着这个合和倒数第三层开始计算最小路径合，直到第一层</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(triangle [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(triangle)<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(triangle[i]);j++&#123;            <span class="hljs-keyword">if</span> triangle[i+<span class="hljs-number">1</span>][j]&lt;triangle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]&#123;                triangle[i][j]+=triangle[i+<span class="hljs-number">1</span>][j]            &#125;<span class="hljs-keyword">else</span>&#123;                triangle[i][j]+=triangle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.70%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>121. 买卖股票的最佳时机</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><font size=6px>买卖股票的最佳时机</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：</p><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p><p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>提示：</p><p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从后往前，如果是负号就说明是前面那个数大哨兵就变成前面那个数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>    k:=<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--&#123;        num:=prices[k]-prices[i<span class="hljs-number">-1</span>]        <span class="hljs-keyword">if</span> num&lt;<span class="hljs-number">0</span>&#123;            k=i<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> max&lt;num&#123;                max = num            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：144 ms, 在所有 Go 提交中击败了62.88%的用户<br>   执行用时：144 ms, 在所有 Go 提交中击败了62.88%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>123. 买卖股票的最佳时机 III</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/123.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20III/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/123.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20III/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a><font size=6px>买卖股票的最佳时机 III</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入：prices &#x3D; [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。<br>     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。<br>示例 2：</p><p>输入：prices &#x3D; [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3：</p><p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这个情况下, 没有交易完成, 所以最大利润为 0。<br>示例 4：</p><p>输入：prices &#x3D; [1]<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>有四个状态，买一次 ，卖一次，买第二次，卖第二次，看官方的思路，用动态规划做，如果是自己买自己卖收益为0，不用考虑，寻找buy1，2的最小（因为是负数），sell1，2最大，看代码把，我也是抄代码勉强理解一下，官方代码太优雅了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    buy1, sell1 := -prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>    buy2, sell2 := -prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;        buy1 = max(buy1, -prices[i])        sell1 = max(sell1, buy1+prices[i])        buy2 = max(buy2, sell1-prices[i])        sell2 = max(sell2, buy2+prices[i])    &#125;    <span class="hljs-keyword">return</span> sell2&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a &gt; b &#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：140 ms, 在所有 Go 提交中击败了62.50%的用户<br>   内存消耗：8.7 MB, 在所有 Go 提交中击败了94.15%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣一二二： 买卖股票的最佳时机 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><font size=6px>买卖股票的最佳时机 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。<br>示例 2:</p><p>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>在7 3 2 4 9 3 1中，先按递减找到最低，然后按递增找到最高，就买和卖，递减找到2，然后递增找到9，买和卖，最大7。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>    i:=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i&lt;<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>&#123;        <span class="hljs-keyword">for</span> i&lt;<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>&amp;&amp;prices[i]&gt;=prices[i+<span class="hljs-number">1</span>]&#123;            i++        &#125;        min:=prices[i]        <span class="hljs-keyword">for</span> i&lt;<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>&amp;&amp;(prices[i]&lt;=prices[i+<span class="hljs-number">1</span>])&#123;            i++        &#125;        max:=prices[i]        sum+=max-min    &#125;    <span class="hljs-keyword">return</span> sum&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了93.86%的用户<br>   内存消耗：3 MB, 在所有 Go 提交中击败了66.37%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>128. 最长连续序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><font size=6px>最长连续序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？</p><p>示例 1：</p><p>输入：nums &#x3D; [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。<br>示例 2：</p><p>输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]<br>输出：9</p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先去重，创造一个map把列表中的数子放进去，把重复数字去掉，再遍历这个map，如果他的num-1&#x3D;&#x3D;false，说明num-1这个数不在列表里面，是一个根结点，再从这个数开始遍历，每次加一判断这个数在不在map里面。</p><pre><code class="hljs apache"><span class="hljs-attribute">if</span> !flag[k-<span class="hljs-number">1</span>]&#123;</code></pre><p>如果把上面这句代码改成true，就遍历到根节点上面一个结点开始找相邻的结点，时间会大大增加，开始没理解算法写错了，时间到1144ms 。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;flag := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<span class="hljs-keyword">for</span> _,v :=<span class="hljs-keyword">range</span>  nums&#123;flag[v] =<span class="hljs-literal">true</span>&#125;length,max :=<span class="hljs-number">0</span>,<span class="hljs-number">1</span><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> flag&#123;<span class="hljs-keyword">if</span> !flag[k<span class="hljs-number">-1</span>]&#123;    length++            <span class="hljs-keyword">for</span> flag[k+<span class="hljs-number">1</span>]==<span class="hljs-literal">true</span>&#123;                length++                k++            &#125;            <span class="hljs-keyword">if</span> length&gt;max&#123;            max =length            &#125;length=<span class="hljs-number">0</span>&#125;&#125;<span class="hljs-keyword">return</span>  max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了96.13%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了66.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14. 最长公共前缀</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a><font size=6px>最长公共前缀</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1：</p><p>输入：strs &#x3D; [“flower”,”flow”,”flight”]<br>输出：”fl”<br>示例 2：</p><p>输入：strs &#x3D; [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先判断各个数是不是空，找出各个数中长度最小的数，之后就每次循环判断一位，记得长度超过最小长度就return</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> min <span class="hljs-type">int</span>     <span class="hljs-keyword">var</span> maxstr []<span class="hljs-type">byte</span>    <span class="hljs-keyword">var</span> i,line <span class="hljs-type">int</span>        min =<span class="hljs-number">999</span>    <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(strs);j++&#123;        <span class="hljs-keyword">if</span> strs[j]==<span class="hljs-string">&quot;&quot;</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> min&gt;<span class="hljs-built_in">len</span>(strs[j])&#123;                min = <span class="hljs-built_in">len</span>(strs[j])            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(strs)==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>]    &#125;    <span class="hljs-keyword">for</span> &#123;        <span class="hljs-keyword">if</span> line==min&#123;            <span class="hljs-keyword">break</span>        &#125;        <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(strs);i++&#123;            <span class="hljs-keyword">if</span> strs[<span class="hljs-number">0</span>][line]!=strs[i][line]&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> i!=<span class="hljs-built_in">len</span>(strs)&#123;            <span class="hljs-keyword">break</span>        &#125;<span class="hljs-keyword">else</span>&#123;            maxstr = <span class="hljs-built_in">append</span>(maxstr,strs[<span class="hljs-number">0</span>][line])            line++        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(maxstr)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.3 MB, 在所有 Go 提交中击败了32.68%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>141. 环形链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><font size=6px>141. 环形链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。</p><p>提示：</p><p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 为 -1 或者链表中的一个 有效索引 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>遇到一个数，就加100000，如果下一次遇到的数大于100000，就说明上次遇到过了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> head==<span class="hljs-literal">nil</span>||head.Next==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">for</span> head.Next!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> head.Val&lt;=<span class="hljs-number">100000</span>&#123;            head.Val+=<span class="hljs-number">1000002</span>            head=head.Next        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了81.97%的用户<br>   内存消耗：4.3 MB, 在所有 Go 提交中击败了24.58%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1416. 恢复数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1416.%20%E6%81%A2%E5%A4%8D%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1416.%20%E6%81%A2%E5%A4%8D%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="1416-恢复数组"><a href="#1416-恢复数组" class="headerlink" title="1416. 恢复数组"></a><font size=6px>1416. 恢复数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 [1, k] 之间，且数组中的数字都没有前导 0 。</p><p>给你字符串 s 和整数 k 。可能会有多种不同的数组恢复结果。</p><p>按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。</p><p>由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。</p><p>示例 1：</p><p>输入：s &#x3D; “1000”, k &#x3D; 10000<br>输出：1<br>解释：唯一一种可能的数组方案是 [1000]<br>示例 2：</p><p>输入：s &#x3D; “1000”, k &#x3D; 10<br>输出：0<br>解释：不存在任何数组方案满足所有整数都 &gt;&#x3D; 1 且 &lt;&#x3D; 10 同时输出结果为 s 。<br>示例 3：</p><p>输入：s &#x3D; “1317”, k &#x3D; 2000<br>输出：8<br>解释：可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]<br>示例 4：</p><p>输入：s &#x3D; “2020”, k &#x3D; 30<br>输出：1<br>解释：唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 &gt; 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。<br>示例 5：</p><p>输入：s &#x3D; “1234567890”, k &#x3D; 90<br>输出：34</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^5.<br>s 只包含数字且不包含前导 0 。<br>1 &lt;&#x3D; k &lt;&#x3D; 10^9.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>我摊牌了，我不会做，是看懂大佬的代码的，<a href="https://leetcode-cn.com/problems/restore-the-array/solution/dong-tai-gui-hua-zhu-zi-fu-jie-xi-pan-duan-you-duo/">https://leetcode-cn.com/problems/restore-the-array/solution/dong-tai-gui-hua-zhu-zi-fu-jie-xi-pan-duan-you-duo/</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfArrays</span><span class="hljs-params">(s <span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> mod <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> dp[<span class="hljs-number">100002</span>] <span class="hljs-type">int</span>    mod = <span class="hljs-number">1000000007</span>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">for</span> j:=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--&#123;            <span class="hljs-keyword">if</span> s[j]==<span class="hljs-string">&#x27;0&#x27;</span>&#123;                <span class="hljs-keyword">continue</span>            &#125;            s1:=s[j:i]            num,err:=strconv.Atoi(s1)            <span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;                            &#125;            <span class="hljs-keyword">if</span> num&lt;=k&#123;                dp[i]+=dp[j]            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span> s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;dp[i]==<span class="hljs-number">0</span>&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                &#125;                <span class="hljs-keyword">break</span>            &#125;        &#125;        dp[i]%=mod    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]%mod&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了30.77%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>142. 环形链表 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="环形链表-II"><a href="#环形链表-II" class="headerlink" title="环形链表 II"></a><font size=6px>环形链表 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O(1) 空间解决此题？</p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>还是和1一样，每个结点加1000000，如果遇到下一个数字大于100000，就说明这个结点之前遇到过了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> head==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;        <span class="hljs-keyword">for</span> head!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> head.Val&gt;<span class="hljs-number">100000</span>&#123;            <span class="hljs-keyword">return</span> head        &#125;        head.Val+=<span class="hljs-number">1000002</span>        head=head.Next    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了98.84%的用户<br>   内存消耗：3.7 MB, 在所有 Go 提交中击败了31.10%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>143. 重排链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/143.%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/143.%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a><font size=6px>重排链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用快慢指针，找到链表的中间结点，让后面的结点逆置，然后后面的结点一个个插入</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(head *ListNode)</span></span>  &#123;    <span class="hljs-keyword">if</span> head==<span class="hljs-literal">nil</span>||head.Next==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">var</span> fast,slow,head2,pre *ListNode    fast,slow=head,head    <span class="hljs-keyword">for</span> fast!=<span class="hljs-literal">nil</span>&amp;&amp;fast.Next!=<span class="hljs-literal">nil</span>&#123;        fast=fast.Next.Next        pre = slow        slow=slow.Next    &#125;    pre.Next=<span class="hljs-literal">nil</span>    head2=<span class="hljs-literal">nil</span>    <span class="hljs-keyword">for</span> slow!=<span class="hljs-literal">nil</span>&#123;        tmp := slow.Next        slow.Next=head2        head2=slow        slow=tmp    &#125;    <span class="hljs-comment">//fmt.Println(head2.Val,head2.Next.Val)</span>    true_head := head    <span class="hljs-keyword">for</span> head.Next!=<span class="hljs-literal">nil</span>&#123;        tmp:=head2.Next        head2.Next=head.Next        head.Next=head2        head=head2.Next        head2=tmp    &#125;      <span class="hljs-keyword">if</span> head2!=<span class="hljs-literal">nil</span>&#123;        head.Next=head2    &#125;    head=true_head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了76.58%的用户<br>   内存消耗：5.3 MB, 在所有 Go 提交中击败了79.64%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>148. 排序链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a><font size=6px>排序链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>进阶：</p><p>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><p>示例 1：</p><p>输入：head &#x3D; [4,2,1,3]<br>输出：[1,2,3,4]<br>示例 2：</p><p>输入：head &#x3D; [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br>示例 3：</p><p>输入：head &#x3D; []<br>输出：[]</p><p>提示：</p><p>链表中节点的数目在范围 [0, 5 * 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>通过次数159,543提交次数237,674</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用归并排序，用递归写更加简洁易懂一些</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> head&#125;fast, slow := head, head<span class="hljs-keyword">var</span> pre *ListNode    <span class="hljs-comment">//用快慢指针</span><span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;pre = slowslow = slow.Nextfast = fast.Next.Next&#125;pre.Next = <span class="hljs-literal">nil</span>l := sortList(head)r := sortList(slow)<span class="hljs-keyword">return</span> mergeList(l, r)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(l, r *ListNode)</span></span> *ListNode &#123;    <span class="hljs-comment">//制造头节点方便操作</span>head := &amp;ListNode&#123;Val: <span class="hljs-number">0</span>&#125;pre := head<span class="hljs-keyword">for</span> l != <span class="hljs-literal">nil</span> &amp;&amp; r != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> l.Val &gt; r.Val &#123;pre.Next = rr = r.Next&#125; <span class="hljs-keyword">else</span> &#123;pre.Next = ll = l.Next&#125;pre = pre.Next&#125;<span class="hljs-keyword">if</span> l != <span class="hljs-literal">nil</span> &#123;pre.Next = l&#125;<span class="hljs-keyword">if</span> r != <span class="hljs-literal">nil</span> &#123;pre.Next = r&#125;    <span class="hljs-comment">//这才是真正的开始</span><span class="hljs-keyword">return</span> head.Next&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：32 ms, 在所有 Go 提交中击败了91.30%的用户<br>   内存消耗：7.1 MB, 在所有 Go 提交中击败了90.61%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15. 三数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><font size=6px>三数之和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：</p><p>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>示例 2：</p><p>输入：nums &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：nums &#x3D; [0]<br>输出：[]</p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 3000<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>双指针加上两面夹逼，先确定一个数，之后两个数开始双指针往中间靠</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sort&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;<span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;    &#125;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    sort.Ints(nums)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;i++&#123;        <span class="hljs-keyword">if</span>  i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i<span class="hljs-number">-1</span>]==nums[i]&#123;                <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">if</span> nums[i]&gt;<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">break</span>        &#125;        j:=i+<span class="hljs-number">1</span>        k:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">for</span> j&lt;k&#123;            n2 :=nums[j]            n3 :=nums[k]            <span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k]==<span class="hljs-number">0</span>&#123;                res = <span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;nums[i],nums[j],nums[k]&#125;)                <span class="hljs-keyword">for</span> j&lt;k &amp;&amp;nums[j]==n2&#123;                    j++                &#125;                <span class="hljs-keyword">for</span> j&lt;k &amp;&amp;nums[k]==n3&#123;                    k--                &#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k]&lt;<span class="hljs-number">0</span>&#123;                j++            &#125;<span class="hljs-keyword">else</span>&#123;                k--            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：40 ms, 在所有 Go 提交中击败了49.59%的用户<br>   内存消耗：7.5 MB, 在所有 Go 提交中击败了27.30%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146. LRU 缓存机制</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/146.%20LRU%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/146.%20LRU%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="LRU-缓存机制"><a href="#LRU-缓存机制" class="headerlink" title="LRU 缓存机制"></a><font size=6px>LRU 缓存机制</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例：</p><p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p><p>解释<br>LRUCache lRUCache &#x3D; new LRUCache(2);<br>lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 {1&#x3D;1}<br>lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 {1&#x3D;1, 2&#x3D;2}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 1<br>lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 {1&#x3D;1, 3&#x3D;3}<br>lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 {4&#x3D;4, 3&#x3D;3}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.get(3);    &#x2F;&#x2F; 返回 3<br>lRUCache.get(4);    &#x2F;&#x2F; 返回 4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>为了做到都是o（1）的复杂度，用哈希和链表结合的数据结构，链表弄一个head和tail，中间放数据，head和tail不放数据，这样的好处是不用判断只有一个结点的情况，方便很多，我能力很差，也是参考大佬的代码，写的很简洁优雅。</p><p><a href="https://leetcode-cn.com/problems/lru-cache/solution/golang-lru-cache-dai-ma-chao-ji-rong-yi-li-jie-by-/">链接在这里</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>head     *LRUCacheNodetail     *LRUCacheNodeMap      <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*LRUCacheNode&#125;<span class="hljs-keyword">type</span> LRUCacheNode <span class="hljs-keyword">struct</span> &#123;k    <span class="hljs-type">int</span>v    <span class="hljs-type">int</span>pre  *LRUCacheNodenext *LRUCacheNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;LRU := <span class="hljs-built_in">new</span>(LRUCache)LRU.Map = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*LRUCacheNode)LRU.<span class="hljs-built_in">cap</span> = capacityLRU.head = &amp;LRUCacheNode&#123;&#125;LRU.tail = &amp;LRUCacheNode&#123;&#125;LRU.head.next = LRU.tailLRU.tail.pre = LRU.head<span class="hljs-keyword">return</span> *LRU&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> node, ok := this.Map[key]; ok &#123;deleteNode(node)this.moveToTail(this.Map[key])<span class="hljs-keyword">return</span> node.v&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;node, ok := this.Map[key]<span class="hljs-keyword">if</span> ok &#123;deleteNode(node)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.Map) == this.<span class="hljs-built_in">cap</span> &#123;<span class="hljs-built_in">delete</span>(this.Map, this.head.next.k)deleteNode(this.head.next)&#125;node = &amp;LRUCacheNode&#123;k: key, v: value&#125;this.Map[key] = node&#125;node.v = valuethis.moveToTail(node)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> moveToTail(node *LRUCacheNode) &#123;tmp := this.tail.pretmp.next = nodenode.pre = tmpnode.next = this.tailthis.tail.pre = node&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(node *LRUCacheNode)</span></span> &#123;node.pre.next = node.nextnode.next.pre = node.pre&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：120 ms, 在所有 Go 提交中击败了76.27%的用户<br>   内存消耗：11.7 MB, 在所有 Go 提交中击败了86.78%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1026 Table Tennis (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1026%20Table%20Tennis%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1026%20Table%20Tennis%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Table-Tennis"><a href="#Table-Tennis" class="headerlink" title="Table Tennis"></a><font size=6px>Table Tennis</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A table tennis club has N tables available to the public. The tables are numbered from 1 to N. For any pair of players, if there are some tables open when they arrive, they will be assigned to the available table with the smallest number. If all the tables are occupied, they will have to wait in a queue. It is assumed that every pair of players can play for at most 2 hours.</p><p>Your job is to count for everyone in queue their waiting time, and for each table the number of players it has served for the day.</p><p>One thing that makes this procedure a bit complicated is that the club reserves some tables for their VIP members. When a VIP table is open, the first VIP pair in the queue will have the privilege to take it. However, if there is no VIP in the queue, the next pair of players can take it. On the other hand, if when it is the turn of a VIP pair, yet no VIP table is available, they can be assigned as any ordinary players.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer <code>N</code> (≤10000) - the total number of pairs of players. Then <code>N</code> lines follow, each contains 2 times and a VIP tag: <code>HH:MM:SS</code> - the arriving time, <code>P</code> - the playing time in minutes of a pair of players, and <code>tag</code> - which is 1 if they hold a VIP card, or 0 if not. It is guaranteed that the arriving time is between 08:00:00 and 21:00:00 while the club is open. It is assumed that no two customers arrives at the same time. Following the players’ info, there are 2 positive integers: <code>K</code> (≤100) - the number of tables, and <code>M</code> (&lt; K) - the number of VIP tables. The last line contains <code>M</code> table numbers.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print the arriving time, serving time and the waiting time for each pair of players in the format shown by the sample. Then print in a line the number of players served by each table. Notice that the output must be listed in chronological order of the serving time. The waiting time must be rounded up to an integer minute(s). If one cannot get a table before the closing time, their information must NOT be printed.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">1020:52:00 10 008:00:00 20 008:02:00 30 020:51:00 10 008:10:00 30 008:12:00 10 120:40:00 13 008:01:30 15 120:53:00 10 120:54:00 10 03 12</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">08:00:00 08:00:00 008:01:30 08:01:30 008:02:00 08:02:00 008:12:00 08:16:30 508:10:00 08:20:00 1020:40:00 20:40:00 020:51:00 20:51:00 020:52:00 20:52:00 020:53:00 20:53:00 04 3 2</code></pre><p><strong>鸣谢用户 黄卓斌 补充数据！鸣谢用户 徐向荣 修正标程！</strong></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>柳神代码有问题，我还给他提了pr，开心</p><p><strong>分析：建立两个结构体，person 和 tablenode，分别创建他们的结构体数组player和table。</strong><br><strong>因为给出的输入是无序的所以要先排序。可以根据最早空闲的桌子是不是vip桌进行分类讨论。</strong><br><strong>如果最早空闲的桌子index是vip桌，那么寻找队列里面第一个vip球员。根据他的到达时间继续分类讨论。</strong><br><strong>如果最早空闲的桌子index不是vip桌，那么看队首的球员是不是vip球员。如果是普通人，就直接把球桌分配给他，如果是vip，那么需要找到最早空闲的vip桌子的号vipindex，根据vip球员的到达时间和vipindex桌子的空闲时间继续分类讨论。</strong><br><strong>分配的时候标记table的num++，统计该table服务的人数。</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;<span class="hljs-keyword">struct</span> person &#123;    <span class="hljs-type">int</span> arrive, start, time;    <span class="hljs-type">bool</span> vip;&#125;tempperson;<span class="hljs-keyword">struct</span> tablenode &#123;    <span class="hljs-type">int</span> end = <span class="hljs-number">8</span> * <span class="hljs-number">3600</span>, num;    <span class="hljs-type">bool</span> vip;&#125;;<span class="hljs-type">bool</span> cmp1(person a, person b) &#123;    <span class="hljs-keyword">return</span> a.arrive &lt; b.arrive;&#125;<span class="hljs-type">bool</span> cmp2(person a, person b) &#123;    <span class="hljs-keyword">return</span> a.start &lt; b.start;&#125;vector&lt;person&gt; player;vector&lt;tablenode&gt; table;void alloctable(<span class="hljs-type">int</span> personid, <span class="hljs-type">int</span> tableid) &#123;    <span class="hljs-keyword">if</span>(player[personid].arrive &lt;= table[tableid].end)        player[personid].start = table[tableid].end;    <span class="hljs-keyword">else</span>        player[personid].start = player[personid].arrive;    table[tableid].end = player[personid].start + player[personid].time;    table[tableid].num++;&#125;<span class="hljs-comment">// 找到第一个vip用户</span><span class="hljs-type">int</span> findnextvip(<span class="hljs-type">int</span> vipid) &#123;    vipid++;    while(vipid &lt; player.size() &amp;&amp; !player[vipid].vip) vipid++;    <span class="hljs-keyword">return</span> vipid;&#125;<span class="hljs-type">int</span> main() &#123;    <span class="hljs-type">int</span> n, k, m, viptable;    scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-type">int</span> h, m, s, temptime, flag;        scanf(<span class="hljs-string">&quot;%d:%d:%d %d %d&quot;</span>, &amp;h, &amp;m, &amp;s, &amp;temptime, &amp;flag);        tempperson.arrive = h * <span class="hljs-number">3600</span> + m * <span class="hljs-number">60</span> + s;        tempperson.start = <span class="hljs-number">21</span> * <span class="hljs-number">3600</span>;        <span class="hljs-keyword">if</span>(tempperson.arrive &gt;= <span class="hljs-number">21</span> * <span class="hljs-number">3600</span>) <span class="hljs-keyword">continue</span>;        tempperson.time = temptime &lt;= <span class="hljs-number">120</span> ? temptime * <span class="hljs-number">60</span> : <span class="hljs-number">7200</span>;        tempperson.vip = (flag == <span class="hljs-number">1</span>);        player.push_back(tempperson);    &#125;    scanf(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;k, &amp;m);    table.resize(k + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;viptable);        table[viptable].vip = <span class="hljs-literal">true</span>;    &#125;    sort(player.begin(), player.end(), cmp1);    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, vipid = <span class="hljs-number">-1</span>;    vipid = findnextvip(vipid);    while(i &lt; player.size()) &#123;        <span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>, minendtime = <span class="hljs-number">999999999</span>;        <span class="hljs-comment">// 找到最早结束的桌子</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) &#123;            <span class="hljs-keyword">if</span>(table[j].end &lt; minendtime) &#123;                minendtime = table[j].end;                index = j;            &#125;        &#125;        <span class="hljs-keyword">if</span>(table[index].end &gt;= <span class="hljs-number">21</span> * <span class="hljs-number">3600</span>) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 这个vip已经被分配过了</span>        <span class="hljs-keyword">if</span>(player[i].vip &amp;&amp; i &lt; vipid) &#123;            i++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 第一个结束的桌子是vip桌</span>        <span class="hljs-keyword">if</span>(table[index].vip) &#123;            <span class="hljs-comment">// 下一个玩家刚好是vip</span>            <span class="hljs-keyword">if</span>(player[i].vip) &#123;                alloctable(i, index);                <span class="hljs-keyword">if</span>(vipid == i) vipid = findnextvip(vipid);                i++;            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//vip桌子空闲了但是下一个不是vip</span>                <span class="hljs-comment">// 看看是否有空闲的非vip桌子</span>                <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=index;j++)&#123;                   <span class="hljs-keyword">if</span>(!table[j].vip &amp;&amp; player[i].arrive &gt;table[j].end)&#123;                       <span class="hljs-comment">// 分配给普通用户</span>                       alloctable(i, j);                       i++;                       flag = <span class="hljs-literal">false</span>;                       <span class="hljs-keyword">break</span>;                   &#125;               &#125;               <span class="hljs-keyword">if</span>(flag)&#123;                   <span class="hljs-comment">// 最近的vip在桌子结束前到达</span>                   <span class="hljs-keyword">if</span>(vipid &lt; player.size() &amp;&amp; player[vipid].arrive &lt;= table[index].end) &#123;                       alloctable(vipid, index);                       vipid = findnextvip(vipid);                   &#125; <span class="hljs-keyword">else</span> &#123;                       <span class="hljs-comment">// 分配给普通用户</span>                       alloctable(i, index);                       i++;                   &#125;               &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 第一个结束的桌子不是vip桌</span>            <span class="hljs-keyword">if</span>(!player[i].vip) &#123; <span class="hljs-comment">// 最近到达的用户不是vip，就分配给他</span>                alloctable(i, index);                i++;            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//最近的用户是vip</span>                <span class="hljs-type">int</span> vipindex = <span class="hljs-number">-1</span>, minvipendtime = <span class="hljs-number">999999999</span>;                <span class="hljs-comment">// 看是最快的vip桌哪时候空闲下来</span>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) &#123;                    <span class="hljs-keyword">if</span>(table[j].vip &amp;&amp; table[j].end &lt; minvipendtime) &#123;                        minvipendtime = table[j].end;                        vipindex = j;                    &#125;                &#125;                <span class="hljs-comment">// vip桌在vip玩家来之前就空闲下来就分配vip桌给vip用户</span>                <span class="hljs-keyword">if</span>(vipindex != <span class="hljs-number">-1</span> &amp;&amp; player[i].arrive &gt;= table[vipindex].end) &#123;                    alloctable(i, vipindex);                    <span class="hljs-keyword">if</span>(vipid == i) vipid = findnextvip(vipid);                    i++;                &#125; <span class="hljs-keyword">else</span> &#123;                    alloctable(i, index);                    <span class="hljs-keyword">if</span>(vipid == i) vipid = findnextvip(vipid);                    i++;                &#125;            &#125;        &#125;    &#125;    sort(player.begin(), player.end(), cmp2);    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; player.size() &amp;&amp; player[i].start &lt; <span class="hljs-number">21</span> * <span class="hljs-number">3600</span>; i++) &#123;        printf(<span class="hljs-string">&quot;%02d:%02d:%02d &quot;</span>, player[i].arrive / <span class="hljs-number">3600</span>, player[i].arrive % <span class="hljs-number">3600</span> / <span class="hljs-number">60</span>, player[i].arrive % <span class="hljs-number">60</span>);        printf(<span class="hljs-string">&quot;%02d:%02d:%02d &quot;</span>, player[i].start / <span class="hljs-number">3600</span>, player[i].start % <span class="hljs-number">3600</span> / <span class="hljs-number">60</span>, player[i].start % <span class="hljs-number">60</span>);        printf(<span class="hljs-string">&quot;%.0f\n&quot;</span>, round((player[i].start - player[i].arrive) / <span class="hljs-number">60.0</span>));    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;        <span class="hljs-keyword">if</span>(i != <span class="hljs-number">1</span>) printf(<span class="hljs-string">&quot; &quot;</span>);        printf(<span class="hljs-string">&quot;%d&quot;</span>, table[i].num);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1034 Head of a Gang (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1034%20Head%20of%20a%20Gang%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1034%20Head%20of%20a%20Gang%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Head-of-a-Gang"><a href="#Head-of-a-Gang" class="headerlink" title="Head of a Gang"></a><font size=6px>Head of a Gang</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between <em>A</em> and <em>B</em>, we say that <em>A</em> and <em>B</em> is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold <em>K</em>. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two positive numbers <em>N</em> and <em>K</em> (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then <em>N</em> lines follow, each in the following format:</p><pre><code class="hljs gcode"><span class="hljs-symbol">Name1</span> <span class="hljs-symbol">Name2</span> Time</code></pre><p>where <code>Name1</code> and <code>Name2</code> are the names of people at the two ends of the call, and <code>Time</code> is the length of the call. A name is a string of three capital letters chosen from <code>A</code>-<code>Z</code>. A time length is a positive integer which is no more than 1000 minutes.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><pre><code class="hljs in">8 59AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><pre><code class="hljs out">2AAA 3GGG 3</code></pre><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><pre><code class="hljs in">8 70AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><pre><code class="hljs out">0</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先把字母转化成编号，用dfs遍历每一个节点，遍历的时候计算出总重和总人数，并且用vis数组来保证一个节点只遍历一次，注意遍历完之后要G[u][i] &#x3D; G[i][u] &#x3D; 0;保证没有回边</p><p>注意点1:</p><pre><code class="hljs inform7">G<span class="hljs-comment">[id1]</span><span class="hljs-comment">[id2]</span> += time;G<span class="hljs-comment">[id2]</span><span class="hljs-comment">[id1]</span> += time;</code></pre><p>因为可能有 重复的情况，比如aaa bbb 1，bbb aaa 2</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include &lt;iostream&gt;#include &lt;<span class="hljs-keyword">map</span>&gt;using namespace std;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">string</span>, <span class="hljs-type">int</span>&gt; stringToInt;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">string</span>&gt; intToString;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">string</span>, <span class="hljs-type">int</span>&gt; ans;<span class="hljs-type">int</span> G[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>], weight[<span class="hljs-number">2010</span>];<span class="hljs-type">bool</span> vis[<span class="hljs-number">2010</span>];<span class="hljs-type">int</span> stringId=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> creatId(<span class="hljs-type">string</span> a)&#123;    <span class="hljs-keyword">if</span>(stringToInt.find(a) != stringToInt.end())&#123;        <span class="hljs-keyword">return</span> stringToInt[a];    &#125;    intToString[stringId] = a;    stringToInt[a] = stringId;    <span class="hljs-keyword">return</span> stringId++;&#125;void dfs(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> &amp;head,<span class="hljs-type">int</span> &amp;membernum,<span class="hljs-type">int</span> &amp;totalweight)&#123;    vis[u] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span>(weight[head] &lt; weight[u]) head = u;    membernum++;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;stringId;i++)&#123;        <span class="hljs-keyword">if</span>(G[i][u] &gt;<span class="hljs-number">0</span> )&#123;            totalweight += G[u][i];            G[u][i] = G[i][u] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span>(!vis[i])&#123;                dfs(i,head,membernum,totalweight);            &#125;        &#125;    &#125;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> m,n;    <span class="hljs-type">string</span> a,b;    <span class="hljs-type">int</span> time;    cin &gt;&gt;m&gt;&gt;n;    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;    while(m--)&#123;        cin &gt;&gt;a &gt;&gt;b&gt;&gt;time;        <span class="hljs-type">int</span> id1 = creatId(a);        <span class="hljs-type">int</span> id2 = creatId(b);        weight[id1] += time;        weight[id2] += time;        G[id1][id2] += time;        G[id2][id1] += time;    &#125;   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;stringId;i++)&#123;       <span class="hljs-keyword">if</span>(vis[i] == <span class="hljs-literal">false</span>)&#123;           <span class="hljs-type">int</span> head = i,membernum = <span class="hljs-number">0</span>,totalweight = <span class="hljs-number">0</span>;           dfs(i,head,membernum,totalweight);           <span class="hljs-keyword">if</span>(totalweight &gt; n &amp;&amp; membernum &gt;<span class="hljs-number">2</span>)&#123;               ans[intToString[head]] = membernum;           &#125;       &#125;   &#125;   cout &lt;&lt; ans.size()&lt;&lt;endl;   <span class="hljs-keyword">for</span>( auto i = ans.begin();i!= ans.end();i++)&#123;       <span class="hljs-keyword">if</span>(i != ans.begin()) cout &lt;&lt;endl;       cout &lt;&lt; i-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i-&gt;second;   &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1080 Graduate Admission (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1080%20Graduate%20Admission%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1080%20Graduate%20Admission%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Graduate-Admission"><a href="#Graduate-Admission" class="headerlink" title="Graduate Admission"></a><font size=6px>Graduate Admission</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.</p><p>Each applicant will have to provide two grades: the national entrance exam grade <em>G**E</em>, and the interview grade <em>G**I</em>. The final grade of an applicant is (<em>G**E</em>+<em>G**I</em>)&#x2F;2. The admission rules are:</p><ul><li>The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.</li><li>If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade <em>G**E</em>. If still tied, their ranks must be the same.</li><li>Each applicant may have <em>K</em> choices and the admission will be done according to his&#x2F;her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.</li><li>If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, <strong>even if its quota will be exceeded</strong>.</li></ul><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case.</p><p>Each case starts with a line containing three positive integers: <em>N</em> (≤40,000), the total number of applicants; <em>M</em> (≤100), the total number of graduate schools; and <em>K</em> (≤5), the number of choices an applicant may have.</p><p>In the next line, separated by a space, there are <em>M</em> positive integers. The <em>i</em>-th integer is the quota of the <em>i</em>-th graduate school respectively.</p><p>Then <em>N</em> lines follow, each contains 2+<em>K</em> integers separated by a space. The first 2 integers are the applicant’s <em>G**E</em> and <em>G**I</em>, respectively. The next <em>K</em> integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to <em>M</em>−1, and the applicants are numbered from 0 to <em>N</em>−1.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">11 6 32 1 2 2 2 3100 100 0 1 260 60 2 3 5100 90 0 3 490 100 1 2 090 90 5 1 380 90 1 0 280 80 0 1 280 80 0 1 280 70 1 3 270 80 1 2 3100 100 0 2 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">0 1035 6 72 81 4</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>根据总成绩和第一个成绩开始降序排序，根据名额把序号进行push中数组中。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;algorithm&quot;</span>using namespace std;<span class="hljs-type">int</span> m,n,k;<span class="hljs-keyword">struct</span> Stu&#123;    <span class="hljs-type">int</span> no;    float score;    <span class="hljs-type">int</span> ge;    <span class="hljs-type">int</span> pre_sch[<span class="hljs-number">6</span>];&#125;;<span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">struct</span> Stu a, <span class="hljs-keyword">struct</span> Stu b)&#123;    <span class="hljs-keyword">if</span>(a.score == b.score)&#123;        <span class="hljs-keyword">return</span> a.ge &gt; b.ge;    &#125;    <span class="hljs-keyword">return</span> a.score &gt; b.score;&#125;<span class="hljs-type">int</span> main()&#123;    cin &gt;&gt;m&gt;&gt;n&gt;&gt;k;    <span class="hljs-type">int</span> a,b;    <span class="hljs-keyword">struct</span> Stu stu[m+<span class="hljs-number">1</span>];    <span class="hljs-type">int</span> sch[n];    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sch_grad;    <span class="hljs-comment">// 输入学校的容量</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        cin &gt;&gt;sch[i];        vector&lt;<span class="hljs-type">int</span>&gt; c;        sch_grad.push_back(c);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m; i++)&#123;        cin &gt;&gt;a&gt;&gt;b;        stu[i].ge = a;        stu[i].score = float (a+b)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;k; j++)&#123;            cin &gt;&gt;stu[i].pre_sch[j];        &#125;        stu[i].no = i;    &#125;    sort(stu, stu+m, cmp);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;k;j++)&#123;            <span class="hljs-comment">//找到一个符合的学校</span>            <span class="hljs-keyword">if</span>(sch[stu[i].pre_sch[j]] &gt;<span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">// 把合适的节点加入</span>                sch_grad[stu[i].pre_sch[j]].push_back(stu[i].no);                sch[stu[i].pre_sch[j]]--;                <span class="hljs-keyword">if</span>(i&lt;m<span class="hljs-number">-1</span> &amp;&amp;stu[i].score == stu[i+<span class="hljs-number">1</span>].score &amp;&amp; stu[i].ge == stu[i+<span class="hljs-number">1</span>].ge)&#123;                    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;p&lt;k;p++)&#123;                        <span class="hljs-keyword">if</span>(stu[i].pre_sch[p] != stu[i+<span class="hljs-number">1</span>].pre_sch[p] )&#123;                            flag = <span class="hljs-literal">false</span>;                            <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                    <span class="hljs-comment">// 和后一个成绩和意愿都一样</span>                    <span class="hljs-keyword">if</span> (flag)&#123;                        <span class="hljs-keyword">if</span>(sch[stu[i].pre_sch[j]] == <span class="hljs-number">0</span>)&#123;                            sch[stu[i].pre_sch[j]]++;                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n;i++)&#123;        sort(sch_grad[i].begin(),sch_grad[i].end() );        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;sch_grad[i].size(); j++)&#123;            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;                cout &lt;&lt; sch_grad[i][j];            &#125;<span class="hljs-keyword">else</span>&#123;                cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;sch_grad[i][j];            &#125;        &#125;        cout&lt;&lt;endl;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1091 Acute Stroke (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1091%20Acute%20Stroke%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1091%20Acute%20Stroke%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Acute-Stroke-30-分"><a href="#Acute-Stroke-30-分" class="headerlink" title="Acute Stroke (30 分)"></a><font size=6px>Acute Stroke (30 分)</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>One important factor to identify acute stroke (急性脑卒中) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 4 positive integers: <em>M</em>, <em>N</em>, <em>L</em> and <em>T</em>, where <em>M</em> and <em>N</em> are the sizes of each slice (i.e. pixels of a slice are in an <em>M</em>×<em>N</em> matrix, and the maximum resolution is 1286 by 128); <em>L</em> (≤60) is the number of slices of a brain; and <em>T</em> is the integer threshold (i.e. if the volume of a connected core is less than <em>T</em>, then that core must not be counted).</p><p>Then <em>L</em> slices are given. Each slice is represented by an <em>M</em>×<em>N</em> matrix of 0’s and 1’s, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1’s to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than <em>T</em> are counted. Two pixels are <strong>connected</strong> and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one.</p><p><img src="https://images.ptausercontent.com/f85c00cc-62ce-41ff-8dd0-d1c288d87409.jpg" alt="figstroke.jpg"></p><p>Figure 1</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output in a line the total volume of the stroke core.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">3 4 5 21 1 1 11 1 1 11 1 1 10 0 1 10 0 1 10 0 1 11 0 1 10 1 0 00 0 0 01 0 1 10 0 0 00 0 0 00 0 0 10 0 0 11 0 0 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">26</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一个三维bfs题，题目不难，细节难，dfs会爆栈不行，bfs不能用vector要用queue，不然会超时。bfs细节是vis[endd.x][endd.y][endd.z] &#x3D; true;这句话放的位置很重要</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;<span class="hljs-keyword">map</span>&gt;#include&lt;queue&gt;using namespace std;<span class="hljs-type">int</span> maze[<span class="hljs-number">60</span>][<span class="hljs-number">1286</span>][<span class="hljs-number">128</span>];<span class="hljs-type">int</span> vis[<span class="hljs-number">60</span>][<span class="hljs-number">1286</span>][<span class="hljs-number">128</span>];<span class="hljs-type">int</span> n,m,l,t;<span class="hljs-type">int</span> nxt[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<span class="hljs-keyword">struct</span> node&#123;    <span class="hljs-type">int</span> x,y,z;&#125;;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;void BFS(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> k)&#123;    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;    queue&lt;node&gt;qu;    node s = &#123;i,j,k&#125;;    qu.push(s);    vis[i][j][k] = <span class="hljs-literal">true</span>;    while(!qu.empty())    &#123;        node tmp = qu.front();        qu.pop();        node endd;        cnt++;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">6</span>; i++)        &#123;            endd.x = tmp.x + nxt[i][<span class="hljs-number">0</span>];            endd.y = tmp.y + nxt[i][<span class="hljs-number">1</span>];            endd.z = tmp.z + nxt[i][<span class="hljs-number">2</span>];            <span class="hljs-keyword">if</span>(endd.x &gt;=<span class="hljs-number">0</span> &amp;&amp; endd.x &lt; l &amp;&amp; endd.y &gt;= <span class="hljs-number">0</span> &amp;&amp; endd.y &lt; n &amp;&amp; endd.z &gt;= <span class="hljs-number">0</span> &amp;&amp; endd.z &lt; m               &amp;&amp; vis[endd.x][endd.y][endd.z] == <span class="hljs-literal">false</span>  &amp;&amp; maze[endd.x][endd.y][endd.z] == <span class="hljs-number">1</span>)            &#123;                vis[endd.x][endd.y][endd.z] = <span class="hljs-literal">true</span>;                qu.push(endd);            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(cnt &gt;= t)        total += cnt;&#125;<span class="hljs-type">int</span> main()&#123;    scanf(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;l,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; m; k++)                scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;maze[i][j][k]);        &#125;    &#125;<span class="hljs-comment">//表示输入</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; m; k++)            &#123;                node s = &#123;i,j,k&#125;;                <span class="hljs-keyword">if</span>(maze[i][j][k] == <span class="hljs-number">1</span> &amp;&amp; !vis[i][j][k])<span class="hljs-comment">//首先这个东西是1? 其次还没有走过它</span>                    BFS(i,j,k);            &#125;        &#125;    &#125;    printf(<span class="hljs-string">&quot;%d\n&quot;</span>,total);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1099 Build A Binary Search Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1099%20Build%20A%20Binary%20Search%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1099%20Build%20A%20Binary%20Search%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Build-A-Binary-Search-Tree"><a href="#Build-A-Binary-Search-Tree" class="headerlink" title="Build A Binary Search Tree "></a><font size=6px>Build A Binary Search Tree </font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2.</p><p><img src="https://images.ptausercontent.com/24c2521f-aaed-4ef4-bac8-3ff562d80a1b.jpg" alt="figBST.jpg"></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤100) which is the total number of nodes in the tree. The next <em>N</em> lines each contains the left and the right children of a node in the format <code>left_index right_index</code>, provided that the nodes are numbered from 0 to <em>N</em>−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally <em>N</em> distinct integer keys are given in the last line.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">91 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">58 25 82 11 38 67 45 73 42</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先按照序列构造二叉树，再讲数组排序用中序插入数字</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;<span class="hljs-keyword">struct</span> node &#123;    <span class="hljs-type">int</span> data, left, right;&#125;tree[<span class="hljs-number">99999</span>];<span class="hljs-type">int</span> ele[<span class="hljs-number">99999</span>], N, l, r, ele_i = <span class="hljs-number">0</span>, start = <span class="hljs-literal">true</span>;void inorder(<span class="hljs-type">int</span> root) &#123;    <span class="hljs-keyword">if</span>(tree[root].left !=  <span class="hljs-number">-1</span>) inorder(tree[root].left);    tree[root].data = ele[ele_i++];    <span class="hljs-keyword">if</span>(tree[root].right !=  <span class="hljs-number">-1</span>) inorder(tree[root].right);&#125;void levelorder(<span class="hljs-type">int</span> root) &#123;    queue&lt;<span class="hljs-type">int</span>&gt; que;    que.push(root);    while(!que.empty()) &#123;        node n = tree[que.front()];        <span class="hljs-keyword">if</span>(start) printf(<span class="hljs-string">&quot;%d&quot;</span>, n.data);        <span class="hljs-keyword">else</span> printf(<span class="hljs-string">&quot; %d&quot;</span>, n.data);        start = <span class="hljs-literal">false</span>;        que.pop();        <span class="hljs-keyword">if</span>(n.left != <span class="hljs-number">-1</span>) que.push(n.left);        <span class="hljs-keyword">if</span>(n.right != <span class="hljs-number">-1</span>) que.push(n.right);    &#125;&#125;<span class="hljs-type">int</span> main() &#123;    scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) scanf(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;tree[i].left, &amp;tree[i].right);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ele[i]);    sort(ele, ele + N);    inorder(<span class="hljs-number">0</span>);    levelorder(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1030 Travel Plan (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1030%20Travel%20Plan%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1030%20Travel%20Plan%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Travel-Plan"><a href="#Travel-Plan" class="headerlink" title="Travel Plan"></a><font size=6px>Travel Plan</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his&#x2F;her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing 4 positive integers <em>N</em>, <em>M</em>, <em>S</em>, and <em>D</em>, where <em>N</em> (≤500) is the number of cities (and hence the cities are numbered from 0 to <em>N</em>−1); <em>M</em> is the number of highways; <em>S</em> and <em>D</em> are the starting and the destination cities, respectively. Then <em>M</em> lines follow, each provides the information of a highway, in the format:</p><pre><code class="hljs arcade">City1 City2 <span class="hljs-built_in">Distance</span> Cost</code></pre><p>where the numbers are all integers no more than 500, and are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">4 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">0 2 3 3 40</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用狄杰斯特拉算法做，再加上一个pre数组来记录前一个数，再dfs来遍历最小cost</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;string.h&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#define inf <span class="hljs-number">0x3f3f3f</span>using  namespace std;<span class="hljs-type">int</span> dest[<span class="hljs-number">501</span>][<span class="hljs-number">501</span>];vector&lt;<span class="hljs-type">int</span>&gt; pre[<span class="hljs-number">501</span>];vector&lt;<span class="hljs-type">int</span>&gt;temp, res;<span class="hljs-type">int</span> costs[<span class="hljs-number">501</span>][<span class="hljs-number">501</span>];<span class="hljs-type">int</span> vis[<span class="hljs-number">501</span>];<span class="hljs-type">int</span> dis[<span class="hljs-number">501</span>];<span class="hljs-type">int</span> n,m,s,d;<span class="hljs-type">int</span> minCost = inf;<span class="hljs-comment">// 得到最短距离结果之后从后往前遍历最小花费</span>void dfs(<span class="hljs-type">int</span> v)&#123;    temp.push_back(v);    <span class="hljs-keyword">if</span>(v == s)&#123;        <span class="hljs-type">int</span> tempCost = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;temp.size(); i++)&#123;            tempCost += costs[temp[i<span class="hljs-number">-1</span>]][temp[i]];        &#125;        <span class="hljs-keyword">if</span>(minCost &gt; tempCost)&#123;            res = temp;            minCost = tempCost;        &#125;        temp.pop_back();        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pre[v].size(); i++)        dfs(pre[v][i]);    temp.pop_back();&#125;<span class="hljs-type">int</span> main()&#123;    memset(dis,inf, sizeof (dis));    fill(dest[<span class="hljs-number">0</span>],dest[<span class="hljs-number">0</span>]+<span class="hljs-number">501</span>*<span class="hljs-number">501</span>, inf);    cin &gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d;    memset(vis,<span class="hljs-number">0</span>, sizeof(vis));    <span class="hljs-type">int</span> a,b,distance,cost;    while(m--)&#123;        cin &gt;&gt;a&gt;&gt;b&gt;&gt;distance&gt;&gt;cost;        dest[a][b] = dest[b][a] = distance;        costs[a][b] = costs[b][a] = cost;    &#125;    dis[s] = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n ;i++)&#123;       <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>,minn = inf;       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)&#123;           <span class="hljs-keyword">if</span>(vis[j] == <span class="hljs-number">0</span> &amp;&amp; ( minn &gt; dis[j]))&#123;               minn = dis[j];               u = j;           &#125;       &#125;       <span class="hljs-keyword">if</span>(u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;       vis[u] = <span class="hljs-number">1</span>;       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n;j++)&#123;           <span class="hljs-keyword">if</span>( !vis[j] &amp;&amp; dest[u][j] != inf)&#123;               <span class="hljs-keyword">if</span> (dis[j] &gt; dis[u] + dest[u][j])&#123;                   dis[j] = dis[u] + dest[u][j];                   pre[j].clear();                   pre[j].push_back(u);               &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[j] == dis[u] + dest[u][j])&#123;                   pre[j].push_back(u);               &#125;           &#125;       &#125;   &#125;    dfs(d);   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=res.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;       <span class="hljs-keyword">if</span>(i == res.size()<span class="hljs-number">-1</span>) cout &lt;&lt;res[i];       <span class="hljs-keyword">else</span> cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;res[i];   &#125;   cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;dis[d]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;minCost;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1087 All Roads Lead to Rome (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1087%20All%20Roads%20Lead%20to%20Rome%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1087%20All%20Roads%20Lead%20to%20Rome%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="All-Roads-Lead-to-Rome"><a href="#All-Roads-Lead-to-Rome" class="headerlink" title="All Roads Lead to Rome"></a><font size=6px>All Roads Lead to Rome</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 2 positive integers <em>N</em> (2≤<em>N</em>≤200), the number of cities, and <em>K</em>, the total number of routes between pairs of cities; followed by the name of the starting city. The next <em>N</em>−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then <em>K</em> lines follow, each describes a route between two cities in the format <code>City1 City2 Cost</code>. Here the name of a city is a string of 3 capital English letters, and the destination is always <code>ROM</code> which represents Rome.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.</p><p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format <code>City1-&gt;City2-&gt;...-&gt;ROM</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">6 7 HZHROM 100PKN 40GDN 55PRS 95BLN 80ROM GDN 1BLN ROM 1HZH PKN 1PRS ROM 2BLN HZH 2PKN GDN 1HZH PRS 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">3 3 195 97HZH-&gt;PRS-&gt;ROM</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>和1030题很像，动态规划➕dfs，用pre数组存储这个节点之前的节点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;string.h&quot;</span>#include <span class="hljs-string">&quot;map&quot;</span>using namespace std;#define inf <span class="hljs-number">0x3f3f3f3f</span><span class="hljs-type">int</span> dis[<span class="hljs-number">201</span>][<span class="hljs-number">201</span>];<span class="hljs-type">int</span> dest[<span class="hljs-number">201</span>];<span class="hljs-type">int</span> vis[<span class="hljs-number">201</span>];vector&lt;<span class="hljs-type">int</span>&gt; pre[<span class="hljs-number">201</span>],temp,res;<span class="hljs-type">int</span> maxHappy = <span class="hljs-number">0</span>;<span class="hljs-keyword">struct</span> City&#123;    <span class="hljs-type">int</span> no,happy;    <span class="hljs-type">string</span> name;&#125;;<span class="hljs-type">int</span> m,n;<span class="hljs-type">string</span> start;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">string</span>, City&gt; mapCity;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">int</span>, City&gt; mapCityNo;<span class="hljs-type">int</span> pathNumber=<span class="hljs-number">0</span>;void dfs(<span class="hljs-type">int</span> v)&#123;    temp.push_back(v);    <span class="hljs-keyword">if</span>(v == mapCity[start].no)&#123;        pathNumber ++;        <span class="hljs-type">int</span> tempHappy = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.size(); i++)&#123;            tempHappy += mapCityNo[temp[i]].happy;        &#125;        <span class="hljs-keyword">if</span>(tempHappy &gt; maxHappy)&#123;            maxHappy = tempHappy;            res = temp;        &#125;        temp.pop_back();        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i: pre[v]) dfs(i);    temp.pop_back();&#125;<span class="hljs-type">int</span> main()&#123;    memset(dis,inf, sizeof(dis));    memset(dest,inf, sizeof(dest));    memset(vis,<span class="hljs-number">0</span>, sizeof(vis));    cin &gt;&gt;m&gt;&gt;n&gt;&gt;start;    City city;    city.no = <span class="hljs-number">0</span>;    city.name = start;    city.happy = <span class="hljs-number">0</span>;    mapCity[start] = city;    mapCityNo[<span class="hljs-number">0</span>] = city;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;        City node;        cin &gt;&gt;node.name &gt;&gt;node.happy;        node.no = i;        mapCity[node.name] = node;        mapCityNo[node.no] = node;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;        <span class="hljs-type">string</span> a,b;        <span class="hljs-type">int</span> c;        cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;        dis[mapCity[a].no][mapCity[b].no] =dis[mapCity[b].no][mapCity[a].no]= c;    &#125;    dest[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m; i++)&#123;        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>, minn = inf;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;            <span class="hljs-keyword">if</span>( vis[j] == <span class="hljs-number">0</span> &amp;&amp; dest[j] &lt; minn)&#123;                minn = dest[j];                u = j;            &#125;        &#125;        <span class="hljs-keyword">if</span>(u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;        vis[u] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m ; j++)&#123;            <span class="hljs-keyword">if</span>(vis[j] == <span class="hljs-number">0</span> &amp;&amp; dis[u][j] != inf)&#123;                <span class="hljs-keyword">if</span>(dest[j] &gt;dest[u] + dis[u][j])&#123;                    dest[j] = dest[u] + dis[u][j];                    pre[j].clear();                    pre[j].push_back(u);                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dest[j] == dest[u] + dis[u][j])&#123;                    pre[j].push_back(u);                &#125;            &#125;        &#125;    &#125;    dfs(mapCity[<span class="hljs-string">&quot;ROM&quot;</span>].no);    cout &lt;&lt; pathNumber&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;dest[mapCity[<span class="hljs-string">&quot;ROM&quot;</span>].no]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;maxHappy&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;maxHappy/(res.size()<span class="hljs-number">-1</span>)&lt;&lt;endl;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=res.size()<span class="hljs-number">-1</span>;i &gt;=<span class="hljs-number">0</span> ;i--)&#123;        <span class="hljs-keyword">if</span>(i == res.size()<span class="hljs-number">-1</span>)&#123;            cout &lt;&lt; mapCityNo[res[i]].name;        &#125;<span class="hljs-keyword">else</span>&#123;           cout &lt;&lt;  <span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt; mapCityNo[res[i]].name;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1107 Social Clusters (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1107%20Social%20Clusters%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1107%20Social%20Clusters%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Social-Clusters"><a href="#Social-Clusters" class="headerlink" title="Social Clusters"></a><font size=6px>Social Clusters</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A <strong>social cluster</strong> is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains a positive integer <em>N</em> (≤1000), the total number of people in a social network. Hence the people are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each gives the hobby list of a person in the format:</p><p><em>K**i</em>: <em>h**i</em>[1] <em>h**i</em>[2] … <em>h**i</em>[<em>K**i</em>]</p><p>where <em>K**i</em> (&gt;0) is the number of hobbies, and <em>h**i</em>[<em>j</em>] is the index of the <em>j</em>-th hobby, which is an integer in [1, 1000].</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">83: 2 7 101: 42: 5 31: 41: 31: 44: 6 8 1 51: 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">34 3 1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>纯纯的并查集题目</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;string.h&quot;</span>#include <span class="hljs-string">&quot;algorithm&quot;</span>using namespace std;<span class="hljs-type">int</span> father[<span class="hljs-number">1001</span>],hobby[<span class="hljs-number">1001</span>];<span class="hljs-type">int</span> num[<span class="hljs-number">1001</span>];<span class="hljs-type">int</span> find(<span class="hljs-type">int</span> a)&#123;    while(a != father[a])&#123;        a = father[a];    &#125;    <span class="hljs-keyword">return</span> a;&#125;void Union(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-type">int</span> fa = find(a);    <span class="hljs-type">int</span> fb = find(b);    <span class="hljs-keyword">if</span>(fa != fb)&#123;        father[fb] = fa;    &#125;&#125;<span class="hljs-type">bool</span> cmp(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-keyword">return</span> a&gt;b;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt;n;    memset(hobby, <span class="hljs-number">0</span> ,sizeof (hobby));    memset(num, <span class="hljs-number">0</span> ,sizeof (hobby));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n ;i++)&#123;        father[i] = i;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> num1;        scanf(<span class="hljs-string">&quot;%d: &quot;</span>,&amp;num1);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j &lt; num1; j++)&#123;            <span class="hljs-type">int</span> t ;            cin &gt;&gt;t;            <span class="hljs-keyword">if</span>( hobby[t] == <span class="hljs-number">0</span>)  hobby[t] = i;            <span class="hljs-keyword">else</span> &#123;               Union(hobby[t], i);           &#125;        &#125;    &#125;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;        <span class="hljs-type">int</span> temp = find(i);        <span class="hljs-keyword">if</span> (i == temp) sum++;        num[temp]++;    &#125;    sort(num,num+<span class="hljs-number">1000</span>,cmp);    cout &lt;&lt; sum&lt;&lt;endl;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sum;i++)&#123;        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;            cout&lt;&lt;num[i];        &#125;<span class="hljs-keyword">else</span>&#123;            cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;num[i];        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1111 Online Map (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1111%20Online%20Map%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1111%20Online%20Map%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Online-Map"><a href="#Online-Map" class="headerlink" title="Online Map "></a><font size=6px>Online Map </font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers <em>N</em> (2≤<em>N</em>≤500), and <em>M</em>, being the total number of streets intersections on a map, and the number of streets, respectively. Then <em>M</em> lines follow, each describes a street in the format:</p><pre><code class="hljs livecodeserver">V1 V2 <span class="hljs-literal">one</span>-way <span class="hljs-built_in">length</span> <span class="hljs-built_in">time</span></code></pre><p>where <code>V1</code> and <code>V2</code> are the indices (from 0 to <em>N</em>−1) of the two ends of the street; <code>one-way</code> is 1 if the street is one-way from <code>V1</code> to <code>V2</code>, or 0 if not; <code>length</code> is the length of the street; and <code>time</code> is the time taken to pass the street.</p><p>Finally a pair of source and destination is given.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, first print the shortest path from the source to the destination with distance <code>D</code> in the format:</p><pre><code class="hljs xl">D<span class="hljs-function"><span class="hljs-title">istance</span> = D: source -&gt;</span> <span class="hljs-function"><span class="hljs-title">v1</span> -&gt;</span> ... -&gt; destination</code></pre><p>Then in the next line print the fastest path with total time <code>T</code>:</p><pre><code class="hljs coq"><span class="hljs-keyword">Time</span> = T: source -&gt; w1 -&gt; ... -&gt; destination</code></pre><p>In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique.</p><p>In case the shortest and the fastest paths are identical, print them in one line in the format:</p><pre><code class="hljs coq">Distance = D; <span class="hljs-keyword">Time</span> = T: source -&gt; u1 -&gt; ... -&gt; destination</code></pre><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><pre><code class="hljs in">10 150 1 0 1 18 0 0 1 14 8 1 1 13 4 0 3 23 9 1 4 10 6 0 1 17 5 1 2 18 5 1 2 12 3 0 2 22 1 1 1 11 3 0 3 11 4 0 1 19 7 1 3 15 1 0 5 26 5 1 1 23 5</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><pre><code class="hljs out">Distance = 6: 3 -&gt; 4 -&gt; 8 -&gt; 5Time = 3: 3 -&gt; 1 -&gt; 5</code></pre><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><pre><code class="hljs in">7 90 4 1 1 11 6 1 1 32 6 1 1 12 5 1 2 23 0 0 1 13 1 1 1 33 2 1 1 24 5 0 2 26 5 1 1 23 5</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><pre><code class="hljs"></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>比普通dijstra多一个单路和双路，思路是两个dijstra算法和前缀算出最短路径的最短时间和最短时间路径最短。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">999999999</span>;<span class="hljs-type">int</span> dis[<span class="hljs-number">510</span>], Time[<span class="hljs-number">510</span>], e[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>], w[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>], dispre[<span class="hljs-number">510</span>],Timepre[<span class="hljs-number">510</span>], weight[<span class="hljs-number">510</span>],NodeNum[<span class="hljs-number">510</span>];<span class="hljs-type">bool</span> visit[<span class="hljs-number">510</span>];vector&lt;<span class="hljs-type">int</span>&gt; dispath, Timepath, temppath;<span class="hljs-type">int</span> st, fin, minnode = inf;void dfsdispath(<span class="hljs-type">int</span> v) &#123;    dispath.push_back(v);    <span class="hljs-keyword">if</span>(v == st) <span class="hljs-keyword">return</span> ;    dfsdispath(dispre[v]);&#125;void dfsTimepath(<span class="hljs-type">int</span> v) &#123;    Timepath.push_back(v);    <span class="hljs-keyword">if</span>(v == st) <span class="hljs-keyword">return</span> ;    dfsTimepath(Timepre[v]);&#125;<span class="hljs-type">int</span> main() &#123;    fill(dis, dis + <span class="hljs-number">510</span>, inf);    fill(Time, Time + <span class="hljs-number">510</span>, inf);    fill(weight, weight + <span class="hljs-number">510</span>, inf);    fill(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">0</span>] + <span class="hljs-number">510</span> * <span class="hljs-number">510</span>, inf);    fill(w[<span class="hljs-number">0</span>], w[<span class="hljs-number">0</span>] + <span class="hljs-number">510</span> * <span class="hljs-number">510</span>, inf);    <span class="hljs-type">int</span> n, m;    scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-type">int</span> a, b, flag, <span class="hljs-built_in">len</span>, t;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        scanf(<span class="hljs-string">&quot;%d %d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;flag, &amp;<span class="hljs-built_in">len</span>, &amp;t);        e[a][b] = <span class="hljs-built_in">len</span>;        w[a][b] = t;        <span class="hljs-keyword">if</span>(flag != <span class="hljs-number">1</span>) &#123;            e[b][a] = <span class="hljs-built_in">len</span>;            w[b][a] = t;        &#125;    &#125;    scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;st, &amp;fin);    dis[st] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        dispre[i] = i;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>, minn = inf;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span>(visit[j] == <span class="hljs-literal">false</span> &amp;&amp; dis[j] &lt; minn) &#123;                u = j;                minn = dis[j];            &#125;        &#125;        <span class="hljs-keyword">if</span>(u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;        visit[u] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;            <span class="hljs-keyword">if</span>(visit[v] == <span class="hljs-literal">false</span> &amp;&amp; e[u][v] != inf) &#123;                <span class="hljs-keyword">if</span>(e[u][v] + dis[u] &lt; dis[v]) &#123;                    dis[v] = e[u][v] + dis[u];                    dispre[v] = u;                    weight[v] = weight[u] + w[u][v];                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e[u][v] + dis[u] == dis[v] &amp;&amp; weight[v] &gt; weight[u] + w[u][v]) &#123;                    weight[v] = weight[u] + w[u][v];                    dispre[v] = u;                &#125;            &#125;        &#125;    &#125;    dfsdispath(fin);    Time[st] = <span class="hljs-number">0</span>;    fill(visit, visit + <span class="hljs-number">510</span>, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>, minn = inf;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span>(visit[j] == <span class="hljs-literal">false</span> &amp;&amp; minn &gt; Time[j]) &#123;                u = j;                minn = Time[j];            &#125;        &#125;        <span class="hljs-keyword">if</span>(u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;        visit[u] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;            <span class="hljs-keyword">if</span>(visit[v] == <span class="hljs-literal">false</span> &amp;&amp; w[u][v] != inf) &#123;                <span class="hljs-keyword">if</span>(w[u][v] + Time[u] &lt; Time[v]) &#123;                    Time[v] = w[u][v] + Time[u];                    Timepre[v]= u;                    NodeNum[v]=NodeNum[u]+<span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(w[u][v] + Time[u] == Time[v]&amp;&amp;NodeNum[u]+<span class="hljs-number">1</span>&lt;NodeNum[v]) &#123;                    Timepre[v]= u;                    NodeNum[v]=NodeNum[u]+<span class="hljs-number">1</span>;                &#125;            &#125;        &#125;    &#125;    dfsTimepath(fin);    printf(<span class="hljs-string">&quot;Distance = %d&quot;</span>, dis[fin]);    <span class="hljs-keyword">if</span>(dispath == Timepath) &#123;        printf(<span class="hljs-string">&quot;; Time = %d: &quot;</span>, Time[fin]);    &#125; <span class="hljs-keyword">else</span> &#123;        printf(<span class="hljs-string">&quot;: &quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = dispath.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            printf(<span class="hljs-string">&quot;%d&quot;</span>, dispath[i]);            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) printf(<span class="hljs-string">&quot; -&gt; &quot;</span>);        &#125;        printf(<span class="hljs-string">&quot;\nTime = %d: &quot;</span>, Time[fin]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = Timepath.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        printf(<span class="hljs-string">&quot;%d&quot;</span>, Timepath[i]);        <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) printf(<span class="hljs-string">&quot; -&gt; &quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1115 Counting Nodes in a BST (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1115%20Counting%20Nodes%20in%20a%20BST%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1115%20Counting%20Nodes%20in%20a%20BST%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Counting-Nodes-in-a-BST"><a href="#Counting-Nodes-in-a-BST" class="headerlink" title="Counting Nodes in a BST"></a><font size=6px>Counting Nodes in a BST</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than or equal to the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>Insert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤1000) which is the size of the input sequence. Then given in the next line are the <em>N</em> integers in [−1000,1000] which are supposed to be inserted into an initially empty binary search tree.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format:</p><pre><code class="hljs gcode"><span class="hljs-symbol">n1</span> + <span class="hljs-symbol">n2</span> = <span class="hljs-symbol">n</span></code></pre><p>where <code>n1</code> is the number of nodes in the lowest level, <code>n2</code> is that of the level above, and <code>n</code> is the sum.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">925 30 42 16 20 20 35 -5 28</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">2 + 4 = 6</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>递归构建二叉树之后，层次遍历各个层的数量，最后输出最后两层。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;queue&quot;</span>using namespace std;<span class="hljs-keyword">struct</span> Node &#123;    Node * left,*right;    <span class="hljs-type">int</span> num;&#125;;Node *buildNode(<span class="hljs-type">int</span> a)&#123;    Node* node = (Node *)malloc(sizeof(Node));    node-&gt;num = a;    node-&gt;right = nullptr;    node-&gt;left = nullptr;    <span class="hljs-keyword">return</span> node;&#125;;Node *build(Node * root, <span class="hljs-type">int</span> a)&#123;    <span class="hljs-keyword">if</span>(root == nullptr)&#123;        <span class="hljs-keyword">return</span> buildNode(a);    &#125;    <span class="hljs-keyword">if</span>(a &gt; root-&gt;num) root-&gt;right = build(root-&gt;right, a);    <span class="hljs-keyword">else</span>  root-&gt;left = build(root-&gt;left, a);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;    cin &gt;&gt; n ;    Node * root = nullptr;    while(n--)&#123;        <span class="hljs-type">int</span> a;        cin &gt;&gt;a;        root = build(root, a);    &#125;    vector&lt;<span class="hljs-type">int</span>&gt; level;    queue&lt;Node *&gt; que1,que2;    que1.push(root);    while(!que1.empty()  )&#123;        <span class="hljs-type">int</span> levels = <span class="hljs-number">0</span>;        while(!que1.empty())&#123;            Node* node = que1.front();            levels++;            que1.pop();            <span class="hljs-keyword">if</span>(node-&gt;left != nullptr)&#123;                que2.push(node-&gt;left);            &#125;            <span class="hljs-keyword">if</span>(node-&gt;right != nullptr)&#123;                que2.push(node-&gt;right);            &#125;        &#125;        level.push_back(levels);        que1 = que2;        while(!que2.empty()) que2.pop();    &#125;    cout&lt;&lt; level[level.size()<span class="hljs-number">-1</span>]&lt;&lt;<span class="hljs-string">&quot; + &quot;</span>&lt;&lt;level[level.size()<span class="hljs-number">-2</span>]&lt;&lt;<span class="hljs-string">&quot; = &quot;</span>&lt;&lt;level[level.size()<span class="hljs-number">-1</span>]+level[level.size()<span class="hljs-number">-2</span>]&lt;&lt;endl;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1127 ZigZagging on a Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1127%20ZigZagging%20on%20a%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1127%20ZigZagging%20on%20a%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="ZigZagging-on-a-Tree"><a href="#ZigZagging-on-a-Tree" class="headerlink" title="ZigZagging on a Tree"></a><font size=6px>ZigZagging on a Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in “zigzagging order” – that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.</p><p><img src="https://images.ptausercontent.com/337cbfb0-a7b2-4500-9664-318e9ffc870e.jpg" alt="zigzag.jpg"></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">812 11 20 17 1 15 8 512 20 17 11 15 8 5 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">1 11 5 8 17 12 20 15</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先根据后序和中序构建二叉树，再层次遍历。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;using namespace std;<span class="hljs-type">int</span> inorder[<span class="hljs-number">31</span>], postorder[<span class="hljs-number">31</span>];<span class="hljs-type">int</span> n ;<span class="hljs-keyword">struct</span> Node&#123;    <span class="hljs-type">int</span> num;    <span class="hljs-keyword">struct</span> Node *left,*right;&#125;;<span class="hljs-type">int</span> find(<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> val)&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size; i++)&#123;        <span class="hljs-keyword">if</span> (val == nums[i])&#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;&#125;Node * buildTree(<span class="hljs-type">int</span> afterOrder[],<span class="hljs-type">int</span> inOrder[], <span class="hljs-type">int</span> size)&#123;    <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> nullptr;    &#125;    Node *root = (Node *)malloc(sizeof(Node));    <span class="hljs-type">int</span> postIndex = find(inOrder,size,afterOrder[size<span class="hljs-number">-1</span>]);    root-&gt;num = afterOrder[size<span class="hljs-number">-1</span>];    root-&gt;left = buildTree(afterOrder,inOrder, postIndex);    root-&gt;right = buildTree(afterOrder+postIndex,inOrder+ postIndex + <span class="hljs-number">1</span>, size - postIndex - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main()&#123;    cin &gt;&gt;n;    vector&lt;Node *&gt; vec1,vec2;    vector&lt;<span class="hljs-type">int</span>&gt; temp;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        cin &gt;&gt; inorder[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        cin &gt;&gt; postorder[i];    &#125;    Node* root  = buildTree(postorder,inorder,n);    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;    <span class="hljs-type">bool</span> first = <span class="hljs-literal">true</span>;    vec1.insert(vec1.begin(),root);    while(!vec1.empty()  || !vec2.empty())&#123;        temp.clear();        while(!vec1.empty())&#123;            Node * node = vec1[vec1.size()<span class="hljs-number">-1</span>];            temp.push_back(node-&gt;num);            vec1.pop_back();            <span class="hljs-keyword">if</span>(node-&gt;left != nullptr)&#123;                vec2.insert(vec2.begin(), node-&gt;left);            &#125;            <span class="hljs-keyword">if</span>(node-&gt;right != nullptr)&#123;                vec2.insert(vec2.begin(), node-&gt;right);            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag)&#123;            std::reverse(temp.begin(), temp.end());        &#125;        flag = !flag;        vec1 = vec2;        vec2.clear();        <span class="hljs-keyword">if</span>(first)&#123;            cout &lt;&lt; temp[<span class="hljs-number">0</span>];            first = <span class="hljs-literal">false</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt; temp.size(); j++)&#123;                cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;temp[j];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1103 Integer Factorization (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1103%20Integer%20Factorization%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1103%20Integer%20Factorization%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Integer-Factorization"><a href="#Integer-Factorization" class="headerlink" title="Integer Factorization "></a><font size=6px>Integer Factorization </font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>The <em>K</em>−<em>P</em> factorization of a positive integer <em>N</em> is to write <em>N</em> as the sum of the <em>P</em>-th power of <em>K</em> positive integers. You are supposed to write a program to find the <em>K</em>−<em>P</em> factorization of <em>N</em> for any positive integers <em>N</em>, <em>K</em> and <em>P</em>.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which gives in a line the three positive integers <em>N</em> (≤400), <em>K</em> (≤<em>N</em>) and <em>P</em> (1&lt;<em>P</em>≤7). The numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, if the solution exists, output in the format:</p><pre><code class="hljs excel"><span class="hljs-built_in">N</span> = <span class="hljs-built_in">n</span>[<span class="hljs-number">1</span>]^P + ... <span class="hljs-built_in">n</span>[K]^P</code></pre><p>where <code>n[i]</code> (<code>i</code> &#x3D; 1, …, <code>K</code>) is the <code>i</code>-th factor. All the factors must be printed in non-increasing order.</p><p>Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 122+42+22+22+12, or 112+62+22+22+22, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen – sequence { <em>a</em>1,<em>a</em>2,⋯,<em>a**K</em> } is said to be <strong>larger</strong> than { <em>b</em>1,<em>b</em>2,⋯,<em>b**K</em> } if there exists 1≤<em>L</em>≤<em>K</em> such that <em>a**i</em>&#x3D;<em>b**i</em> for <em>i</em>&lt;*L* and *a<em><em>L</em>&gt;*b**L</em>.</p><p>If there is no solution, simple output <code>Impossible</code>.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><pre><code class="hljs in">169 5 2</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><pre><code class="hljs out">169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2</code></pre><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><pre><code class="hljs in">169 167 3</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><pre><code class="hljs out">Impossible</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用dfs 遍历所有可能性，并且选择合最大的一组组合</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;math.h&quot;</span>using namespace std;<span class="hljs-type">int</span> n,p,k;vector&lt;<span class="hljs-type">int</span>&gt; res,temp,fac;<span class="hljs-type">int</span> indexSum = <span class="hljs-number">-9999</span>;void dfs(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> nowK,<span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> facSum)&#123;    <span class="hljs-keyword">if</span>(nowK &gt; k || sum &gt;n) <span class="hljs-keyword">return</span> ;    <span class="hljs-keyword">if</span> (sum == n &amp;&amp; nowK == k)&#123;        <span class="hljs-keyword">if</span>(facSum &gt; indexSum )&#123;            indexSum = facSum;            res = temp;        &#125;        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">if</span> (index &gt;=<span class="hljs-number">1</span>)&#123;        temp.push_back(index);        dfs(index, nowK+<span class="hljs-number">1</span>, sum+fac[index], facSum+index);        temp.pop_back();        dfs(index<span class="hljs-number">-1</span>, nowK, sum , facSum );    &#125;&#125;<span class="hljs-type">int</span> main()&#123;    cin &gt;&gt; n&gt;&gt;k&gt;&gt;p;        <span class="hljs-type">int</span> tmp =<span class="hljs-number">0</span>;    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;    while(tmp &lt;= n)&#123;        fac.push_back(tmp);        tmp = <span class="hljs-type">int</span>(pow(j++,p));    &#125;    dfs(fac.size()<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.size(); i++)&#123;        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; n&lt;&lt;<span class="hljs-string">&quot; = &quot;</span>;            cout &lt;&lt; res[i] &lt;&lt;<span class="hljs-string">&quot;^&quot;</span>&lt;&lt;p;        &#125;<span class="hljs-keyword">else</span>            cout &lt;&lt;<span class="hljs-string">&quot; + &quot;</span> &lt;&lt; res[i] &lt;&lt;<span class="hljs-string">&quot;^&quot;</span>&lt;&lt;p;    &#125;    <span class="hljs-keyword">if</span>(indexSum == <span class="hljs-number">-9999</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Impossible&quot;</span>&lt;&lt;endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1135 Is It A Red-Black Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1135%20Is%20It%20A%20Red-Black%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1135%20Is%20It%20A%20Red-Black%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Is-It-A-Red-Black-Tree"><a href="#Is-It-A-Red-Black-Tree" class="headerlink" title="Is It A Red-Black Tree"></a><font size=6px>Is It A Red-Black Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>There is a kind of balanced binary search tree named <strong>red-black tree</strong> in the data structure. It has the following 5 properties:</p><ul><li>(1) Every node is either red or black.</li><li>(2) The root is black.</li><li>(3) Every leaf (NULL) is black.</li><li>(4) If a node is red, then both its children are black.</li><li>(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</li></ul><p>For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not.</p><table><thead><tr><th><img src="https://images.ptausercontent.com/eff80bd4-c833-4818-9786-81680d1b304a.jpg" alt="rbf1.jpg"></th><th><img src="https://images.ptausercontent.com/b11184df-eaab-451c-b7d4-7fc1dc82b028.jpg" alt="rbf2.jpg"></th><th><img src="https://images.ptausercontent.com/625c532b-22fc-47b9-80ea-0537cf00d922.jpg" alt="rbf3.jpg"></th></tr></thead><tbody><tr><td>Figure 1</td><td>Figure 2</td><td>Figure 3</td></tr></tbody></table><p>For each given binary search tree, you are supposed to tell if it is a legal red-black tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains several test cases. The first line gives a positive integer K (≤30) which is the total number of cases. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if the given tree is a red-black tree, or “No” if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">397 -2 1 5 -4 -11 8 14 -15911 -2 1 -7 5 -4 8 14 -15810 -7 5 -6 8 15 -11 17</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">YesNoNo</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>只有三种情况不符合，根结点是负值，连续两个红色，每条path的黑色节点数量不同，其他都是yes</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>using namespace std;<span class="hljs-type">int</span> m;<span class="hljs-type">int</span> num[<span class="hljs-number">31</span>];<span class="hljs-type">bool</span> is_valid;<span class="hljs-keyword">struct</span> Node &#123;    Node *left, *right;    <span class="hljs-type">int</span> num;    <span class="hljs-type">bool</span> isRed;&#125;;Node *buildNode(<span class="hljs-type">int</span> a, <span class="hljs-type">bool</span> is_red) &#123;    Node *node = (Node *) malloc(sizeof(Node));    node-&gt;num = a;    node-&gt;isRed = is_red;    node-&gt;right = nullptr;    node-&gt;left = nullptr;    <span class="hljs-keyword">return</span> node;&#125;;Node *build(Node *root, <span class="hljs-type">int</span> a, <span class="hljs-type">bool</span> is_red) &#123;    <span class="hljs-keyword">if</span> (root == nullptr) &#123;        <span class="hljs-keyword">return</span> buildNode(a, is_red);    &#125;    <span class="hljs-keyword">if</span> (a &gt; root-&gt;num) root-&gt;right = build(root-&gt;right, a, is_red);    <span class="hljs-keyword">else</span> root-&gt;left = build(root-&gt;left, a, is_red);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> blackNodeNums = <span class="hljs-number">0</span>;void dfs(Node *root, <span class="hljs-type">int</span> blackNodeNum) &#123;    <span class="hljs-comment">//如果知道错的就直接return</span>    <span class="hljs-keyword">if</span> (is_valid) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (root == nullptr) &#123;        <span class="hljs-keyword">if</span> (blackNodeNums == <span class="hljs-number">0</span>) blackNodeNums = blackNodeNum;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (blackNodeNums != blackNodeNum) is_valid = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (!root-&gt;isRed) &#123;        dfs(root-&gt;left, blackNodeNum + <span class="hljs-number">1</span>);        dfs(root-&gt;right, blackNodeNum + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        dfs(root-&gt;left, blackNodeNum);        dfs(root-&gt;right, blackNodeNum);    &#125;&#125;void dfsRed(Node *root) &#123;    <span class="hljs-keyword">if</span> (root-&gt;left != nullptr) &#123;        <span class="hljs-keyword">if</span> (root-&gt;isRed &amp;&amp; root-&gt;left-&gt;isRed) is_valid = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">else</span> dfsRed(root-&gt;left);    &#125;    <span class="hljs-keyword">if</span> (root-&gt;right != nullptr) &#123;        <span class="hljs-keyword">if</span> (root-&gt;isRed &amp;&amp; root-&gt;right-&gt;isRed) is_valid = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">else</span> dfsRed(root-&gt;left);    &#125;&#125;<span class="hljs-type">int</span> main() &#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    while (n--) &#123;        cin &gt;&gt; m;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            cin &gt;&gt; num[i];        &#125;        is_valid = <span class="hljs-literal">false</span>;        blackNodeNums = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span>) &#123;            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">continue</span>;        &#125;        Node *root = nullptr;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">if</span> (num[i] &lt; <span class="hljs-number">0</span>) root = build(root, -num[i], <span class="hljs-literal">true</span>);            <span class="hljs-keyword">else</span> root = build(root, num[i], <span class="hljs-literal">false</span>);        &#125;        dfs(root, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (is_valid) &#123;            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">continue</span>;        &#125;        dfsRed(root);        <span class="hljs-keyword">if</span> (is_valid) &#123;            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">continue</span>;        &#125;        cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1139 First Contact (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1139%20First%20Contact%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1139%20First%20Contact%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="First-Contact"><a href="#First-Contact" class="headerlink" title="First Contact"></a><font size=6px>First Contact</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Unlike in nowadays, the way that boys and girls expressing their feelings of love was quite subtle in the early years. When a boy A had a crush on a girl B, he would usually not contact her directly in the first place. Instead, he might ask another boy C, one of his close friends, to ask another girl D, who was a friend of both B and C, to send a message to B – quite a long shot, isn’t it? Girls would do analogously.</p><p>Here given a network of friendship relations, you are supposed to help a boy or a girl to list all their friends who can possibly help them making the first contact.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers N (1 &lt; N ≤ 300) and M, being the total number of people and the number of friendship relations, respectively. Then M lines follow, each gives a pair of friends. Here a person is represented by a 4-digit ID. To tell their genders, we use a negative sign to represent girls.</p><p>After the relations, a positive integer K (≤ 100) is given, which is the number of queries. Then K lines of queries follow, each gives a pair of lovers, separated by a space. It is assumed that the first one is having a crush on the second one.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each query, first print in a line the number of different pairs of friends they can find to help them, then in each line print the IDs of a pair of friends.</p><p>If the lovers A and B are of opposite genders, you must first print the friend of A who is of the same gender of A, then the friend of B, who is of the same gender of B. If they are of the same gender, then both friends must be in the same gender as theirs. It is guaranteed that each person has only one gender.</p><p>The friends must be printed in non-decreasing order of the first IDs, and for the same first ones, in increasing order of the seconds ones.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">10 18-2001 1001-2002 -20011004 1001-2004 -2001-2003 10051005 -20011001 -20031002 10011002 -2004-2004 10011003 -2002-2003 10031004 -2002-2001 -20031001 10031003 -20011002 -2001-2002 -200351001 -2001-2003 10011005 -2001-2002 -20041111 -2003</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">41002 20041003 20021003 20031004 200242001 10022001 10032002 10032002 1004012003 20010</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>题目意思是a和他的同性好友c，b和她同性好友d，如果c和d是认识的，那就打印出来，这题坑很多</p><p>1、需要打印的时候%04</p><p>2、a和b 可能是同性的</p><p>3、需要考虑-0和+0，只能接收string来做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; res;vector&lt;<span class="hljs-type">int</span>&gt; v[<span class="hljs-number">10000</span>];<span class="hljs-keyword">struct</span> Node &#123;    <span class="hljs-type">int</span> a,b;&#125;;<span class="hljs-type">bool</span> cmp(Node a,<span class="hljs-keyword">struct</span> Node b)&#123;    <span class="hljs-keyword">return</span> a.a != b.a ? a.a&lt;b.a : a.b&lt;b.b;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> m, n = <span class="hljs-number">0</span>;    cin &gt;&gt;m&gt;&gt;n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        <span class="hljs-type">string</span> a,b;        cin &gt;&gt;a&gt;&gt;b;        <span class="hljs-keyword">if</span>(a.length() == b.length())&#123;            v[abs(stoi(a))].push_back(abs(stoi(b)));            v[abs(stoi(b))].push_back(abs(stoi(a)));        &#125;        res[abs(stoi(a))*<span class="hljs-number">10000</span> +abs(stoi(b))] = res[abs(stoi(b))*<span class="hljs-number">10000</span> +abs(stoi(a))] = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-type">int</span> p;    cin &gt;&gt;p;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;p;i++)&#123;        <span class="hljs-type">int</span> c,d;        cin &gt;&gt;c&gt;&gt;d;        vector&lt;Node&gt; ans;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;v[abs(c)].size();j++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span> ;k&lt;v[abs(d)].size();k++)&#123;                <span class="hljs-comment">//是自己</span>                <span class="hljs-keyword">if</span> (v[abs(c)][j] == abs(d) || abs(c) == v[abs(d)][k]) <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// c和d认识</span>                <span class="hljs-keyword">if</span>(res[v[abs(c)][j] * <span class="hljs-number">10000</span> + v[abs(d)][k]])&#123;                    ans.push_back(Node&#123;.a = v[abs(c)][j],.b = v[abs(d)][k]&#125;);                &#125;            &#125;        &#125;        sort(ans.begin(),ans.end(), cmp);        cout &lt;&lt; ans.size()&lt;&lt;endl;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;ans.size(); j++)&#123;            printf(<span class="hljs-string">&quot;%04d %04d\n&quot;</span>, ans[j].a, ans[j].b);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1143 Lowest Common Ancestor (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1143%20Lowest%20Common%20Ancestor%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1143%20Lowest%20Common%20Ancestor%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Lowest-Common-Ancestor"><a href="#Lowest-Common-Ancestor" class="headerlink" title="Lowest Common Ancestor"></a><font size=6px>Lowest Common Ancestor</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.</p><p>A binary search tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>Given any two nodes in a BST, you are supposed to find their LCA.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of <strong>int</strong>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each given pair of U and V, print in a line <code>LCA of U and V is A.</code> if the LCA is found and <code>A</code> is the key. But if <code>A</code> is one of U and V, print <code>X is an ancestor of Y.</code> where <code>X</code> is <code>A</code> and <code>Y</code> is the other node. If U or V is not found in the BST, print in a line <code>ERROR: U is not found.</code> or <code>ERROR: V is not found.</code> or <code>ERROR: U and V are not found.</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">6 86 3 1 2 5 4 8 72 58 71 912 -30 899 99</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">LCA of 2 and 5 is 3.8 is an ancestor of 7.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found.</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找到公共祖先，可以指向一个father节点，从下往上遍历，第二个数遍历的时候如果发现有个节点已经被访问了，就可以判断这个就是最小公共节点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;<span class="hljs-keyword">map</span>&gt;using namespace std;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; mp;<span class="hljs-type">int</span> main() &#123;    <span class="hljs-type">int</span> m, n, u, v, a;    scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);    vector&lt;<span class="hljs-type">int</span>&gt; pre(n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pre[i]);        mp[pre[i]] = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            a = pre[j];            <span class="hljs-keyword">if</span> ((a &gt;= u &amp;&amp; a &lt;= v) || (a &gt;= v &amp;&amp; a &lt;= u)) <span class="hljs-keyword">break</span>;        &#125;         <span class="hljs-keyword">if</span> (mp[u] == <span class="hljs-literal">false</span> &amp;&amp; mp[v] == <span class="hljs-literal">false</span>)            printf(<span class="hljs-string">&quot;ERROR: %d and %d are not found.\n&quot;</span>, u, v);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mp[u] == <span class="hljs-literal">false</span> || mp[v] == <span class="hljs-literal">false</span>)            printf(<span class="hljs-string">&quot;ERROR: %d is not found.\n&quot;</span>, mp[u] == <span class="hljs-literal">false</span> ? u : v);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == u || a == v)            printf(<span class="hljs-string">&quot;%d is an ancestor of %d.\n&quot;</span>, a, a == u ? v : u);        <span class="hljs-keyword">else</span>            printf(<span class="hljs-string">&quot;LCA of %d and %d is %d.\n&quot;</span>, u, v, a);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1131 Subway Map (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1131%20Subway%20Map%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1131%20Subway%20Map%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Subway-Map"><a href="#Subway-Map" class="headerlink" title="Subway Map"></a><font size=6px>Subway Map</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>In the big cities, the subway systems always look so complex to the visitors. To give you some sense, the following figure shows the map of Beijing subway. Now you are supposed to help people with your computer skills! Given the starting position of your user, your task is to find the quickest way to his&#x2F;her destination.</p><p><img src="https://images.ptausercontent.com/55799c23-4bdb-4e32-af7f-6d41accfdd2b.jpg" alt="subwaymap.jpg"></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤ 100), the number of subway lines. Then <em>N</em> lines follow, with the <em>i</em>-th (<em>i</em>&#x3D;1,⋯,<em>N</em>) line describes the <em>i</em>-th subway line in the format:</p><p><em>M</em> S[1] S[2] … S[<em>M</em>]</p><p>where <em>M</em> (≤ 100) is the number of stops, and S[<em>i</em>]’s (<em>i</em>&#x3D;1,⋯,<em>M</em>) are the indices of the stations (the indices are 4-digit numbers from 0000 to 9999) along the line. It is guaranteed that the stations are given in the correct order – that is, the train travels between S[<em>i</em>] and S[<em>i</em>+1] (<em>i</em>&#x3D;1,⋯,<em>M</em>−1) without any stop.</p><p>Note: It is possible to have loops, but not self-loop (no train starts from S and stops at S without passing through another station). Each station interval belongs to a unique subway line. Although the lines may cross each other at some stations (so called “transfer stations”), no station can be the conjunction of more than 5 lines.</p><p>After the description of the subway, another positive integer <em>K</em> (≤ 10) is given. Then <em>K</em> lines follow, each gives a query from your user: the two indices as the starting station and the destination, respectively.</p><p>The following figure shows the sample map.</p><p><img src="https://images.ptausercontent.com/932c8f1b-7dd5-489d-a774-a91c1fabba7f.jpg" alt="samplemap.jpg"></p><p>Note: It is guaranteed that all the stations are reachable, and all the queries consist of legal station numbers.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each query, first print in a line the minimum number of stops. Then you are supposed to show the optimal path in a friendly format as the following:</p><pre><code class="hljs lasso"><span class="hljs-keyword">Take</span> Line#X1 from S1 <span class="hljs-keyword">to</span> S2.<span class="hljs-keyword">Take</span> Line#X2 from S2 <span class="hljs-keyword">to</span> S3.<span class="hljs-params">...</span><span class="hljs-params">...</span></code></pre><p>where <code>X</code><em>i</em>‘s are the line numbers and <code>S</code><em>i</em>‘s are the station indices. Note: Besides the starting and ending stations, only the transfer stations shall be printed.</p><p>If the quickest path is not unique, output the one with the minimum number of transfers, which is guaranteed to be unique.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">47 1001 3212 1003 1204 1005 1306 77979 9988 2333 1204 2006 2005 2004 2003 2302 200113 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 30114 6666 8432 4011 130633011 30136666 20012004 3001</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">2Take Line#3 from 3011 to 3013.10Take Line#4 from 6666 to 1306.Take Line#3 from 1306 to 2302.Take Line#2 from 2302 to 2001.6Take Line#2 from 2004 to 1204.Take Line#1 from 1204 to 1306.Take Line#3 from 1306 to 3001.</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>自己做还是做不出来啊，虽然思路想出来了但是太麻烦导致做不出来，还是太菜，通过dfs搜索来做，弄一个visit数组来存储已经访问过的点，并且地铁可以双向通行的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; v(<span class="hljs-number">10000</span>);<span class="hljs-type">int</span> visit[<span class="hljs-number">10000</span>], minCnt, minTransfer, start, end1;unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; line;vector&lt;<span class="hljs-type">int</span>&gt; path, tempPath;<span class="hljs-type">int</span> transferCnt(vector&lt;<span class="hljs-type">int</span>&gt; a) &#123;    <span class="hljs-type">int</span> cnt = <span class="hljs-number">-1</span>, preLine = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; a.size(); i++) &#123;        <span class="hljs-keyword">if</span> (line[a[i<span class="hljs-number">-1</span>]*<span class="hljs-number">10000</span>+a[i]] != preLine) cnt++;        preLine = line[a[i<span class="hljs-number">-1</span>]*<span class="hljs-number">10000</span>+a[i]];    &#125;    <span class="hljs-keyword">return</span> cnt;&#125;void dfs(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> cnt) &#123;    <span class="hljs-keyword">if</span> (node == end1 &amp;&amp; (cnt &lt; minCnt || (cnt == minCnt &amp;&amp; transferCnt(tempPath) &lt; minTransfer))) &#123;        minCnt = cnt;        minTransfer = transferCnt(tempPath);        path = tempPath;    &#125;    <span class="hljs-keyword">if</span> (node == end1) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v[node].size(); i++) &#123;        <span class="hljs-keyword">if</span> (visit[v[node][i]] == <span class="hljs-number">0</span>) &#123;            visit[v[node][i]] = <span class="hljs-number">1</span>;            tempPath.push_back(v[node][i]);            dfs(v[node][i], cnt + <span class="hljs-number">1</span>);            visit[v[node][i]] = <span class="hljs-number">0</span>;            tempPath.pop_back();        &#125;    &#125;&#125;<span class="hljs-type">int</span> main() &#123;    <span class="hljs-type">int</span> n, m, k, pre, temp;    scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        scanf(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;pre);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;            scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;temp);            v[pre].push_back(temp);            v[temp].push_back(pre);            line[pre*<span class="hljs-number">10000</span>+temp] = line[temp*<span class="hljs-number">10000</span>+pre] = i + <span class="hljs-number">1</span>;            pre = temp;        &#125;    &#125;    scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;        scanf(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;start, &amp;end1);        minCnt = <span class="hljs-number">99999</span>, minTransfer = <span class="hljs-number">99999</span>;        tempPath.clear();        tempPath.push_back(start);        visit[start] = <span class="hljs-number">1</span>;        dfs(start, <span class="hljs-number">0</span>);        visit[start] = <span class="hljs-number">0</span>;        printf(<span class="hljs-string">&quot;%d\n&quot;</span>, minCnt);        <span class="hljs-type">int</span> preLine = <span class="hljs-number">0</span>, preTransfer = start;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; path.size(); j++) &#123;            <span class="hljs-keyword">if</span> (line[path[j<span class="hljs-number">-1</span>]*<span class="hljs-number">10000</span>+path[j]] != preLine) &#123;                <span class="hljs-keyword">if</span> (preLine != <span class="hljs-number">0</span>) printf(<span class="hljs-string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>, preLine, preTransfer, path[j<span class="hljs-number">-1</span>]);                preLine = line[path[j<span class="hljs-number">-1</span>]*<span class="hljs-number">10000</span>+path[j]];                preTransfer = path[j<span class="hljs-number">-1</span>];            &#125;        &#125;        printf(<span class="hljs-string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>, preLine, preTransfer, end1);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1151 LCA in a Binary Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1151%20LCA%20in%20a%20Binary%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1151%20LCA%20in%20a%20Binary%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="LCA-in-a-Binary-Tree"><a href="#LCA-in-a-Binary-Tree" class="headerlink" title="LCA in a Binary Tree"></a><font size=6px>LCA in a Binary Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.</p><p>Given any two nodes in a binary tree, you are supposed to find their LCA.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of <strong>int</strong>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each given pair of U and V, print in a line <code>LCA of U and V is A.</code> if the LCA is found and <code>A</code> is the key. But if <code>A</code> is one of U and V, print <code>X is an ancestor of Y.</code> where <code>X</code> is <code>A</code> and <code>Y</code> is the other node. If U or V is not found in the binary tree, print in a line <code>ERROR: U is not found.</code> or <code>ERROR: V is not found.</code> or <code>ERROR: U and V are not found.</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">6 87 2 3 4 6 5 1 85 3 7 2 6 4 8 12 68 17 912 -30 899 99</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">LCA of 2 and 6 is 3.8 is an ancestor of 1.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found.</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>根据前序和中序构建树，然后找两个人的公共祖先</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;#include&lt;<span class="hljs-keyword">map</span>&gt;using namespace std;typedef <span class="hljs-keyword">struct</span> node&#123;<span class="hljs-type">int</span> data;node *lchild,*rchild;&#125;node;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">int</span>,node*&gt;mp;<span class="hljs-type">int</span> in[<span class="hljs-number">1000007</span>],pre[<span class="hljs-number">1000007</span>];node* build(<span class="hljs-type">int</span> inl,<span class="hljs-type">int</span> inr,<span class="hljs-type">int</span> prl,<span class="hljs-type">int</span> prr)&#123;<span class="hljs-keyword">if</span>(inl&gt;inr||prl&gt;prr)&#123;<span class="hljs-keyword">return</span> NULL;&#125;node* root=<span class="hljs-built_in">new</span> node;<span class="hljs-type">int</span> temp,ky;root-&gt;data=in[inl];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=prl;i&lt;=prr;i++)&#123;<span class="hljs-keyword">if</span>(pre[i]==in[inl])&#123;temp=i;<span class="hljs-keyword">break</span>;&#125;&#125;    mp[in[inl]]=root;ky=temp-prl;root-&gt;lchild=build(inl+<span class="hljs-number">1</span>,inl+ky,prl,temp<span class="hljs-number">-1</span>);root-&gt;rchild=build(inl+<span class="hljs-number">1</span>+ky,inr,temp+<span class="hljs-number">1</span>,prr);<span class="hljs-keyword">return</span> root;&#125;node* lcd(node* root,node* a,node* b)&#123;<span class="hljs-keyword">if</span>(root==NULL|root==a||root==b)&#123;<span class="hljs-keyword">return</span> root;&#125;node* l=lcd(root-&gt;lchild,a,b);node* r=lcd(root-&gt;rchild,a,b);<span class="hljs-keyword">if</span>(l==NULL)&#123;<span class="hljs-comment">//如果在两边就会返回根节点，在一边的就会返回子节点。</span><span class="hljs-keyword">return</span> r;&#125;<span class="hljs-keyword">if</span>(r==NULL)&#123;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> m,n,a,b;node *root;scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;pre[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;in[i]);&#125;root=build(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<span class="hljs-keyword">if</span>(!mp[a]&amp;&amp;!mp[b])&#123;printf(<span class="hljs-string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,a,b);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!mp[a])&#123;printf(<span class="hljs-string">&quot;ERROR: %d is not found.\n&quot;</span>,a);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!mp[b])&#123;printf(<span class="hljs-string">&quot;ERROR: %d is not found.\n&quot;</span>,b);&#125;<span class="hljs-keyword">else</span>&#123;node* p=lcd(root,mp[a],mp[b]);<span class="hljs-keyword">if</span>(p-&gt;data==a)&#123;printf(<span class="hljs-string">&quot;%d is an ancestor of %d.\n&quot;</span>,a,b);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;data==b)&#123;printf(<span class="hljs-string">&quot;%d is an ancestor of %d.\n&quot;</span>,b,a);&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;LCA of %d and %d is %d.\n&quot;</span>,a,b,p-&gt;data);&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1155 Heap Paths (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1155%20Heap%20Paths%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1155%20Heap%20Paths%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Heap-Paths"><a href="#Heap-Paths" class="headerlink" title="Heap Paths"></a><font size=6px>Heap Paths</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>In computer science, a <strong>heap</strong> is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">https://en.wikipedia.org/wiki/Heap_(data_structure)</a>)</p><p>One thing for sure is that all the keys along any path from the root to a leaf in a max&#x2F;min heap must be in non-increasing&#x2F;non-decreasing order.</p><p>Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (1&lt;<em>N</em>≤1,000), the number of keys in the tree. Then the next line contains <em>N</em> distinct integer keys (all in the range of <strong>int</strong>), which gives the level order traversal sequence of a complete binary tree.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.</p><p>Finally print in a line <code>Max Heap</code> if it is a max heap, or <code>Min Heap</code> for a min heap, or <code>Not Heap</code> if it is not a heap at all.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><pre><code class="hljs in">898 72 86 60 65 12 23 50</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><pre><code class="hljs out">98 86 2398 86 1298 72 6598 72 60 50Max Heap</code></pre><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><pre><code class="hljs in">88 38 25 58 52 82 70 60</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><pre><code class="hljs out">8 25 708 25 828 38 528 38 58 60Min Heap</code></pre><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3:"></a>Sample Input 3:</h3><pre><code class="hljs in">810 28 15 12 34 9 8 56</code></pre><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3:"></a>Sample Output 3:</h3><pre><code class="hljs out">10 15 810 15 910 28 3410 28 12 56Not Heap</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先构建堆，再用dfs右边优先遍历，到子节点就输出，并且判断是升序还是降序还是错误序列。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;algorithm&quot;</span>using namespace std;<span class="hljs-keyword">struct</span> Node &#123;    <span class="hljs-type">int</span> num;    <span class="hljs-keyword">struct</span> Node *left;    <span class="hljs-keyword">struct</span> Node *right;&#125;;<span class="hljs-type">int</span> num[<span class="hljs-number">1002</span>];<span class="hljs-type">int</span> n;<span class="hljs-type">bool</span> maxFlag = <span class="hljs-literal">false</span>, minFlag = <span class="hljs-literal">false</span>,validFlag= <span class="hljs-literal">false</span>;Node *NewNode(<span class="hljs-type">int</span> idx) &#123;    Node *node = (Node *) malloc(sizeof(Node));    node-&gt;num = num[idx];    node-&gt;left = nullptr;    node-&gt;right = nullptr;    <span class="hljs-keyword">return</span> node;&#125;<span class="hljs-type">bool</span> check(vector&lt;<span class="hljs-keyword">struct</span> Node&gt; res)&#123;    <span class="hljs-keyword">if</span>(minFlag)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;res.size();i++)&#123;            <span class="hljs-keyword">if</span>(res[i].num &lt; res[i<span class="hljs-number">-1</span>].num)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxFlag)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;res.size();i++)&#123;            <span class="hljs-keyword">if</span>(res[i].num &gt; res[i<span class="hljs-number">-1</span>].num)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;Node *build(<span class="hljs-type">int</span> idx) &#123;    <span class="hljs-keyword">if</span> (idx &gt;= n) &#123;        <span class="hljs-keyword">return</span> nullptr;    &#125;    Node *root = NewNode(idx);    root-&gt;left = build(idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);    root-&gt;right = build((idx * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>));    <span class="hljs-keyword">return</span> root;&#125;void dfs(Node *root, vector&lt;<span class="hljs-keyword">struct</span> Node&gt; res) &#123;    <span class="hljs-keyword">if</span> (root == nullptr) &#123;        <span class="hljs-keyword">return</span>;    &#125;    res.push_back(*root);    dfs(root-&gt;right, res);    dfs(root-&gt;left, res);    <span class="hljs-keyword">if</span> (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size(); i++) &#123;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                cout &lt;&lt; res[i].num;            &#125; <span class="hljs-keyword">else</span> &#123;                cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; res[i].num;            &#125;        &#125;        cout &lt;&lt; endl;        <span class="hljs-keyword">if</span>(!check(res))&#123;            validFlag = <span class="hljs-literal">true</span>;        &#125;    &#125;&#125;<span class="hljs-type">int</span> main() &#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        cin &gt;&gt; num[i];    &#125;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;        cout &lt;&lt; num[<span class="hljs-number">0</span>] &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">&quot;Not Heap&quot;</span> &lt;&lt; endl;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    Node *root = build(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] &gt; num[<span class="hljs-number">1</span>]) &#123;        maxFlag = <span class="hljs-literal">true</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        minFlag = <span class="hljs-literal">true</span>;    &#125;    vector&lt;<span class="hljs-keyword">struct</span> Node&gt; res;    dfs(root, res);    <span class="hljs-keyword">if</span>(validFlag)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Not Heap&quot;</span> &lt;&lt; endl;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxFlag)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Max Heap&quot;</span> &lt;&lt;endl;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minFlag)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Min Heap&quot;</span> &lt;&lt;endl;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1159 Structure of a Binary Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1159%20Structure%20of%20a%20Binary%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1159%20Structure%20of%20a%20Binary%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Structure-of-a-Binary-Tree"><a href="#Structure-of-a-Binary-Tree" class="headerlink" title="Structure of a Binary Tree"></a><font size=6px>Structure of a Binary Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined.</p><p>Now given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following:</p><ul><li>A is the root</li><li>A and B are siblings</li><li>A is the parent of B</li><li>A is the left child of B</li><li>A is the right child of B</li><li>A and B are on the same level</li><li>It is a full tree</li></ul><p>Note:</p><ul><li>Two nodes are <strong>on the same level</strong>, means that they have the same depth.</li><li>A <strong>full binary tree</strong> is a tree in which every node other than the leaves has two children.</li></ul><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than 103 and are separated by a space.</p><p>Then another positive integer <em>M</em> (≤30) is given, followed by <em>M</em> lines of statements. It is guaranteed that both <code>A</code> and <code>B</code> in the statements are in the tree.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each statement, print in a line <code>Yes</code> if it is correct, or <code>No</code> if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">916 7 11 32 28 2 23 8 1516 23 7 32 11 2 28 15 8715 is the root8 and 2 are siblings32 is the parent of 1123 is the left child of 1628 is the right child of 27 and 11 are on the same levelIt is a full tree</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">YesNoYesNoYesYesYes</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先按照后序和中序遍历构造出二叉树，二叉树是特殊的，里面有指向父节点的和深度数据，string字符串中得出数字也有很巧妙的方式，看代码</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;map&quot;</span>using namespace  std;typedef <span class="hljs-keyword">struct</span> Node&#123;    <span class="hljs-type">int</span> value;    <span class="hljs-keyword">struct</span> Node *left;    <span class="hljs-keyword">struct</span> Node *right;    <span class="hljs-keyword">struct</span> Node *father;    <span class="hljs-type">int</span> depth;&#125;Node;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">int</span> ,  Node *&gt; mp ;<span class="hljs-type">bool</span> full = <span class="hljs-literal">true</span>;<span class="hljs-type">int</span>  Find(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> v)&#123;<span class="hljs-comment">//找的始终是中序</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;        <span class="hljs-keyword">if</span> (array[i] == v)&#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;Node * BuildTree(<span class="hljs-type">int</span> afterorder[], <span class="hljs-type">int</span> inorder[], <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> depth)&#123;    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span>  nullptr;    &#125;    <span class="hljs-type">int</span> rootValue = afterorder[size<span class="hljs-number">-1</span>];    <span class="hljs-type">int</span> leftSize = Find(inorder, size, rootValue);<span class="hljs-comment">//i的返回值就是左子树的个数</span>    <span class="hljs-comment">//根</span>    Node *root = (Node *)malloc(sizeof(Node));    root-&gt;value = rootValue;    <span class="hljs-comment">//左子树</span>    root-&gt;left = BuildTree(afterorder , inorder, leftSize, depth+<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(root-&gt;left != nullptr)&#123;        root-&gt;left-&gt;father = root;    &#125;    <span class="hljs-comment">//右子树</span>    root-&gt;right = BuildTree(afterorder + leftSize, inorder + leftSize + <span class="hljs-number">1</span>, size - <span class="hljs-number">1</span> - leftSize, depth+<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (root-&gt;right != nullptr)&#123;        root-&gt;right -&gt;father = root;    &#125;    mp[rootValue] = root;    <span class="hljs-keyword">if</span> ((root-&gt;left &amp;&amp; !root-&gt;right) || !root-&gt;left &amp;&amp; root-&gt;right) full = <span class="hljs-literal">false</span>;    root-&gt;depth = depth;    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt;n;    <span class="hljs-type">int</span> postorder[n],inorder[n];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        cin &gt;&gt;postorder[i];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        cin &gt;&gt;inorder[i];    &#125;    Node * root = BuildTree(postorder,inorder, n, <span class="hljs-number">0</span>);    <span class="hljs-type">int</span> n2;    cin &gt;&gt; n2;    getchar();    while (n2--)&#123;        <span class="hljs-type">string</span> s;        <span class="hljs-type">int</span> a,b ;        getline(cin, s);        <span class="hljs-keyword">if</span> (s.find(<span class="hljs-string">&quot;root&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d is the root&quot;</span>, &amp;a);            <span class="hljs-keyword">if</span> (root-&gt;value == a)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            &#125;<span class="hljs-keyword">else</span>&#123;                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;siblings&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d and %d are siblings&quot;</span>, &amp;a, &amp;b);            <span class="hljs-keyword">if</span> (mp[a]-&gt;father == mp[b]-&gt;father)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            &#125;<span class="hljs-keyword">else</span>&#123;                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;parent&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d is the parent of %d&quot;</span>, &amp;a, &amp;b);            <span class="hljs-keyword">if</span>(mp[b]-&gt;father == mp[a])&#123;                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            &#125;<span class="hljs-keyword">else</span>&#123;                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;left&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d is the left child of %d&quot;</span>, &amp;a, &amp;b);            <span class="hljs-keyword">if</span> (mp[b]-&gt;left == mp[a]) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;right&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d is the right child of %d&quot;</span>, &amp;a, &amp;b);            <span class="hljs-keyword">if</span> (mp[b]-&gt;right == mp[a]) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;level&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d and %d are on the same level&quot;</span>, &amp;a, &amp;b);            <span class="hljs-keyword">if</span> (mp[b]-&gt;depth == mp[a]-&gt;depth) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;full&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            <span class="hljs-keyword">if</span> (full) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1161 Merging Linked Lists (25 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1161%20Merging%20Linked%20Lists%20(25%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1161%20Merging%20Linked%20Lists%20(25%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Merging-Linked-Lists"><a href="#Merging-Linked-Lists" class="headerlink" title="Merging Linked Lists"></a><font size=6px>Merging Linked Lists</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given two singly linked lists <em>L</em>1&#x3D;<em>a</em>1→<em>a</em>2→⋯→<em>a**n</em>−1→<em>a**n</em> and <em>L</em>2&#x3D;<em>b</em>1→<em>b</em>2→⋯→<em>b**m</em>−1→<em>b**m</em>. If <em>n</em>≥2<em>m</em>, you are supposed to reverse and merge the shorter one into the longer one to obtain a list like <em>a</em>1→<em>a</em>2→<em>b**m</em>→<em>a</em>3→<em>a</em>4→<em>b**m</em>−1⋯. For example, given one list being 6→7 and the other one 1→2→3→4→5, you must output 1→2→7→3→4→6→5.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of <em>L</em>1 and <em>L</em>2, plus a positive <em>N</em> (≤105) which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by <code>-1</code>.</p><p>Then <em>N</em> lines follow, each describes a node in the format:</p><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span></code></pre><p>where <code>Address</code> is the position of the node, <code>Data</code> is a positive integer no more than 105, and <code>Next</code> is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">00100 01000 702233 2 3489100100 6 0000134891 3 1008601000 1 0223300033 5 -110086 4 0003300001 7 -1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">01000 1 0223302233 2 0000100001 7 3489134891 3 1008610086 4 0010000100 6 0003300033 5 -1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>模拟法做，构建两个链表，长的链表一次输出两个短的一次输出一个</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-comment">//pat 1161</span>#include &lt;bits/stdc++.h&gt;using namespace std;<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-type">int</span> begin1, begin2, n;<span class="hljs-keyword">struct</span> node&#123;<span class="hljs-type">int</span> add, data, next;&#125;a[maxn];vector&lt;node&gt; L1, L2, res; <span class="hljs-type">int</span> main()&#123;<span class="hljs-comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><span class="hljs-comment">//freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span>cin &gt;&gt; begin1 &gt;&gt; begin2 &gt;&gt; n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )&#123;<span class="hljs-type">int</span> address, data, next;cin &gt;&gt; address &gt;&gt; data &gt;&gt; next;a[address].add = address;a[address].data = data;a[address].next = next;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = begin1; p != <span class="hljs-number">-1</span>; p = a[p].next)&#123;L1.push_back(a[p]); &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = begin2; p != <span class="hljs-number">-1</span>; p = a[p].next)&#123;L2.push_back(a[p]); &#125;<span class="hljs-type">int</span> head;<span class="hljs-comment">//res的头 </span><span class="hljs-keyword">if</span>(L1.size() &gt; L2.size()) head = begin1;<span class="hljs-keyword">else</span>&#123;head = begin2;L2 = L1;<span class="hljs-comment">//L2作为短链表 长链表L1根据head在a[]中得到 </span>&#125;<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<span class="hljs-comment">//控制每2个插入一个 </span>    while (head != <span class="hljs-number">-1</span>)&#123;        res.push_back(a[head]);        ++k;        <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; !L2.empty())&#123;<span class="hljs-comment">//每两个中间插一个 </span>            res.push_back(L2.back());            L2.pop_back();        &#125;        head = a[head].next;    &#125;        <span class="hljs-comment">//输出 </span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size() - <span class="hljs-number">1</span>; ++i)        printf(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, res[i].add, res[i].data, res[i+<span class="hljs-number">1</span>].add);    printf(<span class="hljs-string">&quot;%05d %d -1&quot;</span>, res[res.size()<span class="hljs-number">-1</span>].add, res[res.size()<span class="hljs-number">-1</span>].data);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1163 Dijkstra Sequence (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1163%20Dijkstra%20Sequence%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1163%20Dijkstra%20Sequence%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Dijkstra-Sequence"><a href="#Dijkstra-Sequence" class="headerlink" title="Dijkstra Sequence"></a><font size=6px>Dijkstra Sequence</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Dijkstra’s algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</p><p>In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let’s call it <strong>Dijkstra sequence</strong>, is generated by Dijkstra’s algorithm.</p><p>On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two positive integers <em>N**v</em> (≤103) and <em>N**e</em> (≤105), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to <em>N**v</em>.</p><p>Then <em>N**e</em> lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤100) of the edge. It is guaranteed that the given graph is connected.</p><p>Finally the number of queries, <em>K</em>, is given as a positive integer no larger than 100, followed by <em>K</em> lines of sequences, each contains a permutationof the <em>N**v</em> vertices. It is assumed that the first vertex is the source for each sequence.</p><p>All the inputs in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each of the <em>K</em> sequences, print in a line <code>Yes</code> if it is a Dijkstra sequence, or <code>No</code> if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">5 71 2 21 5 12 3 12 4 12 5 23 5 13 4 145 1 3 4 25 3 1 2 42 3 4 5 13 2 1 5 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">YesYesYesNo</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>题目大意是问下面给出的序列符不符合狄杰斯特拉序列，用狄杰斯特拉算法去做就行。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;string.h&quot;</span>using namespace std;#define Inf <span class="hljs-number">0x3f3f3f</span>#define size <span class="hljs-number">1002</span><span class="hljs-type">int</span> dis[size][size];<span class="hljs-type">int</span> ans[size];<span class="hljs-type">int</span> m,n,k;<span class="hljs-type">bool</span> check()&#123;    <span class="hljs-type">int</span> used[size] = &#123;<span class="hljs-number">0</span>&#125;,dist[size] = &#123;<span class="hljs-number">0</span>&#125;;    memset(dist,<span class="hljs-number">0x3f</span>,sizeof (dist));    dist[ans[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>;        <span class="hljs-comment">// 先找到最小值</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;= m;j++)&#123;            <span class="hljs-keyword">if</span>( !used[j] &amp;&amp; (u==<span class="hljs-number">-1</span> || dist[u] &gt; dist[j]) ) u = j;        &#125;        <span class="hljs-keyword">if</span> (dist[u] != dist[ans[i]])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++)&#123;            <span class="hljs-keyword">if</span> (j == u) <span class="hljs-keyword">continue</span>;            dist[j] = min(dist[j], dist[u] + dis[u][j]);        &#125;        used[u] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-type">int</span> main()&#123;    cin &gt;&gt;m&gt;&gt;n;    <span class="hljs-type">int</span> a,b,c;    memset(dis,Inf, sizeof(dis));    while(n--)&#123;        cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;        dis[a][b] = dis[b][a] = c;    &#125;    cin &gt;&gt;k;    while(k--)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;            cin &gt;&gt;ans[i];        &#125;        <span class="hljs-keyword">if</span> (check())&#123;            cout &lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;        &#125;<span class="hljs-keyword">else</span>&#123;            cout &lt;&lt;<span class="hljs-string">&quot;No&quot;</span> &lt;&lt;endl;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1165 Block Reversing (25 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1165%20Block%20Reversing%20(25%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1165%20Block%20Reversing%20(25%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Block-Reversing"><a href="#Block-Reversing" class="headerlink" title="Block Reversing"></a><font size=6px>Block Reversing</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given a singly linked list <em>L</em>. Let us consider every <em>K</em> nodes as a <strong>block</strong> (if there are less than <em>K</em> nodes at the end of the list, the rest of the nodes are still considered as a block). Your job is to reverse all the blocks in <em>L</em>. For example, given <em>L</em> as 1→2→3→4→5→6→7→8 and <em>K</em> as 3, your output must be 7→8→4→5→6→1→2→3.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the size of a block. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.</p><p>Then <em>N</em> lines follow, each describes a node in the format:</p><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span></code></pre><p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">00100 8 371120 7 8866600000 4 9999900100 1 1230968237 6 7112033218 3 0000099999 5 6823788666 8 -112309 2 33218</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">71120 7 8866688666 8 0000000000 4 9999999999 5 6823768237 6 0010000100 1 1230912309 2 3321833218 3 -1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>有两种思路做，一种是链表反转，一种是模拟成结果想要的状态，我是第二种</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;<span class="hljs-keyword">struct</span> node&#123;    <span class="hljs-type">int</span> id,dat,next;&#125;;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> begin, n, k;    scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;begin,&amp;n,&amp;k);    node a[<span class="hljs-number">100010</span>];     <span class="hljs-comment">//特别注意数组大小</span>    vector&lt;node&gt; v, ans;    <span class="hljs-type">int</span> s,d,e;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;        scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;s,&amp;d,&amp;e);        a[s]=&#123;s,d,e&#125;;    &#125;    <span class="hljs-keyword">for</span>(; begin!=<span class="hljs-number">-1</span>; begin=a[begin].next)&#123;        v.push_back(a[begin]);    &#125;    <span class="hljs-type">int</span> num=n/k;    <span class="hljs-keyword">if</span>(n%k) num++;    <span class="hljs-type">int</span> <span class="hljs-built_in">len</span>=v.size();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=num<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;k; j++)&#123;            <span class="hljs-type">int</span> t=i*k+j;            <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-built_in">len</span>) ans.push_back(v[t]);<span class="hljs-comment">//注意插入的写法</span>        &#125;    &#125;    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ans.size()<span class="hljs-number">-1</span>; i++)&#123;        printf(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, ans[i].id, ans[i].dat, ans[i+<span class="hljs-number">1</span>].id);    &#125;    printf(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>, ans[i].id, ans[i].dat);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1166 Summit (25 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1166%20Summit%20(25%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1166%20Summit%20(25%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Summit"><a href="#Summit" class="headerlink" title="Summit"></a><font size=6px>Summit</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A <strong>summit</strong> (峰会) is a meeting of heads of state or government. Arranging the rest areas for the summit is not a simple job. The ideal arrangement of one area is to invite those heads so that everyone is a direct friend of everyone.</p><p>Now given a set of tentative arrangements, your job is to tell the organizers whether or not each area is all set.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 200), the number of heads in the summit, and M, the number of friendship relations. Then M lines follow, each gives a pair of indices of the heads who are friends to each other. The heads are indexed from 1 to N.</p><p>Then there is another positive integer K (≤ 100), and K lines of tentative arrangement of rest areas follow, each first gives a positive number L (≤ N), then followed by a sequence of L distinct indices of the heads. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each of the K areas, print in a line your advice in the following format:</p><ul><li>if in this area everyone is a direct friend of everyone, and no friend is missing (that is, no one else is a direct friend of everyone in this area), print <code>Area X is OK.</code>.</li><li>if in this area everyone is a direct friend of everyone, yet there are some other heads who may also be invited without breaking the ideal arrangement, print <code>Area X may invite more people, such as H.</code> where <code>H</code> is the smallest index of the head who may be invited.</li><li>if in this area the arrangement is not an ideal one, then print <code>Area X needs help.</code> so the host can provide some special service to help the heads get to know each other.</li></ul><p>Here <code>X</code> is the index of an area, starting from 1 to <code>K</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">8 105 67 86 43 64 52 38 22 75 33 464 5 4 3 63 2 8 72 2 31 12 4 63 3 2 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">Area 1 is OK.Area 2 is OK.Area 3 is OK.Area 4 is OK.Area 5 may invite more people, such as 3.Area 6 needs help.</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>想了半天还不知道要用什么算法，原来是个暴力模拟题。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;string.h&quot;</span>using  namespace std;<span class="hljs-type">int</span> rela[<span class="hljs-number">201</span>][<span class="hljs-number">201</span>];<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> m,n,k;    <span class="hljs-type">int</span> head[<span class="hljs-number">201</span>];    cin &gt;&gt;m&gt;&gt;n;    memset(rela,<span class="hljs-number">0</span>,sizeof(rela));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> a,b;        cin &gt;&gt;a&gt;&gt;b;        rela[a][b] = rela[b][a] = <span class="hljs-number">1</span>;    &#125;    cin &gt;&gt;k;    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;    while(k--)&#123;        index++;        <span class="hljs-type">int</span> p;        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;        memset(head, <span class="hljs-number">0</span> ,sizeof (head));        cin &gt;&gt;p;        <span class="hljs-type">int</span> num[p+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p;i++)&#123;            cin &gt;&gt;num[i];            head[num[i]] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 开始暴力模拟</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p &amp;&amp; !flag;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;p;j++)&#123;                <span class="hljs-keyword">if</span>(rela[num[i]][num[j]] != <span class="hljs-number">1</span>)&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;Area &quot;</span>&lt;&lt; index&lt;&lt;<span class="hljs-string">&quot; needs help.&quot;</span>&lt;&lt;endl;                    flag = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (flag ) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">// 开始判断是否有额外的数字可以加入</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;                <span class="hljs-keyword">if</span>(head[i] != <span class="hljs-number">1</span>)&#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;p;j++)&#123;                        <span class="hljs-keyword">if</span>(rela[num[j]][i] != <span class="hljs-number">1</span>)&#123;                            flag = <span class="hljs-literal">true</span>;                            <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                    <span class="hljs-keyword">if</span>(!flag)&#123;                        cout &lt;&lt;<span class="hljs-string">&quot;Area &quot;</span>&lt;&lt; index&lt;&lt;<span class="hljs-string">&quot; may invite more people, such as &quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;.&quot;</span>&lt;&lt;endl;                        flag = <span class="hljs-literal">true</span>;                        <span class="hljs-keyword">break</span>;                    &#125;<span class="hljs-keyword">else</span>&#123;                        flag = <span class="hljs-literal">false</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span>(!flag)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;Area &quot;</span>&lt;&lt; index&lt;&lt;<span class="hljs-string">&quot; is OK.&quot;</span>&lt;&lt;endl;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1167 Cartesian Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1167%20Cartesian%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1167%20Cartesian%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Cartesian-Tree"><a href="#Cartesian-Tree" class="headerlink" title="Cartesian Tree"></a><font size=6px>Cartesian Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A <strong>Cartesian tree</strong> is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal returns the original sequence. For example, given the sequence { 8, 15, 3, 4, 1, 5, 12, 10, 18, 6 }, the min-heap Cartesian tree is shown by the figure.</p><p><img src="https://images.ptausercontent.com/6a99f68a-6578-46e0-9232-fbf0adf3691f.jpg" alt="CTree.jpg"></p><p>Your job is to output the level-order traversal sequence of the min-heap Cartesian tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts from giving a positive integer <em>N</em> (≤30), and then <em>N</em> distinct numbers in the next line, separated by a space. All the numbers are in the range of <strong>int</strong>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line the level-order traversal sequence of the min-heap Cartesian tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">108 15 3 4 1 5 12 10 18 6</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">1 3 5 8 4 6 15 10 12 18</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>别管他什么inorder，先找到序列的最小值，左边是它的左子树，右边是它的右子树，然后构造好树然后层次遍历。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;math.h&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>using namespace  std;<span class="hljs-keyword">struct</span> Node&#123;    <span class="hljs-type">int</span> val;    <span class="hljs-keyword">struct</span> Node * left;    <span class="hljs-keyword">struct</span> Node * right;&#125;;<span class="hljs-type">int</span> findMin(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> size)&#123;    <span class="hljs-type">int</span> mini = <span class="hljs-number">0</span> ;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;size; i++)&#123;        <span class="hljs-keyword">if</span> (nums[mini] &gt; nums[i])&#123;            mini = i;        &#125;    &#125;    <span class="hljs-keyword">return</span> mini;&#125;Node * build(<span class="hljs-type">int</span> nums [],<span class="hljs-type">int</span> size)&#123;    <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> nullptr;    &#125;    <span class="hljs-type">int</span> mini = findMin(nums, size);    Node *root = (Node *)malloc(sizeof(Node));    root-&gt;val = nums[mini];    root-&gt;left = build(nums, mini);    root-&gt;right = build(nums+mini+<span class="hljs-number">1</span>, size-mini<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-type">int</span> inorder[n];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;        cin &gt;&gt; inorder[i];    &#125;    Node * root = build(inorder, n);    vector&lt;Node *&gt; vec;    vec.push_back(root);    cout &lt;&lt; root-&gt;val;    while (!vec.empty())&#123;        Node * node = vec.back();        vec.pop_back();        <span class="hljs-keyword">if</span>(node-&gt;left != nullptr)&#123;            vec.insert(vec.begin(),node-&gt;left );            cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;node-&gt;left-&gt;val;        &#125;        <span class="hljs-keyword">if</span>(node-&gt;right != nullptr)&#123;            vec.insert(vec.begin(),node-&gt;right );            cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;node-&gt;right-&gt;val;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>482. 合唱队形</title>
    <link href="/2022/01/21/acWing/482.%20%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2/"/>
    <url>/2022/01/21/acWing/482.%20%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="合唱队形"><a href="#合唱队形" class="headerlink" title="合唱队形"></a><font size=6px>合唱队形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>NN 位同学站成一排，音乐老师要请其中的 (N−K)(N−K) 位同学出列，使得剩下的 KK 位同学排成合唱队形。     </p><p>合唱队形是指这样的一种队形：设 KK 位同学从左到右依次编号为 1，2…，K1，2…，K，他们的身高分别为 T1，T2，…，TKT1，T2，…，TK，  则他们的身高满足 T1&lt;…<Ti>Ti+1&gt;…&gt;TK(1≤i≤K)T1&lt;…<Ti>Ti+1&gt;…&gt;TK(1≤i≤K)。     </p><p>你的任务是，已知所有 NN 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行是一个整数 NN，表示同学的总数。</p><p>第二行有 NN 个整数，用空格分隔，第 ii 个整数 TiTi 是第 ii 位同学的身高(厘米)。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>2≤N≤1002≤N≤100,<br>130≤Ti≤230130≤Ti≤230</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code class="hljs basic"><span class="hljs-number">8</span><span class="hljs-symbol">186 </span><span class="hljs-number">186</span> <span class="hljs-number">150</span> <span class="hljs-number">200</span> <span class="hljs-number">160</span> <span class="hljs-number">130</span> <span class="hljs-number">197</span> <span class="hljs-number">220</span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code class="hljs">4</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>求出最长序列，然后n-最长序列</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">\#include &lt;iostream&gt;\#include &lt;algorithm&gt;using namespace std;<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>; <span class="hljs-type">int</span> n;<span class="hljs-type">int</span> f[N],g[N],num[N];<span class="hljs-type">int</span> main()&#123;   ​    cin &gt;&gt;n;​    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;num[i];​    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;​        f[i] = <span class="hljs-number">1</span>;​        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;​            <span class="hljs-keyword">if</span> (num[j] &lt;num[i])&#123;​                f[i] = max(f[i],f[j]+<span class="hljs-number">1</span>);​            &#125;​        &#125;​    &#125;​    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;​        g[i] = <span class="hljs-number">1</span>;​        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;i;j--)&#123;​            <span class="hljs-keyword">if</span> (num[j] &lt;num[i])&#123;​                g[i] = max(g[i],g[j]+<span class="hljs-number">1</span>);​            &#125;​        &#125;​    &#125;​    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;​    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;​        <span class="hljs-comment">//printf(&quot;%d\n&quot;,f[i]+g[i]-1);</span>​        res = max(res,f[i]+g[i]<span class="hljs-number">-1</span>);​    &#125;​    printf(<span class="hljs-string">&quot;%d&quot;</span>,n-res);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1123 Is It a Complete AVL Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1123%20Is%20It%20a%20Complete%20AVL%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1123%20Is%20It%20a%20Complete%20AVL%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Is-It-a-Complete-AVL-Tre"><a href="#Is-It-a-Complete-AVL-Tre" class="headerlink" title="Is It a Complete AVL Tre"></a><font size=6px>Is It a Complete AVL Tre</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p><table><thead><tr><th><img src="https://images.ptausercontent.com/fb337acb-93b0-4af2-9838-deff5ce98058.jpg" alt="F1.jpg"></th><th><img src="https://images.ptausercontent.com/d1635de7-3e3f-4aaa-889b-ba29f35890db.jpg" alt="F2.jpg"></th></tr></thead><tbody><tr><td><img src="https://images.ptausercontent.com/e868e4b9-9fea-4f70-b7a7-1f5d8a3be4ef.jpg" alt="F3.jpg"></td><td><img src="https://images.ptausercontent.com/98aa1782-cea5-4792-8736-999436cf43a9.jpg" alt="F4.jpg"></td></tr></tbody></table><p>Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print <code>YES</code> if the tree is complete, or <code>NO</code> if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><pre><code class="hljs in">588 70 61 63 65</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><pre><code class="hljs out">70 63 88 61 65YES</code></pre><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><pre><code class="hljs in">888 70 61 96 120 90 65 68</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><pre><code class="hljs out">88 65 96 61 70 90 120 68NO</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>构建avl树，测试点2，3是来判断是否是完全二叉树的情况的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;queue&quot;</span>using namespace std;<span class="hljs-type">int</span> n;<span class="hljs-keyword">struct</span> Node &#123;    Node *left, *right;    <span class="hljs-type">int</span> num;&#125;;<span class="hljs-type">int</span> getHeight(Node *tree) &#123;    <span class="hljs-keyword">if</span> (tree == nullptr) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> l = getHeight(tree-&gt;left);    <span class="hljs-type">int</span> r = getHeight(tree-&gt;right);    <span class="hljs-keyword">return</span> max(l, r) + <span class="hljs-number">1</span>;&#125;<span class="hljs-type">bool</span> isBalanced(Node *left, Node *right) &#123;    <span class="hljs-keyword">return</span> abs(getHeight(left) - getHeight(right)) &lt; <span class="hljs-number">2</span>;&#125;Node * LeftLeft(Node* t)&#123;    Node * x = t-&gt;right;    Node * y = x-&gt;left;    x-&gt;left = t;    t-&gt;right = y;    <span class="hljs-keyword">return</span> x;&#125;Node * RightRight(Node* t)&#123;    Node * x = t-&gt;left;    Node * y = x-&gt;right;    x-&gt;right = t;    t-&gt;left = y;    <span class="hljs-keyword">return</span> x;&#125;Node * LeftRight(Node *t)&#123;    t-&gt;left = LeftLeft(t-&gt;left);    <span class="hljs-keyword">return</span> RightRight(t);&#125;Node * RightLeft(Node *t)&#123;    t-&gt;right = RightRight(t-&gt;right);    <span class="hljs-keyword">return</span> LeftLeft(t);&#125;Node *buildNode(<span class="hljs-type">int</span> num) &#123;    Node *node = (Node *) malloc(sizeof(Node));    node-&gt;left = node-&gt;right = nullptr;    node-&gt;num = num;    <span class="hljs-keyword">return</span> node;&#125;Node *buildAvl(Node *root, <span class="hljs-type">int</span> num) &#123;    <span class="hljs-keyword">if</span> (root == nullptr) &#123;        <span class="hljs-keyword">return</span> buildNode(num);    &#125;    <span class="hljs-keyword">if</span> (num &gt; root-&gt;num) &#123;        root-&gt;right = buildAvl(root-&gt;right, num);        <span class="hljs-keyword">if</span>(!isBalanced(root-&gt;left, root-&gt;right))&#123;            <span class="hljs-keyword">if</span>(num &gt; root-&gt;right-&gt;num)&#123;                root = LeftLeft(root);            &#125;<span class="hljs-keyword">else</span>&#123;                root = RightLeft(root);            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        root-&gt;left = buildAvl(root-&gt;left, num);        <span class="hljs-keyword">if</span>(!isBalanced(root-&gt;left, root-&gt;right))&#123;            <span class="hljs-keyword">if</span> (num &lt; root-&gt;left-&gt;num)&#123;                root = RightRight(root);            &#125;<span class="hljs-keyword">else</span>&#123;                root = LeftRight(root);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main() &#123;    cin &gt;&gt; n;    Node *root = nullptr;    while (n--) &#123;        <span class="hljs-type">int</span> a;        cin &gt;&gt; a;        root = buildAvl(root, a);    &#125;    queue&lt;Node *&gt; queue;    queue.push(root);    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> treeComplete = <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> after = <span class="hljs-number">0</span>;    while(!queue.empty())&#123;        Node * node = queue.front();        queue.pop();        <span class="hljs-keyword">if</span>(!flag)&#123;            cout &lt;&lt; node-&gt;num;            flag = <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span>&#123;            cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; node-&gt;num;        &#125;        <span class="hljs-comment">//if((node-&gt;right != nullptr &amp;&amp; node-&gt;left == nullptr) || (node-&gt;right == nullptr &amp;&amp; node-&gt;left != nullptr)) treeComplete = 0;</span>        <span class="hljs-keyword">if</span>(node-&gt;left != nullptr)&#123;            queue.push(node-&gt;left);            <span class="hljs-keyword">if</span>(after) treeComplete = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            after = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(node-&gt;right != nullptr)&#123;            queue.push(node-&gt;right);            <span class="hljs-keyword">if</span>(after) treeComplete = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            after = <span class="hljs-number">1</span>;        &#125;    &#125;    cout &lt;&lt;endl;    <span class="hljs-keyword">if</span>(treeComplete) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;    <span class="hljs-keyword">else</span> cout &lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a><font size=6px>04. 二维数组中的查找</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p><p>给定 target &#x3D; 5，返回 true。</p><p>给定 target &#x3D; 20，返回 false。</p><p>限制：</p><p>0 &lt;&#x3D; n &lt;&#x3D; 1000</p><p>0 &lt;&#x3D; m &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从最右上开始，如果比target大就往左，小就往下</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-type">bool</span> findNumberIn2DArray(<span class="hljs-type">int</span>** matrix, <span class="hljs-type">int</span> matrixSize, <span class="hljs-type">int</span>* matrixColSize, <span class="hljs-type">int</span> target)&#123;    <span class="hljs-keyword">if</span>(matrixSize==<span class="hljs-number">0</span> || *matrixColSize==<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;    <span class="hljs-type">int</span> j=*matrixColSize<span class="hljs-number">-1</span>;    while(i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;matrixSize &amp;&amp;j&gt;=<span class="hljs-number">0</span> &amp;&amp;j&lt;*matrixColSize)&#123;        <span class="hljs-keyword">if</span>(matrix[i][j] == target)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target)&#123;            i++;        &#125;<span class="hljs-keyword">else</span>&#123;            j--;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：32 ms, 在所有 C 提交中击败了99.19% 的用户<br>   内存消耗：8 MB, 在所有 C 提交中击败了99.73% 的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a><font size=6px>05. 替换空格</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">char* replaceSpace(char* s)&#123;    char* s1;    s1 = (char *)malloc(sizeof(char)*<span class="hljs-number">10000</span>);    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;strlen(s); i++)&#123;        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;            s1[j++] = <span class="hljs-string">&#x27;%&#x27;</span>;            s1[j++] = <span class="hljs-string">&#x27;2&#x27;</span>;            s1[j++] = <span class="hljs-string">&#x27;0&#x27;</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            s1[j] = s[i];            j++;        &#125;    &#125;    s1[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;    <span class="hljs-keyword">return</span> s1;    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 C 提交中击败了16.70% 的用户<br>   内存消耗：5.6 MB, 在所有 C 提交中击败了31.01% 的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a><font size=6px>06. 从尾到头打印链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span>输出：<span class="hljs-comment">[2,3,1]</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先将链表逆置，在逆置过程中算出长度，最后赋值给数组中</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">struct</span> ListNode* reverse(<span class="hljs-keyword">struct</span> ListNode *head,<span class="hljs-type">int</span> *<span class="hljs-built_in">len</span>)&#123;     <span class="hljs-keyword">struct</span> ListNode *head1=NULL;     <span class="hljs-keyword">struct</span> ListNode *tmp =NULL;     while(head!=NULL)&#123;         tmp = head-&gt;next;         head-&gt;next = head1;         head1 = head;         head = tmp;         *<span class="hljs-built_in">len</span>+=<span class="hljs-number">1</span>;     &#125;     <span class="hljs-keyword">return</span> head1; &#125;<span class="hljs-type">int</span>* reversePrint(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span>* returnSize)&#123;    <span class="hljs-type">int</span> *num;    <span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>;    head = reverse(head, &amp;<span class="hljs-built_in">len</span>);    num = (<span class="hljs-type">int</span> *)malloc(sizeof(<span class="hljs-type">int</span>)*<span class="hljs-number">10000</span>);    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;    while(head!=NULL)&#123;                num[i++] = head-&gt;val;        head = head-&gt;next;    &#125;        *returnSize = <span class="hljs-built_in">len</span>;    <span class="hljs-keyword">return</span> num;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 C 提交中击败了57.35% 的用户<br>   内存消耗：7.4 MB, 在所有 C 提交中击败了20.63% 的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><font size=6px>重建二叉树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>示例 1:</p><p>Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]<br>示例 2:</p><p>Input: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>Output: [-1]</p><p>限制：</p><p>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>递归</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    root := &amp;TreeNode&#123;preorder[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;    i := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(inorder); i++ &#123;        <span class="hljs-keyword">if</span> inorder[i] == preorder[<span class="hljs-number">0</span>] &#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    root.Left = buildTree(preorder[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(inorder[:i])+<span class="hljs-number">1</span>], inorder[:i])    root.Right = buildTree(preorder[<span class="hljs-built_in">len</span>(inorder[:i])+<span class="hljs-number">1</span>:], inorder[i+<span class="hljs-number">1</span>:])    <span class="hljs-keyword">return</span> root&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了93.47%的用户<br>   内存消耗：4 MB, 在所有 Go 提交中击败了67.24%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a><font size=6px>斐波那契数列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p>F(0) &#x3D; 0,   F(1) &#x3D; 1<br>F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：1<br>示例 2：</p><p>输入：n &#x3D; 5<br>输出：5</p><p>提示：</p><p>0 &lt;&#x3D; n &lt;&#x3D; 100<br>通过次数393,397提交次数1,087,540</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">100</span>),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>提前计算好菲波纳且数列的值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">var</span> mp <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mp) == <span class="hljs-number">0</span>&#123;        mp = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> mp[n]    &#125;    mp[<span class="hljs-number">0</span>],mp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>,<span class="hljs-number">1</span>         <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100</span>;i++&#123;        mp[i] = (mp[i<span class="hljs-number">-1</span>]+mp[i<span class="hljs-number">-2</span>])%<span class="hljs-number">1000000007</span>    &#125;    <span class="hljs-keyword">return</span> mp[n]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了83.53%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a><font size=6px>青蛙跳台阶问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：2<br>示例 2：</p><p>输入：n &#x3D; 7<br>输出：21<br>示例 3：</p><p>输入：n &#x3D; 0<br>输出：1<br>提示：</p><p>0 &lt;&#x3D; n &lt;&#x3D; 100<br>注意：本题与主站 70 题相同：<a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>dp</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numWays</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> f []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span> || n == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>    &#125;    f = <span class="hljs-built_in">append</span>(f,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>; i&lt;=n;i++&#123;        f = <span class="hljs-built_in">append</span>(f,(f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>])% <span class="hljs-number">1000000007</span>)    &#125;    <span class="hljs-keyword">return</span> f[n<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了20.91%</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 14- I. 剪绳子</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2014-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2014-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a><font size=6px>剪绳子</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>示例 1：</p><p>输入: 2<br>输出: 1<br>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1<br>示例 2:</p><p>输入: 10<br>输出: 36<br>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36<br>提示：</p><p>2 &lt;&#x3D; n &lt;&#x3D; 58<br>注意：本题与主站 343 题相同：<a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p><p>通过次数231,154提交次数402,798</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>只有均匀分成n份才是最大的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    res := <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n;i++&#123;        tmp := <span class="hljs-number">1</span>        tmpNum := n        <span class="hljs-keyword">for</span> j:=i;j&gt;=<span class="hljs-number">1</span>;j--&#123;            a := tmpNum/j            tmp *= a            tmpNum -= a        &#125;        res = max(res,tmp)    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了23.74%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 14- II. 剪绳子 II</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2014-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2014-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a><font size=6px>剑指 Offer 14- II. 剪绳子 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入: 2<br>输出: 1<br>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1<br>示例 2:</p><p>输入: 10<br>输出: 36<br>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    res = <span class="hljs-number">1</span>    <span class="hljs-keyword">if</span>  n&lt;=<span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>    &#125;    <span class="hljs-keyword">if</span> n == <span class="hljs-number">4</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>    &#125;    <span class="hljs-keyword">for</span> n&gt;<span class="hljs-number">4</span>&#123;        res *= <span class="hljs-number">3</span>        res %= <span class="hljs-number">1000000007</span>        n -= <span class="hljs-number">3</span>    &#125;    <span class="hljs-keyword">return</span> (res *n)%<span class="hljs-number">1000000007</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了58.33%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a><font size=6px>删除链表的节点</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><p>说明：</p><p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * type ListNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *ListNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(head *ListNode, val <span class="hljs-type">int</span>)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> head.Val == val&#123;        <span class="hljs-keyword">return</span> head.Next    &#125;    head2 := <span class="hljs-built_in">new</span>(ListNode)    head2.Next = head    <span class="hljs-keyword">for</span> head2.Next != <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> head2.Next.Val == val&#123;            head2.Next = head2.Next.Next            <span class="hljs-keyword">break</span>        &#125;        head2 = head2.Next    &#125;         <span class="hljs-keyword">return</span> head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.7 MB, 在所有 Go 提交中击败了61.43%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 26. 树的子结构</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><font size=6px>树的子结构</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><pre><code> 3/ \</code></pre><p>   4   5<br>  &#x2F; <br> 1   2<br>给定的树 B：</p><p>   4<br>  &#x2F;<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p>示例 1：</p><p>输入：A &#x3D; [1,2,3], B &#x3D; [3,1]<br>输出：false<br>示例 2：</p><p>输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]<br>输出：true<br>限制：</p><p>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span><span class="hljs-operator">*</span><span class="hljs-params">m</span>)</span>,空间复杂度<span class="hljs-constructor">O()</span></code></pre><p>A一步步遍历看是否等于B</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(A *TreeNode, B *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> A == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> A != <span class="hljs-literal">nil</span> &amp;&amp; B != <span class="hljs-literal">nil</span> &amp;&amp;(bianli(A,B) || isSubStructure(A.Left,B) || isSubStructure(A.Right,B))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bianli</span><span class="hljs-params">(A *TreeNode,B *TreeNode)</span></span><span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">if</span>  B == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> A == <span class="hljs-literal">nil</span> || B == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> A.Val == B.Val&#123;        <span class="hljs-keyword">return</span> bianli(A.Left,B.Left) &amp;&amp; bianli(A.Right,B.Right)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了14.20%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了83.03%</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 28. 对称的二叉树</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2028.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2028.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a><font size=6px>对称的二叉树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>1</code></pre><p>   &#x2F; <br>  2   2<br> &#x2F; \ &#x2F; <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>1</code></pre><p>   &#x2F; <br>  2   2<br>   \   <br>   3    3</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false</p><p>限制：</p><p>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用bfs思路做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || (root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> || root.Right == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">var</span> stack1,stack2 []*TreeNode    stack1 = <span class="hljs-built_in">append</span>(stack1, root.Left)    stack2 = <span class="hljs-built_in">append</span>(stack2,root.Right)    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack1)!=<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(stack2) != <span class="hljs-number">0</span>&#123;        left := stack1[<span class="hljs-number">0</span>]        right := stack2[<span class="hljs-number">0</span>]        stack1 = stack1[<span class="hljs-number">1</span>:]        stack2 = stack2[<span class="hljs-number">1</span>:]        <span class="hljs-keyword">if</span> left.Val != right.Val&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        <span class="hljs-keyword">if</span> left.Left != <span class="hljs-literal">nil</span> &amp;&amp; right.Right != <span class="hljs-literal">nil</span>&#123;            stack1 = <span class="hljs-built_in">append</span>(stack1, left.Left)            stack2 = <span class="hljs-built_in">append</span>(stack2, right.Right)        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> left.Left != <span class="hljs-literal">nil</span> || right.Right != <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;                <span class="hljs-keyword">if</span> left.Right != <span class="hljs-literal">nil</span> &amp;&amp; right.Left != <span class="hljs-literal">nil</span>&#123;            stack1 = <span class="hljs-built_in">append</span>(stack1, left.Right)            stack2 = <span class="hljs-built_in">append</span>(stack2, right.Left)        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> left.Right != <span class="hljs-literal">nil</span> || right.Left != <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack1)!=<span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(stack2)!= <span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了39.95%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a><font size=6px>螺旋矩阵</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><p>示例 1：</p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p><p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p>提示：</p><p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(matrix) != <span class="hljs-number">0</span>&#123;        res = <span class="hljs-built_in">append</span>(res,matrix[<span class="hljs-number">0</span>]...)        matrix = matrix[<span class="hljs-number">1</span>:]        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">break</span>        &#125;        m,n := <span class="hljs-built_in">len</span>(matrix),<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])        tmp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;                <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;                    tmp[j] = <span class="hljs-built_in">append</span>(tmp[j],matrix[i][n-j<span class="hljs-number">-1</span>])                &#125;            &#125;            matrix = tmp                <span class="hljs-comment">//fmt.Println(matrix)</span>    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：32 ms, 在所有 Go 提交中击败了5.26%的用户<br>   内存消耗：7.1 MB, 在所有 Go 提交中击败了5.54%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 35. 复杂链表的复制</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><font size=6px>复杂链表的复制</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>示例 1：</p><p>输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]<br>示例 2：</p><p>输入：head &#x3D; [[1,1],[2,1]]<br>输出：[[1,1],[2,1]]<br>示例 3：</p><p>输入：head &#x3D; [[3,null],[3,0],[3,null]]<br>输出：[[3,null],[3,0],[3,null]]<br>示例 4：</p><p>输入：head &#x3D; []<br>输出：[]<br>解释：给定的链表为空（空指针），因此返回 null。</p><p>提示：</p><p>-10000 &lt;&#x3D; Node.val &lt;&#x3D; 10000<br>Node.random 为空（null）或指向链表中的节点。<br>节点数目不超过 1000 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>使用map做最容易想到，用两个map，一个放node到位置，一个放位置到node，遍历两次</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a Node.</span><span class="hljs-comment"> * type Node struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *Node</span><span class="hljs-comment"> *     Random *Node</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head *Node)</span></span> *Node &#123;    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Node, <span class="hljs-number">0</span>)    mp_int := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Node]<span class="hljs-type">int</span> ,<span class="hljs-number">0</span>)    tmp := head    <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>; tmp != <span class="hljs-literal">nil</span>; k++&#123;        node := <span class="hljs-built_in">new</span>(Node)        node.Val = tmp.Val        mp[k] = node        mp_int[tmp] = k        tmp = tmp.Next    &#125;    tmp = head    <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>; tmp != <span class="hljs-literal">nil</span>; k++&#123;        mp[k].Next = mp[k+<span class="hljs-number">1</span>]                <span class="hljs-keyword">if</span> tmp.Random != <span class="hljs-literal">nil</span>&#123;            mp[k].Random = mp[mp_int[tmp.Random]]        &#125;<span class="hljs-keyword">else</span>&#123;            mp[k].Random = <span class="hljs-literal">nil</span>        &#125;        tmp = tmp.Next    &#125;    <span class="hljs-keyword">return</span> mp[<span class="hljs-number">0</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了38.17%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 39. 数组中出现次数超过一半的数字</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2039.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2039.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><font size=6px>数组中出现次数超过一半的数字</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p><p>限制：</p><p>1 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    num := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> nums&#123;        <span class="hljs-keyword">if</span> res ==<span class="hljs-number">0</span>&#123;            res = v        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> res == v&#123;                num ++            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(num &gt;<span class="hljs-number">0</span>)&#123;                    num--                &#125;<span class="hljs-keyword">else</span>&#123;                    res = v                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了94.86%的用户<br>   内存消耗：5.9 MB, 在所有 Go 提交中击败了99.43%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 40. 最小的k个数</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2040.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2040.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a><font size=6px>最小的k个数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：</p><p>输入：arr &#x3D; [3,2,1], k &#x3D; 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：</p><p>输入：arr &#x3D; [0,1,2,1], k &#x3D; 1<br>输出：[0]</p><p>限制：</p><p>0 &lt;&#x3D; k &lt;&#x3D; arr.length &lt;&#x3D; 10000<br>0 &lt;&#x3D; arr[i] &lt;&#x3D; 10000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>典型堆排序题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i:=n/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        HeapSortMin(arr,i,n)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;        arr[<span class="hljs-number">0</span>],arr[n-i] = arr[n-i],arr[<span class="hljs-number">0</span>]        HeapSortMin(arr,<span class="hljs-number">0</span>,n-i<span class="hljs-number">-1</span>)    &#125;    <span class="hljs-comment">//fmt.Println(arr)</span>    <span class="hljs-keyword">return</span> arr[n-k+<span class="hljs-number">1</span>:]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapSortMin</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,start <span class="hljs-type">int</span>,end <span class="hljs-type">int</span>)</span></span>&#123;    <span class="hljs-keyword">for</span>&#123;        child := start*<span class="hljs-number">2</span> +<span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> child &gt;end&#123;            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">if</span> child &lt; end &amp;&amp;arr[child] &gt; arr[child+<span class="hljs-number">1</span>]&#123;            child++        &#125;        <span class="hljs-keyword">if</span> arr[start] &lt; arr[child]&#123;            <span class="hljs-keyword">return</span>        &#125;        arr[start],arr[child] = arr[child],arr[start]        start = child    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了69.88%的用户<br>   内存消耗：6.4 MB, 在所有 Go 提交中击败了64.23%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 43. 1～n 整数中 1 出现的次数</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2043.%201%EF%BD%9En%20%E6%95%B4%E6%95%B0%E4%B8%AD%201%20%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2043.%201%EF%BD%9En%20%E6%95%B4%E6%95%B0%E4%B8%AD%201%20%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1～n-整数中-1-出现的次数"><a href="#1～n-整数中-1-出现的次数" class="headerlink" title="1～n 整数中 1 出现的次数"></a><font size=6px>1～n 整数中 1 出现的次数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p>示例 1：</p><p>输入：n &#x3D; 12<br>输出：5<br>示例 2：</p><p>输入：n &#x3D; 13<br>输出：6</p><p>限制：</p><p>1 &lt;&#x3D; n &lt; 2^31</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    d := dgt(n)    <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j&lt;=d; j++&#123;        p := <span class="hljs-type">int</span>(math.Pow(<span class="hljs-number">10</span>,<span class="hljs-type">float64</span>(j<span class="hljs-number">-1</span>)))        l := n/p/<span class="hljs-number">10</span>        r := n % p        dj := n /p %<span class="hljs-number">10</span>        res +=   l*p        <span class="hljs-keyword">if</span> dj &gt;<span class="hljs-number">1</span>&#123;            res += p        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dj ==<span class="hljs-number">1</span>&#123;            res += r+<span class="hljs-number">1</span>        &#125;    &#125;        <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dgt</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">var</span> cnt <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> n != <span class="hljs-number">0</span>&#123;        cnt++        n/=<span class="hljs-number">10</span>    &#125;    <span class="hljs-keyword">return</span> cnt&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了40.91%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a><font size=6px>二叉树中和为某一值的路径</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p><p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[]</p><p>提示：</p><p>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>dfs遍历然后到根节点就判断是否等于target</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode,tmp []<span class="hljs-type">int</span>,sum <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode,tmp []<span class="hljs-type">int</span>,sum <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>        &#125;        tmp = <span class="hljs-built_in">append</span>(tmp,root.Val)        sum += root.Val        dfs(root.Left,tmp,sum)        dfs(root.Right,tmp,sum)         <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> sum == targetSum&#123;                tmp2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(tmp))                <span class="hljs-built_in">copy</span>(tmp2,tmp)                res = <span class="hljs-built_in">append</span>(res,tmp2)            &#125;        &#125;    &#125;    dfs(root,[]<span class="hljs-type">int</span>&#123;&#125;,<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了86.83%的用户<br>   内存消耗：4.4 MB, 在所有 Go 提交中击败了41.69%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a><font size=6px>链表中倒数第k个节点</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</p><p>返回链表 4-&gt;5.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>双指针法</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;    fast, slow := head, head    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; k &gt; <span class="hljs-number">0</span> &#123;        fast = fast.Next        k--    &#125;    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;        fast = fast.Next        slow = slow.Next    &#125;    <span class="hljs-keyword">return</span> slow&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了12.35%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2045.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2045.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><font size=6px>把数组排成最小的数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>示例 1:</p><p>输入: [10,2]<br>输出: “102”<br>示例 2:</p><p>输入: [3,30,34,5,9]<br>输出: “3033459”</p><p>提示:</p><p>0 &lt; nums.length &lt;&#x3D; 100<br>说明:</p><p>输出结果可能非常大，所以你需要返回一个字符串而不是整数<br>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>排序的方式比较有创新点，排序方式为a+b &lt; b+a</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strings&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;bufio&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;io&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sort&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums); i++&#123;        s := strconv.Itoa(nums[i])        res = <span class="hljs-built_in">append</span>(res,s)    &#125;    sort.Slice(res,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;        a,_ := strconv.Atoi(res[i]+res[j])        b,_ := strconv.Atoi(res[j] + res[i])        <span class="hljs-keyword">return</span> a&lt;b    &#125;)    <span class="hljs-keyword">return</span> strings.Join(res,<span class="hljs-string">&quot;&quot;</span>)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.6 MB, 在所有 Go 提交中击败了51.65%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 46. 把数字翻译成字符串</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2046.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2046.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a><font size=6px>把数字翻译成字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>示例 1:</p><p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p><p>提示：</p><p>0 &lt;&#x3D; num &lt; 231</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">len</span>(<span class="hljs-params">n</span>)</span>),空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>有点像斐波拉且数列</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    snum := strconv.Itoa(num)    n :=  <span class="hljs-built_in">len</span>(snum)    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> (snum[i]-<span class="hljs-string">&#x27;0&#x27;</span>)+(snum[i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span> &lt;=<span class="hljs-number">25</span> &amp;&amp; snum[i<span class="hljs-number">-1</span>]!= <span class="hljs-string">&#x27;0&#x27;</span>&#123;            <span class="hljs-keyword">if</span> i==<span class="hljs-number">1</span>&#123;                dp[i] = <span class="hljs-number">2</span>*dp[i<span class="hljs-number">-1</span>]            &#125;<span class="hljs-keyword">else</span>&#123;                dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            dp[i] = dp[i<span class="hljs-number">-1</span>]        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了35.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 47. 礼物的最大价值</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2047.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2047.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a><font size=6px>礼物的最大价值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p>示例 1:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p>提示：</p><p>0 &lt; grid.length &lt;&#x3D; 200<br>0 &lt; grid[0].length &lt;&#x3D; 200</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>动态规划</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(grid),<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    <span class="hljs-keyword">if</span> m== <span class="hljs-number">1</span> &amp;&amp; n==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m;i++&#123;        grid[i][<span class="hljs-number">0</span>] += grid[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;n;j++&#123;            grid[i][j] += max(grid[i<span class="hljs-number">-1</span>][j], grid[i][j<span class="hljs-number">-1</span>])        &#125;    &#125;    <span class="hljs-keyword">return</span> grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了98.05%的用户<br>   内存消耗：3.7 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 49. 丑数</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2049.%20%E4%B8%91%E6%95%B0/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2049.%20%E4%B8%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="丑数-II"><a href="#丑数-II" class="headerlink" title="丑数 II"></a>丑数 II</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p><p>丑数 就是只包含质因数 2、3 和&#x2F;或 5 的正整数。</p><p>示例 1：</p><p>输入：n &#x3D; 10 输出：12 解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。 示例 2：</p><p>输入：n &#x3D; 1 输出：1 解释：1 通常被视为丑数。</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 1690</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>dp求三个值里面最小值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    p2,p3,p5 := <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n;i++&#123;        x2,x3,x5 := dp[p2]*<span class="hljs-number">2</span>,dp[p3]*<span class="hljs-number">3</span>,dp[p5]*<span class="hljs-number">5</span>        dp[i] = min(x2,min(x3,x5))        <span class="hljs-keyword">if</span> dp[i] == x2&#123;            p2++        &#125;        <span class="hljs-keyword">if</span> dp[i] == x3&#123;            p3++        &#125;        <span class="hljs-keyword">if</span> dp[i] == x5&#123;            p5++        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p>执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>内存消耗：4 MB, 在所有 Go 提交中击败了62.40%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a><font size=6px>第一个只出现一次的字符</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p>示例 1:</p><p>输入：s &#x3D; “abaccdeff”<br>输出：’b’<br>示例 2:</p><p>输入：s &#x3D; “”<br>输出：’ ‘</p><p>限制：</p><p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        mp[s[i]]++    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">if</span> mp[s[i]] == <span class="hljs-number">1</span>&#123;            <span class="hljs-keyword">return</span> s[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：40 ms, 在所有 Go 提交中击败了33.88%的用户<br>   内存消耗：5.2 MB, 在所有 Go 提交中击败了44.69%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 56 - I. 数组中数字出现的次数</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2056%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2056%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a><font size=6px>数组中数字出现的次数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br>示例 2：</p><p>输入：nums &#x3D; [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2]</p><p>限制：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 10000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>题目还挺有意思，是升级版，要你更加深入使用抑或</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumbers</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    ret := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,n := <span class="hljs-keyword">range</span> nums&#123;        ret ^= n    &#125;    a,b := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    p := <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> (p &amp; ret) == <span class="hljs-number">0</span>&#123;        p *= <span class="hljs-number">2</span>    &#125;    <span class="hljs-comment">//fmt.Println(p)</span>    <span class="hljs-keyword">for</span> _,n := <span class="hljs-keyword">range</span> nums&#123;        <span class="hljs-keyword">if</span> p &amp; n != <span class="hljs-number">0</span>&#123;            <span class="hljs-comment">//fmt.Println(&quot;a&quot;,n)</span>            a ^= n        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//fmt.Println(&quot;b&quot;,n)</span>            b ^= n        &#125;    &#125;    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;a,b&#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了96.80%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了66.50%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 63. 股票的最大利润</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2063.%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2063.%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a><font size=6px>股票的最大利润</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。<br>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>限制：</p><p>0 &lt;&#x3D; 数组长度 &lt;&#x3D; 10^5</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    maxNum,minNum := prices[<span class="hljs-number">0</span>],prices[<span class="hljs-number">0</span>]    n := <span class="hljs-built_in">len</span>(prices)    res := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> prices[i]&gt;maxNum&#123;            maxNum = prices[i]        &#125;        <span class="hljs-keyword">if</span> prices[i] &lt; minNum&#123;            maxNum = prices[i]            minNum = prices[i]        &#125;        res = max(res,maxNum-minNum)    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了90.64%的用户<br>   内存消耗：2.9 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 024. 反转链表</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20024.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20024.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><font size=6px>反转链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p><p>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：</p><p>输入：head &#x3D; []<br>输出：[]</p><p>提示：</p><p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000</p><p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用头插法</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * type ListNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *ListNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-keyword">var</span> head2 *ListNode    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span>&#123;        next := head.Next        head.Next = head2        head2 = head        head = next    &#125;    <span class="hljs-keyword">return</span> head2&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了65.36%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 041. 滑动窗口的平均值</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20041.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20041.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="滑动窗口的平均值"><a href="#滑动窗口的平均值" class="headerlink" title="滑动窗口的平均值"></a><font size=6px>滑动窗口的平均值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。</p><p>实现 MovingAverage 类：</p><p>MovingAverage(int size) 用窗口大小 size 初始化对象。<br>double next(int val) 成员函数 next 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size 个值的移动平均值，即滑动窗口里所有数字的平均值。</p><p>示例：</p><p>输入：<br>inputs &#x3D; [“MovingAverage”, “next”, “next”, “next”, “next”]<br>inputs &#x3D; [[3], [1], [10], [3], [5]]<br>输出：<br>[null, 1.0, 5.5, 4.66667, 6.0]</p><p>解释：<br>MovingAverage movingAverage &#x3D; new MovingAverage(3);<br>movingAverage.next(1); &#x2F;&#x2F; 返回 1.0 &#x3D; 1 &#x2F; 1<br>movingAverage.next(10); &#x2F;&#x2F; 返回 5.5 &#x3D; (1 + 10) &#x2F; 2<br>movingAverage.next(3); &#x2F;&#x2F; 返回 4.66667 &#x3D; (1 + 10 + 3) &#x2F; 3<br>movingAverage.next(5); &#x2F;&#x2F; 返回 6.0 &#x3D; (10 + 3 + 5) &#x2F; 3</p><p>提示：</p><p>1 &lt;&#x3D; size &lt;&#x3D; 1000<br>-105 &lt;&#x3D; val &lt;&#x3D; 105<br>最多调用 next 方法 104 次</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">size</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> MovingAverage <span class="hljs-keyword">struct</span> &#123;    nums []<span class="hljs-type">int</span>    i,j,size <span class="hljs-type">int</span>    &#125;<span class="hljs-comment">/** Initialize your data structure here. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> MovingAverage &#123;    movingAverage := MovingAverage&#123;&#125;    movingAverage.size = size    <span class="hljs-keyword">return</span> movingAverage&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MovingAverage)</span></span> Next(val <span class="hljs-type">int</span>) <span class="hljs-type">float64</span> &#123;    n := <span class="hljs-built_in">len</span>(this.nums)    <span class="hljs-keyword">var</span> res <span class="hljs-type">float64</span>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">float64</span>     this.nums = <span class="hljs-built_in">append</span>(this.nums, val)    <span class="hljs-keyword">if</span> n&lt;this.size&#123;        this.j++        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n;i++&#123;            sum += <span class="hljs-type">float64</span>(this.nums[i])        &#125;        res = sum/(<span class="hljs-type">float64</span>)(n+<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> res    &#125;<span class="hljs-keyword">else</span>&#123;        this.i++        this.j++        <span class="hljs-keyword">for</span> i:=this.i;i&lt;this.j;i++&#123;            sum += <span class="hljs-type">float64</span>(this.nums[i])        &#125;                res = sum/(<span class="hljs-type">float64</span>)(this.size)        <span class="hljs-keyword">return</span> res    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MovingAverage object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor(size);</span><span class="hljs-comment"> * param_1 := obj.Next(val);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了70.54%的用户<br>   内存消耗：7.3 MB, 在所有 Go 提交中击败了81.70%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 047. 二叉树剪枝</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20047.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20047.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树剪枝"><a href="#二叉树剪枝" class="headerlink" title="二叉树剪枝"></a>二叉树剪枝</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。</p><p>返回移除了所有不包含 1 的子树的原二叉树。</p><p>节点 node 的子树为 node 本身加上所有 node 的后代。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,0,0,1] 输出：[1,null,0,null,1] 解释： 只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。 示例 2：</p><p>输入：root &#x3D; [1,0,1,0,0,0,1] 输出：[1,null,1,null,1] 示例 3：</p><p>输入：root &#x3D; [1,1,0,1,1,0,1,0] 输出：[1,1,0,1,1,null,1]</p><p>提示：</p><p>树中节点的数目在范围 [1, 200] 内 Node.val 为 0 或 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>递归做，看到符合条件的赋值成null</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs xquery">/** * Definition <span class="hljs-keyword">for</span> a binary tree <span class="hljs-type">node</span>. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func pruneTree<span class="hljs-built_in">(root</span> *TreeNode) *TreeNode &#123;    <span class="hljs-keyword">if</span><span class="hljs-built_in"> root</span> == nil&#123;        <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>    &#125;    <span class="hljs-keyword">if</span><span class="hljs-built_in"> root</span>.Left != nil&#123;       <span class="hljs-built_in"> root</span>.Left = pruneTree<span class="hljs-built_in">(root</span>.Left)    &#125;    <span class="hljs-keyword">if</span><span class="hljs-built_in"> root</span>.Right != nil&#123;       <span class="hljs-built_in"> root</span>.Right = pruneTree<span class="hljs-built_in">(root</span>.Right)    &#125;    <span class="hljs-keyword">if</span><span class="hljs-built_in"> root</span>.Left == nil &amp;&amp;<span class="hljs-built_in"> root</span>.Right == nil &amp;&amp;<span class="hljs-built_in"> root</span>.Val == <span class="hljs-number">0</span>&#123;       <span class="hljs-built_in"> root</span> = nil    &#125;    <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><pre><code class="hljs erlang-repl">执行用时：<span class="hljs-number">0</span> ms, 在所有 Go 提交中击败了<span class="hljs-number">100.00</span><span class="hljs-comment">%的用户</span>内存消耗：<span class="hljs-number">2.2</span> MB, 在所有 Go 提交中击败了<span class="hljs-number">100.00</span><span class="hljs-comment">%的用户</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 090. 环形房屋偷盗</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20090.%20%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20090.%20%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97/</url>
    
    <content type="html"><![CDATA[<h3 id="环形房屋偷盗"><a href="#环形房屋偷盗" class="headerlink" title="环形房屋偷盗"></a><font size=6px>环形房屋偷盗</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 3：</p><p>输入：nums &#x3D; [0]<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>首个和最后一个只能取一个</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>])    &#125;    <span class="hljs-keyword">return</span> max(_rob(nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]), _rob(nums[<span class="hljs-number">1</span>:]))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]    &#125;    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]    dp[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;        dp[i] = max(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>])    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> x &gt; y &#123;        <span class="hljs-keyword">return</span> x    &#125;    <span class="hljs-keyword">return</span> y&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了46.75%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 61. 扑克牌中的顺子</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2061.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2061.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a><font size=6px>扑克牌中的顺子</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p>示例 1:</p><p>输入: [1,2,3,4,5]<br>输出: True</p><p>示例 2:</p><p>输入: [0,0,1,2,5]<br>输出: True</p><p>限制：</p><p>数组长度为 5 </p><p>数组的数取值为 [0, 13] .</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>判断一个顺子里面的个数加上0的个数是不是5</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    sort.Ints(nums)    cnt0,cnt1 := <span class="hljs-number">0</span>,<span class="hljs-number">1</span>    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>,<span class="hljs-number">0</span>)    i :=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> ;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">0</span>&#123;            cnt0++        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> j:=i;j&lt;<span class="hljs-built_in">len</span>(nums);j++&#123;        mp[nums[j]] = <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">5</span>;j++&#123;        <span class="hljs-keyword">if</span> mp[nums[i]+j]&#123;            cnt1++        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(cnt0,cnt1)</span>    <span class="hljs-keyword">if</span> cnt1+cnt0 == <span class="hljs-number">5</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了14.92%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>去PAT考试需要记忆的东西</title>
    <link href="/2022/01/21/PAT%E4%B9%99/%E5%8E%BBPAT%E4%B9%99%E7%BA%A7%E8%80%83%E8%AF%95%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BF%86%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <url>/2022/01/21/PAT%E4%B9%99/%E5%8E%BBPAT%E4%B9%99%E7%BA%A7%E8%80%83%E8%AF%95%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BF%86%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
    
    <content type="html"><![CDATA[<h4 id="1、使用map"><a href="#1、使用map" class="headerlink" title="1、使用map"></a>1、使用map</h4><h5 id="需要引入头"><a href="#需要引入头" class="headerlink" title="需要引入头"></a>需要引入头</h5><p>using namespace std;</p><h5 id="使用时定义"><a href="#使用时定义" class="headerlink" title="使用时定义"></a>使用时定义</h5><p>map&lt;char[6],struct Output&gt; Map;</p><p>要使用string得导入开头 #include <iostream></p><h4 id="2、使用strupr（）来小写转大写，strlwr来大写转小写"><a href="#2、使用strupr（）来小写转大写，strlwr来大写转小写" class="headerlink" title="2、使用strupr（）来小写转大写，strlwr来大写转小写"></a>2、使用strupr（）来小写转大写，strlwr来大写转小写</h4><p>需要导入#include&lt;string.h&gt;</p><h4 id="3、使用sort函数"><a href="#3、使用sort函数" class="headerlink" title="3、使用sort函数"></a>3、使用sort函数</h4><p>需要头文件：using namespace std;   #include<algorithm></p><p>例子</p><pre><code class="hljs stata">struct Info&#123;int id;int <span class="hljs-keyword">de</span> ;int cai ;int <span class="hljs-keyword">total</span> ;&#125;;<span class="hljs-comment">//按total降序</span>bool cmp(Info a,Info b)&#123;<span class="hljs-keyword">if</span> (a.<span class="hljs-keyword">total</span>!=b.<span class="hljs-keyword">total</span>)&#123;<span class="hljs-keyword">return</span> a.<span class="hljs-keyword">total</span>&gt;b.<span class="hljs-keyword">total</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.<span class="hljs-keyword">de</span>!=b.<span class="hljs-keyword">de</span>)&#123;<span class="hljs-keyword">return</span> a.<span class="hljs-keyword">de</span>&gt;b.<span class="hljs-keyword">de</span>;&#125; <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> a.id&lt;b.id;&#125;&#125; <span class="hljs-keyword">sort</span>(first,first+a,cmp);</code></pre><h4 id="3、会用gcd和gcm，和swap"><a href="#3、会用gcd和gcm，和swap" class="headerlink" title="3、会用gcd和gcm，和swap"></a>3、会用gcd和gcm，和swap</h4><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:<span class="hljs-built_in">gcd</span>(b,a%b);&#125; <span class="hljs-comment">//最大公约数 </span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-built_in">gcd</span>(a,b);<span class="hljs-keyword">return</span> a*b/c; &#125;</code></pre><p>用swap要导入using namespace std； #include<iostream></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我为什么不用golang写PAT了</title>
    <link href="/2022/01/21/PAT%E4%B9%99/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8golang%E5%86%99PTA%E4%BA%86/"/>
    <url>/2022/01/21/PAT%E4%B9%99/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8golang%E5%86%99PTA%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h4 id="先说说我为什么要用golang写算法题"><a href="#先说说我为什么要用golang写算法题" class="headerlink" title="先说说我为什么要用golang写算法题"></a>先说说我为什么要用golang写算法题</h4><ul><li>第一是想让我熟练使用golang语言的各种库，熟悉基础语法，比如go没while循环。。。</li><li>第二是go语言的性能比较高效，最快能与c语言相同，并且与c语言比较，golang库完善编写比如排序只需要调用函数就行，比较简单，c语言就要用到c++的东西，挺麻烦的，还要手写cmp函数。</li></ul><h4 id="再说说为什么我不再用golang写PAT了"><a href="#再说说为什么我不再用golang写PAT了" class="headerlink" title="再说说为什么我不再用golang写PAT了"></a>再说说为什么我不再用golang写PAT了</h4><ul><li>第一是因为你网上找不到用golang写PAT的人（力扣倒是挺多的，而且力扣比较人性化，会把测试用例错误答案和正确答案给你列出来，而且有社区，但是PAT锻炼了你的独立思考能力，自己思考错哪边了），就算写错了自己找不出原因的时候也没地方借鉴，而且PAT在考试的时候<strong>只支持c&#x2F;c++调试环境</strong></li><li>第二因为golang他速度只是最快能到c，有些时候会不达到，然后PAT他的<strong>运行时间卡的比较紧</strong>，举例一道简单题PAT乙级 <a herf="sets/994805260223102976/problems/994805289432236032)"> 1032挖掘技术那家强 </a></li></ul><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,a,b,maxi <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> score [<span class="hljs-number">120000</span>]<span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)     <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scanf(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a,&amp;b)        score[a]+=b    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        <span class="hljs-keyword">if</span> score[maxi]&lt;score[i]&#123;            maxi = i        &#125;    &#125;    fmt.Println(maxi,score[maxi])&#125;</code></pre><p>这道题用golang写最后一个测试点会是运行超时，如果要做的话得考虑用并发实现了，这样做一道题太费时间了，考场里面用这种方法不太可行，也用golang写了30多道题目了，锻炼效果应该差不多，现在开始用c语言写题目温习一下c语言技巧和排序的使用，加油考试吧，虽然只是个对别人来说简简单单的乙级。</p>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>makedown基础语法</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/makedown%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/makedown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1、字体大小"><a href="#1、字体大小" class="headerlink" title="1、字体大小"></a>1、字体大小</h1><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><pre><code class="hljs clean"># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><h6 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h6><p><strong>加粗</strong></p><pre><code class="hljs *">**加粗**</code></pre><p><em>斜体</em></p><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体*</span></code></pre><p>输入代码</p><pre><code class="hljs autohotkey">直接输入”```“然后按下回车键（`在英文情况加按左上角波浪号可打出）</code></pre><p>3、url</p><p>图片导入</p><p>![](C:\Users\89500\Desktop\HTML\my storys\hexo\themes\fluid\source\img\avatar.png)</p><pre><code class="hljs scss">绝对路径： !<span class="hljs-selector-attr">[这里输入图片名字]</span>(这里输入绝对路径)</code></pre>]]></content>
    
    
    <categories>
      
      <category>自动化博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>makedown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><font size=6px>102. 二叉树的层序遍历</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p><p>​    3<br>   &#x2F; <br>  9  20<br>​    &#x2F;  <br>   15   7<br>返回其层序遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>我用广度优先搜索来做，用队列的思想来做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> arr [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> arr    &#125;    qu:=[]*TreeNode&#123;root&#125;    <span class="hljs-keyword">for</span> level:=<span class="hljs-number">0</span>;<span class="hljs-built_in">len</span>(qu)&gt;<span class="hljs-number">0</span>;level++ &#123;        arr=<span class="hljs-built_in">append</span>(arr,[]<span class="hljs-type">int</span>&#123;&#125;)        p:=[]*TreeNode&#123;&#125;        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(qu); i++ &#123;            arr[level]=<span class="hljs-built_in">append</span>(arr[level],qu[i].Val)            <span class="hljs-keyword">if</span> qu[i].Left != <span class="hljs-literal">nil</span> &#123;                p = <span class="hljs-built_in">append</span>(p, qu[i].Left)            &#125;            <span class="hljs-keyword">if</span> qu[i].Right != <span class="hljs-literal">nil</span> &#123;                p = <span class="hljs-built_in">append</span>(p, qu[i].Right)            &#125;        &#125;        qu=p    &#125;    <span class="hljs-keyword">return</span>  arr&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了96.60%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>103. 二叉树的锯齿形层序遍历</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a><font size=6px>二叉树的锯齿形层序遍历</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>返回锯齿形层序遍历如下：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跟102很相似，用队列来做，就是输入到arr的时候输入次序</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> arr [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> arr    &#125;    qu:=[]*TreeNode&#123;root&#125;    <span class="hljs-keyword">for</span> level:=<span class="hljs-number">0</span>;<span class="hljs-built_in">len</span>(qu)&gt;<span class="hljs-number">0</span>;level++&#123;        arr=<span class="hljs-built_in">append</span>(arr,[]<span class="hljs-type">int</span>&#123;&#125;)        p:=[]*TreeNode&#123;&#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(qu);i++&#123;            <span class="hljs-keyword">if</span> qu[i].Left!=<span class="hljs-literal">nil</span>&#123;                p=<span class="hljs-built_in">append</span>(p,qu[i].Left)            &#125;            <span class="hljs-keyword">if</span> qu[i].Right !=<span class="hljs-literal">nil</span>&#123;                p=<span class="hljs-built_in">append</span>(p,qu[i].Right)            &#125;        &#125;        <span class="hljs-keyword">if</span> level%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>&#123;            <span class="hljs-keyword">for</span> j:=<span class="hljs-built_in">len</span>(qu)<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--&#123;                arr[level]=<span class="hljs-built_in">append</span>(arr[level],qu[j].Val)            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(qu);j++&#123;                arr[level]=<span class="hljs-built_in">append</span>(arr[level],qu[j].Val)            &#125;        &#125;        qu=p    &#125;    <span class="hljs-keyword">return</span> arr&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.5 MB, 在所有 Go 提交中击败了79.52%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>101. 对称二叉树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><font size=6px>对称二叉树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false</p><p>提示：</p><p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用两个指针，一个往左边，一个往右边，判断p和q相不相等</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> root== <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">var</span> p,q *TreeNode    p,q = root,root    <span class="hljs-keyword">if</span> root.Left==<span class="hljs-literal">nil</span> &amp;&amp; root.Right== <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span> is(p,q)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">is</span><span class="hljs-params">(p,q *TreeNode)</span></span> <span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &amp;&amp; q == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">if</span> p==<span class="hljs-literal">nil</span> || q == <span class="hljs-literal">nil</span>&#123;               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> p.Val != q.Val&#123;               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    flag := is(p.Left,q.Right)    flag2 :=is(p.Right,q.Left)    <span class="hljs-keyword">return</span> flag &amp;&amp; flag2    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.9 MB, 在所有 Go 提交中击败了69.43%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>343. 整数拆分</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/343.%20%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/343.%20%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><font size=6px>整数拆分</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>示例 1：</p><p>输入: 2<br>输出: 1<br>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1<br>示例 2:</p><p>输入: 10<br>输出: 36<br>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36<br>提示：</p><p>2 &lt;&#x3D; n &lt;&#x3D; 58<br>注意：本题与主站 343 题相同：<a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p><p>通过次数231,154提交次数402,798</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>只有均匀分成n份才是最大的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    res := <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n;i++&#123;        tmp := <span class="hljs-number">1</span>        tmpNum := n        <span class="hljs-keyword">for</span> j:=i;j&gt;=<span class="hljs-number">1</span>;j--&#123;            a := tmpNum/j            tmp *= a            tmpNum -= a        &#125;        res = max(res,tmp)    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了30.27%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1070 结绳</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1070%20%E7%BB%93%E7%BB%B3/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1070%20%E7%BB%93%E7%BB%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="结绳"><a href="#结绳" class="headerlink" title=" 结绳"></a><font size=6px> 结绳</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。</p><p><img src="https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg" alt="rope.jpg"></p><p>给定 <em>N</em> 段绳子的长度，你需要找出它们能串成的绳子的最大长度。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 <em>N</em> (2≤<em>N</em>≤104)；第 2 行给出 <em>N</em> 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过104。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">810 15 12 3 4 13 1 15</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">14</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>题目理解了代码很简单，先说思路，第二次折的时候会把第一次折的再折一次，所以要从最小的开始选，要小的多折几次，所以排序过后选最小的和第二小的开始折就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>   <span class="hljs-string">&quot;sort&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> a,result <span class="hljs-type">float64</span>    fmt.Scan(&amp;n)    num:= <span class="hljs-built_in">make</span>([]<span class="hljs-type">float64</span>,n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scanf(<span class="hljs-string">&quot;%f&quot;</span>,&amp;a)        num[i] = a    &#125;    sort.Float64s(num)    result =num[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        result = (result+num[i])/<span class="hljs-number">2</span>    &#125;    fmt.Println(<span class="hljs-type">int</span>(result))&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1072 开学寄语</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1072%20%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1072%20%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="开学寄语"><a href="#开学寄语" class="headerlink" title="开学寄语"></a><font size=6px>开学寄语</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p><p><img src="https://images.ptausercontent.com/3b1d9f4a-778b-4942-a9e2-836262f363aa.JPG" alt="jiyu.JPG"></p><p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）：</p><pre><code class="hljs makefile"><span class="hljs-section">姓名缩写: 物品编号1 物品编号2 ……</span></code></pre><p>最后一行输出存在问题的学生的总人数和被查缴物品的总数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">4 22333 6666CYLL 3 1234 2345 3456U 4 9966 6666 8888 6666GG 2 2333 7777JJ 3 0012 6666 2333</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">U: 6666 6666GG: 2333JJ: 6666 23333 5</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第一次提交被最后两个测试点卡住，仔细看了下题目这个数字前面是有0的，所以要用string去接受和输出，问题解决，用暴力解最容易，判断每一个学生的物品编号是不是违禁物品就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> c,stuNum,forbidNum,countStuNum,countTotalNum,flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> s,a,b <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> forbid []<span class="hljs-type">string</span>    fmt.Scan(&amp;stuNum,&amp;forbidNum)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;forbidNum;i++&#123;        fmt.Scan(&amp;a)        forbid =<span class="hljs-built_in">append</span>(forbid,a)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;stuNum;i++&#123;        fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s)        fmt.Scan(&amp;c)        <span class="hljs-comment">//检测学生的物品是否是违禁物品</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;c;j++&#123;            fmt.Scan(&amp;b)            <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> forbid&#123;                <span class="hljs-keyword">if</span> v==b&#123;                    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;                        flag=<span class="hljs-number">1</span>                        fmt.Printf(<span class="hljs-string">&quot;%s:&quot;</span>,s)                        countStuNum++                    &#125;                    fmt.Printf(<span class="hljs-string">&quot; %s&quot;</span>,b)                    countTotalNum++                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> flag==<span class="hljs-number">1</span>&#123;            flag=<span class="hljs-number">0</span>            fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)        &#125;    &#125;    fmt.Printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,countStuNum,countTotalNum)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1075 链表元素分类</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1075%20%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1075%20%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="链表元素分类"><a href="#链表元素分类" class="headerlink" title="链表元素分类"></a><font size=6px>链表元素分类</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤105)；以及正整数K (≤103)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 N 行，每行格式为：</p><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span></code></pre><p>其中 <code>Address</code> 是结点地址；<code>Data</code> 是该结点保存的数据，为 [−105,105] 区间内的整数；<code>Next</code> 是下一结点的地址。题目保证给出的链表不为空。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">00100 9 1023333 10 2777700000 0 9999900100 18 1230968237 -6 2333333218 -4 0000048652 -2 -199999 5 6823727777 11 4865212309 7 33218</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">33218 -4 6823768237 -6 4865248652 -2 1230912309 7 0000000000 0 9999999999 5 2333323333 10 0010000100 18 2777727777 11 -1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>代码参考网上，写的很巧妙，用了vector包，分三个部分，小于0，小于k，和大于k的，然后保存他们的地址，最后在输出的时候也巧妙，先输出现在的地址和数据，下一个地址和数据在下一次输出。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;using namespace std;<span class="hljs-keyword">struct</span> list&#123;<span class="hljs-type">int</span> data;<span class="hljs-type">int</span> next;&#125;l[<span class="hljs-number">100002</span>];vector&lt;<span class="hljs-type">int</span>&gt; v[<span class="hljs-number">3</span>];<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> first,n,k,a,flag;scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;first,&amp;n,&amp;k);while(n--)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l[a].data,&amp;l[a].next);&#125;<span class="hljs-comment">//分3个部分，把每个部分的地址传进去 </span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=first;i!=<span class="hljs-number">-1</span>;i=l[i].next)&#123;<span class="hljs-keyword">if</span> (l[i].data&lt;<span class="hljs-number">0</span>)&#123;v[<span class="hljs-number">0</span>].push_back(i);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l[i].data&gt;k)&#123;v[<span class="hljs-number">2</span>].push_back(i) ;&#125;<span class="hljs-keyword">else</span>&#123;v[<span class="hljs-number">1</span>].push_back(i);&#125;&#125;    flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;v[i].size();j++)&#123;            <span class="hljs-comment">//很巧妙的解决了不知道下一个地址的问题</span><span class="hljs-keyword">if</span> (flag==<span class="hljs-number">0</span>)&#123;printf(<span class="hljs-string">&quot;%05d %d &quot;</span>,v[i][j],l[v[i][j]].data);flag=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%05d\n%05d %d &quot;</span>,v[i][j],v[i][j],l[v[i][j]].data);&#125;&#125;&#125;printf(<span class="hljs-string">&quot;-1\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1078 字符串压缩与解压</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1078%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1078%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串压缩与解压"><a href="#字符串压缩与解压" class="headerlink" title="字符串压缩与解压"></a><font size=6px>字符串压缩与解压</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 <code>ccccc</code> 就用 <code>5c</code> 来表示。如果字符没有重复，就原样输出。例如 <code>aba</code> 压缩后仍然是 <code>aba</code>。</p><p>解压方法就是反过来，把形如 <code>5c</code> 这样的表示恢复为 <code>ccccc</code>。</p><p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个字符，如果是 <code>C</code> 就表示下面的字符串需要被压缩；如果是 <code>D</code> 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>根据要求压缩或解压字符串，并在一行中输出结果。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">CTTTTThhiiiis isssss a   tesssst CAaaa as</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">5T2h4is i5s a3 te4st CA3a as</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">D5T2h4is i5s a3 te4st CA3a as10Z</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">TTTTThhiiiis isssss a   tesssst CAaaa asZZZZZZZZZZ</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>坑点，得用getchar（）弄掉C&#x2F;D后面的换行符，用get（b）接受有空格的字符串。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;<span class="hljs-type">int</span> main()&#123;char a;<span class="hljs-type">int</span> count=<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;a);    getchar();char b[<span class="hljs-number">100002</span>];gets(b);<span class="hljs-keyword">if</span> (a==<span class="hljs-string">&#x27;C&#x27;</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strlen(b);i++)&#123;<span class="hljs-keyword">if</span>(b[i]==b[i+<span class="hljs-number">1</span>])&#123;count++;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (count==<span class="hljs-number">1</span>)&#123;printf(<span class="hljs-string">&quot;%c&quot;</span>,b[i]);&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%d%c&quot;</span>,count,b[i]);count=<span class="hljs-number">1</span>;&#125;&#125;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a==<span class="hljs-string">&#x27;D&#x27;</span>)&#123;count=<span class="hljs-number">0</span>;while(k&lt;strlen(b))&#123;<span class="hljs-keyword">if</span>(b[k]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;b[k]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;while(b[k]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;b[k]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;count=count*<span class="hljs-number">10</span>+(b[k]-<span class="hljs-string">&#x27;0&#x27;</span>);k++;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;count;j++)&#123;printf(<span class="hljs-string">&quot;%c&quot;</span>,b[k]);&#125;count=<span class="hljs-number">0</span>;k=k+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%c&quot;</span>,b[k]);k++;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1082 射击比赛</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1082%20%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1082%20%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="射击比赛"><a href="#射击比赛" class="headerlink" title="射击比赛"></a><font size=6px>射击比赛</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">ID x y</span></code></pre><p>其中 <code>ID</code> 是运动员的编号（由 4 位数字组成）；<code>x</code> 和 <code>y</code> 是其打出的弹洞的平面坐标(<code>x</code>,<code>y</code>)，均为整数，且 0 ≤ |<code>x</code>|, |<code>y</code>| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">30001 5 71020 -1 30233 0 -1</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">0233 0001</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>创立一个10002的数组，记得是float类型的，输入完成之后就遍历这10000个数字找最大最小值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> b,id,n,c,maxi,mini <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max,min <span class="hljs-type">float64</span>    max = <span class="hljs-number">0</span>    min = <span class="hljs-number">10000</span>    <span class="hljs-keyword">var</span> score [<span class="hljs-number">10002</span>]<span class="hljs-type">float64</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10000</span>;i++&#123;        score[i]= <span class="hljs-number">-1</span>    &#125;    fmt.Scan(&amp;n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;id,&amp;b,&amp;c)        score[id]=math.Sqrt(<span class="hljs-type">float64</span>(c*c+b*b))    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++&#123;        <span class="hljs-keyword">if</span> score[i]!=<span class="hljs-number">-1</span>&#123;            <span class="hljs-keyword">if</span> score[i]&gt;max&#123;                max = score[i]                maxi =i            &#125;            <span class="hljs-keyword">if</span> score[i]&lt;min&#123;                min = score[i]                mini = i            &#125;        &#125;    &#125;    fmt.Printf(<span class="hljs-string">&quot;%04d %04d\n&quot;</span>,mini,maxi)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1085 PAT单位排行</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1085%20PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1085%20PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="PAT单位排行"><a href="#PAT单位排行" class="headerlink" title="PAT单位排行"></a><font size=6px>PAT单位排行</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 N（≤105），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息：</p><pre><code class="hljs">准考证号 得分 学校</code></pre><p>其中<code>准考证号</code>是由 6 个字符组成的字符串，其首字母表示考试的级别：<code>B</code>代表乙级，<code>A</code>代表甲级，<code>T</code>代表顶级；<code>得分</code>是 [0, 100] 区间内的整数；<code>学校</code>是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜：</p><pre><code class="hljs">排名 学校 加权总分 考生人数</code></pre><p>其中<code>排名</code>是该单位的排名（从 1 开始）；<code>学校</code>是全部按小写字母输出的单位码；<code>加权总分</code>定义为<code>乙级总分/1.5 + 甲级总分 + 顶级总分*1.5</code>的<strong>整数部分</strong>；<code>考生人数</code>是该属于单位的考生的总人数。</p><p>学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">10A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypu</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">51 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>实现思路：这里从一开始就摒弃了在输入的过程中进行学校控制，即循环对已存在学校代码进行匹配的算法，因为前面有题验证过，会导致超时，这里采用了另外的方法，即先将所有数据输入，然后依据学校代码排序，这样相同的学校必定相邻，直接循环验证即可，不同的学校存放在结果数组，相同的就将分数相加，最后得到结果数组，再进行快速排序，即可。最后一题完美依次通过，哈哈。</p><p>1.定义学校结构体，包含学校代码，分数，学生人数；</p><p>2.定义指定数量的结构体数组两个，一个存放输入数据，一个存放结果数据，都分别初始化；</p><p>3.逐个输入数据，过程中把输入分数直接进行加权，学生数统一置为1；</p><p>4.按照学校代码进行快速排序；</p><p>5.遍历数组，按照前后项是否相等决定是向结果数组中写入新学校还是增加旧学校分数，得到结果数组；</p><p>6.按照学校分数、考生人数、学校字典序进行快速排序；</p><p>7.输出。</p><h5 id="说说踩过的坑："><a href="#说说踩过的坑：" class="headerlink" title="说说踩过的坑："></a>说说踩过的坑：</h5><p>1、最后两个都是段错误，怎么样都找不出错误，段错误先找是否是数组越界，然后后来看别人知道<strong>把c++的cin和cout全部换成scanf和printf就可以</strong></p><p>2、两个字符串的比较，不能直接比较，因为字符串是地址，比较是比较地址，而这两个地址是不一样的，所以就算名字一样地址不一样就是不一样，得用strcmp，并且字符串不能赋值给字符串，得用strcpy。</p><p>3、计算的综合成绩得用小数保存，最后输出用int</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std; <span class="hljs-keyword">struct</span> Input&#123;char id[<span class="hljs-number">6</span>];double score;char school[<span class="hljs-number">6</span>];&#125;;<span class="hljs-keyword">struct</span> Output&#123;char id[<span class="hljs-number">6</span>];double score;<span class="hljs-type">int</span> num;<span class="hljs-type">int</span> xuhao;&#125;;<span class="hljs-comment">//把所有的学校名都改成小写 </span>void tolower(char *a)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<span class="hljs-keyword">if</span> (a[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;a[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)&#123;a[i]+=<span class="hljs-number">32</span>;&#125;&#125;&#125;<span class="hljs-comment">//计算分数，记得用double最后再相加 </span>double Calculate_score(char *id,double score)&#123;    <span class="hljs-keyword">if</span> (strlen(id)&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">if</span> (id[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;A&#x27;</span>)&#123;<span class="hljs-keyword">return</span> score;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;B&#x27;</span>)&#123;<span class="hljs-keyword">return</span> score/<span class="hljs-number">1.5</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> score*<span class="hljs-number">1.5</span>;&#125;&#125;&#125;<span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">struct</span> Output a,<span class="hljs-keyword">struct</span> Output b)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-type">int</span>(a.score)!=<span class="hljs-type">int</span>(b.score))&#123;<span class="hljs-keyword">return</span> a.score&gt;b.score;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.num!=b.num) &#123;<span class="hljs-keyword">return</span> a.num&lt;b.num;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> strcmp(a.id,b.id)&lt;<span class="hljs-number">0</span>;<span class="hljs-comment">//别用下面的那个，字符串比较无脑用strcp </span><span class="hljs-comment">//return a.id&lt;b.id;</span>&#125;&#125;<span class="hljs-type">bool</span> cmp1(<span class="hljs-keyword">struct</span> Input a,<span class="hljs-keyword">struct</span> Input b) &#123;<span class="hljs-keyword">return</span> strcmp(a.school,b.school)&lt;<span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n,i,k=<span class="hljs-number">0</span>;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">struct</span> Output output[n];<span class="hljs-keyword">struct</span> Input input[n];<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;output[i].num=<span class="hljs-number">0</span>;output[i].score=<span class="hljs-number">0</span>;&#125;i=<span class="hljs-number">0</span>;<span class="hljs-comment">//输入数据 </span>while(i&lt;n)&#123;scanf(<span class="hljs-string">&quot;%s%lf%s&quot;</span>,input[i].id,&amp;input[i].score,input[i].school);tolower(input[i].school);i++;&#125;sort(input,input+n,cmp1);<span class="hljs-comment">//为了测试数据而输出 </span><span class="hljs-comment">//for(i=0;i&lt;n;i++)&#123;</span><span class="hljs-comment">//printf(&quot;%s\n&quot;,input[i].school);</span><span class="hljs-comment">//&#125;</span><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;strcpy(output[i].id,input[i].school);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span>(strcmp(input[i].school,input[i<span class="hljs-number">-1</span>].school)!=<span class="hljs-number">0</span>)&#123;k++;strcpy(output[k].id,input[i].school);&#125;&#125;output[k].num++;output[k].score+=Calculate_score(input[i].id,input[i].score);&#125;k++;sort(output,output+k,cmp);<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;output[i].xuhao=i+<span class="hljs-number">1</span>;&#125;printf(<span class="hljs-string">&quot;%d\n&quot;</span>,k);<span class="hljs-comment">//输出环节 </span><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-type">int</span>(output[i].score)==<span class="hljs-type">int</span>(output[i<span class="hljs-number">-1</span>].score))&#123;output[i].xuhao=output[i<span class="hljs-number">-1</span>].xuhao;printf(<span class="hljs-string">&quot;%d &quot;</span>,output[i<span class="hljs-number">-1</span>].xuhao);&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%d &quot;</span>,output[i].xuhao);&#125;&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%d &quot;</span>,output[i].xuhao);&#125;printf(<span class="hljs-string">&quot;%s %d %d\n&quot;</span>,output[i].id,<span class="hljs-type">int</span>(output[i].score),output[i].num);<span class="hljs-comment">//cout &lt;&lt;output[i].id&lt;&lt;&quot; &quot;&lt;&lt;int(output[i].score)&lt;&lt;&quot; &quot;&lt;&lt;output[i].num&lt;&lt;endl;</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>参考地址:<a href="https://blog.csdn.net/bawangtu/article/details/81544845">https://blog.csdn.net/bawangtu/article/details/81544845</a></p>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1088 三人行</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1088%20%E4%B8%89%E4%BA%BA%E8%A1%8C/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1088%20%E4%B8%89%E4%BA%BA%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="三人行"><a href="#三人行" class="headerlink" title="三人行"></a><font size=6px>三人行</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”</p><p>本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 <code>Cong</code>；平等则输出 <code>Ping</code>；比你弱则输出 <code>Gai</code>。其间以 1 个空格分隔，行首尾不得有多余空格。</p><p>注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 <code>No Solution</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">48 3 7</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">48 Ping Cong Gai</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">48 11 6</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">No Solution</code></pre><h4 id="思路-题目简单好理解，有两个易错点讲一下，第一个是丙是甲和乙能力的绝对插值，丙应该是个float64类型的数字，不是int类型的。"><a href="#思路-题目简单好理解，有两个易错点讲一下，第一个是丙是甲和乙能力的绝对插值，丙应该是个float64类型的数字，不是int类型的。" class="headerlink" title="思路:题目简单好理解，有两个易错点讲一下，第一个是丙是甲和乙能力的绝对插值，丙应该是个float64类型的数字，不是int类型的。"></a>思路:题目简单好理解，有两个易错点讲一下，第一个是丙是甲和乙能力的绝对插值，丙应该是个float64类型的数字，不是int类型的。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> a,b,c,x,y,flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> z <span class="hljs-type">float64</span>    fmt.Scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">99</span>;i&gt;=<span class="hljs-number">10</span>;i--&#123;        x=i        y=(i/<span class="hljs-number">10</span>)+(i % <span class="hljs-number">10</span>)*<span class="hljs-number">10</span>        z = math.Abs(<span class="hljs-type">float64</span>(x-y)) / <span class="hljs-type">float64</span>(b)            <span class="hljs-keyword">if</span> <span class="hljs-type">float64</span>(c) * z==<span class="hljs-type">float64</span>(y)&#123;                fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,x)                compare(<span class="hljs-type">float64</span>(a),<span class="hljs-type">float64</span>(x))                compare(<span class="hljs-type">float64</span>(a),<span class="hljs-type">float64</span>(y))                compare(<span class="hljs-type">float64</span>(a),z)                flag=<span class="hljs-number">1</span>                <span class="hljs-keyword">break</span>            &#125;    &#125;    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;        fmt.Println(<span class="hljs-string">&quot;No Solution&quot;</span>)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compare</span><span class="hljs-params">(a,b <span class="hljs-type">float64</span>)</span></span>  &#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        fmt.Printf(<span class="hljs-string">&quot; Gai&quot;</span>)    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a==b&#123;        fmt.Printf(<span class="hljs-string">&quot; Ping&quot;</span>)    &#125;<span class="hljs-keyword">else</span>&#123;        fmt.Printf(<span class="hljs-string">&quot; Cong&quot;</span>)    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1087 有多少不同的值</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1087%20%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1087%20%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="有多少不同的值"><a href="#有多少不同的值" class="headerlink" title="有多少不同的值"></a><font size=6px>有多少不同的值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>1087 有多少不同的值 (20 分)</p><p>当自然数 <em>n</em> 依次取 1、2、3、……、<em>N</em> 时，算式 ⌊<em>n</em>&#x2F;2⌋+⌊<em>n</em>&#x2F;3⌋+⌊<em>n</em>&#x2F;5⌋ 有多少个不同的值？（注：⌊<em>x</em>⌋ 为取整函数，表示不超过 <em>x</em> 的最大自然数，即 <em>x</em> 的整数部分。）</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入给出一个正整数 <em>N</em>（2≤<em>N</em>≤104）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出题面中算式取到的不同值的个数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">2017</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">1480</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> hash [<span class="hljs-number">25000</span>]<span class="hljs-type">int</span>    fmt.Scan(&amp;a)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=a;i++&#123;        hash[i/<span class="hljs-number">2</span>+i/<span class="hljs-number">3</span>+i/<span class="hljs-number">5</span>]++    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">25000</span>;i++&#123;        <span class="hljs-keyword">if</span> hash[i]&gt;=<span class="hljs-number">1</span>&#123;            b++        &#125;    &#125;    fmt.Println(b)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1091 N-自守数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1091%20N-%E8%87%AA%E5%AE%88%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1091%20N-%E8%87%AA%E5%AE%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="N-自守数"><a href="#N-自守数" class="headerlink" title="N-自守数"></a><font size=6px>N-自守数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>如果某个数 <em>K</em> 的平方乘以 <em>N</em> 以后，结果的末尾几位数等于 <em>K</em>，那么就称这个数为“<em>N</em>-自守数”。例如 3×922&#x3D;25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。</p><p>本题就请你编写程序判断一个给定的数字是否关于某个 <em>N</em> 是 <em>N</em>-自守数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>M</em>（≤20），随后一行给出 <em>M</em> 个待检测的、不超过 1000 的正整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个需要检测的数字，如果它是 <em>N</em>-自守数就在一行中输出最小的 <em>N</em> 和 <em>N**K</em>2 的值，以一个空格隔开；否则输出 <code>No</code>。注意题目保证 <em>N</em>&lt;10。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">392 5 233</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">3 253921 25No</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把n从1到9遍历，如果哪个N的后几位等于自守数，就输出，简单题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> n,a,flag <span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++&#123;            len_a := getlen(a)            <span class="hljs-keyword">if</span> a*a*i % <span class="hljs-type">int</span>(math.Pow(<span class="hljs-number">10</span>,<span class="hljs-type">float64</span>(len_a)))==a&#123;                fmt.Printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,a*a*i)                flag = <span class="hljs-number">1</span>                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> flag ==<span class="hljs-number">1</span>&#123;            flag=<span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Println(<span class="hljs-string">&quot;No&quot;</span>)        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getlen</span><span class="hljs-params">(n <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">len</span>(strconv.Itoa(n))&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1079 延迟的回文数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1079%20%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1079%20%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="延迟的回文数"><a href="#延迟的回文数" class="headerlink" title="延迟的回文数"></a><font size=6px>延迟的回文数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 <em>k</em>+1 位的正整数 <em>N</em>，写成 <em>a**k</em>⋯<em>a</em>1<em>a</em>0 的形式，其中对所有 <em>i</em> 有 0≤<em>a**i</em>&lt;10 且 <em>a*<em>k</em>&gt;0。</em>N* 被称为一个<strong>回文数</strong>，当且仅当对所有 <em>i</em> 有 <em>a**i</em>&#x3D;<em>a**k</em>−<em>i</em>。零也被定义为一个回文数。</p><p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为<strong>延迟的回文数</strong>。（定义翻译自 <a href="https://en.wikipedia.org/wiki/Palindromic_number">https://en.wikipedia.org/wiki/Palindromic_number</a> ）</p><p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个不超过1000位的正整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对给定的整数，一行一行输出其变出回文数的过程。每行格式如下</p><pre><code class="hljs armasm">A + <span class="hljs-keyword">B</span> = C</code></pre><p>其中 <code>A</code> 是原始的数字，<code>B</code> 是 <code>A</code> 的逆转数，<code>C</code> 是它们的和。<code>A</code> 从输入的整数开始。重复操作直到 <code>C</code> 在 10 步以内变成回文数，这时在一行中输出 <code>C is a palindromic number.</code>；或者如果 10 步都没能得到回文数，最后就在一行中输出 <code>Not found in 10 iterations.</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">97152</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">97152 + 25179 = 122331122331 + 133221 = 255552255552 is a palindromic number.</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">196</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">196 + 691 = 887887 + 788 = 16751675 + 5761 = 74367436 + 6347 = 1378313783 + 38731 = 5251452514 + 41525 = 9403994039 + 93049 = 187088187088 + 880781 = 10678691067869 + 9687601 = 1075547010755470 + 07455701 = 18211171Not found in 10 iterations.</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>写三个函数，分别是数字倒置，判断是不是回文数（逆置数和原来数一不一样），两数相加，记得是string来接受值，最后一个结点是好多位树，超过int64.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> n,n1,n2 <span class="hljs-type">string</span>    fmt.Scan(&amp;n)    <span class="hljs-keyword">if</span> Palindrome(n)==<span class="hljs-literal">true</span>&#123;        fmt.Printf(<span class="hljs-string">&quot;%s is a palindromic number.\n&quot;</span>,n)        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++&#123;        n1=inverse(n)        n2=add(n,n1)        fmt.Printf(<span class="hljs-string">&quot;%s + %s = %s\n&quot;</span>,n,n1,n2)        <span class="hljs-keyword">if</span> Palindrome(n2)==<span class="hljs-literal">true</span>&#123;            flag=<span class="hljs-number">1</span>            fmt.Printf(<span class="hljs-string">&quot;%s is a palindromic number.\n&quot;</span>,n2)            <span class="hljs-keyword">break</span>        &#125;        n= n2    &#125;    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;        fmt.Println(<span class="hljs-string">&quot;Not found in 10 iterations.&quot;</span>)    &#125;&#125;<span class="hljs-comment">//数字倒置</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inverse</span><span class="hljs-params">(n <span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> s []<span class="hljs-type">rune</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(n)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        s=<span class="hljs-built_in">append</span>(s,<span class="hljs-type">rune</span>(n[i]))    &#125;    <span class="hljs-keyword">return</span>  <span class="hljs-type">string</span>(s)&#125;<span class="hljs-comment">//判断是不是回文数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Palindrome</span><span class="hljs-params">(n <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(n)/<span class="hljs-number">2</span>;i++&#123;        <span class="hljs-keyword">if</span> n[i]!=n[<span class="hljs-built_in">len</span>(n)-i<span class="hljs-number">-1</span>]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">//两数相加</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(n,n1 <span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span>  &#123;    <span class="hljs-keyword">var</span> jinwei <span class="hljs-type">uint8</span>    <span class="hljs-keyword">var</span> result <span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(n)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">if</span> <span class="hljs-type">int</span>(n1[i]<span class="hljs-number">-48</span>+n[i]<span class="hljs-number">-48</span>+jinwei)&lt;<span class="hljs-number">10</span>&#123;            result=strconv.Itoa(<span class="hljs-type">int</span>(n1[i]<span class="hljs-number">-48</span>+n[i]<span class="hljs-number">-48</span>+jinwei))+result            jinwei=<span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            result=strconv.Itoa(<span class="hljs-type">int</span>(n1[i]<span class="hljs-number">-48</span>+n[i]<span class="hljs-number">-48</span>+jinwei<span class="hljs-number">-10</span>))+result            jinwei=<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> jinwei==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>+<span class="hljs-type">string</span>(result)    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(result)    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1093 字符串A+B</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1093%E5%AD%97%E7%AC%A6%E4%B8%B2A+B/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1093%E5%AD%97%E7%AC%A6%E4%B8%B2A+B/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串A-B"><a href="#字符串A-B" class="headerlink" title="字符串A+B"></a><font size=6px>字符串A+B</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个字符串 <em>A</em> 和 <em>B</em>，本题要求你输出 <em>A</em>+<em>B</em>，即两个字符串的并集。要求先输出 <em>A</em>，再输出 <em>B</em>，但<strong>重复的字符必须被剔除</strong>。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在两行中分别给出 <em>A</em> 和 <em>B</em>，均为长度不超过 106的、由可见 ASCII 字符 (即码值为32~126)和空格组成的、由回车标识结束的非空字符串。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出题面要求的 <em>A</em> 和 <em>B</em> 的和。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">This is a sample testto show you_How it works</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">This ampletowyu_Hrk</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>这题不能用fmt.Scanf或者fmt.Scan来输入，因为这两个是用空格或者换行符间隔的，得用bufio来做输入，bufio输入的时候会把字符串最后一个‘\n’也输入，记得去掉即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;bufio&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> s1,s2,s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> mp=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint8</span>]<span class="hljs-type">int</span>,<span class="hljs-number">129</span>)    read:= bufio.NewReader(os.Stdin)    s1,_ = read.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)    s2,_ = read.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1)<span class="hljs-number">-1</span>;i++&#123;        mp[s1[i]]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s2)<span class="hljs-number">-1</span>;i++&#123;        mp[s2[i]]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1);i++&#123;        <span class="hljs-keyword">if</span> mp[s1[i]]==<span class="hljs-number">1</span>&#123;            s=s+<span class="hljs-type">string</span>(s1[i])            mp[s1[i]]=<span class="hljs-number">0</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s2);i++&#123;        <span class="hljs-keyword">if</span> mp[s2[i]]==<span class="hljs-number">1</span>&#123;            s=s+<span class="hljs-type">string</span>(s2[i])            mp[s2[i]]=<span class="hljs-number">0</span>        &#125;    &#125;    fmt.Println(s)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT题目合集</title>
    <link href="/2022/01/21/PAT%E4%B9%99/PAT%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
    <url>/2022/01/21/PAT%E4%B9%99/PAT%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<style>table th:first-of-type {    width: 30%;}table th:nth-of-type(2) {    width: 30%;}table th:nth-of-type(3) {    width: 10%;} table th:nth-of-type(4) {    width: 15%;table th:nth-of-type(5) {    width: 30%;}</style><div style="font-size:20px"><table><thead><tr><th align="center">题目</th><th align="center">收获</th><th align="center">语言</th><th align="center">分数</th><th>是否做完</th></tr></thead><tbody><tr><td align="center"><a href="http://www.hkctfsys.com/2021/03/02/PAT/1010%20%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/">1010 一元多项式求导</a></td><td align="center"></td><td align="center">go</td><td align="center">25</td><td>是</td></tr><tr><td align="center">1025 反转链表</td><td align="center">知道怎么反转链表</td><td align="center">c</td><td align="center">25</td><td>是</td></tr><tr><td align="center">1038 统计同成绩学生</td><td align="center"></td><td align="center">c</td><td align="center">20</td><td>是</td></tr><tr><td align="center">1049 数列的片段和</td><td align="center">知道double是不是精确的</td><td align="center">c</td><td align="center">25</td><td>是</td></tr><tr><td align="center">1062 最简分数</td><td align="center">学会gcd与gcm（最大公因数公约数），与swap。</td><td align="center">c</td><td align="center">20</td><td>是</td></tr><tr><td align="center">1060 爱丁顿数</td><td align="center"></td><td align="center">c</td><td align="center">25</td><td>是</td></tr><tr><td align="center">1078 字符串压缩与解压</td><td align="center">学会了用gets（）接收有空格的字符必</td><td align="center">c</td><td align="center">20</td><td>是</td></tr><tr><td align="center">1075 链表元素分类</td><td align="center">学会用vector，v[1].push_back(i),v[1].size()</td><td align="center">c&#x2F;c++</td><td align="center">25</td><td>是</td></tr><tr><td align="center">1085 PAT单位排行</td><td align="center">学会字符串比较和赋值（strcmp，strcpy），学会段错误的特殊原因</td><td align="center">c&#x2F;c++</td><td align="center">25</td><td>是</td></tr></tbody></table></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1038 统计同成绩学生</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1038%20%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1038%20%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="统计同成绩学生"><a href="#统计同成绩学生" class="headerlink" title="统计同成绩学生"></a><font size=6px>统计同成绩学生</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题要求读入 <em>N</em> 名学生的成绩，将获得某一给定分数的学生人数输出。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第 1 行给出不超过 105 的正整数 <em>N</em>，即学生总人数。随后一行给出 <em>N</em> 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 <em>K</em>（不超过 <em>N</em> 的正整数），随后是 <em>K</em> 个分数，中间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">1060 75 90 55 75 99 82 90 75 503 75 90 88</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">3 2 0</code></pre><h4 id="思路-无"><a href="#思路-无" class="headerlink" title="思路:无"></a>思路:无</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n,a;<span class="hljs-type">int</span> sco[<span class="hljs-number">101</span>],flag=<span class="hljs-number">0</span>;memset(sco,<span class="hljs-number">0</span>,sizeof(sco));scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);sco[a]++;&#125;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<span class="hljs-keyword">if</span> (flag==<span class="hljs-number">0</span>)&#123;printf(<span class="hljs-string">&quot;%d&quot;</span>,sco[a]);flag=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot; %d&quot;</span>,sco[a]);&#125;&#125;printf(<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1049 数列的片段和</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1049%20%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1049%20%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="数列的片段和"><a href="#数列的片段和" class="headerlink" title="数列的片段和"></a><font size=6px>数列的片段和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。</p><p>给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 &#x3D; 5.0。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个不超过 105 的正整数 <em>N</em>，表示数列中数的个数，第二行给出 <em>N</em> 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">40.1 0.2 0.3 0.4</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">5.00</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>与其说是个程序题，不如说是个数学题，找到规律，但是要考虑的一点是doube类型的精度在数字大了之后是不够的，比如4.182，在计算机里面是4.18200000000000000004121532，数字大了之后就不行了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n;long long sum;double a;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;scanf(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a);sum+=(long long)(a*<span class="hljs-number">1000</span>)*i*(n-i+<span class="hljs-number">1</span>);&#125; printf(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,sum/<span class="hljs-number">1000.0</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1044 火星数字</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1044%20%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1044%20%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="火星数字"><a href="#火星数字" class="headerlink" title="火星数字"></a><font size=6px>火星数字</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>火星人是以 13 进制计数的：</p><ul><li>地球人的 0 被火星人称为 tret。</li><li>地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。</li><li>火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。</li></ul><p>例如地球人的数字 <code>29</code> 翻译成火星文就是 <code>hel mar</code>；而火星文 <code>elo nov</code> 对应地球数字 <code>115</code>。为了方便交流，请你编写程序实现地球和火星数字之间的互译。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 <em>N</em>（&lt;100），随后 <em>N</em> 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对应输入的每一行，在一行中输出翻译后的另一种语言的数字。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">4295elo novtam</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">hel marmay11513</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>题目不难，我用switch-case做就显得冗长，但是好理解，用c[0]判断是数字还是字符，然后分别判断</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;bufio&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;os&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>    <span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,result <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    r:=bufio.NewReader(os.Stdin)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        c,_:=r.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)        <span class="hljs-comment">//如果是数字，就转换成字母</span>        <span class="hljs-keyword">if</span> c[<span class="hljs-number">0</span>] &gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c[<span class="hljs-number">0</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&#123;            <span class="hljs-comment">//把c最后换行符取消掉</span>            c=strings.Replace(c,<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">-1</span>)            num,_ :=strconv.Atoi(c)            <span class="hljs-comment">//如果可以用13整除</span>            <span class="hljs-keyword">if</span> num % <span class="hljs-number">13</span>==<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">switch</span> (num/<span class="hljs-number">13</span>) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                    fmt.Printf(<span class="hljs-string">&quot;tret\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                    fmt.Printf(<span class="hljs-string">&quot;tam\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                    fmt.Printf(<span class="hljs-string">&quot;hel\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                    fmt.Printf(<span class="hljs-string">&quot;maa\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                    fmt.Printf(<span class="hljs-string">&quot;huh\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                    fmt.Printf(<span class="hljs-string">&quot;tou\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:                    fmt.Printf(<span class="hljs-string">&quot;kes\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:                    fmt.Printf(<span class="hljs-string">&quot;hei\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:                    fmt.Printf(<span class="hljs-string">&quot;elo\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:                    fmt.Printf(<span class="hljs-string">&quot;syy\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                    fmt.Printf(<span class="hljs-string">&quot;lok\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:                    fmt.Printf(<span class="hljs-string">&quot;mer\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:                    fmt.Printf(<span class="hljs-string">&quot;jou\n&quot;</span>)                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span> num/<span class="hljs-number">13</span>!=<span class="hljs-number">0</span>&#123;                    <span class="hljs-keyword">switch</span> (num/<span class="hljs-number">13</span>) &#123;                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                        fmt.Printf(<span class="hljs-string">&quot;tam &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                        fmt.Printf(<span class="hljs-string">&quot;hel &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                        fmt.Printf(<span class="hljs-string">&quot;maa &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                        fmt.Printf(<span class="hljs-string">&quot;huh &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                        fmt.Printf(<span class="hljs-string">&quot;tou &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:                        fmt.Printf(<span class="hljs-string">&quot;kes &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:                        fmt.Printf(<span class="hljs-string">&quot;hei &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:                        fmt.Printf(<span class="hljs-string">&quot;elo &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:                        fmt.Printf(<span class="hljs-string">&quot;syy &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                        fmt.Printf(<span class="hljs-string">&quot;lok &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:                        fmt.Printf(<span class="hljs-string">&quot;mer &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:                        fmt.Printf(<span class="hljs-string">&quot;jou &quot;</span>)                    &#125;                &#125;                <span class="hljs-keyword">switch</span> (num % <span class="hljs-number">13</span>) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                    fmt.Printf(<span class="hljs-string">&quot;jan\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                    fmt.Printf(<span class="hljs-string">&quot;feb\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                    fmt.Printf(<span class="hljs-string">&quot;mar\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                    fmt.Printf(<span class="hljs-string">&quot;apr\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                    fmt.Printf(<span class="hljs-string">&quot;may\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:                    fmt.Printf(<span class="hljs-string">&quot;jun\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:                    fmt.Printf(<span class="hljs-string">&quot;jly\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:                    fmt.Printf(<span class="hljs-string">&quot;aug\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:                    fmt.Printf(<span class="hljs-string">&quot;sep\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                    fmt.Printf(<span class="hljs-string">&quot;oct\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:                    fmt.Printf(<span class="hljs-string">&quot;nov\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:                    fmt.Printf(<span class="hljs-string">&quot;dec\n&quot;</span>)                &#125;            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//是字符串怎么办</span>            c:=strings.Replace(c,<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">-1</span>)            c1:=strings.Split(c,<span class="hljs-string">&quot; &quot;</span>)            <span class="hljs-keyword">for</span> _,v:= <span class="hljs-keyword">range</span> c1&#123;                <span class="hljs-keyword">switch</span> (v) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;tam&quot;</span>:                    result+=<span class="hljs-number">1</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hel&quot;</span>:                    result+=<span class="hljs-number">2</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;maa&quot;</span>:                    result+=<span class="hljs-number">3</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;huh&quot;</span>:                    result+=<span class="hljs-number">4</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;tou&quot;</span>:                    result+=<span class="hljs-number">5</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;kes&quot;</span>:                    result+=<span class="hljs-number">6</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hei&quot;</span>:                    result+=<span class="hljs-number">7</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;elo&quot;</span>:                    result+=<span class="hljs-number">8</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;syy&quot;</span>:                    result+=<span class="hljs-number">9</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;lok&quot;</span>:                    result+=<span class="hljs-number">10</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mer&quot;</span>:                    result+=<span class="hljs-number">11</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jou&quot;</span>:                    result+=<span class="hljs-number">12</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;tret&quot;</span>:                    result+=<span class="hljs-number">0</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jan&quot;</span>:                    result+=<span class="hljs-number">1</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;feb&quot;</span>:                    result+=<span class="hljs-number">2</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mar&quot;</span>:                    result+=<span class="hljs-number">3</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;apr&quot;</span>:                    result+=<span class="hljs-number">4</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;may&quot;</span>:                    result+=<span class="hljs-number">5</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jun&quot;</span>:                    result+=<span class="hljs-number">6</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jly&quot;</span>:                    result+=<span class="hljs-number">7</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;aug&quot;</span>:                    result+=<span class="hljs-number">8</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sep&quot;</span>:                    result+=<span class="hljs-number">9</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;oct&quot;</span>:                    result+=<span class="hljs-number">10</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;nov&quot;</span>:                    result+=<span class="hljs-number">11</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;dec&quot;</span>:                    result+=<span class="hljs-number">12</span>                &#125;            &#125;            fmt.Println(result)            result=<span class="hljs-number">0</span>        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1048 数字加密</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1048%20%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1048%20%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="数字加密"><a href="#数字加密" class="headerlink" title="数字加密"></a><font size=6px>数字加密</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出加密后的结果。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">1234567 368782971</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">3695Q8118</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>这个题目没有讲明白，如果两个字串长度不一样长，要在短的那个字符前面前面补零，还有一个坑的地方就是他题目说的第一个数字就是字符串的最后一个数字，所以要逆置接受，然后长度不相等在后面补零，得出结果再逆置输出</p><pre><code class="hljs armasm"><span class="hljs-comment">//这段代码在输入样例里面只会执行一次，因为一次s1=&quot;0&quot;+s1会使s1长度增加使for语句实际执行次数少一半，和c语言不同</span><span class="hljs-symbol">for</span> i:<span class="hljs-number">=0</span><span class="hljs-comment">;i&lt;len(s2)-len(s1);i++&#123;</span>            fmt.Println(<span class="hljs-built_in">s1</span>)            <span class="hljs-built_in">s1</span>=<span class="hljs-string">&quot;0&quot;</span>+<span class="hljs-built_in">s1</span>        &#125;</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> s1,s2,s3 <span class="hljs-type">string</span>    list :=[<span class="hljs-number">13</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>&#125;    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>    fmt.Scan(&amp;s1,&amp;s2)    s1=reverse(s1)    s2=reverse(s2)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1)&lt;<span class="hljs-built_in">len</span>(s2)&#123;        a:=<span class="hljs-built_in">len</span>(s2)-<span class="hljs-built_in">len</span>(s1)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;a;i++&#123;            s1+=<span class="hljs-string">&quot;0&quot;</span>        &#125;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1)&gt;<span class="hljs-built_in">len</span>(s2)&#123;        a:=<span class="hljs-built_in">len</span>(s1)-<span class="hljs-built_in">len</span>(s2)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;a;i++&#123;            s2+=<span class="hljs-string">&quot;0&quot;</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1);i++&#123;        <span class="hljs-comment">//如果为个位</span>        <span class="hljs-keyword">if</span> i %<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&#123;            sum = (<span class="hljs-type">int</span>(s1[i]-<span class="hljs-string">&#x27;0&#x27;</span>)+<span class="hljs-type">int</span>(s2[i]-<span class="hljs-string">&#x27;0&#x27;</span>))%<span class="hljs-number">13</span>            s3+=list[sum]        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果为偶位</span>            sum = <span class="hljs-type">int</span>(s2[i]-<span class="hljs-string">&#x27;0&#x27;</span>)-<span class="hljs-type">int</span>(s1[i]-<span class="hljs-string">&#x27;0&#x27;</span>)            <span class="hljs-keyword">if</span> sum&lt;<span class="hljs-number">0</span>&#123;                sum+=<span class="hljs-number">10</span>            &#125;            s3+=strconv.Itoa(sum)        &#125;    &#125;    fmt.Println(reverse(s3))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span>&#123;    re:=[]<span class="hljs-type">rune</span>(s)    n:=<span class="hljs-built_in">len</span>(re)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++&#123;        temp:=re[i]        re[i]=re[n-i<span class="hljs-number">-1</span>]        re[n-i<span class="hljs-number">-1</span>]=temp    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(re)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1060 爱丁顿数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1060%20%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1060%20%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="爱丁顿数"><a href="#爱丁顿数" class="headerlink" title="爱丁顿数"></a><font size=6px>爱丁顿数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” <em>E</em> ，即满足有 <em>E</em> 天骑车超过 <em>E</em> 英里的最大整数 <em>E</em>。据说爱丁顿自己的 <em>E</em> 等于87。</p><p>现给定某人 <em>N</em> 天的骑车距离，请你算出对应的爱丁顿数 <em>E</em>（≤<em>N</em>）。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 <em>N</em> (≤105)，即连续骑车的天数；第二行给出 <em>N</em> 个非负整数，代表每天的骑车距离。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中给出 <em>N</em> 天的爱丁顿数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">106 7 6 9 3 10 8 2 7 8</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">6</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>题目好理解，讲讲思路，先从大到小sort，按题目的例子，用序号10比较最小的2，是序号大，然后用序号9比较第二小的3，这样比较直到数字比序号大，就输出，别忘了数字都是0 的特殊情况，测试点4就是这样的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;<span class="hljs-type">bool</span> cmp(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;<span class="hljs-keyword">return</span> a&gt;b;&#125;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n,count,flag=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> arr[<span class="hljs-number">100002</span>];scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;arr[i]);&#125;sort(arr,arr+n,cmp);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<span class="hljs-keyword">if</span>(arr[i<span class="hljs-number">-1</span>]&gt;i)&#123;printf(<span class="hljs-string">&quot;%d\n&quot;</span>,i);            flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;    <span class="hljs-keyword">if</span> (flag!=<span class="hljs-number">1</span>)&#123;        printf(<span class="hljs-string">&quot;0\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1050 螺旋矩阵</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1050%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1050%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20/</url>
    
    <content type="html"><![CDATA[<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a><font size=6px>螺旋矩阵</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题要求将给定的 <em>N</em> 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 <em>m</em> 行 <em>n</em> 列，满足条件：<em>m</em>×<em>n</em> 等于 <em>N</em>；<em>m</em>≥<em>n</em>；且 <em>m</em>−<em>n</em> 取所有可能值中的最小值。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第 1 行中给出一个正整数 <em>N</em>，第 2 行给出 <em>N</em> 个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出螺旋矩阵。每行 <em>n</em> 个数字，共 <em>m</em> 行。相邻数字以 1 个空格分隔，行末不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">1237 76 20 98 76 42 53 95 60 81 58 93</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">98 95 9342 37 8153 20 7658 60 76</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>最后一直有个最后的测试点是<strong>非零返回</strong>，最后查资料大神说最后一个测试点的数据是9773，真狠，最后结果是9773行1列，非零返回是因为flag数组开小了。</p><p><img src="/img/PAT1050.png"></p><p>level是外层循环，计算公式是m&#x2F;2+m%2，再加上四层内层循环，数字一定要是右-下-左-上的顺序。</p><p>学习了新东西：</p><pre><code class="hljs arcade"><span class="hljs-built_in">sort</span>.<span class="hljs-built_in">Sort</span>(<span class="hljs-built_in">sort</span>.<span class="hljs-built_in">Reverse</span>(<span class="hljs-built_in">sort</span>.IntSlice(num)))</code></pre><p>将一个数字切片逆序排序</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>    <span class="hljs-string">&quot;sort&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> nu, a,m,n,count,level <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> num []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> flag [<span class="hljs-number">10000</span>][<span class="hljs-number">200</span>]<span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nu)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nu; i++ &#123;        fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a)        num = <span class="hljs-built_in">append</span>(num, a)    &#125;    sort.Sort(sort.Reverse(sort.IntSlice(num)))    <span class="hljs-comment">//求m和n，确定长和宽,m是几行，n是几列</span>    <span class="hljs-keyword">for</span> i := <span class="hljs-type">int</span>(math.Sqrt(<span class="hljs-type">float64</span>(nu))); i &gt;=<span class="hljs-number">1</span>; i-- &#123;            <span class="hljs-keyword">if</span> nu % i == <span class="hljs-number">0</span> &#123;                n = i                m = nu / i                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-comment">//fmt.Println(m,n)</span>   level = m/<span class="hljs-number">2</span> +m % <span class="hljs-number">2</span>   <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;level;i++&#123;       <span class="hljs-comment">//第一行</span>       <span class="hljs-keyword">for</span> j:=i;j&lt;n-i&amp;&amp;count&lt;nu;j++&#123;           flag[i][j] = num[count]           count++       &#125;       <span class="hljs-comment">//最后一列</span>       <span class="hljs-keyword">for</span> j:=i+<span class="hljs-number">1</span>;j&lt;m-i<span class="hljs-number">-1</span>&amp;&amp;count&lt;nu;j++&#123;           flag[j][n<span class="hljs-number">-1</span>-i] = num[count]           count++       &#125;       <span class="hljs-comment">//最后一行</span>       <span class="hljs-keyword">for</span> j:=n-i<span class="hljs-number">-1</span>;j&gt;=i&amp;&amp;count&lt;nu;j--&#123;           flag[m-i<span class="hljs-number">-1</span>][j] = num[count]           count++       &#125;       <span class="hljs-comment">//第一列</span>       <span class="hljs-keyword">for</span> j:=m-i<span class="hljs-number">-2</span>;j&gt;i&amp;&amp;count&lt;nu;j--&#123;           flag[j][i] = num[count]           count++       &#125;   &#125;   <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;       <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;           fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,flag[i][j])           <span class="hljs-keyword">if</span> j!=n<span class="hljs-number">-1</span>&#123;               fmt.Printf(<span class="hljs-string">&quot; &quot;</span>)           &#125;<span class="hljs-keyword">else</span> &#123;               fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)           &#125;       &#125;   &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1062 最简分数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1062%20%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1062%20%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="最简分数"><a href="#最简分数" class="headerlink" title="最简分数"></a><font size=6px>最简分数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一个分数一般写成两个整数相除的形式：<em>N</em>&#x2F;<em>M</em>，其中 <em>M</em> 不为0。最简分数是指分子和分母没有公约数的分数表示形式。</p><p>现给定两个不相等的正分数 <em>N</em>1&#x2F;<em>M</em>1 和 <em>N</em>2&#x2F;<em>M</em>2，要求你按从小到大的顺序列出它们之间分母为 <em>K</em> 的最简分数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中按 <em>N</em>&#x2F;<em>M</em> 的格式给出两个正分数，随后是一个正整数分母 <em>K</em>，其间以空格分隔。题目保证给出的所有整数都不超过 1000。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中按 <em>N</em>&#x2F;<em>M</em> 的格式列出两个给定分数之间分母为 <em>K</em> 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">7/18 13/20 12</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">5/12 7/12</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="题目解释：开始我题目都读不懂，我解释一下，把7-x2F-18转换成4-66-x2F-12，把13-x2F-20转换成7-8-x2F-12，就是求4-66到7-8之间的整数之间有无与12最大公因数为1的数"><a href="#题目解释：开始我题目都读不懂，我解释一下，把7-x2F-18转换成4-66-x2F-12，把13-x2F-20转换成7-8-x2F-12，就是求4-66到7-8之间的整数之间有无与12最大公因数为1的数" class="headerlink" title="题目解释：开始我题目都读不懂，我解释一下，把7&#x2F;18转换成4.66&#x2F;12，把13&#x2F;20转换成7.8&#x2F;12，就是求4.66到7.8之间的整数之间有无与12最大公因数为1的数"></a>题目解释：开始我题目都读不懂，我解释一下，把7&#x2F;18转换成4.66&#x2F;12，把13&#x2F;20转换成7.8&#x2F;12，就是求4.66到7.8之间的整数之间有无与12最大公因数为1的数</h5><p>把先求出18，20，12三个数的最大公约数，把两个数转换成相同底，就是70&#x2F;180，117&#x2F;180，就是求70到117之间有无能被15（180&#x2F;12）整除然后整除的数与12最大公因数为1.</p><p><strong>注意区间为（70，117），边界取不到</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>using namespace <span class="hljs-built_in">std</span>;<span class="hljs-comment">//求最大公因数 </span><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);&#125; <span class="hljs-comment">//最大公约数 </span><span class="hljs-type">int</span> <span class="hljs-title function_">gcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<span class="hljs-type">int</span> c=gcd(a,b);<span class="hljs-keyword">return</span> a*b/c; &#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-type">int</span> a,b,c,e,d,j=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> num[<span class="hljs-number">1000</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d/%d%d/%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e);<span class="hljs-type">int</span> t=gcm(b,d);<span class="hljs-type">int</span> t1=gcm(t,e);<span class="hljs-type">int</span> g=t1/e;<span class="hljs-type">int</span> first=t1/b*a;<span class="hljs-type">int</span> last = t1/d*c;<span class="hljs-keyword">if</span> (first&gt;last)&#123;swap(first,last);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=first+<span class="hljs-number">1</span>;i&lt;last;i++)&#123;<span class="hljs-keyword">if</span> (i%g==<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>(gcd(i/g,e)==<span class="hljs-number">1</span>)&#123;num[j++]=i/g;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;j;i++)&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d/%d&quot;</span>,num[i],e);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d/%d&quot;</span>,num[i],e);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1067 试密码</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1067%20%E8%AF%95%E5%AF%86%E7%A0%81/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1067%20%E8%AF%95%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="试密码"><a href="#试密码" class="headerlink" title="试密码"></a><font size=6px>试密码</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 <code>Welcome in</code>，并结束程序；如果是错误的，则在一行中按格式输出 <code>Wrong password: 用户输入的错误密码</code>；当错误尝试达到 N 次时，再输出一行 <code>Account locked</code>，并结束程序。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">Correct%pw 3correct%pwCorrect@PWwhatisthepassword!Correct%pw#</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">Wrong password: correct%pwWrong password: Correct@PWWrong password: whatisthepassword!Account locked</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">cool@gplt 3coolman@gpltcoollady@gpltcool@gplttry again#</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">Wrong password: coolman@gpltWrong password: coollady@gpltWelcome in</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>有个地方需要注意一下，输入的密码有可能包含空格，所以要用bufio来输入</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;bufio&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;os&quot;</span>    <span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> s,password <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> n,flag <span class="hljs-type">int</span>    fmt.Scan(&amp;password,&amp;n)    r:=bufio.NewReader(os.Stdin)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        s,_=r.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)        s=strings.Replace(s,<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">-1</span>)        <span class="hljs-keyword">if</span> s==<span class="hljs-string">&quot;#&quot;</span>&#123;            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">if</span> s==password&#123;            fmt.Println(<span class="hljs-string">&quot;Welcome in&quot;</span>)            flag=<span class="hljs-number">1</span>            <span class="hljs-keyword">break</span>        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;Wrong password: %s\n&quot;</span>,s)        &#125;    &#125;    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;        fmt.Println(<span class="hljs-string">&quot;Account locked&quot;</span>)    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1069 微博转发抽奖</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1069%20%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1069%20%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96/</url>
    
    <content type="html"><![CDATA[<h3 id="微博转发抽奖"><a href="#微博转发抽奖" class="headerlink" title="微博转发抽奖"></a><font size=6px>微博转发抽奖</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。</p><p>注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 <code>Keep going...</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">9 3 2Imgonnawin!PickMePickMeMeMeeeLookHereImgonnawin!TryAgainAgainTryAgainAgainImgonnawin!TryAgainAgain</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">PickMeImgonnawin!TryAgainAgain</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">2 3 5Imgonnawin!PickMe</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">Keep going...</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先输出第一个数，开始计数，每隔n个输出人名，并用map判断有没有之前就拿奖。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> m,n,s,interval <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> name <span class="hljs-type">string</span>    mp:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>,<span class="hljs-number">1001</span>)    fmt.Scan(&amp;m,&amp;n,&amp;s)    <span class="hljs-keyword">if</span> s&gt;m&#123;        fmt.Println(<span class="hljs-string">&quot;Keep going...&quot;</span>)        <span class="hljs-keyword">return</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;            <span class="hljs-comment">//先输出第一个</span>            <span class="hljs-keyword">if</span> i==s&#123;                fmt.Scan(&amp;name)                fmt.Println(name)                mp[name]=<span class="hljs-number">1</span>                <span class="hljs-comment">//输出一个个之后开始计数</span>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i&gt;s&#123;                fmt.Scan(&amp;name)                interval++                <span class="hljs-keyword">if</span> interval ==n&#123;                    <span class="hljs-keyword">if</span> mp[name]==<span class="hljs-number">1</span>&#123;                        interval--                    &#125;<span class="hljs-keyword">else</span>&#123;                        fmt.Println(name)                        mp[name]=<span class="hljs-number">1</span>                        interval=<span class="hljs-number">0</span>                    &#125;                &#125;            &#125;<span class="hljs-keyword">else</span> &#123;                fmt.Scan(&amp;name)            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1065 单身狗</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1065%20%E5%8D%95%E8%BA%AB%E7%8B%97/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1065%20%E5%8D%95%E8%BA%AB%E7%8B%97/</url>
    
    <content type="html"><![CDATA[<h3 id="单身狗"><a href="#单身狗" class="headerlink" title="单身狗"></a><font size=6px>单身狗</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻&#x2F;伴侣的对数；随后 N 行，每行给出一对夫妻&#x2F;伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">510000 23333 44444 55555 88888</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-comment">//最后两个测试点会超时</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;sort&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> s1,s2 <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> id []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> flag [<span class="hljs-number">10001</span>]<span class="hljs-type">int</span>    mp:= <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>,<span class="hljs-number">50001</span>)    fmt.Scan(&amp;n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scan(&amp;s1,&amp;s2)        <span class="hljs-keyword">if</span> s1&gt;s2&#123;            mp[s2]=s1        &#125;<span class="hljs-keyword">else</span> &#123;            mp[s1]=s2        &#125;    &#125;    fmt.Scan(&amp;n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scan(&amp;s1)        id = <span class="hljs-built_in">append</span>(id,s1)    &#125;    sort.Strings(id)    result:=n    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> flag[i]==<span class="hljs-number">0</span>&amp;&amp;mp[id[i]]!=<span class="hljs-string">&quot;0&quot;</span>&#123;            <span class="hljs-keyword">for</span> k:=i+<span class="hljs-number">1</span>;k&lt;n;k++&#123;                <span class="hljs-keyword">if</span> mp[id[i]]==id[k]&#123;                    flag[i]=<span class="hljs-number">1</span>                    flag[k]=<span class="hljs-number">1</span>                    result-=<span class="hljs-number">2</span>                    <span class="hljs-keyword">break</span>                &#125;            &#125;        &#125;    &#125;    fmt.Println(result)    first:=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> flag[i]==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> first==<span class="hljs-number">0</span>&#123;                fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,id[i])                first=<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                fmt.Printf(<span class="hljs-string">&quot; %s&quot;</span>,id[i])            &#125;        &#125;    &#125;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1006 换个格式输出整数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1006%20%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1006%20%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1006-换个格式输出整数"><a href="#1006-换个格式输出整数" class="headerlink" title="1006 换个格式输出整数"></a><font size=6px><strong>1006 换个格式输出整数</strong></font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>让我们用字母 <code>B</code> 来表示“百”、字母 <code>S</code> 表示“十”，用 <code>12...n</code> 来表示不为零的个位数字 <code>n</code>（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 <code>234</code> 应该被输出为 <code>BBSSS1234</code>，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，给出正整数 <em>n</em>（&lt;1000）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，用规定的格式输出 <em>n</em>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">234</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">BBSSS1234</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">23</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">SS123</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把每个数的百位十位个位求出来就可以</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,a,b,c <span class="hljs-type">int</span><span class="hljs-comment">//a代表百位，b代表十位，c代表各位</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    a=n/<span class="hljs-number">100</span>    b=n/<span class="hljs-number">10</span> %<span class="hljs-number">10</span>    c=n%<span class="hljs-number">10</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;a;i++&#123;        fmt.Printf(<span class="hljs-string">&quot;B&quot;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;b;i++&#123;        fmt.Printf(<span class="hljs-string">&quot;S&quot;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;c;i++&#123;        fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,i+<span class="hljs-number">1</span>)    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1007 素数对猜想</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1007%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1007%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="1007-素数对猜想"><a href="#1007-素数对猜想" class="headerlink" title="1007 素数对猜想"></a><font size=6px><strong>1007 素数对猜想</strong></font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>让我们定义<em>d**n</em>为：<em>d**n</em>&#x3D;<em>p**n</em>+1−<em>p**n</em>，其中<em>p**i</em>是第<em>i</em>个素数。显然有<em>d</em>1&#x3D;1，且对于<em>n</em>&gt;1有<em>d**n</em>是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p><p>现给定任意正整数<code>N</code>(&lt;105)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出正整数<code>N</code>。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code class="hljs in">20</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code class="hljs out">4</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先把素数求出来放一个切片里面，然后让每个相邻的切片相减看看是不是等于2</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,sum,num <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> p []<span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">3</span>&#123;        fmt.Println(<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n;i++&#123;        <span class="hljs-keyword">if</span> prime(i)==<span class="hljs-literal">true</span>&#123;            p=<span class="hljs-built_in">append</span>(p,i)            num++        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;num<span class="hljs-number">-1</span>;i++&#123;        <span class="hljs-keyword">if</span> p[i+<span class="hljs-number">1</span>]-p[i]==<span class="hljs-number">2</span>&#123;            sum++        &#125;    &#125;    fmt.Println(sum)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prime</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-type">int</span>(math.Sqrt(<span class="hljs-type">float64</span>(n)));i++&#123;        <span class="hljs-keyword">if</span> n%i==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1008 数组元素循环右移问题</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1008%20%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1008%20%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="数组元素循环右移问题"><a href="#数组元素循环右移问题" class="headerlink" title="数组元素循环右移问题"></a><font size=6px>数组元素循环右移问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一个数组<em>A</em>中存有<em>N</em>（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移<em>M</em>（≥0）个位置，即将<em>A</em>中的数据由（<em>A</em>0<em>A</em>1⋯<em>A**N</em>−1）变换为（<em>A**N</em>−<em>M</em>⋯<em>A**N</em>−1<em>A</em>0<em>A</em>1⋯<em>A**N</em>−<em>M</em>−1）（最后<em>M</em>个数循环移至最前面的<em>M</em>个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每个输入包含一个测试用例，第1行输入<em>N</em>（1≤<em>N</em>≤100）和<em>M</em>（≥0）；第2行输入<em>N</em>个整数，之间用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出循环右移<em>M</em>位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code class="hljs in">6 21 2 3 4 5 6</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code class="hljs out">5 6 1 2 3 4</code></pre><h4 id="思路-题目简单，可是用golang始终有个测试点过不了-换c"><a href="#思路-题目简单，可是用golang始终有个测试点过不了-换c" class="headerlink" title="思路:题目简单，可是用golang始终有个测试点过不了,换c"></a>思路:题目简单，可是用golang始终有个测试点过不了,换c</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-type">int</span> a[<span class="hljs-number">201</span>],i,j,n,m;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">if</span>(m&gt;n) m=m%n;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);a[i+n]=a[i];&#125;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;a[i]=a[<span class="hljs-number">2</span>*n-m+i];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);&#125;<span class="hljs-keyword">for</span>(i=m;i&lt;n;i++)&#123;a[i]=a[n-m+i];<span class="hljs-keyword">if</span>(i!=n<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[i]);&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1009 说反话</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1009%20%E8%AF%B4%E5%8F%8D%E8%AF%9D/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1009%20%E8%AF%B4%E5%8F%8D%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="说反话"><a href="#说反话" class="headerlink" title="说反话"></a><font size=6px>说反话</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，输出倒序后的句子。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">Hello World Here I Come</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">Come I Here World Hello</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>go语言思路就是先接受一个个单词放到shting切片里面，然后从后往前print</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> s []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> s1 <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>    <span class="hljs-keyword">var</span> k <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> &#123;        _,err=fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s1)        <span class="hljs-keyword">if</span> err==<span class="hljs-literal">nil</span>&#123;            s=<span class="hljs-built_in">append</span>(s,s1)            k++        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,s[k<span class="hljs-number">-1</span>])    <span class="hljs-keyword">for</span> i:=k<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        fmt.Printf(<span class="hljs-string">&quot; %s&quot;</span>,s[i])    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1010 一元多项式求导</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1010%20%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1010%20%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="一元多项式求导"><a href="#一元多项式求导" class="headerlink" title="一元多项式求导"></a><font size=6px>一元多项式求导</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设计函数求一元多项式的导数。（注：<em>x**n</em>（<em>n</em>为整数）的一阶导数为<em>n<strong>x</strong>n</em>−1。）</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 <code>0 0</code>。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code class="hljs in">3 4 -5 2 6 1 -2 0</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code class="hljs out">12 3 -10 1 6 0</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>感觉题目没有说的很清楚，就是最后一个是阶乘是0的话就结束，然后有测试点不是以阶乘为0结束</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-comment">//golang版</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">int</span>        fmt.Scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)        <span class="hljs-keyword">if</span> b==<span class="hljs-number">0</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;0 0&quot;</span>)            <span class="hljs-keyword">return</span>        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;%d %d&quot;</span>,a*b,b<span class="hljs-number">-1</span>)        &#125;        <span class="hljs-keyword">for</span>&#123;            _,err:=fmt.Scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)            <span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;                <span class="hljs-keyword">break</span>            &#125;            <span class="hljs-keyword">if</span> b==<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">break</span>            &#125;<span class="hljs-keyword">else</span>&#123;                fmt.Printf(<span class="hljs-string">&quot; %d %d&quot;</span>,a*b,b<span class="hljs-number">-1</span>)            &#125;        &#125;&#125;</code></pre><pre><code class="hljs c"><span class="hljs-comment">//c语言版</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> a,b;         <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);        <span class="hljs-keyword">if</span> (b==<span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 0&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,a*b,b<span class="hljs-number">-1</span>);        &#125;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)!=EOF)&#123;            <span class="hljs-keyword">if</span> (b==<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d %d&quot;</span>,a*b,b<span class="hljs-number">-1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1011 A+B 和 C</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1011%20A+B%E5%92%8CC/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1011%20A+B%E5%92%8CC/</url>
    
    <content type="html"><![CDATA[<h3 id="A-B-和-C"><a href="#A-B-和-C" class="headerlink" title="A+B 和 C"></a><font size=6px>A+B 和 C</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定区间 [−231,231] 内的 3 个整数 <em>A</em>、<em>B</em> 和 <em>C</em>，请判断 <em>A</em>+<em>B</em> 是否大于 <em>C</em>。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第 1 行给出正整数 <em>T</em> (≤10)，是测试用例的个数。随后给出 <em>T</em> 组测试用例，每组占一行，顺序给出 <em>A</em>、<em>B</em> 和 <em>C</em>。整数间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出 <code>Case #X: true</code> 如果 <em>A</em>+<em>B</em>&gt;<em>C</em>，否则输出 <code>Case #X: false</code>，其中 <code>X</code> 是测试用例的编号（从 1 开始）。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">41 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">Case #1: falseCase #2: trueCase #3: trueCase #4: false</code></pre><h4 id="思路-无"><a href="#思路-无" class="headerlink" title="思路:无"></a>思路:无</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,i <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> a,b,c <span class="hljs-type">int64</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">for</span> i&lt;n&#123;        fmt.Scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c)        fmt.Printf(<span class="hljs-string">&quot;Case #%d: &quot;</span>,i+<span class="hljs-number">1</span>)        <span class="hljs-comment">//fmt.Println(&quot;%d  %d&quot;,a+b,c)</span>        <span class="hljs-keyword">if</span> a+b&gt;c&#123;            fmt.Printf(<span class="hljs-string">&quot;true&quot;</span>)        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;false&quot;</span>)        &#125;        fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)        i++    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1015 德才论</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1015%20%E5%BE%B7%E6%89%8D%E8%AE%BA/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1015%20%E5%BE%B7%E6%89%8D%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="德才论"><a href="#德才论" class="headerlink" title="德才论"></a><font size=6px>德才论</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p><p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出 3 个正整数，分别为：<em>N</em>（≤105），即考生总数；<em>L</em>（≥60），为录取最低分数线，即德分和才分均不低于 <em>L</em> 的考生才有资格被考虑录取；<em>H</em>（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 <em>H</em>，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 <em>L</em> 的考生也按总分排序，但排在第三类考生之后。</p><p>随后 <em>N</em> 行，每行给出一位考生的信息，包括：<code>准考证号 德分 才分</code>，其中<code>准考证号</code>为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出第一行首先给出达到最低分数线的考生人数 <em>M</em>，随后 <em>M</em> 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">14 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">1210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跟着题目思路，分好四类，并把数据存入结构体，排序条件要注意一下，题目没有给全，应该是在同一类总分相同，再按德分降序，在按编号升序。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;<span class="hljs-keyword">struct</span> Info&#123;<span class="hljs-type">int</span> id;<span class="hljs-type">int</span> de ;<span class="hljs-type">int</span> cai ;<span class="hljs-type">int</span> total ;&#125;;<span class="hljs-type">bool</span> cmp(Info a,Info b)&#123;<span class="hljs-keyword">if</span> (a.total!=b.total)&#123;<span class="hljs-keyword">return</span> a.total&gt;b.total;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.de!=b.de)&#123;<span class="hljs-keyword">return</span> a.de&gt;b.de;&#125; <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> a.id&lt;b.id;&#125;&#125; <span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> num,a,b,c,d,m,n;scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;num,&amp;m,&amp;n);<span class="hljs-keyword">struct</span> Info info[num];<span class="hljs-keyword">struct</span> Info first[num];<span class="hljs-keyword">struct</span> Info second[num];<span class="hljs-keyword">struct</span> Info third[num];<span class="hljs-keyword">struct</span> Info forth[num];<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;d=<span class="hljs-number">0</span>;while(num--)&#123;scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;info[i].id,&amp;info[i].de,&amp;info[i].cai);info[i].total=info[i].cai+info[i].de;<span class="hljs-keyword">if</span> (info[i].cai&gt;=n&amp;&amp;info[i].de&gt;=n)&#123;first[a++]=info[i];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(info[i].de&gt;=n&amp;&amp;info[i].cai&gt;=m)&#123;second[b++]=info[i];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(info[i].de&gt;=m&amp;&amp;info[i].cai&gt;=m&amp;&amp;info[i].de&gt;=info[i].cai)&#123;third[c++]=info[i];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(info[i].de&gt;=m&amp;&amp;info[i].cai&gt;=m)&#123;forth[d++]=info[i];&#125;i++;&#125;<span class="hljs-comment">//进行排序</span>sort(first,first+a,cmp);sort(second,second+b,cmp);sort(third,third+c,cmp);sort(forth,forth+d,cmp);printf(<span class="hljs-string">&quot;%d\n&quot;</span>,a+b+c+d);i=<span class="hljs-number">0</span>;while(a--)&#123;printf(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,first[i].id,first[i].de,first[i].cai);i++;&#125;i=<span class="hljs-number">0</span>;while(b--)&#123;printf(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,second[i].id,second[i].de,second[i].cai);i++;&#125;i=<span class="hljs-number">0</span>;while(c--)&#123;printf(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,third[i].id,third[i].de,third[i].cai);i++;&#125;i=<span class="hljs-number">0</span>;while(d--)&#123;printf(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,forth[i].id,forth[i].de,forth[i].cai);i++;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1025 反转链表</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1025%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1025%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><font size=6px>反转链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个常数 <em>K</em> 以及一个单链表 <em>L</em>，请编写程序将 <em>L</em> 中每 <em>K</em> 个结点反转。例如：给定 <em>L</em> 为 1→2→3→4→5→6，<em>K</em> 为 3，则输出应该为 3→2→1→6→5→4；如果 <em>K</em> 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 <em>K</em> 个元素不反转。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em> (≤<em>N</em>)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span></code></pre><p>其中 <code>Address</code> 是结点地址，<code>Data</code> 是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">00100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">00000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用l接收初始数据，用l1接收标好序号的数据，用l2去接收倒序后的数据，用空间换时间，代码很烂，但是能过。</p><p>坑点：最后一个测试点有部分数据是无用的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;using namespace std;<span class="hljs-keyword">struct</span> list&#123;<span class="hljs-type">int</span> add;<span class="hljs-type">int</span> data;<span class="hljs-type">int</span> next;&#125;l[<span class="hljs-number">100002</span>],l1[<span class="hljs-number">100002</span>],l2[<span class="hljs-number">100002</span>];<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> first,n,k,a,flag,num;scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;first,&amp;n,&amp;k);<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;while(m&lt;n)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l[a].data,&amp;l[a].next);l[a].add=a;m++;&#125;<span class="hljs-type">int</span> linshi=first;m=<span class="hljs-number">0</span>;<span class="hljs-comment">//使他有序化 </span>while(l[linshi].next!=<span class="hljs-number">-1</span>)&#123;l1[m]=l[linshi];m++;linshi=l[linshi].next;num++;&#125;n=num+<span class="hljs-number">1</span>;l1[m] = l[linshi];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n/k;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*k;j&lt;i*k+k;j++)&#123;<span class="hljs-type">int</span> y=i*k+k-(j-i*k)<span class="hljs-number">-1</span>;l2[y]=l1[j];&#125;  &#125; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-(n%k);i++)&#123;<span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>)&#123;printf(<span class="hljs-string">&quot;%05d %d &quot;</span>,l2[i].add,l2[i].data);&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%05d\n%05d %d &quot;</span>,l2[i].add,l2[i].add,l2[i].data);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-(n%k);i&lt;n;i++)&#123;printf(<span class="hljs-string">&quot;%05d\n%05d %d &quot;</span>,l1[i].add,l1[i].add,l1[i].data);&#125;printf(<span class="hljs-string">&quot;-1\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1013 数素数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1013%20%E6%95%B0%E7%B4%A0%E6%95%B0%20/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1013%20%E6%95%B0%E7%B4%A0%E6%95%B0%20/</url>
    
    <content type="html"><![CDATA[<h3 id="数素数"><a href="#数素数" class="headerlink" title="数素数"></a><font size=6px>数素数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>令 <em>P**i</em> 表示第 <em>i</em> 个素数。现任给两个正整数 <em>M</em>≤<em>N</em>≤104，请输出 <em>P**M</em> 到 <em>P**N</em> 的所有素数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出 <em>M</em> 和 <em>N</em>，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出从 <em>P**M</em> 到 <em>P**N</em> 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">5 27</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">11 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103</code></pre><h4 id="思路-先预处理求出前10000个素数，然后再输出想要的素数"><a href="#思路-先预处理求出前10000个素数，然后再输出想要的素数" class="headerlink" title="思路:先预处理求出前10000个素数，然后再输出想要的素数"></a>思路:先预处理求出前10000个素数，然后再输出想要的素数</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,i,a,b,k <span class="hljs-type">int</span>    k=<span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> primenumber []<span class="hljs-type">int</span>    i=<span class="hljs-number">2</span>    <span class="hljs-comment">//求前10000个素数</span>    <span class="hljs-keyword">for</span> n&lt;<span class="hljs-number">10000</span>&#123;        <span class="hljs-keyword">if</span> prime(i)==<span class="hljs-literal">true</span>&#123;            primenumber=<span class="hljs-built_in">append</span>(primenumber,i)            n++        &#125;        i++    &#125;    fmt.Scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)    <span class="hljs-keyword">for</span> i=a;i&lt;=b;i++&#123;        k++        <span class="hljs-keyword">if</span> i==b&#123;            fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,primenumber[i<span class="hljs-number">-1</span>])        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//为了满足十个数字换行</span>            <span class="hljs-keyword">if</span> k==<span class="hljs-number">10</span>&#123;                fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>,primenumber[i<span class="hljs-number">-1</span>])                k=<span class="hljs-number">0</span>            &#125;<span class="hljs-keyword">else</span>&#123;                fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>,primenumber[i<span class="hljs-number">-1</span>])            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">//判断素数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prime</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span>  <span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-type">int</span>(math.Sqrt(<span class="hljs-type">float64</span>(n)));i++&#123;        <span class="hljs-keyword">if</span> n% i==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1017 A除以B</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1017%20A%E9%99%A4%E4%BB%A5B/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1017%20A%E9%99%A4%E4%BB%A5B/</url>
    
    <content type="html"><![CDATA[<h3 id="A除以B"><a href="#A除以B" class="headerlink" title="A除以B"></a><font size=6px>A除以B</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题要求计算 <em>A</em>&#x2F;<em>B</em>，其中 <em>A</em> 是不超过 1000 位的正整数，<em>B</em> 是 1 位正整数。你需要输出商数 <em>Q</em> 和余数 <em>R</em>，使得 <em>A</em>&#x3D;<em>B</em>×<em>Q</em>+<em>R</em> 成立。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中依次给出 <em>A</em> 和 <em>B</em>，中间以 1 空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中依次输出 <em>Q</em> 和 <em>R</em>，中间以 1 空格分隔。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">123456789050987654321 7</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">17636684150141093474 3</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> s,q <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> num,sum <span class="hljs-type">int</span>    fmt.Scan(&amp;s,&amp;num)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        sum=sum*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s)&gt;<span class="hljs-number">1</span>&#123;            <span class="hljs-keyword">if</span> i!=<span class="hljs-number">0</span>&#123;                q=q+strconv.Itoa(sum/num)                sum %= num            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            q=q+strconv.Itoa(sum/num)            sum %= num        &#125;    &#125;    fmt.Printf(<span class="hljs-string">&quot;%s %d\n&quot;</span>,q,sum)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1033 旧键盘打字</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1033%20%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1033%20%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="旧键盘打字"><a href="#旧键盘打字" class="headerlink" title="旧键盘打字"></a><font size=6px>旧键盘打字</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 105 个字符的串。可用的字符包括字母 [<code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>]、数字 <code>0</code>-<code>9</code>、以及下划线 <code>_</code>（代表空格）、<code>,</code>、<code>.</code>、<code>-</code>、<code>+</code>（代表上档键）。题目保证第 2 行输入的文字串非空。</p><p>注意：如果上档键坏掉了，那么大写的英文字母无法被打出。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">7+IE.7_This_is_a_test.</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">_hs_s_a_tst</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h6 id="题读错了，我以为、-、-、-、-（代表上档键）代表上档键，其实只有加号才代表上挡键，s1有可能是空行。"><a href="#题读错了，我以为、-、-、-、-（代表上档键）代表上档键，其实只有加号才代表上挡键，s1有可能是空行。" class="headerlink" title="题读错了，我以为、,、.、-、+（代表上档键）代表上档键，其实只有加号才代表上挡键，s1有可能是空行。"></a>题读错了，我以为、<code>,</code>、<code>.</code>、<code>-</code>、<code>+</code>（代表上档键）代表上档键，其实只有加号才代表上挡键，s1有可能是空行。</h6><h6 id="思路：只要这个字母出现过，就把acs【i】置1，最后判断s2中的字母的asc值是否为1，是0就输出。"><a href="#思路：只要这个字母出现过，就把acs【i】置1，最后判断s2中的字母的asc值是否为1，是0就输出。" class="headerlink" title="思路：只要这个字母出现过，就把acs【i】置1，最后判断s2中的字母的asc值是否为1，是0就输出。"></a>思路：只要这个字母出现过，就把acs【i】置1，最后判断s2中的字母的asc值是否为1，是0就输出。</h6><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> asc [<span class="hljs-number">128</span>]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> s1,s2,s3 <span class="hljs-type">string</span>    fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s1)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1);i++&#123;        <span class="hljs-keyword">if</span> s1[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;s1[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>&#123;            asc[s1[i]+<span class="hljs-number">32</span>]=<span class="hljs-number">1</span>        &#125;        asc[s1[i]]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">if</span> asc[<span class="hljs-string">&#x27;+&#x27;</span>]==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-string">&#x27;A&#x27;</span>;i&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>;i++&#123;            asc[i]=<span class="hljs-number">1</span>        &#125;    &#125;    fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s2)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s2);i++&#123;        <span class="hljs-keyword">if</span> asc[s2[i]]==<span class="hljs-number">0</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>,s2[i])        &#125;    &#125;    fmt.Print(s3)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1030 完美数列</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1030%20%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1030%20%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="完美数列"><a href="#完美数列" class="headerlink" title="完美数列"></a><font size=6px>完美数列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个正整数数列，和正整数 <em>p</em>，设这个数列中的最大值是 <em>M</em>，最小值是 <em>m</em>，如果 <em>M</em>≤<em>m**p</em>，则称这个数列是完美数列。</p><p>现在给定参数 <em>p</em> 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数 <em>N</em> 和 <em>p</em>，其中 <em>N</em>（≤105）是输入的正整数的个数，<em>p</em>（≤109）是给定的参数。第二行给出 <em>N</em> 个正整数，每个数不超过 109。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">10 82 3 20 4 5 1 6 7 8 9</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">8</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从第一个开始找，找到最大可以符合完美数列的数，下标为i，然后从第二个开始找，直接从i+1个下标的数开始找是否还有符合完美数列的数存在，如果有就把值赋给result，注意加上如果条件不成立就break节省时间，不然倒数第二个测试点过不去</p><p><strong>注意点</strong>：p和num数组是个长整型，输入和输出格式注意一下</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;<span class="hljs-type">bool</span> cmp(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;<span class="hljs-keyword">return</span> a&lt;b;&#125;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n,i,temp;long long p;scanf(<span class="hljs-string">&quot;%d %lld&quot;</span>,&amp;n,&amp;p);long long num[n+<span class="hljs-number">1</span>];i=<span class="hljs-number">0</span>;while(i&lt;n)&#123;scanf(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;num[i]);i++;&#125;<span class="hljs-type">int</span> result=<span class="hljs-number">0</span>;sort(num,num+n,cmp);<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+result;j&lt;n;j++)&#123;<span class="hljs-keyword">if</span>(num[i]*p&gt;=num[j])&#123;temp=j-i+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(temp&gt;result)&#123;result = temp;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125; printf(<span class="hljs-string">&quot;%d\n&quot;</span>,result);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1027 打印沙漏</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1027%20%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1027%20%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="打印沙漏"><a href="#打印沙漏" class="headerlink" title="打印沙漏"></a><font size=6px>打印沙漏</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p><pre><code class="hljs asciidoc">***** ***  * ********</code></pre><p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p><p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code class="hljs in">19 *</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code class="hljs out">***** ***  * ********2</code></pre><h4 id="思路-简答题，无"><a href="#思路-简答题，无" class="headerlink" title="思路:简答题，无"></a>思路:简答题，无</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> num,sum,i <span class="hljs-type">int</span>    fmt.Scan(&amp;num,&amp;s)    sum=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">2</span>;i&lt;<span class="hljs-number">1001</span>;i++&#123;        <span class="hljs-keyword">if</span> sum&gt;num&#123;            sum=sum-(<span class="hljs-number">4</span>*i)+<span class="hljs-number">6</span>            <span class="hljs-keyword">break</span>        &#125;        sum+=<span class="hljs-number">4</span>*i<span class="hljs-number">-2</span>    &#125;    i=i<span class="hljs-number">-2</span>   <span class="hljs-comment">//打印上面的三角</span>    <span class="hljs-keyword">for</span> j:=i;j&gt;<span class="hljs-number">0</span>;j--&#123;        <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;i-j;k++&#123;            fmt.Printf(<span class="hljs-string">&quot; &quot;</span>)        &#125;        <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;j*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;k++&#123;            fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,s)        &#125;        fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)    &#125;   <span class="hljs-comment">//打印下面的三角</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">2</span>;j&lt;=i;j++&#123;       <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;i-j;k++&#123;           fmt.Printf(<span class="hljs-string">&quot; &quot;</span>)       &#125;       <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;j*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;k++&#123;           fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,s)       &#125;       fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)   &#125;   <span class="hljs-comment">//输出剩下没用掉的符号数</span>   fmt.Println(num-sum)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1001 害死人不偿命的3n+1猜想</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1001%20%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%843n+1%E7%8C%9C%E6%83%B3%20/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1001%20%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%843n+1%E7%8C%9C%E6%83%B3%20/</url>
    
    <content type="html"><![CDATA[<h3 id="害死人不偿命的3n-1猜想"><a href="#害死人不偿命的3n-1猜想" class="headerlink" title="害死人不偿命的3n+1猜想 "></a><font size=6px>害死人不偿命的3n+1猜想 </font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>卡拉兹(Callatz)猜想：</p><p>对任何一个正整数 <em>n</em>，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3<em>n</em>+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 <em>n</em>&#x3D;1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3<em>n</em>+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p><p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 <em>n</em>，简单地数一下，需要多少步（砍几下）才能得到 <em>n</em>&#x3D;1？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em> 的值。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出从 <em>n</em> 计算到 1 需要的步数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">3</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">5</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无，看代码</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> a,k <span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a)    <span class="hljs-keyword">for</span> a!=<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> a%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&#123;            a=a/<span class="hljs-number">2</span>        &#125;<span class="hljs-keyword">else</span>&#123;            a=(<span class="hljs-number">3</span>*a+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>        &#125;        k++    &#125;    fmt.Println(k)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1002 写出这个数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1002%20%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1002%20%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="写出这个数"><a href="#写出这个数" class="headerlink" title="写出这个数"></a><font size=6px>写出这个数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>读入一个正整数 <em>n</em>，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出自然数 <em>n</em> 的值。这里保证 <em>n</em> 小于 10100。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行内输出 <em>n</em> 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">1234567890987654321123456789</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">yi san wu</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>思路还是很简单的，用string接受，然后一位位加起来成sum，最后把sum转化成切片，再转化成中文输出（这一步用map会更好）写’jiu‘的时候写成了’qiu‘，卡了我半天，我是憨批，而且写的很冗长，比较烂</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s)    <span class="hljs-comment">//转化成合数</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        sum=sum+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    sumLen:=<span class="hljs-built_in">len</span>(strconv.Itoa(sum))    sumSlice:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,sumLen)    <span class="hljs-comment">//转换成切片</span>    <span class="hljs-keyword">for</span> i:=sumLen;i&gt;<span class="hljs-number">0</span>;i--&#123;        sumSlice[sumLen-i]=sum / <span class="hljs-type">int</span>(math.Pow(<span class="hljs-number">10</span>,<span class="hljs-type">float64</span> (i)<span class="hljs-number">-1</span>)) %<span class="hljs-number">10</span>    &#125;    <span class="hljs-comment">//fmt.Println(sumSlice)</span>    <span class="hljs-keyword">switch</span> (sumSlice[<span class="hljs-number">0</span>]) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: fmt.Print(<span class="hljs-string">&quot;ling&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: fmt.Print(<span class="hljs-string">&quot;yi&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: fmt.Print(<span class="hljs-string">&quot;er&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: fmt.Print(<span class="hljs-string">&quot;san&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: fmt.Print(<span class="hljs-string">&quot;si&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: fmt.Print(<span class="hljs-string">&quot;wu&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: fmt.Print(<span class="hljs-string">&quot;liu&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: fmt.Print(<span class="hljs-string">&quot;qi&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: fmt.Print(<span class="hljs-string">&quot;ba&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: fmt.Print(<span class="hljs-string">&quot;jiu&quot;</span>)        <span class="hljs-keyword">break</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;sumLen;i++&#123;        <span class="hljs-keyword">switch</span> (sumSlice[i]) &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: fmt.Print(<span class="hljs-string">&quot; ling&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: fmt.Print(<span class="hljs-string">&quot; yi&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: fmt.Print(<span class="hljs-string">&quot; er&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: fmt.Print(<span class="hljs-string">&quot; san&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: fmt.Print(<span class="hljs-string">&quot; si&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: fmt.Print(<span class="hljs-string">&quot; wu&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: fmt.Print(<span class="hljs-string">&quot; liu&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: fmt.Print(<span class="hljs-string">&quot; qi&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: fmt.Print(<span class="hljs-string">&quot; ba&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: fmt.Print(<span class="hljs-string">&quot; jiu&quot;</span>)            <span class="hljs-keyword">break</span>        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1003 我要通过</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1003%20%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1003%20%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h3 id="我要通过"><a href="#我要通过" class="headerlink" title="我要通过"></a><font size=6px>我要通过</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>“<strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。</p><p>得到“<strong>答案正确</strong>”的条件是：</p><ol><li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li><li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li><li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。</li></ol><p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 <em>n</em> (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">8PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">YESYESYESYESNONONONO</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先读懂题目，只能有P A T三个字母，其他字母不行</p><p><strong>3、如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。</strong>最重要是第三个条件，设P前面的A的数量为counta，P和T中间A的数量为countb，T之后的A的数量为countc，找规律就可以知道countc&#x3D;counta*countb，这个规律知道之后就好写了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n , i ,j , counta ,countb,countc,flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">for</span> i&lt;n&#123;                fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s)        <span class="hljs-comment">//判断有无其他字符</span>        <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;<span class="hljs-built_in">len</span>(s);k++&#123;            <span class="hljs-keyword">if</span> s[k]!=<span class="hljs-string">&#x27;P&#x27;</span>&amp;&amp;s[k]!=<span class="hljs-string">&#x27;T&#x27;</span>&amp;&amp;s[k]!=<span class="hljs-string">&#x27;A&#x27;</span>&#123;                i++                flag=<span class="hljs-number">1</span>                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> flag==<span class="hljs-number">1</span>&#123;            flag=<span class="hljs-number">0</span>            fmt.Printf(<span class="hljs-string">&quot;NO\n&quot;</span>)            <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">for</span> j&lt;<span class="hljs-built_in">len</span>(s)&amp;&amp;s[j]!=<span class="hljs-string">&#x27;P&#x27;</span>&#123;            counta++            j++        &#125;        j++        <span class="hljs-keyword">for</span> j&lt;<span class="hljs-built_in">len</span>(s)&amp;&amp;s[j]!=<span class="hljs-string">&#x27;T&#x27;</span>&#123;            countb++            j++        &#125;        countc=<span class="hljs-built_in">len</span>(s)-countb-counta<span class="hljs-number">-2</span>        <span class="hljs-comment">//println(counta ,countb ,countc)</span>        <span class="hljs-keyword">if</span> countb==<span class="hljs-number">0</span>||counta*countb!=countc&#123;            fmt.Printf(<span class="hljs-string">&quot;NO\n&quot;</span>)        &#125;<span class="hljs-keyword">else</span> &#123;            fmt.Printf(<span class="hljs-string">&quot;YES\n&quot;</span>)        &#125;        <span class="hljs-comment">//清零</span>        countc=<span class="hljs-number">0</span>        counta=<span class="hljs-number">0</span>        countb=<span class="hljs-number">0</span>        j=<span class="hljs-number">0</span>        i++    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1004 成绩排名</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1004%20%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1004%20%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="成绩排名"><a href="#成绩排名" class="headerlink" title="成绩排名"></a><font size=6px>成绩排名</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>读入 <em>n</em>（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，格式为</p><pre><code class="hljs tap">第<span class="hljs-number"> 1 </span>行：正整数 n第<span class="hljs-number"> 2 </span>行：第<span class="hljs-number"> 1 </span>个学生的姓名 学号 成绩第<span class="hljs-number"> 3 </span>行：第<span class="hljs-number"> 2 </span>个学生的姓名 学号 成绩  ... ... ...第 n+1 行：第 n 个学生的姓名 学号 成绩</code></pre><p>其中<code>姓名</code>和<code>学号</code>均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">3Joe Math990112 89Mike CS991301 100Mary EE990830 95</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">Mike CS991301Joe Math990112</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>挺简单的题目，用map来写，注意map要写101个大小，因为有0分和100分，如果n&#x3D;&#x3D;1时要输入两遍一样的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> s1 ,s2,s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> score,n,i <span class="hljs-type">int</span>    mp:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>,<span class="hljs-number">101</span>)    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">1</span>&#123;        fmt.Scanf(<span class="hljs-string">&quot;%s%s%d&quot;</span>,&amp;s1,&amp;s2,&amp;score)        fmt.Println(s1+<span class="hljs-string">&quot; &quot;</span>+s2)        fmt.Println(s1+<span class="hljs-string">&quot; &quot;</span>+s2)    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> i&lt;n&#123;            fmt.Scanf(<span class="hljs-string">&quot;%s%s%d&quot;</span>,&amp;s1,&amp;s2,&amp;score)            s=s1+<span class="hljs-string">&quot; &quot;</span>+s2            mp[score]=s            i++        &#125;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">100</span>;j&gt;=<span class="hljs-number">0</span>;j--&#123;            <span class="hljs-keyword">if</span> mp[j]!=<span class="hljs-string">&quot;&quot;</span>&#123;                fmt.Println(mp[j])                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">100</span>;j++&#123;            <span class="hljs-keyword">if</span> mp[j]!=<span class="hljs-string">&quot;&quot;</span>&#123;                fmt.Println(mp[j])                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1005 继续3n+1猜想</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1005%20%E7%BB%A7%E7%BB%AD3n+1%E7%8C%9C%E6%83%B3%20/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1005%20%E7%BB%A7%E7%BB%AD3n+1%E7%8C%9C%E6%83%B3%20/</url>
    
    <content type="html"><![CDATA[<h3 id="继续3n-1猜想"><a href="#继续3n-1猜想" class="headerlink" title="继续3n+1猜想 "></a><font size=6px>继续3n+1猜想 </font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p><p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 <em>n</em>&#x3D;3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 <em>n</em>&#x3D;5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 <em>n</em> 为“关键数”，如果 <em>n</em> 不能被数列中的其他数字所覆盖。</p><p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 <em>K</em> (&lt;100)，第 2 行给出 <em>K</em> 个互不相同的待验证的正整数 <em>n</em> (1&lt;<em>n</em>≤100)的值，数字间用空格隔开。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">63 5 6 7 8 11</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">7 6</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>输出的时候一个变量名字打错竟然卡了我1个钟头？</p><p>题目理解就是在给出的k个正整数里面找到不是卡拉兹猜想的中间数，</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,i ,a <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> array [<span class="hljs-number">101</span>]<span class="hljs-type">int</span>    mp:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,<span class="hljs-number">101</span>)    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">for</span> i&lt;n&#123;        fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a)        array[i]=a        <span class="hljs-comment">//mp[]=101代表没有被覆盖</span>        mp[a]=<span class="hljs-number">101</span>        i++    &#125;    <span class="hljs-comment">//把每个数字能覆盖的都覆盖了</span>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        flag:=array[i]        <span class="hljs-keyword">for</span> array[i]!=<span class="hljs-number">1</span>&#123;            <span class="hljs-keyword">if</span> array[i]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>&#123;                array[i]=(array[i]*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>            &#125;<span class="hljs-keyword">else</span>&#123;                array[i]/=<span class="hljs-number">2</span>            &#125;            mp[array[i]]=flag        &#125;    &#125;    <span class="hljs-comment">//下面是为了使最后一个没有空格</span>    <span class="hljs-keyword">var</span> j <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> j=<span class="hljs-number">100</span>;j&gt;<span class="hljs-number">0</span>;j--&#123;        <span class="hljs-keyword">if</span> mp[j]==<span class="hljs-number">101</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,j)            <span class="hljs-keyword">break</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> k:=j<span class="hljs-number">-1</span>;k&gt;<span class="hljs-number">0</span>;k--&#123;        <span class="hljs-keyword">if</span> mp[k]==<span class="hljs-number">101</span>&#123;            fmt.Printf(<span class="hljs-string">&quot; %d&quot;</span>,k)        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
