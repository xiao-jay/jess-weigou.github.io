<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>万万没想到之聪明的编辑</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E8%81%AA%E6%98%8E%E7%9A%84%E7%BC%96%E8%BE%91/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E8%81%AA%E6%98%8E%E7%9A%84%E7%BC%96%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h3 id="万万没想到之聪明的编辑"><a href="#万万没想到之聪明的编辑" class="headerlink" title="万万没想到之聪明的编辑"></a><font size=6px>万万没想到之聪明的编辑</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径：</p><p>\1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -&gt; hello</p><p>\2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -&gt; hello</p><p>\3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC</p><p>我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！</p><p>……</p><p>万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的……</p><p>请听题：请实现大锤的自动校对程序</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><pre><code class="hljs excel">第一行包括一个数字<span class="hljs-built_in">N</span>，表示本次用例包括多少个待校验的字符串。后面跟随<span class="hljs-built_in">N</span>行，每行为一个待校验的字符串。</code></pre><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><pre><code class="hljs excel"><span class="hljs-built_in">N</span>行，每行包括一个被修复后的字符串。</code></pre><h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><pre><code class="hljs">2helloowooooooow</code></pre><h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><pre><code class="hljs ebnf"><span class="hljs-attribute">hello</span><span class="hljs-attribute">woow</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>简单题，无思路</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span>fmt.Scan(&amp;n)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;fmt.Scan(&amp;str)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(str) &lt; <span class="hljs-number">3</span> &#123;fmt.Println(str)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(check(str))&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;correctStr := []<span class="hljs-type">byte</span>&#123;&#125;correctStr = <span class="hljs-built_in">append</span>(correctStr, <span class="hljs-type">byte</span>(str[<span class="hljs-number">0</span>]), <span class="hljs-type">byte</span>(str[<span class="hljs-number">1</span>]))k := <span class="hljs-number">2</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> || k == <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">if</span> correctStr[k<span class="hljs-number">-1</span>] == str[i] &amp;&amp; correctStr[k<span class="hljs-number">-1</span>] == correctStr[k<span class="hljs-number">-2</span>] &#123;<span class="hljs-keyword">continue</span>&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> correctStr[k<span class="hljs-number">-1</span>] == str[i] &amp;&amp; correctStr[k<span class="hljs-number">-1</span>] == correctStr[k<span class="hljs-number">-2</span>] &#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">if</span> correctStr[k<span class="hljs-number">-3</span>] == correctStr[k<span class="hljs-number">-2</span>] &amp;&amp; correctStr[k<span class="hljs-number">-1</span>] == str[i] &#123;<span class="hljs-keyword">continue</span>&#125;&#125;correctStr = <span class="hljs-built_in">append</span>(correctStr, <span class="hljs-type">byte</span>(str[i]))k++&#125;<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(correctStr)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：5ms, 超过62.59%用Go提交的代码<br>  占用内存：1048KB, 超过21.33%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客网刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>头条校招</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%A4%B4%E6%9D%A1%E6%A0%A1%E6%8B%9B/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%A4%B4%E6%9D%A1%E6%A0%A1%E6%8B%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="头条校招"><a href="#头条校招" class="headerlink" title="头条校招"></a><font size=6px>头条校招</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队，每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来，在选题之前，我们对题目进行了盲审，并定出了每道题的难度系统。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件：<br>a&lt;&#x3D;b&lt;&#x3D;c<br>b-a&lt;&#x3D;10<br>c-b&lt;&#x3D;10<br>所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs armasm">输入的第一行包含一个整数n，表示目前已经出好的题目数量。第二行给出每道题目的难度系数<span class="hljs-built_in">d1</span>,<span class="hljs-built_in">d2</span>,...,<span class="hljs-meta">dn</span>。 数据范围对于<span class="hljs-number">30</span>%的数据，<span class="hljs-number">1</span> ≤ n,di ≤ <span class="hljs-number">5</span><span class="hljs-comment">;</span>对于<span class="hljs-number">100</span>%的数据，<span class="hljs-number">1</span> ≤ n ≤ <span class="hljs-number">10</span>^<span class="hljs-number">5</span>,<span class="hljs-number">1</span> ≤ di ≤ <span class="hljs-number">100</span>。在样例中，一种可行的方案是添加<span class="hljs-number">2</span>个难度分别为<span class="hljs-number">20</span>和<span class="hljs-number">50</span>的题目，这样可以组合成两场考试：（<span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">23</span>）和（<span class="hljs-number">35</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>）。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">输出只包括一行，即所求的答案。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span> <span class="hljs-symbol">20 </span><span class="hljs-number">35</span> <span class="hljs-number">23</span> <span class="hljs-number">40</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">2</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先找三个的，再找两个的，最后输出只有单独一个的*2+两个的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sort&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n,a,sum1,sum2  <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    flag := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scan(&amp;a)        num[i] = a    &#125;    sort.Ints(num)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;n;i++&#123;        <span class="hljs-comment">//找到三个数的</span>        <span class="hljs-keyword">if</span> flag[i<span class="hljs-number">-2</span>]==<span class="hljs-number">0</span>&amp;&amp;flag[i<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;flag[i]==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> num[i]-num[i<span class="hljs-number">-1</span>]&lt;=<span class="hljs-number">10</span>&amp;&amp;num[i<span class="hljs-number">-1</span>]-num[i<span class="hljs-number">-2</span>]&lt;=<span class="hljs-number">10</span>&#123;                flag[i],flag[i<span class="hljs-number">-1</span>],flag[i<span class="hljs-number">-2</span>] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>                sum1++            &#125;        &#125;    &#125;    <span class="hljs-comment">//找到两个数的</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> flag[i<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;flag[i]==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> num[i]-num[i<span class="hljs-number">-1</span>]&lt;=<span class="hljs-number">10</span>&#123;                flag[i],flag[i<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span>                sum2++            &#125;        &#125;    &#125;    fmt.Println(sum2+<span class="hljs-number">2</span>*(n<span class="hljs-number">-3</span>*sum1<span class="hljs-number">-2</span>*sum2))    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可转换最长子串</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%8F%AF%E8%BD%AC%E6%8D%A2%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%8F%AF%E8%BD%AC%E6%8D%A2%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="可转换最长子串"><a href="#可转换最长子串" class="headerlink" title="可转换最长子串"></a><font size=6px>可转换最长子串</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个仅包含’a’和’b’两种字符的字符串s，长度为n，每次操作可以把一个字符做一次转换（把一个’a’设置为’b’，或者把一个’b’置成’a’)；但是操作的次数有上限m，问在有限的操作数范围内，能够得到最大连续的相同字符的子串的长度是多少。.</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行两个整数 <span class="hljs-built_in">n</span> , m (<span class="hljs-number">1</span>&lt;=m&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">50000</span>)，第二行为长度为<span class="hljs-built_in">n</span>且只包含’a’和’b’的字符串s。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs css">输出在操作次数不超过 m 的情况下，能够得到的 最大连续 全’<span class="hljs-selector-tag">a</span>’子串或全’<span class="hljs-selector-tag">b</span>’子串的长度。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs apache"><span class="hljs-attribute">8</span> <span class="hljs-number">1</span><span class="hljs-attribute">aabaabaa</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">5</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs 1c">把第一个 &#x27;b&#x27; 或者第二个 &#x27;b&#x27; 置成 &#x27;a&#x27;，可得到长度为 <span class="hljs-number">5</span> 的全 &#x27;a&#x27; 子串。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用滑动窗口法</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;<span class="hljs-type">int</span> main()&#123;    char c[<span class="hljs-number">500001</span>];    <span class="hljs-type">int</span> n,m;    scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c[i]);    &#125;    <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>,l=<span class="hljs-number">0</span>,maxl=<span class="hljs-number">0</span>,an=<span class="hljs-number">0</span>,bn=<span class="hljs-number">0</span>;    while(r&lt;n)&#123;        <span class="hljs-keyword">if</span>(c[r]==<span class="hljs-string">&#x27;a&#x27;</span>) an++;        <span class="hljs-keyword">else</span> bn++;        <span class="hljs-keyword">if</span>(an&lt;=m||bn&lt;=m)&#123;            r++;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(r-l&gt;maxl) maxl = r-l;            <span class="hljs-keyword">if</span>(c[l]==<span class="hljs-string">&#x27;a&#x27;</span>)&#123;                an--;                l++;            &#125;<span class="hljs-keyword">else</span>&#123;                bn--;                l++;            &#125;            r++;        &#125;    &#125;    <span class="hljs-keyword">if</span>(r-l &gt;maxl) maxl = r-l;    printf(<span class="hljs-string">&quot;%d&quot;</span>,maxl);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：4ms, 超过61.29%用C提交的代码<br>   占用内存：416KB, 超过83.87%用C提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字母交换</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E6%AF%8D%E4%BA%A4%E6%8D%A2/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E6%AF%8D%E4%BA%A4%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="字母交换"><a href="#字母交换" class="headerlink" title="字母交换"></a><font size=6px>字母交换</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>【编码题】字符串S由小写字母构成，长度为n。定义一种操作，每次都可以挑选字符串中任意的两个相邻字母进行交换。询问在至多交换m次之后，字符串中最多有多少个连续的位置上的字母相同？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs coq">第一行为一个字符串S与一个非负整数m。(<span class="hljs-number">1</span> &lt;= |<span class="hljs-type">S</span>| <span class="hljs-type">&lt;= 1000</span>, <span class="hljs-number">1</span> &lt;= m &lt;= <span class="hljs-number">1000000</span>)</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">一个非负整数，表示操作之后，连续最长的相同字母数量。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs apache"><span class="hljs-attribute">abcbaa</span> <span class="hljs-number">2</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">2</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs css">使<span class="hljs-number">2</span>个字母<span class="hljs-selector-tag">a</span>连续出现，至少需要<span class="hljs-number">3</span>次操作。即把第<span class="hljs-number">1</span>个位w置上的<span class="hljs-selector-tag">a</span>移动到第<span class="hljs-number">4</span>个位置。所以在至多操作<span class="hljs-number">2</span>次的情况下，最多只能使<span class="hljs-number">2</span>个<span class="hljs-selector-tag">b</span>或<span class="hljs-number">2</span>个<span class="hljs-selector-tag">a</span>连续出现。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划递推公式 dp【i】[j]&#x3D;  dp【i+1】【j-1】 + a[j]-a[i] -(j-i);,计算时只算上三角情况，每个字母单独计算，递归公式看懂就会做了。第一轮计算相邻相同字母的相邻距离，第二轮计算相差两个位置的字母靠近需要多少距离</p><p>上三角举例</p><p>0111</p><p>0011</p><p>0001</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;#include&lt;stdlib.h&gt;<span class="hljs-type">int</span> max(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-type">int</span> main()&#123;    char s[<span class="hljs-number">10001</span>];    <span class="hljs-type">int</span> m,max_seq;    scanf(<span class="hljs-string">&quot;%s%d&quot;</span>,s,&amp;m);    <span class="hljs-type">int</span> size_s = strlen(s);    <span class="hljs-keyword">for</span>(char c =<span class="hljs-string">&#x27;a&#x27;</span>;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span> ; c++)&#123;        <span class="hljs-type">int</span> *a = (<span class="hljs-type">int</span> *)malloc(sizeof(<span class="hljs-type">int</span>)*<span class="hljs-number">10002</span>);        <span class="hljs-type">int</span> size =<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size_s;i++)&#123;            <span class="hljs-comment">//把相同字符的位置求出来</span>            <span class="hljs-keyword">if</span>(s[i] ==c) a[size++] = i;        &#125;        <span class="hljs-keyword">if</span>(size)&#123;            <span class="hljs-type">int</span> dp[<span class="hljs-number">1002</span>][<span class="hljs-number">1001</span>];            memset(dp,<span class="hljs-number">0</span>,sizeof(dp));            <span class="hljs-type">int</span> seq = <span class="hljs-number">1</span>;            <span class="hljs-comment">//只计算上三角情况</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>;r&lt;size;r++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size-r;i++)&#123;                    <span class="hljs-type">int</span> j = i+r;                    <span class="hljs-comment">// 在第一轮的情况下</span>                    <span class="hljs-keyword">if</span>(j==i+<span class="hljs-number">1</span>)&#123;                        dp[i][j] = a[j]-a[i]<span class="hljs-number">-1</span>;                    &#125;<span class="hljs-keyword">else</span>&#123;                        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + a[j]-a[i] -(j-i);                    &#125;                    <span class="hljs-keyword">if</span>(dp[i][j]&lt;=m)                        seq = max(seq,j-i+<span class="hljs-number">1</span>);                &#125;            &#125;            max_seq = max(max_seq,seq);        &#125;    &#125;    printf(<span class="hljs-string">&quot;%d\n&quot;</span>,max_seq);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：11ms, 超过57.14%用C提交的代码<br>   占用内存：4348KB, 超过40.00%用C提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动附加题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%99%84%E5%8A%A0%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%99%84%E5%8A%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="字节跳动附加题"><a href="#字节跳动附加题" class="headerlink" title="字节跳动附加题"></a><font size=6px>字节跳动附加题</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>存在n+1个房间，每个房间依次为房间1 2 3…i，每个房间都存在一个传送门，i房间的传送门可以把人传送到房间pi(1&lt;&#x3D;pi&lt;&#x3D;i),现在路人甲从房间1开始出发(当前房间1即第一次访问)，每次移动他有两种移动策略：<br>  A. 如果访问过当前房间 i 偶数次，那么下一次移动到房间i+1；<br>  B. 如果访问过当前房间 i 奇数次，那么移动到房间pi；<br>现在路人甲想知道移动到房间n+1一共需要多少次移动；</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行包括一个数字<span class="hljs-built_in">n</span>(<span class="hljs-comment">30%数据1&lt;=n&lt;=100，100%数据 1&lt;=n&lt;=1000</span>)，表示房间的数量，接下来一行存在<span class="hljs-built_in">n</span>个数字 <span class="hljs-built_in">pi</span>(<span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">pi</span>&lt;=i), <span class="hljs-built_in">pi</span>表示从房间i可以传送到房间<span class="hljs-built_in">pi</span>。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs dns">输出一行数字，表示最终移动的次数，最终结果需要对<span class="hljs-number">1000000007</span> (<span class="hljs-number">10</span>e9 + <span class="hljs-number">7</span>) 取模。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs css">开始从房间<span class="hljs-number">1</span> 只访问一次所以只能跳到p1即 房间<span class="hljs-number">1</span>， 之后采用策略<span class="hljs-selector-tag">A</span>跳到房间<span class="hljs-number">2</span>，房间<span class="hljs-number">2</span>这时访问了一次因此采用策略<span class="hljs-selector-tag">B</span>跳到房间<span class="hljs-number">2</span>，之后采用策略<span class="hljs-selector-tag">A</span>跳到房间<span class="hljs-number">3</span>，因此到达房间<span class="hljs-number">3</span>需要 <span class="hljs-number">4</span> 步操作。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一道递推题，dp【i】需要一次奇数和偶数移动，偶数移动 &#x3D; dp【i-1】+1,奇数移动是dp【i】&#x3D; dp【i-1】-dp【jump【i-1】】+1。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">2</span>)    jump := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)    mod := <span class="hljs-number">1000000007</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        fmt.Scan(&amp;jump[i])    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++&#123;        count[i] = (<span class="hljs-number">2</span>*count[i<span class="hljs-number">-1</span>]%mod-count[jump[i<span class="hljs-number">-1</span>]]+<span class="hljs-number">2</span>)%mod    &#125;    fmt.Println(count[n+<span class="hljs-number">1</span>])&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：2 ms, 在所有 Go 提交中击败了100.00%的用户<br>   占用内存：988KB, 超过13.64%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大点集</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%80%E5%A4%A7%E7%82%B9%E9%9B%86/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%80%E5%A4%A7%E7%82%B9%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="最大点集"><a href="#最大点集" class="headerlink" title="最大点集"></a><font size=6px>最大点集</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>P为给定的二维平面整数点集。定义P中某点x，如果x满足P中任意点都不在x的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复,坐标轴范围在[0, 1e9]内）</p><p>如下图：实心点为满足条件的点的集合。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180711/305700_1531276401135_0787E0E2ECD199446DCB82BEAE571BDF" alt="img"></p><p>请实现代码找到集合P中的所有”最大“点的集合并输出。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行输入点集的个数<span class="hljs-built_in">N</span>， 接下来<span class="hljs-built_in">N</span>行，每行两个数字代表点的X轴和Y轴。<span class="hljs-number">1</span> ≤ <span class="hljs-built_in">n</span> ≤ <span class="hljs-number">500000</span></code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs tp">输出“最大的”点集合， 按照<span class="hljs-keyword">X</span>轴从小到大的方式输出，每行两个数字分别代表点的<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先按照x升序和y升序排序，然后从后到前判断</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;<span class="hljs-keyword">struct</span> num &#123;    <span class="hljs-type">int</span> a,b;&#125;;<span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">struct</span> num num1,<span class="hljs-keyword">struct</span> num num2)&#123;    <span class="hljs-keyword">if</span> (num1.a &gt; num2.a)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num1.a &lt; num2.a)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span> (num1.b&lt;num2.b)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">struct</span> num nums[n];    <span class="hljs-keyword">struct</span> num res[n];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums[i].a);        scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums[i].b);    &#125;    sort(nums,nums+n,cmp);    <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;    <span class="hljs-type">int</span> max = nums[n<span class="hljs-number">-1</span>].b;    res[<span class="hljs-number">0</span>].a = nums[n<span class="hljs-number">-1</span>].a;    res[<span class="hljs-number">0</span>].b = nums[n<span class="hljs-number">-1</span>].b;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-keyword">if</span>(nums[i].b &gt;max)&#123;            max = nums[i].b;            res[k].a = nums[i].a;            res[k++].b = nums[i].b;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,res[i].a,res[i].b);    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：173ms, 超过80.50%用C++提交的代码<br>   占用内存：12684KB, 超过44.93%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>房间人数</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%88%BF%E9%97%B4%E4%BA%BA%E6%95%B0/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%88%BF%E9%97%B4%E4%BA%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="房间人数"><a href="#房间人数" class="headerlink" title="房间人数"></a><font size=6px>房间人数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有n个房间，现在i号房间里的人需要被重新分配，分配的规则是这样的：先让i号房间里的人全都出来，接下来按照 i+1, i+2, i+3, … 的顺序依此往这些房间里放一个人，n号房间的的下一个房间是1号房间，直到所有的人都被重新分配。</p><p>现在告诉你分配完后每个房间的人数以及最后一个人被分配的房间号x，你需要求出分配前每个房间的人数。数据保证一定有解，若有多解输出任意一个解。</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><pre><code class="hljs excel">第一行两个整数<span class="hljs-built_in">n</span>, x (<span class="hljs-number">2</span>&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">5</span>, <span class="hljs-number">1</span>&lt;=x&lt;=<span class="hljs-built_in">n</span>)，代表房间房间数量以及最后一个人被分配的房间号；第二行<span class="hljs-built_in">n</span>个整数 a_i(<span class="hljs-number">0</span>&lt;=a_i&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">9</span>) ，代表每个房间分配后的人数。</code></pre><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><pre><code class="hljs excel">输出<span class="hljs-built_in">n</span>个整数，代表每个房间分配前的人数。</code></pre><h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><span class="hljs-symbol">6 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span></code></pre><h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>需要考虑的情况是</p><pre><code class="hljs hsp"><span class="hljs-keyword">while</span>(room[<span class="hljs-keyword">pos</span>]!=mn)        <span class="hljs-keyword">pos</span>=<span class="hljs-keyword">pos</span>&gt;<span class="hljs-number">0</span>?<span class="hljs-keyword">pos</span><span class="hljs-number">-1</span>:n<span class="hljs-number">-1</span><span class="hljs-comment">;</span></code></pre><p>最后一个房间的人的前一个最小数才是真正的最小数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;limits.h&gt;#include&lt;algorithm&gt;using namespace std;#define ll long long<span class="hljs-type">int</span> n,x;ll room[<span class="hljs-number">1500005</span>];<span class="hljs-type">int</span> main(void)&#123;    scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);    ll mn=INT_MAX;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;room[i]);        mn=min(mn, room[i]);    &#125;    x-=<span class="hljs-number">1</span>;    <span class="hljs-type">int</span> pos=x;    while(room[pos]!=mn)        pos=pos&gt;<span class="hljs-number">0</span>?pos<span class="hljs-number">-1</span>:n<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        room[i]-=mn;    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i!=pos;i=i&gt;<span class="hljs-number">0</span>?i<span class="hljs-number">-1</span>:n<span class="hljs-number">-1</span>)&#123;        room[i]-=<span class="hljs-number">1</span>;        count+=<span class="hljs-number">1</span>;    &#125;    room[pos]+=count+n*mn;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        printf(<span class="hljs-string">&quot;%lld &quot;</span>,room[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人跳跃问题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="机器人跳跃问题"><a href="#机器人跳跃问题" class="headerlink" title="机器人跳跃问题"></a><font size=6px>机器人跳跃问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。 </p><p>起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第个k+1建筑。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果 H(k+1) &gt; E 那么机器人就失去 H(k+1) - E 的能量值，否则它将得到 E - H(k+1) 的能量值。</p><p>游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs css">第一行输入，表示一共有 N 组数据.第二个是 N 个空格分隔的整数，<span class="hljs-selector-tag">H1</span>, <span class="hljs-selector-tag">H2</span>, <span class="hljs-selector-tag">H3</span>, ..., Hn 代表建筑物的高度</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">输出一个单独的数表示完成游戏所需的最少单位的初始能量</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><p>示例2</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span></code></pre><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><p>示例3</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span></code></pre><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">3</code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h2><pre><code class="hljs parser3"><span class="language-xml">数据约束：</span><span class="language-xml"></span><span class="hljs-number">1</span><span class="language-xml"> &lt;= N &lt;= </span><span class="hljs-number">10</span><span class="hljs-keyword">^5</span><span class="language-xml"></span><span class="language-xml"></span><span class="hljs-number">1</span><span class="language-xml"> &lt;= H(i) &lt;= </span><span class="hljs-number">10</span><span class="hljs-keyword">^5</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用动态规划,令 f(n)&#x3D;E(n)，</p><p>则 f(n+1)&#x3D;2f(n)–H(n+1)≥0，所以 f(n)&#x3D;⌈(f(n+1)+H(n+1))&#x2F;2⌉</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n,a <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scan(&amp;a)        num[i] = a    &#125;    <span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(num)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        ans = ceil(ans , num[i])    &#125;    fmt.Println(ans)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ceil</span><span class="hljs-params">( a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> (a+b) %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> (a+b)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> (a+b)/<span class="hljs-number">2</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：15ms, 超过9.84%用Go提交的代码<br>   占用内存：1036KB, 超过37.70%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业旅行问题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%AF%95%E4%B8%9A%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%AF%95%E4%B8%9A%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="毕业旅行问题"><a href="#毕业旅行问题" class="headerlink" title="毕业旅行问题"></a><font size=6px>毕业旅行问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">城市个数<span class="hljs-built_in">n</span>（<span class="hljs-number">1</span>&lt;<span class="hljs-built_in">n</span>≤<span class="hljs-number">20</span>，包括北京）城市间的车票价钱 <span class="hljs-built_in">n</span>行<span class="hljs-built_in">n</span>列的矩阵 m[<span class="hljs-built_in">n</span>][<span class="hljs-built_in">n</span>]</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">最小车费花销 s</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">4</span><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><span class="hljs-symbol">6 </span><span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">13</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs tap">共<span class="hljs-number"> 4 </span>个城市，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 1 </span>的车费为0，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 2 </span>之间的车费为 2，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 3 </span>之间的车费为 6，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 4 </span>之间的车费为 5，依次类推。假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用状态压缩动态规划来写，1代表已经走过这个地方了，解释一下代码</p><p>第一层循环代表所有情况，第二层代表下一个要去的城市是第几个城市，第三层循环代表中间结点城市。</p><pre><code class="hljs 1c">i&gt;&gt;j <span class="hljs-meta">&amp;1 <span class="hljs-comment">//判断i的第j位是不是1</span></span></code></pre><p>i^(1&lt;&lt;j) &#x2F;&#x2F;把i的第j位置为1</p><pre><code class="hljs cpp">#### 代码:```golang<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;    <span class="hljs-keyword">if</span>(a &gt; b)&#123;        <span class="hljs-keyword">return</span> b;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-type">int</span> dp[<span class="hljs-number">1</span>&lt;&lt;n][n];        <span class="hljs-type">int</span> num[n][n];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num[i][j]);    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dp));    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i+=<span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;            <span class="hljs-keyword">if</span>((i&gt;&gt;j &amp;<span class="hljs-number">1</span>==<span class="hljs-number">0</span>)) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;                <span class="hljs-keyword">if</span>(j==k) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>((i&gt;&gt;k)&amp;<span class="hljs-number">1</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)][k]+num[k][j]);            &#125;        &#125;    &#125;    <span class="hljs-type">int</span> res =<span class="hljs-number">9999</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        res = <span class="hljs-built_in">min</span>(res,dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i]+num[i][<span class="hljs-number">0</span>]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：78ms, 超过33.33%用C提交的代码<br>   占用内存：18732KB, 超过15.69%用C提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点排序</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%82%B9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%82%B9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="点排序"><a href="#点排序" class="headerlink" title="点排序"></a><font size=6px>点排序</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>P为给定的二维平面整数点集。定义 P 中某点x，如果x满足 P 中任意点都不在 x 的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复, 坐标轴范围在[0, 1e9) 内）</p><p>如下图：实心点为满足条件的点的集合。请实现代码找到集合 P 中的所有 ”最大“ 点的集合并输出。</p><p><img src="https://uploadfiles.nowcoder.com/images/20170817/300557_1502940399706_1329AFEA3FC7961DEA219781A71B3B5B" alt="img"></p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行输入点集的个数 <span class="hljs-built_in">N</span>， 接下来 <span class="hljs-built_in">N</span> 行，每行两个数字代表点的 X 轴和 Y 轴。对于 <span class="hljs-number">50%</span>的数据,  <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">N</span> &lt;= <span class="hljs-number">10000</span>;对于 <span class="hljs-number">100%</span>的数据, <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">N</span> &lt;= <span class="hljs-number">500000</span>;</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs tp">输出“最大的” 点集合， 按照 <span class="hljs-keyword">X</span> 轴从小到大的方式输出，每行两个数字分别代表点的 <span class="hljs-keyword">X</span> 轴和 <span class="hljs-keyword">Y</span>轴。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;using namespace std;<span class="hljs-keyword">struct</span> node&#123;    <span class="hljs-type">int</span> x;    <span class="hljs-type">int</span> y;&#125;;<span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">struct</span> node a,<span class="hljs-keyword">struct</span> node b)&#123;    <span class="hljs-keyword">if</span>(a.x&lt;b.x)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-type">int</span> max(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-keyword">if</span>(a&gt;b)&#123;        <span class="hljs-keyword">return</span> a;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b;    &#125;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">struct</span> node node1[n];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;node1[i].x,&amp;node1[i].y);    &#125;    sort(node1,node1+n,cmp);    <span class="hljs-type">int</span> maxNum[n];    memset(maxNum,<span class="hljs-number">0</span>,sizeof(maxNum));    maxNum[n<span class="hljs-number">-1</span>] = node1[n<span class="hljs-number">-1</span>].y;    <span class="hljs-comment">//找出这个点到最后的数中最大数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        maxNum[i] = max(maxNum[i+<span class="hljs-number">1</span>],node1[i].y);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(node1[i].y==maxNum[i])&#123;            printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,node1[i].x,node1[i].y);        &#125;    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：207ms, 超过89.17%用C++提交的代码<br>   占用内存：19556KB, 超过27.91%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程题2</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%BC%96%E7%A8%8B%E9%A2%982/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%BC%96%E7%A8%8B%E9%A2%982/</url>
    
    <content type="html"><![CDATA[<h3 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a><font size=6px>编程题2</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有n个房间，现在i号房间里的人需要被重新分配，分配的规则是这样的：先让i号房间里的人全都出来，接下来按照 i+1, i+2, i+3, … 的顺序依此往这些房间里放一个人，n号房间的的下一个房间是1号房间，直到所有的人都被重新分配。</p><p>现在告诉你分配完后每个房间的人数以及最后一个人被分配的房间号x，你需要求出分配前每个房间的人数。数据保证一定有解，若有多解输出任意一个解。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行两个整数<span class="hljs-built_in">n</span>, x (<span class="hljs-number">2</span>&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">5</span>, <span class="hljs-number">1</span>&lt;=x&lt;=<span class="hljs-built_in">n</span>)，代表房间房间数量以及最后一个人被分配的房间号；第二行<span class="hljs-built_in">n</span>个整数 a_i(<span class="hljs-number">0</span>&lt;=a_i&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">9</span>) ，代表每个房间分配后的人数。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs excel">输出<span class="hljs-built_in">n</span>个整数，代表每个房间分配前的人数。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><span class="hljs-symbol">6 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找出last左右边最小的数，如果左右边最小的数相等，就选last左边的最小数，写的像屎一样的代码，不想写思路了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n,last,min,min1 <span class="hljs-type">int</span>        fmt.Scan(&amp;n,&amp;last)    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-comment">//找出last左右边最小的数，如果左右边最小的数相等，就选last左边的最小数</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;last;i++&#123;        fmt.Scan(&amp;num[i])        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>&#123;            min = i        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> num[min] &gt;=num[i]&#123;                min = i            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=last;i&lt;n;i++&#123;        fmt.Scan(&amp;num[i])        <span class="hljs-keyword">if</span> i==last&#123;            min1 = i        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> num[min1] &gt;=num[i]&#123;                min1 = i            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> num[min]&gt;num[min1]&#123;        min = min1    &#125;    sum :=<span class="hljs-number">0</span>    minNum :=num[min]    <span class="hljs-keyword">if</span> last &lt; min+<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">for</span> i:=min+<span class="hljs-number">1</span>;i&lt;n;i++&#123;            num[i] -=minNum+<span class="hljs-number">1</span>           &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;last;i++&#123;            num[i] -=minNum+<span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">for</span> i:=last;i&lt;=min;i++&#123;            num[i] -=minNum        &#125;        sum = (last+n-(min+<span class="hljs-number">1</span>))*(minNum+<span class="hljs-number">1</span>)+(n-last-(n-(min+<span class="hljs-number">1</span>)))*minNum    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> last&gt;min+<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=min;i++&#123;            num[i] -=minNum        &#125;         <span class="hljs-keyword">for</span> i:=last;i&lt;n;i++&#123;            num[i] -=minNum        &#125;        <span class="hljs-keyword">for</span> i:=min+<span class="hljs-number">1</span>;i&lt;last;i++&#123;            num[i] -=minNum+<span class="hljs-number">1</span>        &#125;        sum = (last-min<span class="hljs-number">-1</span>) *(minNum+<span class="hljs-number">1</span>)+(n-(last-min)+<span class="hljs-number">1</span>)*minNum    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;            num[i]-=minNum        &#125;        sum = n*minNum    &#125;    num[min] = sum    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,num[i])        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Printf(<span class="hljs-string">&quot; %d&quot;</span>,num[i])        &#125;    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：686ms, 超过66.67%用Go提交的代码<br>   占用内存：6812KB, 超过83.33%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选区间</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E9%80%89%E5%8C%BA%E9%97%B4/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E9%80%89%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="选区间"><a href="#选区间" class="headerlink" title="选区间"></a><font size=6px>选区间</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组序列,需要求选出一个区间,使得该区间是所有区间中经过如下计算的值最大的一个：</p><p>区间中的最小数*区间所有数的和</p><p>最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列 [6 2 1]则根据上述公式,可得到所有可以选定各个区间的计算值:</p><p>[6] &#x3D; 6 * 6 &#x3D; 36;</p><p>[2] &#x3D; 2 * 2 &#x3D; 4;</p><p>[1] &#x3D; 1 * 1 &#x3D; 1;</p><p>[6,2] &#x3D; 2 * 8 &#x3D; 16;</p><p>[2,1] &#x3D; 1 * 3 &#x3D; 3;</p><p>[6, 2, 1] &#x3D; 1 * 9 &#x3D; 9;</p><p>从上述计算可见选定区间[6]，计算值为36， 则程序输出为36。</p><p>区间内的所有数字都在[0, 100]的范围内;</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs">第一行输入数组序列个数，第二行输入数组序列。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">输出数组经过计算后的最大值。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">6 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">36</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把每个数当成最小数，从左到右遍历</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n,max=<span class="hljs-number">-1</span>,sum,res;    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-type">int</span> num[n+<span class="hljs-number">1</span>];    <span class="hljs-type">int</span> numSum[n+<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num[i]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;=<span class="hljs-number">1</span>;j--)&#123;            <span class="hljs-keyword">if</span> (num[j]&gt;=num[i])&#123;                sum +=num[j];            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            <span class="hljs-keyword">if</span> (num[j]&gt;=num[i])&#123;                sum +=num[j];            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        res = num[i]*sum;        sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (max &lt;res)&#123;            max = res;        &#125;    &#125;    printf(<span class="hljs-string">&quot;%d&quot;</span>,max);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：1038ms, 超过19.45%用C++提交的代码<br>   占用内存：3472KB, 超过39.60%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大一生活的总结</title>
    <link href="/2022/01/21/%E5%A4%A7%E5%AD%A6%E4%B8%80%E5%B9%B4%E7%94%9F%E6%B4%BB%E7%9A%84%E6%84%9F%E6%82%9F/"/>
    <url>/2022/01/21/%E5%A4%A7%E5%AD%A6%E4%B8%80%E5%B9%B4%E7%94%9F%E6%B4%BB%E7%9A%84%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<p>​      </p><p>大一生活最大的收获就是从经济转去了计算机，顺便在转去的时候拿了个一等奖学金。</p><p>​      大一的时候把全部精力都投入怎么提高绩点的路上了，其实现在想起来哦，好多东西都学的太迟了，在大一下的时候才从学长学姐那边了解到以后就业分前后端两个大方向，前端是做页面，在vue，react等主流框架下写代码，后端与数据库打交道，写完后写api接口给前端用，其实我最开始选择后端是因为赚钱多，毕竟后端的任务比较难，前端好上手，一写代码就能看到成果，但是好像以后就业活会比较枯燥比较机械，现在开始加入杭助后端，开始学golang和数据库，和大佬比学的太迟了。</p>  <h2>学习篇：</h2><p>​    在大一下疫情在家的时间，自学了c，学习了指针，链表，结构体，数据结构也学了栈，队列，还有到现在都没理解的分治算法（递归的方式看不懂），二叉树，还有自学了python，但是只能写写基础语法，然后在大一下学了前端的html和css语言（确实很好上手，没有什么逻辑关系，就是没有if语句这些判断），最后还有大一下买的吉他，谈了几天到学校就没时间谈学（现在已经积灰了）。</p> <h2>竞赛篇：</h2> <p>大一下参加证卷投资大赛，发现选导师真的很重要，如果他是你的评委老师你做的东西对他口味分数就会高，其实这个比赛策略组根本就不需要基础，导师会给你题目，给你模板和大概方向，你只需要一定时间把word写长和ppt做漂亮，然后给导师改一下，就能得奖。感觉统调，金融创新应该都差不多，含金量不高，还是大创含金量相对高一点，不过最后还是要花大量时间写word和ppt，一般比赛的时候熬夜是常态，推荐竞赛的话血推数模，acm（这比赛大一就要训练，一般人还参加不了），真的挺硬核。你说大一没人带不敢参加竞赛，其实感兴趣大胆参加，你说没想法，你可以只找一个最粗略的想法，然后找导师问问，如果最粗略也没有，只要你脸皮够厚，直接找导师要，毕竟你拿奖了对导师也有好处，最好早点找导师，迟了可能导师人太多不要你，这是我个人意见，看看就好了。（竞赛真的要多参加哦，说不定有意外惊喜，我女朋友就是竞赛认识的）</p>  <h2>社团篇：</h2><p>社团粗略分为三类，学生会杭助非技术部这种干活交朋友写策划社团，滑轮滑板等兴趣社团，红家、杭电助手技术部这种技术社团，当然还有这种特点都有的社团，我大一参加了经济学院学生会，说一下体验吧，几乎学院一半的人都加入了学生会，你可以在里面交到各种各样的人，还有部门联谊，部长也很亲切，不过一般最亲切的还是同部门的人，举办活动还有东西吃圣诞节还会给你送糖果吃，如果你加入了也最好别退，因为你退了的话本来属于你的活就要平均分配到其他小干事身上和部长身上。其实本质来说哦，就是招你去干活的，事情会挺多，真的贼多，好多活动会轮到你们部门出策划，大家就想想法，出策划，不过等你们部门想的活动节目顺利办完了的时候还是有点小成就感的。我感觉我不适合这种部门，而且竞赛和学业这两个事情有可能会和社团的事情重合，那就有你的爽了。兴趣社团我也去，杭助也才刚刚二面，等体验过了以后再说。</p><hr><p>  最后说说我最近的状态吧，等转到计算机，我熬夜已经成为常态，天天1点睡，4天有早课，然后水课补课，主要选了acm（这课很值），数据结构这种课，要花好长时间写作业，还有报了社团，得花很多时间学东西，还有勤工俭学，帮老师改作业，事情太多了，感觉最近人有点累和迷茫了，得找个时间出去散散心。<br>    1、不是特别清楚下一步怎么走，不知道怎么找老师怎么找项目做，2、不知道从学校到实习这一步改怎么走（打算问问已经工作学长学姐），3、不知道怎么去规划自己的后端学习路线（打算问问部长），好迷茫压，感觉最近学习效率也不高，学了一会不想学了。算了，其实也没关系，都是有办法解决的，跨过这座山，他们就会听见你的故事，先写到这里吧，等我 把这3个问题都解决了就更我的未来学习打算，恋爱部分这边不提了，我整一个完整的板块写。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>情侣间的日常琐事记录</title>
    <link href="/2022/01/21/%E6%83%85%E4%BE%A3%E7%94%9C%E8%9C%9C%E5%B0%8F%E6%97%A5%E5%B8%B8/"/>
    <url>/2022/01/21/%E6%83%85%E4%BE%A3%E7%94%9C%E8%9C%9C%E5%B0%8F%E6%97%A5%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="情侣间的日常琐事记录"><a href="#情侣间的日常琐事记录" class="headerlink" title="情侣间的日常琐事记录"></a>情侣间的日常琐事记录</h1><p class="label label-warning"style= "font-size:24px" >记录了一部分成为情侣之后的日常，超甜勿看</p><hr><h3 id="2020-7-10第一次约会去撸猫"><a href="#2020-7-10第一次约会去撸猫" class="headerlink" title="2020.7.10第一次约会去撸猫"></a>2020.7.10第一次约会去撸猫</h3><h3 id="2020-7-12-yyj生日、第一次一起去逛西湖"><a href="#2020-7-12-yyj生日、第一次一起去逛西湖" class="headerlink" title="2020.7.12 yyj生日、第一次一起去逛西湖"></a>2020.7.12 yyj生日、第一次一起去逛西湖</h3><h3 id="2020-7-19-答辩结束-yyj到家啦-虽然结果不咋地-但是收获了一个npy-不错"><a href="#2020-7-19-答辩结束-yyj到家啦-虽然结果不咋地-但是收获了一个npy-不错" class="headerlink" title="2020.7.19 答辩结束:yyj到家啦,虽然结果不咋地,但是收获了一个npy,不错~"></a>2020.7.19 答辩结束:yyj到家啦,虽然结果不咋地,但是收获了一个npy,不错~</h3><h3 id="2020-8-第一次出去玩-乌镇旅游-一起看了一部恐怖片）"><a href="#2020-8-第一次出去玩-乌镇旅游-一起看了一部恐怖片）" class="headerlink" title="2020,8.第一次出去玩(乌镇旅游+一起看了一部恐怖片）"></a>2020,8.第一次出去玩(乌镇旅游+一起看了一部恐怖片）</h3><h3 id="2020-8-2第一出认真的舌吻哈哈"><a href="#2020-8-2第一出认真的舌吻哈哈" class="headerlink" title="2020.8.2第一出认真的舌吻哈哈"></a>2020.8.2第一出认真的舌吻哈哈</h3><h3 id="2020-8-25第一个情人节-看了第一场电影、收获第一支玫瑰🌹"><a href="#2020-8-25第一个情人节-看了第一场电影、收获第一支玫瑰🌹" class="headerlink" title="2020.8.25第一个情人节,看了第一场电影、收获第一支玫瑰🌹"></a>2020.8.25第一个情人节,看了第一场电影、收获第一支玫瑰🌹</h3><h3 id="2020-9-6他来抗州找我玩，第一出去逛了宜家"><a href="#2020-9-6他来抗州找我玩，第一出去逛了宜家" class="headerlink" title="2020.9.6他来抗州找我玩，第一出去逛了宜家"></a>2020.9.6他来抗州找我玩，第一出去逛了宜家</h3><h3 id="2020-10-2获得了秋天第一个柚子"><a href="#2020-10-2获得了秋天第一个柚子" class="headerlink" title="2020.10.2获得了秋天第一个柚子"></a>2020.10.2获得了秋天第一个柚子</h3><p><img src="http://qjzagkyy7.hn-bkt.clouddn.com/%E6%9F%9A%E5%AD%901.jpg" alt="柚子"></p><hr><h3 id="2020-11-13第一次在外面过夜，可惜没看到日出，但是一起包饺子了"><a href="#2020-11-13第一次在外面过夜，可惜没看到日出，但是一起包饺子了" class="headerlink" title="2020.11.13第一次在外面过夜，可惜没看到日出，但是一起包饺子了"></a>2020.11.13第一次在外面过夜，可惜没看到日出，但是一起包饺子了</h3>]]></content>
    
    
    <categories>
      
      <category>生活杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大二上半学期学期总结</title>
    <link href="/2022/01/21/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%8D%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/21/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%8D%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>​    </p><p>​    很快半年就过去了，都懒得写半年总结，每天都在催自己写，每天都说明天一定写，真的人人都笑贝塔，人人都是贝塔，贝塔最经典的语录就是，在寝室晚上的时候“明天一定学习，阿健明天带我去图书馆学习”，然后在寝室玩了一天电脑，其实我也差不多，寒假在家当个废物，不想写算法题不想起床，在家写了一会就不想写了，就叫女朋友打游戏去了。最近有点丧，想个办法改变一下，越玩愧疚感越大。</p><p>​    总的来说，大二上这半年是失败的，考试考试没考好，方法没用对，平时也不怎么努力学，平时都在写acm布置的作业（ps：这作业每周要花好久写），因为想早点去公司实习，要早点开始准备企业的面试，就好好写这个作业，然后其他作业很多都是很草率，什么工程经济学项目管理课都是乱来的，想不去就不去，因为每天差不多一点睡，早上8点起，感觉有报复性迟到的心理，只要是早八课就必迟到。</p><p>​    先说说班级的事情吧，大二转专业来到一个新班级，真就个个是学霸，确实班级里面就有很多大佬，跟他们相处之后发现大一一年一点计算机没学确实落后很多，会比你更早进入实验室、老师的项目、新苗之类的，哦对了，还是选择当班长，班长很水，事情没多少，听着还威风呢，然后还有李子睿同学全程安排了一次班会，班级水果捞，水果吃的很开心，还有班级小游戏玩的很开心。</p><p>​    再说说学业上面做了什么，参加了数学建模认证杯，成功拿了一个参赛奖，还干了啥，上课睡觉，早课迟到，这学期过的很水，感觉有些课真的不太听得懂，比如数据结构，都是好多都是课后自学的。哦对，还有创新实践，我承认这个创新实践是乱选的（听学长推荐的），选了嵌入式，不过老师真的很不错，很和善，教的还好，她带的研究生教的也好，很热心回答问题，我导师她还帮我找了服务外包大赛的队员，谢谢张桦老师。</p><p>  说说我学到了什么，这个确实还是挺多的，加入了杭电助手的后台部，跟着社团接触到了golang语言和它的gorm和gin框架，最近就用goalng写力扣，上acm课系统的学了一遍算法，上数据结构课基础的数据结构都能掌握，上创新实践也了解了一点硬件的知识，硬件和电脑用串口和wifi的两种通信方式，还有学了sql serve，了解了关系型数据库基本的构建过程，就是先画er图之后在建表这些，我还用hexo弄了个静态的博客，现在我打算把它部署到服务器上面，每天更换一张好看的图片到首页，让他变成动态。</p><p>​    说说爱情方面，想想我们这半年都去过什么地方，去过杭州动物园，去良渚看风景，和一起做了一顿饺子（皮厚馅少，面包蟹好吃），一起做了一度饭（好家伙忘记买米了，还没了一把雨伞和忘记拿充电头），一起吃了炸鸡，自助烤肉，牛排，奶酸菜鱼，肯德基，吴山烤禽，一起去点了痣。。。。。</p><p>​    总的来说，是失败的，失败中藏着胜利，这个寒假要做的事情还是很多的，准备浙大的pat考试乙级，学习js，在寒假也开始做服务外包大赛的前期准备，还问了学长接下来go改怎么做，他教我让我自己包装一个阿里dns接口，然后把我的博客用nginx弄成动态再acme部署https证书，还是有很多事情做（自己还这么懒，打自己两巴掌）想好了之后大方向是想做后端&#x2F;算法岗位，不过阿里和字节都举办了前端练习生活动，大公司前端岗位缺失，也会考虑一下前端吧，再说。</p>]]></content>
    
    
    <categories>
      
      <category>生活杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>把hexo博客部署到windows服务器中</title>
    <link href="/2022/01/21/%E6%8A%8A%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/"/>
    <url>/2022/01/21/%E6%8A%8A%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary"; style="font-size:22px">   前提需要：一个三个月以上时间的windows服务器，一个已经备案好的域名，已经会熟悉使用hexo，为了把hexo从github中部署到自己的服务器中。</p><h4 id="1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码"><a href="#1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码" class="headerlink" title="1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码"></a>1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码</h4><p><img src="http://hkctfsys.com/img/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5.png" alt="远程桌面连接"></p><h4 id="2、把IE增强的安全配置给关了（安全就代表麻烦），win-gt-服务器管理器-gt-IE增强的安全配置：启动点进去然后关闭"><a href="#2、把IE增强的安全配置给关了（安全就代表麻烦），win-gt-服务器管理器-gt-IE增强的安全配置：启动点进去然后关闭" class="headerlink" title="2、把IE增强的安全配置给关了（安全就代表麻烦），win-&gt;服务器管理器-&gt;IE增强的安全配置：启动点进去然后关闭"></a>2、把IE增强的安全配置给关了（安全就代表麻烦），win-&gt;服务器管理器-&gt;IE增强的安全配置：启动点进去然后关闭</h4><h4 id="3、下载宝塔-选windows版本，点下载，用来集成配置服务器的好工具"><a href="#3、下载宝塔-选windows版本，点下载，用来集成配置服务器的好工具" class="headerlink" title="3、下载宝塔,选windows版本，点下载，用来集成配置服务器的好工具"></a>3、下载<a href="https://www.bt.cn/">宝塔</a>,选windows版本，点下载，用来集成配置服务器的好工具</h4><p><img src="http://hkctfsys.com/img/%E5%AE%9D%E5%A1%94%E8%BF%9B%E5%85%A5%E7%95%8C%E9%9D%A2.png" alt="宝塔进入界面"></p><h4 id="4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以"><a href="#4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以" class="headerlink" title="4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以"></a>4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以</h4><h4 id="5、宝塔先放放，等下再绑定域名，现在先下载-git和node-（点击可获得安装包，可能不是最新版的也可以去官网下载"><a href="#5、宝塔先放放，等下再绑定域名，现在先下载-git和node-（点击可获得安装包，可能不是最新版的也可以去官网下载" class="headerlink" title="5、宝塔先放放，等下再绑定域名，现在先下载**git和node **（点击可获得安装包，可能不是最新版的也可以去官网下载"></a>5、宝塔先放放，等下再绑定域名，现在先下载**<a href="http://hkctfsys.com/Git-2.30.0.2-64-bit.exe">git</a><strong>和</strong><a href="http://hkctfsys.com/node-v15.10.0-x64.msi">node</a> **（点击可获得安装包，可能不是最新版的也可以去官网下载</h4><p>下载完之后安装，一直点next就行）</p><p>node下载安装有一个注意点是,到这一步要选Add To Path</p><p><img src="http://hkctfsys.com/img/node%E5%AE%89%E8%A3%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.png" alt="node安装注意事项"></p><h4 id="6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git-bosh"><a href="#6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git-bosh" class="headerlink" title="6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git bosh"></a>6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git bosh</h4><p><img src="http://hkctfsys.com/img/gitbosh.png" alt="gitbosh"></p><pre><code class="hljs undefined">npm install -g hexo-cli //如果没反应可以到cmd运行这个代码</code></pre><p>初始化hexo程序，如果有hexo 的人可以直接把hexo文件复制进去就可</p><pre><code class="hljs kotlin">hexo <span class="hljs-keyword">init</span></code></pre><p>然后输入</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span></code></pre><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span></code></pre><p>打开网页，输入<a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到hexo界面了，说明成功一大半了</p><p>![hexo界面](<a href="http://hkctfsys.com/img/hexo">http://hkctfsys.com/img/hexo</a> 界面.png)</p><h4 id="7、下载和配置Nginx"><a href="#7、下载和配置Nginx" class="headerlink" title="7、下载和配置Nginx"></a>7、下载和配置Nginx</h4><p><a href="http://hkctfsys.com/nginx-1.16.1.zip">Nginx安装包</a>，下载了之后点击nginx-1.16.1-&gt;conf-&gt;nginx,这个文件用txt打开，然后把下放的root改成你hexo的public地方，其他不用改</p><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span> &#123;        <span class="hljs-keyword">listen</span>       <span class="hljs-number">80</span>;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.<span class="hljs-keyword">access</span>.<span class="hljs-keyword">log</span>  main;        <span class="hljs-keyword">location</span> / &#123;            root   C:\Users\Administrator\Desktop\hexo\<span class="hljs-built_in">public</span>;            <span class="hljs-keyword">index</span>  <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;        &#125;</code></pre><p>下面介绍为什么要下载nignx和为什么要把root 地址改成hexo的public文件夹，因为source文件夹中makedown文件执行hexo g被编译成html文件放在public文件夹中，并且把网站的根目录指向public文件夹，用Nginx反向代理使得人们可以访问我这个网站。</p><p><img src="http://hkctfsys.com/img/Nginx%E5%8E%9F%E7%90%86.png" alt="http://hkctfsys.com/img/Nginx%E5%8E%9F%E7%90%86.png"></p><h4 id="8、接下来让网站根目录指向public文件夹，打开宝塔软件-信息输入密码之后点保存，然后通过面板地址，http-f-x2F-hkctfsys-com-8990-x2F-OEsp376s（这是我的面板地址，在面板最上面找）"><a href="#8、接下来让网站根目录指向public文件夹，打开宝塔软件-信息输入密码之后点保存，然后通过面板地址，http-f-x2F-hkctfsys-com-8990-x2F-OEsp376s（这是我的面板地址，在面板最上面找）" class="headerlink" title="8、接下来让网站根目录指向public文件夹，打开宝塔软件,信息输入密码之后点保存，然后通过面板地址，http: f&#x2F;hkctfsys. com: 8990&#x2F;OEsp376s（这是我的面板地址，在面板最上面找）"></a>8、接下来让网站根目录指向public文件夹，打开宝塔软件,信息输入密码之后点保存，然后通过面板地址，http: f&#x2F;hkctfsys. com: 8990&#x2F;OEsp376s（这是我的面板地址，在面板最上面找）</h4><p><img src="http://hkctfsys.com/img/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E8%AE%BE%E7%BD%AE.png" alt="http://hkctfsys.com/img/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E8%AE%BE%E7%BD%AE.png"></p><p>然后点开网站-&gt;添加站点,把根目录指向hexo的public文件夹，大功告成啦</p><p><img src="http://hkctfsys.com/img/%E5%AE%9D%E5%A1%94%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9.png" alt="http://hkctfsys.com/img/%E5%AE%9D%E5%A1%94%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9.png"></p><p>现在在浏览器里面输入你的域名，可以正常显示了</p><p><img src="http://hkctfsys.com/img/%E5%8D%9A%E5%AE%A2%E9%A6%96%E9%A1%B5.png" alt="http://hkctfsys.com/img/%E5%8D%9A%E5%AE%A2%E9%A6%96%E9%A1%B5.png"></p>]]></content>
    
    
    <categories>
      
      <category>生活杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>情侣间的小问题</title>
    <link href="/2022/01/21/%E6%83%85%E4%BE%A3%E9%97%B4%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E6%83%85%E4%BE%A3%E9%97%B4%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="问题：粘在一起反而会玩玩不痛快，学的时候效率低学不进去。"><a href="#问题：粘在一起反而会玩玩不痛快，学的时候效率低学不进去。" class="headerlink" title="问题：粘在一起反而会玩玩不痛快，学的时候效率低学不进去。"></a>问题：粘在一起反而会玩玩不痛快，学的时候效率低学不进去。</h4><p>做作业学习都在图书馆，来易班默认就是玩的，默认把时间浪费掉。我们是情侣，不是商业合作伙伴，很多时候的付出其实也没那么计较实质性看得见的回报</p>]]></content>
    
    
    <categories>
      
      <category>生活杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈git的使用</title>
    <link href="/2022/01/21/%E6%B5%85%E8%B0%88git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/21/%E6%B5%85%E8%B0%88git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="观前提醒：我写这个主要是来巩固我学的git操作"><a href="#观前提醒：我写这个主要是来巩固我学的git操作" class="headerlink" title="观前提醒：我写这个主要是来巩固我学的git操作"></a><p class="note note-primary">观前提醒：我写这个主要是来巩固我学的git操作</p></h2><p>在程序中#这个符号后面代表我的注释</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h4 id="0、先安装git，这里我引用别人的文章git安装"><a href="#0、先安装git，这里我引用别人的文章git安装" class="headerlink" title="0、先安装git，这里我引用别人的文章git安装"></a>0、先安装git，这里我引用别人的文章<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">git安装</a></h4><h4 id="1、创建一个文件夹，创建一个readme-txt文件，里面写入hello-git文字（这个之后会用到）"><a href="#1、创建一个文件夹，创建一个readme-txt文件，里面写入hello-git文字（这个之后会用到）" class="headerlink" title="1、创建一个文件夹，创建一个readme.txt文件，里面写入hello git文字（这个之后会用到）"></a>1、创建一个文件夹，创建一个readme.txt文件，里面写入hello git文字（这个之后会用到）</h4><h4 id="2、在文件夹中右键，会有一个Git-Bosh-Here，点这个"><a href="#2、在文件夹中右键，会有一个Git-Bosh-Here，点这个" class="headerlink" title="2、在文件夹中右键，会有一个Git Bosh Here，点这个"></a>2、在文件夹中右键，会有一个Git Bosh Here，点这个</h4><p><img src="/img/gitbosh.png"></p><h4 id="3、配置环境，输入提交人的名字和邮箱"><a href="#3、配置环境，输入提交人的名字和邮箱" class="headerlink" title="3、配置环境，输入提交人的名字和邮箱"></a>3、配置环境，输入提交人的名字和邮箱</h4><pre><code class="hljs stylus"><span class="hljs-variable">$git</span> config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;输入你的名字&quot;</span><span class="hljs-variable">$git</span> config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;输入你的邮箱&quot;</span><span class="hljs-variable">$git</span> config <span class="hljs-attr">--global</span> -l  #查看仓库配置，用来查看你是否配置成功</code></pre><h4 id="4-建立仓库"><a href="#4-建立仓库" class="headerlink" title="4.建立仓库"></a>4.建立仓库</h4><pre><code class="hljs autoit">$git init     <span class="hljs-meta">#会给你创建一个.git隐藏文件，用来存放你的操作记录，注意在你的路径里面最好不要有中文</span></code></pre><h2 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h2><p>创建好文件夹和txt文件之后，在git里面输入</p><pre><code class="hljs autoit">$git status <span class="hljs-meta">#查看现在的仓库状态</span></code></pre><p>会出现这样的语句</p><pre><code class="hljs smali">Untracked files:  <span class="hljs-comment">#有个未被跟踪的readme.txt文件</span>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include in what will be committed)        readme .txtno changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span><span class="hljs-built_in"> and/or </span><span class="hljs-string">&quot;git commit -a&quot;</span>)</code></pre><p>然后添加文件</p><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> readme.txt</code></pre><p>如果提交了没提示那就是提交正确了，输入了命令什么都没提示就是最好的提示。</p><p>最后提交文件</p><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m&quot;写你提交了什么东西，方便回溯的时候看回溯到哪个版本&quot;  #可以<span class="hljs-keyword">add</span>多个文件一起<span class="hljs-keyword">commit</span></code></pre><p>现在再输入git status会显示</p><pre><code class="hljs pgsql">$ git status<span class="hljs-keyword">On</span> branch dev<span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean #没有东西可以提交</code></pre><p>用 git log命令能知道提交人的id和提交日期</p><pre><code class="hljs llvm">$ git logcommit <span class="hljs-number">507671</span>f<span class="hljs-number">473</span>bbbfa<span class="hljs-number">18</span>ec<span class="hljs-number">0</span><span class="hljs-keyword">c</span><span class="hljs-number">2</span>de<span class="hljs-number">9</span>ed<span class="hljs-number">80</span><span class="hljs-keyword">c</span><span class="hljs-number">27</span><span class="hljs-keyword">cc</span><span class="hljs-number">483</span>b<span class="hljs-number">53</span>Author: jess-weigou &lt;<span class="hljs-number">895006375</span><span class="hljs-title">@qq.com</span>&gt;Date:   Fri Nov <span class="hljs-number">13</span> <span class="hljs-number">00</span>:<span class="hljs-number">10</span>:<span class="hljs-number">45</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span>wrote a readme.file</code></pre><p>用 git show命令能知道最近一个人的提交id，id后面回溯的时候要用到</p><pre><code class="hljs sql">$ git <span class="hljs-keyword">show</span><span class="hljs-keyword">commit</span> <span class="hljs-number">20</span>b009be6781d2fe5df568f8bf859bdf7e489408 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> dev) #这一串字母就是                                                                    #<span class="hljs-keyword">commit</span> idAuthor: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Thu Nov <span class="hljs-number">26</span> <span class="hljs-number">09</span>:<span class="hljs-number">44</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    write a readme.txt</code></pre><p>我们再在readme.txt文件中“hello git。”的基础上再添加“hello world”文字，并保存。</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>  我们来讲git最有趣的回溯功能,先用git log功能看提交的记录和提交人的id,这里我提交了多次。</p><pre><code class="hljs sql">$ git log<span class="hljs-keyword">commit</span> <span class="hljs-number">80</span>ee417c0d4eb1803202b762dbabe747fa38d1f6 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> dev)Author: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Mon Nov <span class="hljs-number">30</span> <span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    <span class="hljs-keyword">add</span> hello world<span class="hljs-keyword">commit</span> <span class="hljs-number">3</span>bb0b8bfb6f2f9178d31a4d0cb372b3d87b461aeAuthor: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Sun Nov <span class="hljs-number">29</span> <span class="hljs-number">09</span>:<span class="hljs-number">46</span>:<span class="hljs-number">26</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    <span class="hljs-keyword">add</span> hello world<span class="hljs-keyword">commit</span> <span class="hljs-number">20</span>b009be6781d2fe5df568f8bf859bdf7e489408Author: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Thu Nov <span class="hljs-number">26</span> <span class="hljs-number">09</span>:<span class="hljs-number">44</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    write a readme.txt<span class="hljs-keyword">commit</span> <span class="hljs-number">268</span>d66e08b1ebf50d9ddbf20096504592463051dAuthor: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Thu Nov <span class="hljs-number">26</span> <span class="hljs-number">09</span>:<span class="hljs-number">34</span>:<span class="hljs-number">36</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    write a readme.txt</code></pre><p>用git reset –hard “写提交的id”</p><pre><code class="hljs maxima">$ git <span class="hljs-built_in">reset</span> --hard <span class="hljs-number">20b009</span> #只要前几个字母id就可以匹配到你的提交idHEAD <span class="hljs-built_in">is</span> now <span class="hljs-built_in">at</span> 20b009b write a readme.txt</code></pre><p>这里说head指针已经指向20b009b,我们打开readme.txt，会发现写的“hello world”已经不见了。</p><p><strong>如果回退到以前的版本了还想回会到最新的版本，那咋办？</strong></p><p>找到之前git log的界面，就像我之前git log，那一条最新的日志记录</p><pre><code class="hljs sql">$ git log<span class="hljs-keyword">commit</span> <span class="hljs-number">80</span>ee417c0d4eb1803202b762dbabe747fa38d1f6 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> dev)Author: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Mon Nov <span class="hljs-number">30</span> <span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    <span class="hljs-keyword">add</span> hello world</code></pre><p>输入 git reset –hard “80ee417”就可以回退到之前的最新版本</p><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 80ee417c0</span>HEAD <span class="hljs-keyword">is</span> now at <span class="hljs-number">80</span>ee417 <span class="hljs-keyword">add</span> hello world</code></pre><p>你会发现hello world又出现了，所以别轻易清屏，清屏了也没关系，用git reflog查看历史命令</p><pre><code class="hljs pgsql">$ git reflog<span class="hljs-number">80</span>ee417 (HEAD -&gt; dev) HEAD@&#123;<span class="hljs-number">0</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">80</span>ee417c0<span class="hljs-number">20</span>b009b HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">20</span>b009<span class="hljs-number">80</span>ee417 (HEAD -&gt; dev) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> hello world<span class="hljs-number">3</span>bb0b8b HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> hello world<span class="hljs-number">20</span>b009b HEAD@&#123;<span class="hljs-number">4</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">write</span> a readme.txt<span class="hljs-number">268</span>d66e HEAD@&#123;<span class="hljs-number">5</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">write</span> a readme.txte845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">6</span>&#125;: checkout: moving <span class="hljs-keyword">from</span> master <span class="hljs-keyword">to</span> deve845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">7</span>&#125;: checkout: moving <span class="hljs-keyword">from</span> dev <span class="hljs-keyword">to</span> mastere845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">8</span>&#125;: checkout: moving <span class="hljs-keyword">from</span> master <span class="hljs-keyword">to</span> deve845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">9</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> e845<span class="hljs-number">507671</span>f HEAD@&#123;<span class="hljs-number">10</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">50767</span>e845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">11</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> <span class="hljs-keyword">some</span> words<span class="hljs-number">507671</span>f HEAD@&#123;<span class="hljs-number">12</span>&#125;: <span class="hljs-keyword">commit</span> (initial): wrote a readme.file</code></pre>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跃表</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>为了解决一个有序表查询的问题，发明的跳跃表，为了插入方便选择用链表，但是链表怎么解决查找的问题呢？这就引出我们要介绍的跳跃表</p><p>​    从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数</p><p>为 2 + 4 + 6 &#x3D; 12 次。有没有优化的算法吗?  链表是有序的，但不能使用二分查找。类似二叉</p><p>搜索树，我们把一些节点提取出来，作为索引。得到如下结构：</p><p><img src="https://images0.cnblogs.com/blog2015/408418/201505/151151540794271.jpg" alt="img"></p><p> 这里我们把 &lt; 14, 34, 50, 72 &gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。</p><p>可以再把部分一级索引的数字提取出来成为二级索引</p><h2 id="跳跃表的插入"><a href="#跳跃表的插入" class="headerlink" title="跳跃表的插入"></a>跳跃表的插入</h2><p>先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）</p><p>然后在 Level 1 … Level K 各个层的链表都插入元素。</p><p>例子：插入 119， K &#x3D; 2</p><h2 id="丢硬币决定-K"><a href="#丢硬币决定-K" class="headerlink" title="丢硬币决定 K"></a>丢硬币决定 K</h2><p>插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：</p><h2 id="跳表的高度。"><a href="#跳表的高度。" class="headerlink" title="跳表的高度。"></a>跳表的高度。</h2><p>n 个元素的跳表，每个元素插入的时候都要做一次实验，用来决定元素占据的层数 K，</p><p>跳表的高度等于这 n 次实验中产生的最大 K</p><h2 id="跳表的空间复杂度分析"><a href="#跳表的空间复杂度分析" class="headerlink" title="跳表的空间复杂度分析"></a>跳表的空间复杂度分析</h2><p>根据上面的分析，每个元素的期望高度为 2， 一个大小为 n 的跳表，其节点数目的</p><p>期望值是 2n。本质是以空间换时间</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目问题回答</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94/</url>
    
    <content type="html"><![CDATA[<h5 id="1、接口设计遵循了什么规范"><a href="#1、接口设计遵循了什么规范" class="headerlink" title="1、接口设计遵循了什么规范"></a>1、接口设计遵循了什么规范</h5><p>接口遵循restful规范，post，delete，put，get，分别对应增，删，改，查</p><p>get请求把请求数据放在header或者url上面</p><p>接口复用，比如work接口，用get请求表示获取工作信息，用post表示增加工作信息</p><h5 id="2、服务器上面装了什么"><a href="#2、服务器上面装了什么" class="headerlink" title="2、服务器上面装了什么"></a>2、服务器上面装了什么</h5><p>nginx作为web反向代理服务，mysql作为数据库，并发抗多少没试过</p><h5 id="3、项目遇到的问题"><a href="#3、项目遇到的问题" class="headerlink" title="3、项目遇到的问题"></a>3、项目遇到的问题</h5><p>（1）接受前端给的信息，使用gin框架用shouldbind，bindjson，shouldbindjson等接受数据方法的选择</p><p>这几个方法区别是有should只会返回错误信息，不会自动在header里面自动加入400的错误码</p><p>（2）跨域问题</p><p>​    产生原因：ajax请求只能同源请求，为了防止恶意行为，访问其他域的资源会出现跨域问题</p><p>​    解决方法：在http请求头部加上access-control-allow-origin</p><p>这又有一个问题，发现put请求还有跨域问题，看代码发现Access-Control-Allow-Methods只有post和get，加上put就可以。</p><h5 id="4、部署到服务器方式奇特，因为用的windows-server2012，我是直接在服务器上面下载goland并且运行，代码文件是直接复制过去的，这样就很吃内存，改进之后用ssh连接服务器并且传输文件给服务器，不用goland在cmd里面运行go程序"><a href="#4、部署到服务器方式奇特，因为用的windows-server2012，我是直接在服务器上面下载goland并且运行，代码文件是直接复制过去的，这样就很吃内存，改进之后用ssh连接服务器并且传输文件给服务器，不用goland在cmd里面运行go程序" class="headerlink" title="4、部署到服务器方式奇特，因为用的windows server2012，我是直接在服务器上面下载goland并且运行，代码文件是直接复制过去的，这样就很吃内存，改进之后用ssh连接服务器并且传输文件给服务器，不用goland在cmd里面运行go程序"></a>4、部署到服务器方式奇特，因为用的windows server2012，我是直接在服务器上面下载goland并且运行，代码文件是直接复制过去的，这样就很吃内存，改进之后用ssh连接服务器并且传输文件给服务器，不用goland在cmd里面运行go程序</h5><h5 id="5、进行部署的时候无代理拉不下来包，用goproxy解决"><a href="#5、进行部署的时候无代理拉不下来包，用goproxy解决" class="headerlink" title="5、进行部署的时候无代理拉不下来包，用goproxy解决"></a>5、进行部署的时候无代理拉不下来包，用goproxy解决</h5><h5 id="6、在路由的时候用group把工作模块的路由都包括了，但是细分到具体路由输入了“-x2F-”"><a href="#6、在路由的时候用group把工作模块的路由都包括了，但是细分到具体路由输入了“-x2F-”" class="headerlink" title="6、在路由的时候用group把工作模块的路由都包括了，但是细分到具体路由输入了“&#x2F;”"></a>6、在路由的时候用group把工作模块的路由都包括了，但是细分到具体路由输入了“&#x2F;”</h5><pre><code class="hljs pf"><span class="hljs-literal">self</span>Info:=r.Group(<span class="hljs-string">&quot;/profiles/:phone&quot;</span>)    &#123;       <span class="hljs-literal">self</span>Info.GET(<span class="hljs-string">&quot;/&quot;</span>,s.GetSelfDetail)       <span class="hljs-literal">self</span>Info.PUT(<span class="hljs-string">&quot;/&quot;</span>,s.ModifySelfDetail)    &#125;</code></pre><p>像这样，最后url出来是&#x2F;profiles&#x2F;:phone&#x2F;，这样gin会报一个307的错误，因为这样接口请求会被重定向，丢失Authorization头</p><h5 id="7、er图设计中未考虑token，每个表的功能不清晰，混杂在一起，后期分成一张张功能明确的表（请介绍一下）"><a href="#7、er图设计中未考虑token，每个表的功能不清晰，混杂在一起，后期分成一张张功能明确的表（请介绍一下）" class="headerlink" title="7、er图设计中未考虑token，每个表的功能不清晰，混杂在一起，后期分成一张张功能明确的表（请介绍一下）"></a>7、er图设计中未考虑token，每个表的功能不清晰，混杂在一起，后期分成一张张功能明确的表（请介绍一下）</h5><p>账号表一张，存储个人账号密码（MD5加密）token，一个表存放个人详细信息，身份证号之类的，另一个表存放工作信息，像绩效出勤之类的要经常改变的表就再分出来一个</p><h5 id="8、讲讲项目结构"><a href="#8、讲讲项目结构" class="headerlink" title="8、讲讲项目结构"></a>8、讲讲项目结构</h5><p>一个service存放方法，有initconfig，initDB，initrouter，config文件里面把数据库配置信息读进来，database存放initDB，用来连接数据库，router里面存放接口，model里面存放各种表的结构体，method里面放路由方法，utils里面封装了错误和正确返回。</p><p>存在的问题：项目结构单一，不能满足面向对象的封装，继承，多态，且项目可复用性很差，无法灵活的增加需求，需要改动原来的代码。</p><h5 id="9、熟悉golang语言，有没有用过语言特性"><a href="#9、熟悉golang语言，有没有用过语言特性" class="headerlink" title="9、熟悉golang语言，有没有用过语言特性"></a>9、熟悉golang语言，有没有用过语言特性</h5><p>1、用过交换的语法糖，只有for循环，并且for循环的时候是用循环地址，把值赋值给地址，然后输出这个地址的值，for循环把地址传给多个值，多个值会相同</p><p>2、知道切片扩充是开辟一个新内存再把原来的值复制进去，每次扩充容量都乘2，到1024之后每次扩充百分之25</p><p>3、defer调用的时候是倒叙调用</p><p>4、接口是鸭子类型，如果叫起来是鸭子，跑起来的鸭子，那他就是鸭子，写过自定义sort函数，重写sort函数接口</p><h5 id="10、golang-GC了解吗"><a href="#10、golang-GC了解吗" class="headerlink" title="10、golang GC了解吗"></a>10、golang GC了解吗</h5><p>了解过，golang的垃圾回收，golang使用三色标记法，开始每个事件都是白色，扫描到一个进程，标记为灰色，就把他丢入队列，每次从队列取出来一个，从这个事件的开始遍历这个事件引出的其他事件，然后把这个事件标记成黑色，有二叉树层次遍历那味，不会重新遍历黑色的事件，知道灰色事件队列没事件了，清除白色事件。</p><p>GC触发条件：</p><p>1、长时间（2分钟）没GC，就GC一次</p><p>2、内存分配到一定比例</p><p>3、手动</p><h6 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h6><p>因为程序与标记是并发运行的，可能这个事件已经是黑色的还会引出事件，这个时候新事件还是白色，会被清除，这个时候加入写屏障，约定在清扫开始前黑色事件不引出其他事件</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分模块刷力扣题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/1%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E7%89%9B%E5%AE%A2%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/1%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E7%89%9B%E5%AE%A2%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><style>table th:first-of-type {    width: 20%;}table th:nth-of-type(2) {    width: 50%;}table th:nth-of-type(3) {    width: 20%;} table th:nth-of-type(4) {    width: 30%;}</style><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">题目</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">万万没想到之抓捕孔连顺</td><td align="center"></td><td align="center">golang</td><td align="center">普通</td></tr><tr><td align="center">机器人跳跃问题</td><td align="center">认真读题目</td><td align="center">golang</td><td align="center">普通</td></tr><tr><td align="center">选区间</td><td align="center"></td><td align="center">c</td><td align="center">中等</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">万万没想到之聪明的编辑</td><td align="center"></td><td align="center">go</td><td align="center">入门</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">字节跳动附加题</td><td align="center">熟悉了递推式</td><td align="center">go</td><td align="center">普通</td></tr><tr><td align="center">编程题2</td><td align="center"></td><td align="center">go</td><td align="center">中等</td></tr><tr><td align="center">字母交换</td><td align="center">看懂递推式</td><td align="center">c</td><td align="center">普通</td></tr><tr><td align="center">毕业旅行问题</td><td align="center">学会压缩状态动态规划</td><td align="center">c</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">头条校招</td><td align="center"></td><td align="center">go</td><td align="center">普通</td></tr><tr><td align="center">最大点集</td><td align="center"></td><td align="center">c</td><td align="center">普通</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>万万没想到之抓捕孔连顺</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E6%8A%93%E6%8D%95%E5%AD%94%E8%BF%9E%E9%A1%BA/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E6%8A%93%E6%8D%95%E5%AD%94%E8%BF%9E%E9%A1%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="万万没想到之抓捕孔连顺"><a href="#万万没想到之抓捕孔连顺" class="headerlink" title="万万没想到之抓捕孔连顺"></a><font size=6px>万万没想到之抓捕孔连顺</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议</p><ol><li><p>我们在字节跳动大街的N个建筑中选定3个埋伏地点。</p></li><li><p>为了相互照应，我们决定相距最远的两名特工间的距离不超过D。</p></li></ol><p>我特喵是个天才! 经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！</p><p>……</p><p>万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！</p><p>请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。</p><p>注意：</p><ol><li><p>两个特工不能埋伏在同一地点</p></li><li><p>三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用</p></li></ol><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs mathematica">第一行包含空格分隔的两个数字 <span class="hljs-built_in">N</span>和<span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span> ≤ <span class="hljs-built_in">N</span> ≤ <span class="hljs-number">1000000</span><span class="hljs-operator">;</span> <span class="hljs-number">1</span> ≤ <span class="hljs-built_in">D</span> ≤ <span class="hljs-number">1000000</span><span class="hljs-punctuation">)</span>第二行包含<span class="hljs-built_in">N</span>个建筑物的的位置，每个位置用一个整数（取值区间为<span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-number">1000000</span><span class="hljs-punctuation">]</span>）表示，从小到大排列（将字节跳动大街看做一条数轴）</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs dns">一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 <span class="hljs-number">99997867</span> 取模</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs gcode">可选方案 <span class="hljs-comment">(1, 2, 3)</span>, <span class="hljs-comment">(1, 2, 4)</span>, <span class="hljs-comment">(1, 3, 4)</span>, <span class="hljs-comment">(2, 3, 4)</span></code></pre><p>示例2</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">19</span><span class="hljs-symbol">1 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">50</span></code></pre><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">1</code></pre><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs gcode">可选方案 <span class="hljs-comment">(1, 10, 20)</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先选一个数，然后从后开始遍历找到符合条件（num【j】-num【i】&lt;&#x3D;distance）的第一个数，然后从i+1到j里面选2个数字出来就可以，排列组合问题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a, n, dis,i,j,sum <span class="hljs-type">int</span>mod := <span class="hljs-number">99997867</span>fmt.Scan(&amp;n, &amp;dis)<span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span> &#123;fmt.Println(<span class="hljs-number">0</span>)&#125; <span class="hljs-keyword">else</span> &#123;num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;fmt.Scan(&amp;a)num[i] = a&#125;<span class="hljs-keyword">for</span> i ,j= <span class="hljs-number">0</span>, <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<span class="hljs-keyword">for</span> ;i&gt;=<span class="hljs-number">2</span>&amp;&amp;num[i]-num[j]&gt;dis;&#123;j++&#125;sum += ((i-j)*(i-j<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)&#125;&#125;sum %= modfmt.Println(sum)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：510ms, 超过77.73%用Go提交的代码<br>   占用内存：5636KB, 超过75.78%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>​    举个例子，一个被装饰与多种装饰物，多个装饰物层层嵌套的，举个例子，一个人是被装饰物，衣服，裤子，鞋子，是装饰物，先给人装饰衣服，可以自己选白色衣服，然后用白色裤子装饰穿着白色衣服的人，再用黑色鞋子装饰穿着白色衣服白色鞋子的人，这个装饰关系的嵌套关系。</p><p>​    使用场景是需要添加新功能，但是旧功能全部保留，就可以用装饰模式来设计。好处是把类的核心模块和装饰模块分开了，去除相关类中重复的部分。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的六个原则</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E4%B8%AA%E5%8E%9F%E5%88%99/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E4%B8%AA%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>一个类或者接口只负责唯一职责，尽量设计出单一功能的接口</p><p>给一个类加上各种各样的功能，这就意味着无论任何需求来，都要更改这个类，这很糟糕，维护麻烦，复用更加不可能，也缺乏灵活性。</p><h3 id="2、依赖倒转原则"><a href="#2、依赖倒转原则" class="headerlink" title="2、依赖倒转原则"></a>2、依赖倒转原则</h3><p>高层模块不应该依赖低层模块具体实现，解耦高层和低层，既面向接口编程，当发送变化时，只需要提供新的实现类，不需要修改高层代码</p><p><strong>（1）高层模块不应该依赖于低层模块，两个都应该依赖于抽象</strong></p><p><strong>（2）抽象不应该依赖细节，细节应该依赖于抽象</strong></p><h3 id="3、开放封闭原则"><a href="#3、开放封闭原则" class="headerlink" title="3、开放封闭原则"></a>3、开放封闭原则</h3><p>程序对外扩展开放，对修改关闭，当需求发生变化时，我们可以通过添加新模块来满足新需求，而不是通过修改原来的实现代码来满足新的需求。</p><h3 id="4、迪米特法则（最小知识原则）"><a href="#4、迪米特法则（最小知识原则）" class="headerlink" title="4、迪米特法则（最小知识原则）"></a>4、迪米特法则（最小知识原则）</h3><p>一个软件实体应当尽可能的少与其他实体发生相互作用，每一个软件单位对其他软件单位都只有最少知识</p><h3 id="5、接口隔离原则"><a href="#5、接口隔离原则" class="headerlink" title="5、接口隔离原则"></a>5、接口隔离原则</h3><p>客户端不应该依赖他不需要的接口，类间的依赖关系应建立在最小的接口上。</p><h4 id="接口隔离原则的优点"><a href="#接口隔离原则的优点" class="headerlink" title="接口隔离原则的优点"></a>接口隔离原则的优点</h4><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><ol><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ol><h3 id="6、里式替换原则"><a href="#6、里式替换原则" class="headerlink" title="6、里式替换原则"></a>6、里式替换原则</h3><p>任何基类可以出现的地方，子类一定可以出现，里式代换原则是继承复用的基石。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自我介绍</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>​    面试官你好，很荣幸参加面试,我叫应宇杰，家住绍兴，是一个来自杭电的大二学生，很喜欢计算机这个专业，我是大二开始的时候从经济学院转到计算机学院。在上半年通过了pat乙级考试拿到了600人里面55的排名，参加过服务外包大赛做过一个人才管理系统，在项目中学到了数据库设计和创建和部署的操作，并且也接触了restful风格的接口，也更加深入了解http协议和tcp传输协议。</p><p>​    来之前我也看了咱公司的业务是小微企业贷款，和大公司分开竞争，有很大潜力。做项目用的是go，但是很愿意去转换语言，JAVA学过课程会基础的语言涉及框架还没学。</p><p>项目亮点：</p><p>代码结构完整，各个模块高内聚，并且在数据库方面没用字符串拼接防止sql注入，sql表结构分明，用外键和主键加上索引能加快查找速度。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP四次挥手出现大量time_wait是什么原因</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8Ftime_wait%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8Ftime_wait%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<p>TIME_WAIT产生条件：TCP四次挥手中，第一个发送FIN&#x3D;1的TCP报文的人称为主动关闭者，主动关闭者在发送四次挥手最后一个ACK后会变成TIME_WAIT状态，持续时间为2MSL（linux一个MSL为30s，不可配置）</p><p>TIME_WAIT持续两个MSL的作用：</p><p>1、可靠安全关闭TCP连接，比如网络拥塞，如果主动关闭方最后一个ACK没有被关闭方接收到（它怎么知道有没有被关闭方收到？？），这时被动关闭方会对FIN超时重传，这时尚未关闭的TIME_WAIT就会把这些尾巴问题处理掉，不至于对新连接以及其他服务产生影响</p><p>2、防止由于没有持续的TIME_WAIT时间，导致新的TCP连接建立起来，延迟的FIN重传包会干扰新的连接。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP拥塞处理</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E/</url>
    
    <content type="html"><![CDATA[<h5 id="为什么要TCP拥塞控制"><a href="#为什么要TCP拥塞控制" class="headerlink" title="为什么要TCP拥塞控制"></a>为什么要TCP拥塞控制</h5><h5 id="网络拥塞："><a href="#网络拥塞：" class="headerlink" title="网络拥塞："></a>网络拥塞：</h5><p>​    网络中对某一资源的需求量超过该资源所提供的可用部分，网络性能就会变坏，这种叫做网络拥塞，若出现拥塞不进行控制，随着网络请求的增加会导致吞吐量越来越小，最后会导致吞吐量为0，形成死锁，TCP拥塞控制就是要解决这个问题。</p><p><img src="http://hkctfsys.com/img/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="tcp拥塞控制"></p><h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><h6 id="1、慢开始，拥塞避免"><a href="#1、慢开始，拥塞避免" class="headerlink" title="1、慢开始，拥塞避免"></a>1、慢开始，拥塞避免</h6><p>​    发送方维持一个动态大小的拥塞窗口cwnd（congestion window），假设初始设置慢启动阈值为sstresh16，慢开始起始cwnd为1，服务端返回一个确认报文，每次乘以2，第二次发送2个报文，服务端返回两个确认报文，直到慢启动阈值16为止，开始拥塞避免，每次只加一，服务器返回相同数量的确认报文，直到网络拥塞</p><p>怎么确认网络已经拥塞了？</p><p>假设24个报文在传输过程中有4个报文丢失，有4个报文重传计时器超时，缺失四个数量的确认报文，表示了网络拥塞，然后把慢启动阈值设为网络拥塞时的cwnd的一半，再重置cwnd为1执行慢启动，到达慢启动阈值就开始拥塞避免。</p><h6 id="2、快重传，快恢复"><a href="#2、快重传，快恢复" class="headerlink" title="2、快重传，快恢复"></a>2、快重传，快恢复</h6><p>​    快重传就是让发送方尽快进行重传，在重传计时器超时之前完成重传，假设在发送M3报文后发生了数据报文丢失，没有立即发送确认报文，就发送M4,M5,M6报文，每接收方接收到一次报文，就发送一个确认M3报文，接收到连续三个的确认报文，发送方就知道现在网络是不拥塞的，立即重传M3，接收方回复收到M6，避免重复传，之后从M7开始重新传报文，服务端发送确认M7报文。</p><p>​    快恢复是发送方一但接收三次重复的确认报文，会开始快恢复</p><p>1、发送发会把sstresh慢开始门限值设为当前的cwnd拥塞窗口的一半，开始执行避免拥塞算法</p><p>2、也有把快速恢复开始时的拥塞窗口cwnd再增大一些</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一次完整的HTTP请求过程</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/http%E5%AE%8C%E6%95%B4%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/http%E5%AE%8C%E6%95%B4%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1、域名解析"><a href="#1、域名解析" class="headerlink" title="1、域名解析"></a>1、域名解析</h3><p>浏览器解析域名得到对应的IP地址</p><h3 id="2、TCP三次握手"><a href="#2、TCP三次握手" class="headerlink" title="2、TCP三次握手"></a>2、TCP三次握手</h3><h3 id="3、建立连接发起HTTP请求"><a href="#3、建立连接发起HTTP请求" class="headerlink" title="3、建立连接发起HTTP请求"></a>3、建立连接发起HTTP请求</h3><h3 id="4、服务器响应http请求，浏览器得到html代码"><a href="#4、服务器响应http请求，浏览器得到html代码" class="headerlink" title="4、服务器响应http请求，浏览器得到html代码"></a>4、服务器响应http请求，浏览器得到html代码</h3><h3 id="5、浏览器解析html码，并请求html代码中的资源"><a href="#5、浏览器解析html码，并请求html代码中的资源" class="headerlink" title="5、浏览器解析html码，并请求html代码中的资源"></a>5、浏览器解析html码，并请求html代码中的资源</h3><h3 id="6、浏览器对页面进行渲染给用户"><a href="#6、浏览器对页面进行渲染给用户" class="headerlink" title="6、浏览器对页面进行渲染给用户"></a>6、浏览器对页面进行渲染给用户</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络协议层详情</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82%E8%AF%A6%E6%83%85/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82%E8%AF%A6%E6%83%85/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>OSI七层模型</th><th>TCP四层协议</th><th>综合五层协议</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>应用层</td></tr><tr><td>表示层</td><td></td><td></td></tr><tr><td>会话层</td><td></td><td></td></tr><tr><td>运输层</td><td>运输层</td><td>运输层</td></tr><tr><td>网络层</td><td>网络层</td><td>网络层</td></tr><tr><td>数据链路层</td><td>网络接口层</td><td>数据链路层</td></tr><tr><td>物理层</td><td></td><td>物理层</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>三次握手，四次挥手</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>大值理解：tcp为了确认传输数据的安全，第一次发送特殊tcp报文段给客户，客户第二次回复特殊的tcp报文段给服务器，第三次服务器发送要发送的数据给客户。</p><p><img src="https://img2018.cnblogs.com/blog/1344250/201904/1344250-20190402114137828-2119548758.png"></p><ul><li>第一次客户端发送SYN&#x3D;1和初始化的序列号seq x给服务器请求连接连接（ SYN：同步标志）</li><li>第二次服务器回复ACK&#x3D;1，ack&#x3D;x+1,seq&#x3D;y是发送数据的第一个字符的数据编号，SYN为1 代表收到消息并且也请求连接</li><li>第三次用户回复ACK&#x3D;1，ack为y+1，sep为x+1的tcp报文，连接完毕可以传输数据</li></ul><p>ACK代表确认（acknowledge character）</p><p>序列号seq就是这个报文段中的第一个字节的数据编号</p><h4 id="2、四次挥手"><a href="#2、四次挥手" class="headerlink" title="2、四次挥手"></a>2、四次挥手</h4><p><img src="https://img2018.cnblogs.com/blog/1344250/201904/1344250-20190402114059390-716421818.png"></p><ul><li><p>用户和服务器其中两个都可以终止连接，假设用户想取消连接了，先给服务器发送一个FIN置为1,seq为u的报文</p></li><li><p>服务器收到之后，会立马回复一个ACK为1，ack为u+1，seq为v的报文，ack会自动回复上一个报文加一的seq数据，表示收到。</p></li><li><p>隔了一个close_wait时间回复一个FIN置为1，ACK置为1的报文，seq为w，ack为u+1表示同意，为什么要等待一段时间，是因为要询问上层的软件是否同意关闭，服务器不发FIN代表自己可以收到消息但是客户不会发消息了</p></li><li><p>最后用户回复ACK为1，seq为u+1,ack为w+1的报文，结束连接。</p></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>1、 为什么三次握手和四次挥手？，而不是两次握手</p><p>三次握手是得把ACK和SYN都发送给对方，三次握手才能保证双方都接收到消息，第一次是喂，用户：我要连接，服务器：好，我收到了，用户：我收到你的收到了，如果是两次握手那服务器不知道客户收到没有。四次握手是没必要，已经有很大概率链接连接成功了，而且四次握手需要更多的网络资源。</p><p>四次挥手是ack和fin分开发送，原因就是要确认上层应用同意断开，不然会发生数据丢失</p><p>2、为什么客户端最后还要等待2MSL？</p><p>确实服务器收到了ACK&#x3D;1，如果没收到可以再发，通知上层应用连接要关闭了。</p><p>3、<strong>ISN代表什么？意义何在？</strong></p><p>发送方的字节数据编号的原点，isn代表双方连接的钥匙，钥匙要对上孔</p><p>4、<strong>ISN是固定不变的吗？</strong></p><p>动态随机</p><p>5、<strong>ISN为何要动态随机？</strong></p><p>防止被第三方猜到，从而被第三方仿造的RST报文的reset。</p><p>6、<strong>三次握手的第一次可以携带数据吗？为何？</strong>对方难道不可以将数据缓存下来，等握手成功再提交给应用程序？</p><p><strong>不可以，三次握手还没有完成。</strong>，因为如果带大量1k字节数据的话服务器要开辟大量缓存来处理，容易使服务器拒绝访问，这是洪泛攻击</p><p>7、<strong>第三次可以携带数据吗？为何？</strong></p><p>可以，能够发送第三次代表第二次报文已经接收到了，伪装的ip接收不到第二次报文，所以第三次发送的时候是安全的。</p><p><strong>8、如果输入的端口不存在会怎么办</strong></p><p>握手不能进行，会出现超时未响应的错误。</p><p><strong>9、为什么断开连接却需要四次呢？</strong></p><p>1、确保数据能够完整传输。<br>2、当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>单例模式</p><p>该类负责创建自己的对象，同时确保只有单个对象被创建（构造器私有化）。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul></li></ol><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>优点：</strong></p><ul><li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>2、避免对资源的多重占用（比如写文件操作）。</li></ul><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p>饿汉式：</p><p>​    在类加载时就完成初始化并且返回，线程安全缺点是会产生垃圾对象</p><p>懒汉式：</p><p>​    每次使用判断类是否初始化，未初始化就初始化返回类，初始化了就直接返回，速度快但是无线程安全。</p><p>双次确认懒汉式：</p><p>​    在实例化的时候判断类是不是已经创建好了，如果没有再确认一次是否已经创建，速度快而且线程安全</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>a</p><p>选择一个模板，用clone方法克隆一个，clone有深克隆和浅克隆，浅克隆是直接加引用，深克隆是重新new一个对象实例出来，修改克隆父亲不会改变克隆儿子。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>外观模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>​    外观模式为子系统的一组接口提供一个一致的界面，封装了多个相似的类在一个外观类中，客户调用外观类中的方法来，完美体现依赖倒转原则和迪米特法则</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>建造者模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>举个例子，需要造一个人，需要捏手脚头和身体，就创建一个接口类，来放入捏手脚头和身体的函数的原型，构建一个类来作为指挥者，指挥人的构建，指挥类是用来隔离用户和构造过程之间的联系，最后可以输入不同参数构建起一个不同尺寸的人。这就符合开放封闭原则，要一个胖子只需要增加一个胖子类输入参数就可以构建。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模板方法模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>提取相同的模板封装为一个类，举个例子就是一张试卷，卷子内容一样，不同同学答案不一样，就把相同的那张卷子封装为一个类，每个同学实例化一个卷子对象的时候可以填上自己的答案，这就防止冗余。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>简单工厂模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>​    这种设计模式属于创建型模式，在创建对象时不会对客户端暴露创建逻辑，而是通过使用一个接口指向新创建的对象</p><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</p><p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p><strong>关键代码：</strong>创建过程在其子类执行。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 和 HTTPS 的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP%E5%92%8C%20HTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP%E5%92%8C%20HTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><p> http是超文本传输协议，最开始是为了方便传输html而创建的，传输的信息都是没经过加密的，并且是无状态的，连接通过TCP连接，端口为80，安全性很差，但是连接很简单，速度快减少界面加载延时</p><p>https是经过ssl证书认证并且在传输过程加密的一种传输方式，端口为443安全性大大增加</p><p>安全的基础是ssl协议，连接方式不同（待补充），https是http+ssl协议进行构建的加密传输、身份认证的网络协议，比http协议安全很多，连接方式通常也是tcp，也有可能是SCTP。</p><p>ssl由权威机构颁发，ssl是一个非对称加密，有一个公钥，和一个私钥，用公钥加密后的信息只能由私钥解密，用私钥加密的数据只能公钥解密,公钥放在服务器，私钥放在个人主机。</p><h4 id="http缺点"><a href="#http缺点" class="headerlink" title="http缺点"></a>http缺点</h4><p>1、无法验证报文的完整性</p><p>2、无法验证发送人，所以可能被伪装</p><p>3、通信使用明文，可能信息被窃听</p><p><img src="http://hkctfsys.com/img/http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="http请求报文"></p><p><img src="http://hkctfsys.com/img/http%E6%8A%A5%E6%96%87.png" alt="http报文"></p><h4 id="http常见状态码"><a href="#http常见状态码" class="headerlink" title="http常见状态码"></a>http常见状态码</h4><table><thead><tr><th>http状态码</th><th>解释</th></tr></thead><tbody><tr><td>200 OK</td><td>请求成功完成</td></tr><tr><td>301 Moved Permanently</td><td>永久移动</td></tr><tr><td>302 Found</td><td>临时移动</td></tr><tr><td>400 Bad Request</td><td>客户端请求错误,服务器理解不了</td></tr><tr><td>403 Forbidden</td><td>服务器收到并且理解请求，但是拒绝提供服务</td></tr><tr><td>404 Not Found</td><td>客户端所要找的资源找不到</td></tr><tr><td>500 Internal Server Error</td><td>服务器错误</td></tr></tbody></table><h4 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h4><p>1、get请求表示的意思是要得到信息，并且get请求参数都放header或者url上面，安全性较差放url上面有长度限制，最多1024个字符，不适合传大长度信息。</p><p>2、post请求表示添加信息 ，请求参数作为键值对放在http请求中，不会出现在url中，安全性较get较好</p><p>3、get请求在url不可加入中文字符，会乱码，post可以</p><h4 id="Restful风格的接口"><a href="#Restful风格的接口" class="headerlink" title="Restful风格的接口"></a>Restful风格的接口</h4><p>1、请求头</p><p>get  表示请求数据 ，一般数据放header里面</p><p>post 表示增加数据 ，一般数据放body里面</p><p>put 表示修改数据，一般数据放body里面</p><p>delete  表示删除数据，一般数据放body里面</p><p>2、url的复用，比如work这块，写一个group里面，然后get “&#x2F;”表示获取工作信息，post“&#x2F;”增加工作信息</p><p>3、状态码，详情看上面</p><p>4、制作一个统一的返回信息的格式，写一个可以多处用的success return和error return，返回结果统一json</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP和UDP的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>TCP的优点：提供可靠稳定安全的连接，无差错，不重复，不丢失，三次握手建立连接，数据传输时有确认、窗口、重传、拥塞控制，数据传完还有四次挥手断开连接。</p><p>TCP缺点：慢，效率低，开销较大，占用硬件资源多，传输效率较低，TCP有确认机制容易被人利用，实现DDOS等攻击</p><p>UDP的优点：无状态的传输协议，单位时间传输数据多。</p><p>UDP的缺点：不可靠，在网络不好的时候容易丢包。</p><p>TCP和UPD的区别</p><p>1、基于连接与无连接</p><p>2、对系统资源的要求不同</p><p>3、UDP程序结构比较简单</p><p>4、TCP要求数据正确，保证数据顺序；UDP可能丢包，不保证数据顺序。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>B树、B+树、红黑树、AVL树</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h5 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h5><p>是一个特殊的AVL（平衡二叉搜索树）,需要遵守几个条件</p><p>1、根节点得是黑色的</p><p>2、连续两个红色节点不能连续</p><p>3、根节点到每个子节点遇到的黑色节点数量相同</p><h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><p>1、根节点是黑色的</p><p>2、最大长度为2*（log（n+1））</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>2-3树是B树的一种特例，二叉搜索树搜索效率高，但是为了保持平衡需要的代价太大，所以人想出了一个结点允许多个值的数据结构-B树</p><p> <img src="http://hkctfsys.com/img/B%E6%A0%91.png" alt="B树"></p><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><p>1、所有叶子子结点在同一层上面，和平衡二叉树比层数低，磁盘io少，加快了查询插入速度</p><p>2、每个节点的元素从小到大排列</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><img src="http://hkctfsys.com/img/b%E5%8A%A0%E6%A0%91.png" alt="b+树png"></p><h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><p>1、所有叶子节点都在同一层，并且中间结点是他的子结点的最大或者最小值，最大值在根节点中</p><p>2、所有数据都在子结点上面，子结点包括了所有信息，每个元素不保存数据只用来索引，查询稳定，所有子结点都链接起来，导出全部数据方便</p><p>3、非叶子节点只有key，没有value，叶子节点有key，value</p><h4 id="B树和B-树的区别，为什么mysql会选b-树"><a href="#B树和B-树的区别，为什么mysql会选b-树" class="headerlink" title="B树和B+树的区别，为什么mysql会选b+树"></a>B树和B+树的区别，为什么mysql会选b+树</h4><p>1、B+树的中间节点没有卫星数据，同样大小的磁盘页可以容纳更多的节点元素。意味着，数据量相同的情况下，B+树的结构比B树更加矮胖，因此查询时IO次数更少，B+树更加的矮胖一点，磁盘IO操作少，查询速度比B快</p><p>2、数据库扫库更加方便，范围查询更加方便，查询一段区别的数据比B树方便</p><p>3、查询性能更加稳定，B+树得每次查到叶子结点，B树可能查到中间结点查到数据就终止</p><h4 id="hash比B-树快-为什么还选B-树"><a href="#hash比B-树快-为什么还选B-树" class="headerlink" title="hash比B+树快,为什么还选B+树"></a>hash比B+树快,为什么还选B+树</h4><p>因为只选一个数据是hash块，但是范数据量大无法一次装入内存，范围查询的话是B+树快</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MyISAM与InnoDB 的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MyISAM%E4%B8%8EInnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MyISAM%E4%B8%8EInnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</strong> </p><p>2、 InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p><p>   MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p><p>3、 <strong>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</strong> </p><p>4、 <strong>系统奔溃后，MyISAM恢复起来更困难</strong>，Innodb奔溃了能自动恢复</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>索引底层数据结构是B+数</p><p>单例索引：一个索引只能包含一个列，一个表可以有多个单例索引</p><p>组合索引：一个组合索引包含两个或以上的列，原理简单，在a，b，c字段上创建索引，索引记录会首先安装A排序，A一样照B排序，B一样照C排序。</p><p><img src="http://hkctfsys.com/img/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png"></p><p>聚簇索引：数据存储和索引放一块，b+树叶子节点存放的是数据表的行记录，可以理解成将数据存储和索引放到了一块,这是主键索引，因为InnoDB数据文件本身要按主键聚集，所以InnoDB要求必须有主键，如果没有就自动生成一个隐含的字段作为主键</p><p><img src="http://hkctfsys.com/img/innode%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png"></p><p>为什么mysql表要有一个自增的id主键，因为mysql索引用b+数，得是一个递增的，因为如果不递增增加数据的话得裂表影响效率，而且不建议使用太长的字段作为主键。</p><p>非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。</p><p>聚簇索引优点：</p><ul><li>数据访问更快，因为聚簇索引将数据放在同一个B+树中，所以比非聚簇索引快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul><p>缺点：</p><ul><li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将出现页分裂，严重影响性能，我们一般会定义一个自增的ID作为主键</li><li>更新主键的代价很高</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><h3 id="1、一级索引"><a href="#1、一级索引" class="headerlink" title="1、一级索引"></a>1、一级索引</h3><p>索引和数据存储在一起，都存储在同一个B+tree中的叶子节点。一般主键索引都是一级索引。</p><h3 id="2、二级索引"><a href="#2、二级索引" class="headerlink" title="2、二级索引"></a>2、二级索引</h3><p>二级索引树的叶子节点存储的是主键而不是数据。也就是说，在找到索引后，得到对应的主键，再回到一级索引中找主键对应的数据记录。</p><h3 id="3、一级索引和二级索引的关系：回表"><a href="#3、一级索引和二级索引的关系：回表" class="headerlink" title="3、一级索引和二级索引的关系：回表"></a>3、一级索引和二级索引的关系：回表</h3><p>一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引，这叫做“回表”。</p><h3 id="4、索引建立原则"><a href="#4、索引建立原则" class="headerlink" title="4、索引建立原则"></a>4、索引建立原则</h3><p>（1）最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，<br>如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>（2）&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，<br>mysql的查询优化器会帮你优化成索引可以识别的形式</p><p>（3）尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，<br>比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，<br>那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，<br>一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</p><p>（4）索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，<br>原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，<br>显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’);</p><p>（5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库隔离</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>数据库事务的定义：</strong>一个或多个数据库操作</p><h4 id="事物的四大特性"><a href="#事物的四大特性" class="headerlink" title="事物的四大特性"></a>事物的四大特性</h4><p>A atom 原子性  事务执行是原子，一个事务中所有操作，要么全部完成，要么全部不完成，不会结束在中间的环节。</p><p>C Consistency 一致性    在事务开始和事务开始后，数据库的完整性约束没被破坏</p><p>​                            完整性约束：主键的约束没有变，数据库中不能输入不符合约束的值。</p><p>I    isolation 隔离性    多个并发事务相互独立互不影响，多个用户的并发事务访问同一个数据库，一个用户的事务应该被隔离起来不被干扰。</p><p>D durability 持久性    事务处理后对数据的修改是永久的</p><h4 id="不考虑隔离级别会发生的事情"><a href="#不考虑隔离级别会发生的事情" class="headerlink" title="不考虑隔离级别会发生的事情"></a>不考虑隔离级别会发生的事情</h4><p>1、脏读</p><p>一个事务在处理数据时读到别的未提交事务的数据，然后这个数据回滚了</p><p>2、不可重复读</p><p>数据库中的某个数据，在一次事务中多次查询得到的数据不一致，因为另一个事务修改并且提交了</p><p>3、幻读</p><p>假如读取一个数据为1，然后修改为2，另一个事务把这个数据修改成1，第一个事务在读取这个数据还是为1好像未修改一样，这就是幻读，和不可重复读的共同点都是读取了已经提交的数据，但是不可重复读是一个数据，幻读是一批数据整体，解决不可重复读的办法<strong>是锁行</strong>，解决幻读的办法是<strong>锁表</strong>。</p><h4 id="mysql四种隔离级别"><a href="#mysql四种隔离级别" class="headerlink" title="mysql四种隔离级别"></a>mysql四种隔离级别</h4><p>1、读未提交</p><p>如果一个事物已经开始写数据，则另外一个事物则不允许同时进行写操作，但是允许读数据，会出现脏读。</p><p>2、读已提交</p><p>未提交的写事物禁止其他事物访问</p><p>​    可避免脏读</p><p>3、可重复读(数据库默认隔离级别)</p><p>sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。</p><p>​    可避免脏读，不可重复读</p><p>4、串行化</p><p>​    可避免脏读，不可重复读和幻读</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql锁</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>用处：保证数据安全，处理并发访问</p><p>乐观锁定义：（现实中用的较多）默认用户访问正在改变的数据的概率很小，直到修改完成准备提交所作的修改才会将数据锁住修改为再释放。</p><p>悲观锁定义：默认用户访问正在改变的数据的概率很大，会在数据修改时上锁，只有能数据修改后提交才能解锁让其他用户修改这个数据。使用悲观锁会让访问数据库的时间增加，并发性不好。</p><p>共享读锁（S锁）：</p><p>​    如果一个事务对这个对象加了锁，当前事务只能进行读操作，其他事务也可以对这个对象加共享锁。</p><p>排他写锁（X锁）：</p><p>​    加锁之后只能有一个事务对他做写操作和更新操作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux定时任务</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ArchLinux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ArchLinux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>sudo pacman -S cronie</code></p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><pre><code class="hljs nsis"><span class="hljs-comment">#设置开机启动</span>sudo <span class="hljs-params">system</span>ctl enable cronie.service<span class="hljs-comment">#立即启动</span>sudo <span class="hljs-params">system</span>ctl start cronie.service</code></pre><h4 id="crontab用法"><a href="#crontab用法" class="headerlink" title="crontab用法"></a>crontab用法</h4><p>crontab –e : 修改 crontab 文件，如果文件不存在会自动创建。<br>crontab –l : 显示 crontab 文件。<br>crontab -r : 删除 crontab 文件。<br>crontab -ir : 删除 crontab 文件前提醒用户。</p><pre><code class="hljs arcade"><span class="hljs-built_in">minute</span> <span class="hljs-built_in">hour</span> <span class="hljs-built_in">day</span>-of-<span class="hljs-built_in">month</span> <span class="hljs-built_in">month</span>-of-<span class="hljs-built_in">year</span> <span class="hljs-built_in">day</span>-of-<span class="hljs-built_in">week</span> commands</code></pre><p>除了数字还有几个特殊的符号：”*”、”&#x2F;“和”-“、”,”</p><ul><li>*代表所有的取值范围内的数字</li><li>“&#x2F;“代表每的意思,”&#x2F;5”表示每5个单位</li><li>“-“代表从某个数字到某个数字</li><li>“,”分开几个离散的数字</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="三月份-周一到周五-每1分钟执行一次-x2F-runonce-sh"><a href="#三月份-周一到周五-每1分钟执行一次-x2F-runonce-sh" class="headerlink" title="三月份 周一到周五 每1分钟执行一次.&#x2F;runonce.sh"></a>三月份 周一到周五 每1分钟执行一次.&#x2F;runonce.sh</h5><p>*&#x2F;1 * * mar mon-fri .&#x2F;runonce.sh</p><h4 id="每分钟执行一次-x2F-restartTomcat-sh"><a href="#每分钟执行一次-x2F-restartTomcat-sh" class="headerlink" title="每分钟执行一次~&#x2F;restartTomcat.sh"></a>每分钟执行一次~&#x2F;restartTomcat.sh</h4><p>*&#x2F;1 * * * * sh &#x2F;home&#x2F;itkey&#x2F;restartTomcat.sh</p><h5 id="凌晨1点10分执行一次操作"><a href="#凌晨1点10分执行一次操作" class="headerlink" title="凌晨1点10分执行一次操作"></a>凌晨1点10分执行一次操作</h5><p>10 1 * * * sh &#x2F;home&#x2F;apex&#x2F;restartTomcat.sh</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CPU时间片</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E6%97%B6%E9%97%B4%E7%89%87/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E6%97%B6%E9%97%B4%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>现在的操作系统是分时系统，会给每个进程分配相同时间CPU资源，如果这个进程在时间片结束前阻塞或者结束，可以进行CPU切换来提高CPU的利用率。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LINUX和Windows的区别（从底层来说）</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LINUX%E5%92%8CWindows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BB%8E%E5%BA%95%E5%B1%82%E6%9D%A5%E8%AF%B4%EF%BC%89/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LINUX%E5%92%8CWindows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BB%8E%E5%BA%95%E5%B1%82%E6%9D%A5%E8%AF%B4%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>先说一下现象，Linux是服务器和嵌入式的主流操作系统,Windows是个人pc领域的绝对王者</p><p>再来说一下为什么</p><p><strong>Linux的优点：</strong>Linux是开源的，并且有完善的权限管理机制，是适合多用户的操作系统，在广大贡献者的作用下，Linux安全性和稳定性好，能运行一年很少宕机，并且要常年处于开机状态要最好避免内存碎片问题，使用伙伴系统进行内存管理。</p><p>**Windows的优点:**是闭源的，有高度完善好用的图形化界面，吸引广大用户使用，使用傻瓜式的安装软件使用体验，安装包是二进制，防止泄露源代码。</p><p> <strong>Linux和Windows的最大区别在于Linux是高度模块化的</strong></p><p>​    Linux是由数百个小型的独立程序一起运行组成，Linux可以去除不需要的模块从而创造一个迎合特定需要的强健而简洁的操作系统。并且可以模块化编译，修改内核十分方便，修改了一个小东西不用编译整个操作系统。Linux内核分为进程调度，内存管理，进程通信，虚拟文件系统和网络接口。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux常用命令</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>1、ls (list) 查看linux文件夹包含的文件</p><p>ls -a 列出所以文件，包含隐藏文件</p><p>ls -t 以文件修改时间排序</p><p>ls -S 以文件大小排序</p><p>ls -h 以易读大小显示</p><p>ls -l除了文件名之外，还有文件的权限、所有者、文件大小等信息</p><p>2、cd (chaneg directory) 进入目录</p><p>cd   &#x2F;     进入根目录</p><p>cd ~     进入home目录</p><p>cd -     进入上一次工作路径</p><p>cd     !$ 把上个命令的参数作为cd参数用</p><p>3、pwd     查看当前工作路径目录</p><p>pwd    -p    查看软连接的实际路径</p><p>4、rm    remove</p><p>rm    -rf    删除子目录及子目录中所以档案</p><p>5、mkdir    （make directory）创建文件夹</p><p>6、rmdir    (remove directory) 只能删除空目录，删除时必须具有对其父目录的写权限。</p><p>7、mv    （move）    移动文件</p><p>8、cp    （copy）  将原文件复制至目标文件</p><p>cp -i    提示</p><p>cd -r    复制目录及目录内所有项目</p><p>cp    -a    复制的文件与原文件时间一样</p><p>9、cat    </p><p>cat  filename    一次性显示整个文件</p><p>cat    &gt;    filename    从键盘创建一个文件</p><p>cat    file1    file2    &gt;    file    将几个文件合并为一个文件</p><p>cat    -n    输出所有行号</p><p>10、more    功能类似于cat但是可以一页一页方便逐页阅读，按space下一页，b就往回</p><p>more    +3    text.txt    显示文件从第三行起的内容</p><p>11、less    和more类型</p><p>12、head    用来显示档案的开头至标志输出</p><p>13、tail    用于显示指定文件末尾内容</p><p>14、which    </p><p>15、whereis</p><p>16、locate</p><p>17、find</p><p>18、chmod    用于改变linux系统文件或者目录的访问权限，</p><p>u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</p><p>常用参数：</p><p>​    -c 当发送改变时，报告处理信息</p><p>​    -R处理指定目录以及子目录下所有文件</p><p>权限范围：</p><p>​    u：目录或者文件的当前的用户</p><p>​    g：目录或者文件的当前的群组</p><p>​    a：所有 的用户及群组</p><p>实例：</p><p>chmod    a+x    t.log    增加文件t.log所有用户可执行权限</p><p>19、tar    用于压缩和解压文件，本身只有打包功能，打包是将一大堆文件或者目录变成一个总的文件</p><p>常用参数：</p><p>​    -c    （creat）建立新的压缩文件</p><p>​    -f    (file)指定压缩文件</p><p>​    -u 添加改了和现有的文件到压缩包中</p><p>​    -x    从压缩包中抽取文件</p><p>​    -t    显示压缩文件的内容</p><p>​    -z    支持gzip压缩</p><p>​    -j    支持bzip2压缩</p><p>​    -Z    支持compress解压文件</p><p>​    -v    显示操作过程</p><p>20、chown</p><p>21、df    显示磁盘空间使用情况,磁盘空间以1KB显示</p><p>-a    全部文件系统列表</p><p>-h    方便阅读方式显示信息</p><p>-i    显示inode信息</p><p>-l    只显示本地磁盘</p><p>22、du命令</p><p>23、ln    （link）为文件在另外一个位置建立一个同步的链接，默认为硬链接</p><p>dmesg</p><p>isomod</p><p>rmmod</p><p>make</p><p>dhcpcd</p><p>ipconfig</p><p>ifconfig</p><p>xrandr</p><p>pacman</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux硬连接和软连接</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h4 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h4><p>Linux 下的文件是通过索引节点（inode）识别文件，硬链接可以认为为一个指针指向文件索引节点，系统并不分配inode，文件链接数加一。</p><p>不足：1、不可以在不同文件系统的文件间建立链接</p><p>2、只有超级用户才可以为目录创建硬链接</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>没有任何文件系统的限制，任何用户可以创建指向目录的符号链接，有更大灵活性，可以跨越不同机器</p><p>缺点：</p><p>1、链接文件包含有源文件的路径信息，需要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</p><p>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程线程和协程的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>进程是操作系统分配资源的最小单位</p><p>线程是操作系统所能调度执行的最小单位</p><p>协程是用户态的轻量级线程，操作系统所不能开辟的，但是可以由程序控制</p><p>一个进程中有多个线程，一个线程里面可以有多个协程，因为进程是最大的了，进程切换需要的开销很大，但是进程挂了，其他进程因为保护机制会不受影响，但是这个进程里面的线程协程也都会挂掉。</p><h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><p>1、极高的执行效率，因为子程序切换不是线程切换，而是程序自身切换，没有线程切换开销效率高。</p><p>2、不需要多线程的锁机制，因为只有一个线程不存在同时写变量冲突。</p><h3 id="为什么协程切换代价比线程低"><a href="#为什么协程切换代价比线程低" class="headerlink" title="为什么协程切换代价比线程低"></a>为什么协程切换代价比线程低</h3><p>协程切换流程：</p><p>1、保存当前寄存器信息</p><p>2、选择下一个要执行的协程</p><p>3、恢复寄存器上下文</p><p>线程切换流程：</p><p>1、软中断</p><p>2、保存寄存器信息到内核堆栈、</p><p>3、选择下一个要执行的线程</p><p>4、恢复上下文</p><p>5、返回用户堆栈</p><p>需要保存的寄存器信息大小不同，线程需要把寄存器保存到内核堆栈，并且 返回用户堆栈</p><p>协程无多线程锁机制，因为一个协程运行就一个线程。</p><p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p><strong>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行</strong>。</p><p>协程的特点在于是一个线程执行</p><p>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><h4 id="go语言内的协程"><a href="#go语言内的协程" class="headerlink" title="go语言内的协程"></a>go语言内的协程</h4><p>goroutine 非常的<strong>轻量</strong>，初始分配只有 2KB，当栈空间不够用时，会自动扩容。同时，自身存储了执行 stack 信息，用于在调度时能恢复上下文信息。</p><p>而线程比较重，一般初始大小有几 MB(不同系统分配不同)，线程是由操作系统调度，是操作系统的调度基本单位。而 golang 实现了自己的调度机制，goroutine 是它的调度基本单位。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java%E7%BD%91%E6%98%93%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java%E7%BD%91%E6%98%93%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>java网易后端一面面试问题</p><p>1、有没有了解过spring</p><p>没有了解过</p><p>2、java的继承封装多态概念</p><p>封装:隐藏对象的属性和细节，对外提供公共访问方式，让使用者只能通过程序员规定的方法来访问数据</p><p>继承：子类继承父类的方法，具有父类非private 的方法</p><p>多态：重写和重载是实现多态的两种主要方式</p><p>（1）、重写：子类定义了一个方法，其方法名、返回值类型，参数列表与父类中某个方法一样，就说子类重写父类的同名方法。</p><p>（2）、重载：同一个类中存在多个方法的方法名相同，但是参数列表不同，体现了多态。</p><p>3、gorm框架中怎么把go语句转化成mysql语句</p><p>​    对象关系映射（Object Relational Mapping，简称ORM），在业务逻辑层和数据库之间充当桥梁，能够把struct类映射成表，将sql查询全部封装成编程语言的函数，通过函数的链式组合生成最终的sql代码</p><p>4、协程的调度</p><p>每个协程有独立的栈，而栈既保留了变量的值，也保留了函数的调用关系、参数和返回值，CPU中的栈寄存器SP指向了当前协程的栈，而指令寄存器IP保存着下一条要执行的指令地址。因此，从协程1切换到协程2时，首先要把SP、IP寄存器的值为线程1保存下来，再从内存中找出协程2上一次切换前保存好的寄存器值，写入CPU的寄存器，这样就完成了协程切换。（Swoole4实现原理相似。）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA的垃圾回收</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JAVA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JAVA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p>1、怎么样进行垃圾回收</p><p>它自动地释放不再被程序引用的对象，java会在所有活的进程中判断如果没有进程引用它就把它放入删除缓冲区之后隔段时间删除</p><p>2、哪时候运行GC</p><p>在内存快满时或手动执行</p><p>3、可以程序员手动操控吗？</p><p>不可以，是jvm按照程序来回收内存，该对象符合删除条件，就将其加入回收队列，但不是立即销毁对象，何时销毁并释放内存是无法预知的。。</p><p>4、什么内存GC不回收</p><p>静态变量</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目遇到的问题</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%81%9A%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%81%9A%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>bindjson不能接收完整的信息，换成shouldbind就好</p><p>数据库er图的制作</p><p>跨域问题,网上代码默认有get，post方法，我们用put方法就会出现跨域问题</p><p>数据库外键和主键的处理,数据库必须有一个自增的主键</p><p>项目结构简单冗杂，进行重构</p><p>UPDATE tinyint的时候置1后就不能置0</p><p>can not find the package ，包拉不下来，用goproxy</p><p>url最后加了一个&#x2F;</p><p>不加”&#x2F;“,系统会自动进行301的重定向，把url变成末尾加”&#x2F;“的地址。而request.getParameter(“”)仅有一次生命周期，经过两次跳转后，前系统传的值失效了。此外，如直接发送 URL：<a href="http://msdn.microsoft.com/ie/">http://msdn.microsoft.com/ie/</a> 比发送<a href="http://msdn.microsoft.com/ie%E9%80%9F%E5%BA%A6%E5%B0%86%E4%BC%9A%E6%9B%B4%E5%BF%AB%EF%BC%8C%E5%BD%93%E7%84%B6%E8%BF%99%E7%A7%8D%E9%80%9F%E5%BA%A6%E6%98%AF%E6%84%9F%E8%A7%89%E4%B8%8D%E5%88%B0%E7%9A%84%EF%BC%8C%E4%BD%86%E4%BC%98%E5%8C%96%E5%BA%94%E8%AF%A5%E2%80%9C%E5%B0%BD%E5%8F%AF%E8%83%BD%E2%80%9D%EF%BC%8C%E5%87%8F%E5%B0%91%E6%B5%AA%E8%B4%B9%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%82">http://msdn.microsoft.com/ie速度将会更快，当然这种速度是感觉不到的，但优化应该“尽可能”，减少浪费的时间。</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>堆和栈的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h4><ul><li>申请方式不同：栈是由系统自动分配的，堆是程序员自己申请的（实例化一个对象）</li><li>申请大小不同：栈申请获得的空间较小，堆获得的空间较大</li><li>申请效率不同：栈由系统自动分配，速度较快，堆分配速度较慢</li><li>底层不同，栈是连续空间，堆是分散空间</li><li>存储内容不同：栈在函数调用时，在声明一个函数或者声明一个局部变量时会把这个函数放入栈中，函数的各种参数入栈，然后函数结束这个函数就从栈中pop掉，堆一般是头部用一个字节存放堆的大小,存放静态变量，堆中具体内容是人为安排，长时间不用会被gc掉。</li></ul><p>内存泄露：堆内存中内存申请了但是没有释放，每次执行就会申请内存以至于可用内存减少。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>接口和抽象类的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ol><li>抽象类只能继承一次，但是可以实现多个接口</li><li>接口和抽象类必须实现其中所有的方法，抽象类中如果有未实现的抽象方法，那么子类也需要定义为抽象类。抽象类中可以有非抽象的方法，继承接口必须实现接口的全部方法</li><li>接口中的变量必须用 public static final 修饰，并且需要给出初始值。所以实现类不能重新定义，也不能改变其值。</li><li>接口中的方法默认是 public abstract，也只能是这个类型。不能是 static，接口中的方法也不允许子类覆写，抽象类中允许有static 的方法</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON和XML的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JSON%E5%92%8CXML%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JSON%E5%92%8CXML%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>(1)XML定义</strong><br>扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML使用DTD(document type definition)文档类型定义来组织数据;格式统一，跨平台和语言，早已成为业界公认的标准。<br>XML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。</p><p><strong>(2)JSON定义</strong><br>JSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言文本格式，同时也具备类似于C语言的习惯(包括C, C++, C#, Java, JavaScript, Perl, Python等)体系的行为。这些特性使JSON成为理想的数据交换语言。<br>JSON基于JavaScript Programming Language , Standard ECMA-262 3rd Edition - December 1999 的一个子集。</p><h4 id="XML的优缺点"><a href="#XML的优缺点" class="headerlink" title="XML的优缺点"></a>XML的优缺点</h4><p>​    <strong>优点：</strong>1、格式统一，符合标准</p><p>​                2、容易和其他系统进行远程交互</p><p>​                3、SAX解析方式XML提供了对大规模数据的逐步解析方案，这种方案很适合于对大量数据的处理。</p><p>​    <strong>缺点：</strong>1、服务端和客户端解析需要花费大量时间和资源，代码效率过低</p><p>​                2、XML文件庞大，格式复杂，不易压缩，传输占带宽</p><p>​                3、不同浏览器解析XML格式不一样，不兼容</p><h4 id="JSON的优缺点"><a href="#JSON的优缺点" class="headerlink" title="JSON的优缺点"></a>JSON的优缺点</h4><p>​    优点：1、文件简单，格式简单，易压缩，占用带宽小，传输速度更快</p><p>​                2、解析简单，简单的对JSON数据进行读取，占很少服务器时间</p><p>​                3、JSON格式能直接为服务器端代码使用，大大简化服务器端和客户端的代码开发量</p><p>​    缺点：1、没有XML推广的那么深入人心，没有XML那么通用性</p><p>​                2、JSON只提供整体解析方案，而这种方法只在解析较少的数据时才能起到良好的效果</p><p>​                </p><p>​    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GMP</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/GMP/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/GMP/</url>
    
    <content type="html"><![CDATA[<p>1、什么是GMP？</p><p>G是goroutine,M是内核线程的抽象，P是逻辑处理器，提供执行一个go语言代码片段所需要的资源，内存分配状态，任务队列（G），存储了所有需要它来调度的G，可以用户使用gomaxprocs来设置。就是讲golang怎么从cup到实现goroutine</p><p><img src="http://hkctfsys.com/img/GMP.jfif"></p><p>2、如果某个M陷入阻塞如何处理？</p><p>当一个os线程由于io操作而陷入阻塞，P会带其中的G链接到其他M中去，如果M恢复了，会从别的M上拿过来一个P，把原先跑在上面的G0放到p的队列里面，如果找不到P，就把运行在其上面的G0放到全局global runqueue里面。</p><p>3、如果有的M较忙，有的M较闲？</p><p>链接M的P中gorouitne做完了，会去global runqueue中要G，如果没有会从别的M里面要G，一般是一个进程的一半Goroutine。</p><p>4、如果一个G的运行时间过长，导致队列中后续G无法运行？</p><p>会专门创建一个线程sysmon，用于监控和管理，在内部是一个循环，记录所有P的G任务计数schedtick，如果一个P的schedtick一直不增加说明一个G一直在运行，如果运行时间太长（&gt;10ms）就给这个goroutine打标记，下一次遇到这个就直接放到总队列的最后</p><p>5、一个G由于调用被中断，此后如何恢复？</p><p>终端你的时候把在寄存器中的栈信息重新赋值给G，等下一次运行把保存的信息复制到栈里面就可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>defer函数</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/defer%E5%87%BD%E6%95%B0/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/defer%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="1、defer函数参数即时求值"><a href="#1、defer函数参数即时求值" class="headerlink" title="1、defer函数参数即时求值"></a>1、<strong>defer函数参数即时求值</strong></h4><pre><code class="hljs stylus">func <span class="hljs-built_in">g</span>(<span class="hljs-selector-tag">i</span> int) &#123;   fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;g i:&quot;</span>, i)&#125;func <span class="hljs-built_in">f</span>() &#123;   <span class="hljs-selector-tag">i</span> := <span class="hljs-number">100</span>   defer <span class="hljs-built_in">g</span>(i)  <span class="hljs-comment">//1</span>   fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;begin i:&quot;</span>, i)   <span class="hljs-selector-tag">i</span> = <span class="hljs-number">200</span>   fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;end i:&quot;</span>, i)   return&#125;</code></pre><p>会输出begin i :100,end i: 200,最后输出g i:100</p><p><strong>g（）函数延迟执行，参数不会</strong></p><h4 id="2、反序调用"><a href="#2、反序调用" class="headerlink" title="2、反序调用"></a>2、反序调用</h4><pre><code class="hljs gradle">func f() &#123;   defer fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;defer01&quot;</span>)   fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;begin&quot;</span>)   defer fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;defer02&quot;</span>)   fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;----&quot;</span>)   defer fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;defer03&quot;</span>)   fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;end&quot;</span>)   <span class="hljs-keyword">return</span>&#125;</code></pre><pre><code class="hljs asciidoc"><span class="hljs-section">begin</span><span class="hljs-section">----</span>enddefer03defer02defer01</code></pre><h4 id="3、defer与return"><a href="#3、defer与return" class="headerlink" title="3、defer与return"></a>3、defer与return</h4><p><strong>defer 函数的执行既不是在 return 之后也不是在 return 之前，而是一条go语言的 return 语句包含了对 defer 函数的调用</strong>,给你举个例子：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-keyword">var</span> g = <span class="hljs-number">100</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        g = <span class="hljs-number">200</span>    &#125;()     fmt.Printf(<span class="hljs-string">&quot;f: g = %d\n&quot;</span>, g)     <span class="hljs-keyword">return</span> g&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    i := f()    fmt.Printf(<span class="hljs-string">&quot;main: i = %d, g = %d\n&quot;</span>, i, g)&#125;</code></pre><p>输出g &#x3D;100，i &#x3D;100, g &#x3D;200</p><p>这个简单理解，看看下一个例子</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-keyword">var</span> g = <span class="hljs-number">100</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;    r = g    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        r = <span class="hljs-number">200</span>    &#125;()     fmt.Printf(<span class="hljs-string">&quot;f: r = %d\n&quot;</span>, r)     r = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> r&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    i := f()    fmt.Printf(<span class="hljs-string">&quot;main: i = %d, g = %d\n&quot;</span>, i, g)&#125;</code></pre><p>输出：</p><p>r &#x3D;100</p><p>i &#x3D;200, g &#x3D;100</p><p>看起来很冲突的结果，到汇编层面来看，用gdb层面来看，我看不懂，直接说结论</p><p>defer 函数的执行既不是在 return 之后也不是在 return 之前，而是一条go语言的 return 语句包含了对 defer 函数的调用，即 return 会被翻译成如下几条伪指令</p><pre><code class="hljs go">保存返回值到栈上调用<span class="hljs-keyword">defer</span>函数调整函数栈retq指令返回</code></pre><h4 id="自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return-g是先g把值赋值给r-然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r-的值改变了，所以最后return的时候r-x3D-200。"><a href="#自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return-g是先g把值赋值给r-然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r-的值改变了，所以最后return的时候r-x3D-200。" class="headerlink" title="自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return g是先g把值赋值给r,然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r 的值改变了，所以最后return的时候r&#x3D;200。"></a>自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return g是先g把值赋值给r,然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r 的值改变了，所以最后return的时候r&#x3D;200。</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang是怎么实现函数返回多个值的</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC%E7%9A%84/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;a := i + jb := i - j<span class="hljs-keyword">return</span> a, b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a, b := test(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)fmt.Println(a, b)&#125;</code></pre><p>例子很简单，主要是说明golang多值返回的过程，下面编译成汇编</p><pre><code class="hljs maxima"><span class="hljs-built_in">go</span> tool <span class="hljs-built_in">compile</span> -S test.<span class="hljs-built_in">go</span> &gt; test.s</code></pre><pre><code class="hljs x86asm"><span class="hljs-string">&quot;&quot;</span>.test STEXT size=<span class="hljs-number">16</span> args=<span class="hljs-number">0x10</span> locals=<span class="hljs-number">0x0</span> funcid=<span class="hljs-number">0x0</span> <span class="hljs-meta">align</span>=<span class="hljs-number">0x0</span> leaf<span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">5</span>)TEXT<span class="hljs-string">&quot;&quot;</span>.test(SB), LEAF|NOFRAME|ABIInternal, <span class="hljs-number">$0</span>-<span class="hljs-number">16</span><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">5</span>)FUNCDATAZR, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)<span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">5</span>)FUNCDATA<span class="hljs-number">$1</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)<span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">5</span>)FUNCDATA<span class="hljs-number">$5</span>, <span class="hljs-string">&quot;&quot;</span>.test<span class="hljs-number">.</span>arginfo1(SB)<span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">5</span>)FUNCDATA<span class="hljs-number">$6</span>, <span class="hljs-string">&quot;&quot;</span>.test<span class="hljs-number">.</span>argliveinfo(SB)<span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">5</span>)PCDATA<span class="hljs-number">$3</span>, <span class="hljs-number">$1</span><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">6</span>)<span class="hljs-keyword">ADD</span><span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R2</span><span class="hljs-number">0x0004</span> <span class="hljs-number">00004</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">7</span>)<span class="hljs-keyword">SUB</span><span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R1</span><span class="hljs-number">0x0008</span> <span class="hljs-number">00008</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">8</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R0</span><span class="hljs-number">0x000c</span> <span class="hljs-number">00012</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">8</span>)<span class="hljs-keyword">RET</span>(R30)<span class="hljs-number">0x0000</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> 8b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> cb e0 <span class="hljs-number">03</span> <span class="hljs-number">02</span> aa c0 <span class="hljs-number">03</span> 5f d6  .............._.<span class="hljs-string">&quot;&quot;</span>.main STEXT size=<span class="hljs-number">144</span> args=<span class="hljs-number">0x0</span> locals=<span class="hljs-number">0x58</span> funcid=<span class="hljs-number">0x0</span> <span class="hljs-meta">align</span>=<span class="hljs-number">0x0</span><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)TEXT<span class="hljs-string">&quot;&quot;</span>.main(SB), ABIInternal, <span class="hljs-number">$96</span>-<span class="hljs-number">0</span><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-number">16</span>(g), R16<span class="hljs-number">0x0004</span> <span class="hljs-number">00004</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)PCDATA<span class="hljs-number">$0</span>, $-<span class="hljs-number">2</span><span class="hljs-number">0x0004</span> <span class="hljs-number">00004</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-built_in">RSP</span>, R17<span class="hljs-number">0x0008</span> <span class="hljs-number">00008</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)<span class="hljs-keyword">CMP</span>R16, R17<span class="hljs-number">0x000c</span> <span class="hljs-number">00012</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)BLS<span class="hljs-number">132</span><span class="hljs-number">0x0010</span> <span class="hljs-number">00016</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)PCDATA<span class="hljs-number">$0</span>, $-<span class="hljs-number">1</span><span class="hljs-number">0x0010</span> <span class="hljs-number">00016</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-number">.</span>WR30, -<span class="hljs-number">96</span>(<span class="hljs-built_in">RSP</span>)<span class="hljs-number">0x0014</span> <span class="hljs-number">00020</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)<span class="hljs-keyword">MOVD</span>R29, -<span class="hljs-number">8</span>(<span class="hljs-built_in">RSP</span>)<span class="hljs-number">0x0018</span> <span class="hljs-number">00024</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)<span class="hljs-keyword">SUB</span><span class="hljs-number">$8</span>, <span class="hljs-built_in">RSP</span>, R29<span class="hljs-number">0x001c</span> <span class="hljs-number">00028</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)FUNCDATAZR, gclocals·69c1753bd5f81501d95132d08af04464(SB)<span class="hljs-number">0x001c</span> <span class="hljs-number">00028</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)FUNCDATA<span class="hljs-number">$1</span>, gclocals·ef901d0ae51b5399f7d4b5dfa3bc0b42(SB)<span class="hljs-number">0x001c</span> <span class="hljs-number">00028</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)FUNCDATA<span class="hljs-number">$2</span>, <span class="hljs-string">&quot;&quot;</span>.main<span class="hljs-number">.</span>stkobj(SB)<span class="hljs-number">0x001c</span> <span class="hljs-number">00028</span> (&lt;unknown line number&gt;)<span class="hljs-keyword">NOP</span><span class="hljs-number">0x001c</span> <span class="hljs-number">00028</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">12</span>)STP(ZR, ZR), <span class="hljs-string">&quot;&quot;</span>..autotmp_16-<span class="hljs-number">32</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-number">0x0020</span> <span class="hljs-number">00032</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)STP(ZR, ZR), <span class="hljs-string">&quot;&quot;</span>..autotmp_16-<span class="hljs-number">16</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-number">0x0024</span> <span class="hljs-number">00036</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-number">$3</span>, <span class="hljs-built_in">R0</span><span class="hljs-number">0x0028</span> <span class="hljs-number">00040</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)PCDATA<span class="hljs-number">$1</span>, <span class="hljs-number">$1</span><span class="hljs-number">0x0028</span> <span class="hljs-number">00040</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)<span class="hljs-keyword">CALL</span>runtime<span class="hljs-number">.</span>convT64(SB)<span class="hljs-number">0x002c</span> <span class="hljs-number">00044</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)<span class="hljs-keyword">MOVD</span>$type<span class="hljs-number">.</span><span class="hljs-keyword">int</span>(SB), <span class="hljs-built_in">R1</span><span class="hljs-number">0x0034</span> <span class="hljs-number">00052</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-built_in">R1</span>, <span class="hljs-string">&quot;&quot;</span>..autotmp_16-<span class="hljs-number">32</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-number">0x0038</span> <span class="hljs-number">00056</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-built_in">R0</span>, <span class="hljs-string">&quot;&quot;</span>..autotmp_16-<span class="hljs-number">24</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-number">0x003c</span> <span class="hljs-number">00060</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-number">$1</span>, <span class="hljs-built_in">R0</span><span class="hljs-number">0x0040</span> <span class="hljs-number">00064</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)<span class="hljs-keyword">CALL</span>runtime<span class="hljs-number">.</span>convT64(SB)<span class="hljs-number">0x0044</span> <span class="hljs-number">00068</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)<span class="hljs-keyword">MOVD</span>$type<span class="hljs-number">.</span><span class="hljs-keyword">int</span>(SB), <span class="hljs-built_in">R1</span><span class="hljs-number">0x004c</span> <span class="hljs-number">00076</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-built_in">R1</span>, <span class="hljs-string">&quot;&quot;</span>..autotmp_16-<span class="hljs-number">16</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-number">0x0050</span> <span class="hljs-number">00080</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">13</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-built_in">R0</span>, <span class="hljs-string">&quot;&quot;</span>..autotmp_16-<span class="hljs-number">8</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-number">0x0054</span> <span class="hljs-number">00084</span> (&lt;unknown line number&gt;)<span class="hljs-keyword">NOP</span><span class="hljs-number">0x0054</span> <span class="hljs-number">00084</span> (&lt;unknown line number&gt;)PCDATA<span class="hljs-number">$0</span>, $-<span class="hljs-number">3</span><span class="hljs-number">0x0054</span> <span class="hljs-number">00084</span> ($GOROOT/src/fmt/print<span class="hljs-number">.</span>go:<span class="hljs-number">274</span>)<span class="hljs-keyword">MOVD</span>os<span class="hljs-number">.</span>Stdout(SB), <span class="hljs-built_in">R1</span><span class="hljs-number">0x0060</span> <span class="hljs-number">00096</span> ($GOROOT/src/fmt/print<span class="hljs-number">.</span>go:<span class="hljs-number">274</span>)PCDATA<span class="hljs-number">$0</span>, $-<span class="hljs-number">1</span><span class="hljs-number">0x0060</span> <span class="hljs-number">00096</span> ($GOROOT/src/fmt/print<span class="hljs-number">.</span>go:<span class="hljs-number">274</span>)<span class="hljs-keyword">MOVD</span>$go<span class="hljs-number">.</span>itab.*os<span class="hljs-number">.</span>File,io<span class="hljs-number">.</span>Writer(SB), <span class="hljs-built_in">R0</span><span class="hljs-number">0x0068</span> <span class="hljs-number">00104</span> ($GOROOT/src/fmt/print<span class="hljs-number">.</span>go:<span class="hljs-number">274</span>)<span class="hljs-keyword">MOVD</span>$<span class="hljs-string">&quot;&quot;</span>..autotmp_16-<span class="hljs-number">32</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">R2</span><span class="hljs-number">0x006c</span> <span class="hljs-number">00108</span> ($GOROOT/src/fmt/print<span class="hljs-number">.</span>go:<span class="hljs-number">274</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-number">$2</span>, <span class="hljs-built_in">R3</span><span class="hljs-number">0x0070</span> <span class="hljs-number">00112</span> ($GOROOT/src/fmt/print<span class="hljs-number">.</span>go:<span class="hljs-number">274</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-built_in">R3</span>, <span class="hljs-built_in">R4</span><span class="hljs-number">0x0074</span> <span class="hljs-number">00116</span> ($GOROOT/src/fmt/print<span class="hljs-number">.</span>go:<span class="hljs-number">274</span>)PCDATA<span class="hljs-number">$1</span>, ZR<span class="hljs-number">0x0074</span> <span class="hljs-number">00116</span> ($GOROOT/src/fmt/print<span class="hljs-number">.</span>go:<span class="hljs-number">274</span>)<span class="hljs-keyword">CALL</span>fmt<span class="hljs-number">.</span>Fprintln(SB)<span class="hljs-number">0x0078</span> <span class="hljs-number">00120</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">14</span>)<span class="hljs-keyword">MOVD</span>-<span class="hljs-number">8</span>(<span class="hljs-built_in">RSP</span>), R29<span class="hljs-number">0x007c</span> <span class="hljs-number">00124</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">14</span>)<span class="hljs-keyword">MOVD</span><span class="hljs-number">.</span>P<span class="hljs-number">96</span>(<span class="hljs-built_in">RSP</span>), R30<span class="hljs-number">0x0080</span> <span class="hljs-number">00128</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">14</span>)<span class="hljs-keyword">RET</span>(R30)<span class="hljs-number">0x0084</span> <span class="hljs-number">00132</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">14</span>)<span class="hljs-keyword">NOP</span><span class="hljs-number">0x0084</span> <span class="hljs-number">00132</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)PCDATA<span class="hljs-number">$1</span>, $-<span class="hljs-number">1</span><span class="hljs-number">0x0084</span> <span class="hljs-number">00132</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)PCDATA<span class="hljs-number">$0</span>, $-<span class="hljs-number">2</span><span class="hljs-number">0x0084</span> <span class="hljs-number">00132</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)<span class="hljs-keyword">MOVD</span>R30, <span class="hljs-built_in">R3</span><span class="hljs-number">0x0088</span> <span class="hljs-number">00136</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)<span class="hljs-keyword">CALL</span>runtime<span class="hljs-number">.</span>morestack_noctxt(SB)<span class="hljs-number">0x008c</span> <span class="hljs-number">00140</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)PCDATA<span class="hljs-number">$0</span>, $-<span class="hljs-number">1</span><span class="hljs-number">0x008c</span> <span class="hljs-number">00140</span> (<span class="hljs-keyword">test</span><span class="hljs-number">.</span>go:<span class="hljs-number">11</span>)<span class="hljs-keyword">JMP</span><span class="hljs-number">0</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title；golang内存分配"><a href="#title；golang内存分配" class="headerlink" title="title；golang内存分配"></a>title；golang内存分配</h2><p>go语言启动时会分配一块内存，然后切成小块进行管理，分成span，bitmap，arena，</p><p>arena：将内存分成8kb的页（page），一起组成起来称mspan，成为go内存管理的基本单元。</p><p>bitmap：标记堆区使用的映射表，记录哪些区保存对象，哪些区包含指针</p><p>spans:存放mspan指针，根据spans信息很容易找到mspan，可以在GC时更快速找到大块内存mspan。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang后台面试题目</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1、go struct 能不能比较</p><p>struct是强类型语言，不同类型不能比较，同类型才能比较，实例也不能比较，因为实例是指针类型</p><p>2、写出下面代码输出内容</p><pre><code class="hljs autoit">package mainimport (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">func</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;defer_call()&#125;<span class="hljs-keyword">func</span> <span class="hljs-title function_">defer_call</span><span class="hljs-params">()</span> &#123;defer <span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123; <span class="hljs-title function_">fmt</span>.<span class="hljs-title function_">Println</span><span class="hljs-params">(<span class="hljs-string">&quot;打印前&quot;</span>)</span> &#125;<span class="hljs-params">()</span>defer <span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123; <span class="hljs-title function_">fmt</span>.<span class="hljs-title function_">Println</span><span class="hljs-params">(<span class="hljs-string">&quot;打印中&quot;</span>)</span> &#125;<span class="hljs-params">()</span>defer <span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123; <span class="hljs-title function_">fmt</span>.<span class="hljs-title function_">Println</span><span class="hljs-params">(<span class="hljs-string">&quot;打印后&quot;</span>)</span> &#125;<span class="hljs-params">()</span>panic(<span class="hljs-string">&quot;触发异常&quot;</span>)&#125;</code></pre><p>打印后<br>打印中<br>打印前<br>panic: 触发异常</p><h4 id="3、range陷阱"><a href="#3、range陷阱" class="headerlink" title="3、range陷阱"></a>3、range陷阱</h4><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span>import <span class="hljs-string">&quot;fmt&quot;</span>type AStruct struct &#123;    bar string&#125;func <span class="hljs-selector-tag">main</span>() &#123;    list := <span class="hljs-selector-attr">[]</span>AStruct&#123;        &#123;<span class="hljs-string">&quot;1&quot;</span>&#125;,        &#123;<span class="hljs-string">&quot;2&quot;</span>&#125;,        &#123;<span class="hljs-string">&quot;3&quot;</span>&#125;,    &#125;    copyedList := <span class="hljs-built_in">make</span>(<span class="hljs-selector-attr">[]</span>*AStruct, <span class="hljs-built_in">len</span>(list))    <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>,v:= range list &#123;        copyedList<span class="hljs-selector-attr">[i]</span> = &amp;v    &#125;    fmt<span class="hljs-selector-class">.Println</span>(list<span class="hljs-selector-attr">[0]</span>, list<span class="hljs-selector-attr">[1]</span>, list<span class="hljs-selector-attr">[2]</span>)    fmt<span class="hljs-selector-class">.Println</span>(copyedList<span class="hljs-selector-attr">[0]</span>, copyedList<span class="hljs-selector-attr">[1]</span>, copyedList<span class="hljs-selector-attr">[2]</span>)&#125;</code></pre><p>运行这段代码，你就会发现</p><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;2&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"></span><span class="language-xml">&amp;</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"> &amp;</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"> &amp;</span><span class="hljs-template-variable">&#123;3&#125;</span></code></pre><p>怎么都是同一个地址，因为range赋值用的是用的是一个循环变量的地址，Go每次循环都会复用这一”循环变量”，所以一直会输出最后一个数的地址</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> list &#123;  copyedList[i] = &amp;list[i]&#125;</code></pre><h4 id="4、变量的作用域陷阱"><a href="#4、变量的作用域陷阱" class="headerlink" title="4、变量的作用域陷阱"></a>4、变量的作用域陷阱</h4><p>下面这段程序会有什么输出结果？</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;runtime&quot;</span>    <span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)    wg := sync.WaitGroup&#123;&#125;    wg.Add(<span class="hljs-number">20</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;            fmt.Println(<span class="hljs-string">&quot;A: &quot;</span>, i)            wg.Done()        &#125;()    &#125;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;            fmt.Println(<span class="hljs-string">&quot;B: &quot;</span>, i)            wg.Done()        &#125;(i)    &#125;    wg.Wait()&#125;</code></pre><p>A都输出10，B先输出9，然后按顺序输出</p><pre><code class="hljs apache"><span class="hljs-attribute">B</span>:  <span class="hljs-number">9</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">0</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">1</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">2</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">4</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">5</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">6</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">7</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">8</span></code></pre><p>如果不用runtime.GOMAXPROCS(1)约束，就会随机输出A和B，A和B中数字也随机输出,但是A是10</p><pre><code class="hljs apache"><span class="hljs-attribute">A</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">5</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">9</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">1</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">0</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">2</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">4</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">6</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">7</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">8</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span></code></pre><p>为什么A一直会是10，这是一个变量作用域不同引起的</p><h4 id="5、继承和组合的区别和优势劣势（还不懂）"><a href="#5、继承和组合的区别和优势劣势（还不懂）" class="headerlink" title="5、继承和组合的区别和优势劣势（还不懂）"></a>5、继承和组合的区别和优势劣势（还不懂）</h4><p><strong>继承</strong>是一个白盒模型，父类的内部细节对子类是透明的，</p><p><strong>组合</strong>是黑盒模型，父类的内部细节对子类不透明，对现有的对象进行拼装组合产生更复杂的功能</p><h5 id="继承的优点："><a href="#继承的优点：" class="headerlink" title="继承的优点："></a>继承的优点：</h5><p>易于操作，易于修改和拓展父类</p><h5 id="继承的缺点："><a href="#继承的缺点：" class="headerlink" title="继承的缺点："></a>继承的缺点：</h5><p>1、子类和父类缺乏独立性，父类改变子类不得不改变</p><p>2、破坏了封装性</p><h5 id="组合的优点"><a href="#组合的优点" class="headerlink" title="组合的优点"></a>组合的优点</h5><p>1、降低各个模块之间的耦合性</p><p>2、不会破坏封装性，只用一个接口用来连接对象内部的函数</p><p>3、减少依存关系</p><h5 id="组合的缺点"><a href="#组合的缺点" class="headerlink" title="组合的缺点"></a>组合的缺点</h5><p>1、操作困难，对不熟悉的人难以操作</p><p>2、比继承要写更多的代码</p><h4 id="6、go的组合和继承"><a href="#6、go的组合和继承" class="headerlink" title="6、go的组合和继承"></a>6、go的组合和继承</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowA() &#123;    fmt.Println(<span class="hljs-string">&quot;showA&quot;</span>)    p.ShowB()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowB() &#123;    fmt.Println(<span class="hljs-string">&quot;showB&quot;</span>)&#125;<span class="hljs-keyword">type</span> Teacher <span class="hljs-keyword">struct</span> &#123;    People&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Teacher)</span></span> ShowB() &#123;    fmt.Println(<span class="hljs-string">&quot;teacher showB&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    t := Teacher&#123;&#125;    t.ShowA()&#125;</code></pre><p>输出</p><pre><code class="hljs ebnf"><span class="hljs-attribute">showA</span><span class="hljs-attribute">showB</span></code></pre><p>解答：被组合的类型People虽然被包装成Teacher，执行t.ShowA()但是people并不自己会被什么类型组合，所以t.showB()不会执行</p><h4 id="7、select的随机性"><a href="#7、select的随机性" class="headerlink" title="7、select的随机性"></a>7、select的随机性</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)    int_chan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)    string_chan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">1</span>)    int_chan &lt;- <span class="hljs-number">1</span>    string_chan &lt;- <span class="hljs-string">&quot;hello&quot;</span>    <span class="hljs-keyword">select</span> &#123;    <span class="hljs-keyword">case</span> value := &lt;-int_chan:        fmt.Println(value)    <span class="hljs-keyword">case</span> value := &lt;-string_chan:        <span class="hljs-built_in">panic</span>(value)    &#125;&#125;</code></pre><p>答案：select随机执行一个case，有一定概率出现panic（“hello”），一定概率输出1</p><h4 id="8、defer执行顺序"><a href="#8、defer执行顺序" class="headerlink" title="8、defer执行顺序"></a>8、defer执行顺序</h4><pre><code class="hljs stylus">func <span class="hljs-built_in">calc</span>(index string, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> int) int &#123;ret := <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>fmt<span class="hljs-selector-class">.Println</span>(index, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, ret)return ret&#125;func <span class="hljs-selector-tag">main</span>() &#123;<span class="hljs-selector-tag">a</span> := <span class="hljs-number">1</span><span class="hljs-selector-tag">b</span> := <span class="hljs-number">2</span>defer <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-selector-tag">a</span>, <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-selector-tag">a</span>, b))<span class="hljs-selector-tag">a</span> = <span class="hljs-number">0</span>defer <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-selector-tag">a</span>, <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;20&quot;</span>, <span class="hljs-selector-tag">a</span>, b))<span class="hljs-selector-tag">b</span> = <span class="hljs-number">1</span>&#125;</code></pre><p>结果</p><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">20 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre><p>解析;calc(“1”, a, calc(“10”, a, b))会先对这句话里面的a，b赋值，赋值过程中先执行10，同理下一句话先执行20，再是2，最后1，因为defer是像栈一样，最后的先执行</p><h4 id="9、看看下面会有什么问题"><a href="#9、看看下面会有什么问题" class="headerlink" title="9、看看下面会有什么问题"></a>9、看看下面会有什么问题</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> UserAges <span class="hljs-keyword">struct</span> &#123;ages <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>sync.Mutex&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ua *UserAges)</span></span> Add(name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>) &#123;ua.Lock()<span class="hljs-keyword">defer</span> ua.Unlock()ua.ages[name] = age&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ua *UserAges)</span></span> Get(name <span class="hljs-type">string</span>) <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> age, ok := ua.ages[name]; ok &#123;<span class="hljs-keyword">return</span> age&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><p>解答：在并发处理的时候可能会出现<code>fatal error: concurrent map read and map write</code>.，因为get没上锁，在同一时间读写一个东西会出现竞争</p><h4 id="10、printf和Sprintf的区别"><a href="#10、printf和Sprintf的区别" class="headerlink" title="10、printf和Sprintf的区别"></a>10、printf和Sprintf的区别</h4><p>printf</p><ol><li>用传入的格式化规则符将传入的变量写入到标准输出里面(即在终端中有显示)，</li><li>返回值为 写入标准输出的字节数和写入过程中遇到的问题。</li></ol><p>sprintf</p><ol><li>用传入的格式化规则符将传入的变量格式化，(终端中不会有显示)</li><li>返回为 格式化后的字符串。</li></ol><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span>import (    <span class="hljs-string">&quot;fmt&quot;</span>)func <span class="hljs-selector-tag">main</span>()  &#123;    testStr := <span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(<span class="hljs-string">&quot;test str&quot;</span>)    fmt<span class="hljs-selector-class">.Println</span>(testStr, <span class="hljs-string">&quot;hello world&quot;</span>)    <span class="hljs-comment">//[116 101 115 116 32 115 116 114] hello world</span>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, testStr) <span class="hljs-comment">//test str</span>    fmt<span class="hljs-selector-class">.Println</span>()    fmt<span class="hljs-selector-class">.Sprintf</span>(<span class="hljs-string">&quot;%s&quot;</span>, testStr) <span class="hljs-comment">//空，无IO输出</span>    fmt<span class="hljs-selector-class">.Println</span>()    printStr := fmt<span class="hljs-selector-class">.Sprintf</span>(<span class="hljs-string">&quot;%s&quot;</span>, testStr)    fmt<span class="hljs-selector-class">.Println</span>(printStr)    <span class="hljs-comment">//test str</span>&#125;</code></pre><p>sprintf就是把一个[]byte类型的东西格式化成string</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go语言chan缓存和阻塞</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80chan%E7%BC%93%E5%AD%98%E5%92%8C%E9%98%BB%E5%A1%9E/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80chan%E7%BC%93%E5%AD%98%E5%92%8C%E9%98%BB%E5%A1%9E/</url>
    
    <content type="html"><![CDATA[<p>问题：下面迭代会有什么问题</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>) <span class="hljs-comment">//下面的迭代会有什么问题？</span><span class="hljs-keyword">type</span> threadSafeSet <span class="hljs-keyword">struct</span> &#123;sync.RWMutexs []<span class="hljs-keyword">interface</span>&#123;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(set *threadSafeSet)</span></span> Iter() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// 解除注释看看！</span><span class="hljs-comment">//ch := make(chan interface&#123;&#125;,len(set.s))</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;set.RLock()<span class="hljs-keyword">for</span> elem,value := <span class="hljs-keyword">range</span> set.s &#123;ch &lt;- elemfmt.Println(<span class="hljs-string">&quot;Iter:&quot;</span>,elem,value)&#125;<span class="hljs-built_in">close</span>(ch)set.RUnlock()&#125;()<span class="hljs-keyword">return</span> ch&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;th:=threadSafeSet&#123;s:[]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>&#125;,&#125;vs := th.Iter()fmt.Println(&lt;- vs)&#125;</code></pre><p>结果</p><pre><code class="hljs apache"><span class="hljs-attribute">Iter</span>: <span class="hljs-number">0</span> <span class="hljs-number">1</span><span class="hljs-attribute">0</span></code></pre><p>解释一下这段代码，在iter（）里面有一个goroutin，用来执行输入数据到channel里面，这里创了一个0空间的channel缓存，只要输入一个数据就会阻塞，为什么这里还能输入一个，因为倒数第二行输出了一个channel，就可以再输入一个数据然后阻塞。</p><p>如果把vs这个变量取消掉，然后把prinln也去掉，就什么都不能输出了</p><p>为了方便你的理解，把代码里面注释的去掉，把原来那行注释</p><pre><code>ch := make(chan interface&#123;&#125;) //ch := make(chan interface&#123;&#125;,len(set.s))</code></pre><p>现在channel就有两个缓存了，只有能够把数据输入到channel里面不堵塞才能执行这句话</p><pre><code class="hljs reasonml">fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;Iter:&quot;</span>,<span class="hljs-params">elem</span>,<span class="hljs-params">value</span>)</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go语言runtime</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80runtime/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80runtime/</url>
    
    <content type="html"><![CDATA[<p>go语言goroutine用的是协程</p><h4 id="go-runtime中的GC（garbage-collection）过程"><a href="#go-runtime中的GC（garbage-collection）过程" class="headerlink" title="go runtime中的GC（garbage collection）过程"></a>go runtime中的GC（garbage collection）过程</h4><p>用三色标记法和写屏障减少STW（stop the world）的时间</p><h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><ul><li><p>开始事件都标记成白色，从root开始扫描，扫描到的时候标记成灰色，放入到待处理队列里面</p></li><li><p>遍历灰色对象队列，将其引用的对象标记成灰色，自身标记成黑色</p></li><li><p>这样重复遍历，直到待处理队列中无灰色事件，最后将白色事件回收</p></li></ul><h5 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h5><p>标记与程序的并发执行的，会出现一个问题，已经标记为黑色的事件还是会引出对象，这时候这个被引出的对象是白色，因为黑色已经被标记不会被扫描，这个黑色事件引出的白色事件不会被扫描，最后被删掉，为了解决这个问题加入写屏障，约定在清扫开始前的时候黑色的事件不可以引出对象</p><h5 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h5><p>1、内存分配到一定比例</p><p>2、2分钟内没触发过GC，就触发GC</p><p>3、手动触发，调用runtime.GC</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>map</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/map/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/map/</url>
    
    <content type="html"><![CDATA[<p>map分为hmap和bmap，是一个哈希表，是一个数组，golang用链表法解决哈希冲突，如果溢出会弄一个溢出bucket放进去，之后迁移进去，溢出把oldbucket放进newbucket，map类型是[int64]int8，key是int64，value是int8，所以是放七个key，然后连续7个value放在同一个byte里面节省空间</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>切片</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E5%88%87%E7%89%87/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h4 id="1、切片扩容流程"><a href="#1、切片扩容流程" class="headerlink" title="1、切片扩容流程"></a>1、切片扩容流程</h4><p>如果超过容量，会重新扩一个内存，创建新的数组，并把指针指向这个数组，容量如果不超过1024会阔一倍，如果容量超过1024扩容量会每次增加25%。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    a := []<span class="hljs-type">int</span>&#123;&#125;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">33</span>; i++ &#123;        a = <span class="hljs-built_in">append</span>(a, i)        fmt.Print(<span class="hljs-built_in">cap</span>(a), <span class="hljs-string">&quot; &quot;</span>)    &#125;&#125;</code></pre><p>结果：</p><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span></code></pre><h4 id="2、切片和数组区别"><a href="#2、切片和数组区别" class="headerlink" title="2、切片和数组区别"></a>2、切片和数组区别</h4><ul><li><p>切片是可以扩容的，数组定好之后就不能扩容，大小固定</p></li><li><pre><code>var` `x[3]int = [3]int&#123;1,2,3&#125;var` `y[3]int = xfmt.Println(x,y)y[0]=999fmt.Println(x,y)　<pre><code class="hljs">结果</code></pre>[1 2 3] [1 2 3][1 2 3] [999 2 3]<pre><code class="hljs"></code></pre>var x[]int = []int&#123;1,2,3&#125;var y[]int = xfmt.Println(x,y)y[0]=999fmt.Println(x,y)　<pre><code class="hljs">结果</code></pre>[1 2 3] [1 2 3][999 2 3] [999 2 3]<pre><code class="hljs clean">结论：切片赋值是指针赋值，不是简单的数复制，子改变了父也会改变。#### <span class="hljs-number">3</span>、make默认值和append</code></pre>func main() &#123;  s := make([]int, 5)  s = append(s, 1, 2, 3)  fmt.Println(s)&#125;<pre><code class="hljs"></code></pre>[0 0 0 0 0 1 2 3]</code></pre></li></ul><p>解析：</p><p>产生5个空int类型，之后插入1，2，3</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 27. 二叉树的镜像</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><font size=6px>二叉树的镜像</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code> 4</code></pre><p>   &#x2F;   <br>  2     7<br> &#x2F; \   &#x2F; <br>1   3 6   9<br>镜像输出：</p><pre><code> 4</code></pre><p>   &#x2F;   <br>  7     2<br> &#x2F; \   &#x2F; <br>9   6 3   1</p><p>示例 1：</p><p>输入：root &#x3D; [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>每次交互一个父节点的左右子结点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mirrorTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span>  root    &#125;    root.Left,root.Right = mirrorTree(root.Right),mirrorTree(root.Left)    <span class="hljs-keyword">return</span> root&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了18.27%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣第一题：两数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>观前啰嗦：</strong>这是我第一次做力扣题目，本题用c语言做的，接下来打算用go语言写，来锻炼我go语言能力，无论用哪种语言其实都一样，语言是一种工具，思想才是最重要的。</p><h2>1、两数之和</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p> <strong>示例</strong></p><pre><code class="hljs inform7">给定 nums = <span class="hljs-comment">[2, 7, 11, 15]</span>, target = 9因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> = 2 + 7 = 9所以返回 <span class="hljs-comment">[0, 1]</span></code></pre><p>思想：这题思想不难理解，就是第一次错题有些细节要注意，target表示给的最终指，returnSize是个指针，表示最终的返回数个数。</p><p><strong>代码</strong></p><pre><code class="hljs c"><span class="hljs-comment">/*我用最传统的方法写的*/</span><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span>&#123;    *returnSize =<span class="hljs-number">2</span>;<span class="hljs-comment">//用来说明有几个返回大小</span>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a[<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;numsSize;j++)        &#123;            <span class="hljs-keyword">if</span>((nums[i]+nums[j])==target)            &#123;                a[<span class="hljs-number">0</span>]=i;                a[<span class="hljs-number">1</span>]=j;                <span class="hljs-keyword">return</span> a;            &#125;         &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">  执行用时：12 ms, 在所有 C 提交中击败了30.82%的用户<br>  内存消耗：6 MB, 在所有 C 提交中击败了50.75%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十一;乘最多水的容器</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/11.%E4%B9%98%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/11.%E4%B9%98%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:乘最多水的容器</font></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p>示例 1：</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"></p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>示例 2：</p><p>输入：height &#x3D; [1,1]<br>输出：1<br>示例 3：</p><p>输入：height &#x3D; [4,3,2,1,4]<br>输出：16<br>示例 4：</p><p>输入：height &#x3D; [1,2,1]<br>输出：2</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​            用到对撞指针的思路，指针开始指向开头和末尾，从开始和末尾分别判断， 如果  (height[end]&gt;height[first])，就first++。</p><h4 id="go代码"><a href="#go代码" class="headerlink" title="go代码"></a>go代码</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    max:=<span class="hljs-number">0</span>    end:=<span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span>    first:=<span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> first&lt;end&#123;        width := end-first        <span class="hljs-keyword">if</span>(height[end]&gt;height[first])&#123;            ans=width*height[first]            first++        &#125;<span class="hljs-keyword">else</span>&#123;            ans=width*height[end]            end--        &#125;        <span class="hljs-keyword">if</span>(max&lt;ans)&#123;            max=ans        &#125;    &#125;   <span class="hljs-keyword">return</span> max &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了83.14%的用户<br>   内存消耗：6.3 MB, 在所有 Go 提交中击败了53.07%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十三：罗马数字转整数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目-罗马数字转整数"><a href="#题目-罗马数字转整数" class="headerlink" title="题目:罗马数字转整数"></a><font size=6px>题目:罗马数字转整数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>​    一个难点如果小的数字出现在大的数字前面的时候，这个数字变成减而不是加上这个数字的大小，用switch写比较清楚。其他比较简单易理解。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    sum:=<span class="hljs-number">0</span>    len_s:=<span class="hljs-built_in">len</span>(s)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;len_s;i++&#123;        <span class="hljs-keyword">switch</span> s[i]&#123;           <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>:                 sum++                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;V&#x27;</span>|| s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;X&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-2</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>:                sum+=<span class="hljs-number">5</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;V&#x27;</span>|| s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;X&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-2</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>:                sum+=<span class="hljs-number">10</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-20</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:                sum+=<span class="hljs-number">50</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-100</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:                sum+=<span class="hljs-number">100</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-200</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:                sum+=<span class="hljs-number">500</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-1000</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:                sum+=<span class="hljs-number">1000</span>                <span class="hljs-keyword">break</span>         &#125;    &#125;    <span class="hljs-keyword">return</span> sum&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了47.27%的用户<br>   内存消耗：3.1 MB, 在所有 Go 提交中击败了99.24%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十五;三数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="题目-三数之和"><a href="#题目-三数之和" class="headerlink" title="题目:三数之和"></a><font size=6px>题目:三数之和</font></h4><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>难度中等</p><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c &#x3D;</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><pre><code class="hljs inform7">给定数组 nums = <span class="hljs-comment">[-1, 0, 1, 2, -1, -4]</span>，满足要求的三元组集合为：<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[-1, 0, 1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[-1, -1, 2]</span></span><span class="hljs-comment">]</span></code></pre><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​    先排序，再用for从0到length-2中选一个k值，选定k值之后把k后面的数用对撞指针从k+1到length-1用对撞指针求一个值等于-num[k]，记得判断left右边和right左边的值是否和自己相同</p><p><strong>一直出现这个错误，检查之后发现最后少个大括号</strong></p><p><code>Line 40: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;<span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-comment">//先排序</span>    sort.Ints(nums)    length:=<span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    <span class="hljs-comment">//确认好一个数之后用对撞指针</span>     <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;length<span class="hljs-number">-2</span>;k++&#123;        <span class="hljs-keyword">if</span> nums[k]&gt;<span class="hljs-number">0</span> &#123;            <span class="hljs-keyword">break</span>        &#125;        <span class="hljs-keyword">if</span> k&gt;<span class="hljs-number">0</span>&amp;&amp;nums[k]==nums[k<span class="hljs-number">-1</span>]&#123;            <span class="hljs-keyword">continue</span>        &#125;        left:=k+<span class="hljs-number">1</span>        right:=length<span class="hljs-number">-1</span>        <span class="hljs-keyword">for</span> left&lt;right&#123;            sum := nums[left]+nums[right]+nums[k]            <span class="hljs-comment">//要判断left和它右边的值一不一样，right的值和它左边的一不一样</span>            <span class="hljs-keyword">if</span> sum&gt;<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">for</span> right=right<span class="hljs-number">-1</span>;right&gt;left &amp;&amp;nums[right]==nums[right+<span class="hljs-number">1</span>];right-- &#123;&#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum&lt;<span class="hljs-number">0</span> &#123;                <span class="hljs-keyword">for</span> left=left+<span class="hljs-number">1</span>;right&gt;left &amp;&amp;nums[left]==nums[left<span class="hljs-number">-1</span>];left++ &#123;&#125;            &#125;<span class="hljs-keyword">else</span>&#123;                res = <span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;nums[k],nums[left],nums[right]&#125;)                <span class="hljs-keyword">for</span> right=right<span class="hljs-number">-1</span>;right&gt;left &amp;&amp;nums[right]==nums[right+<span class="hljs-number">1</span>];right-- &#123;&#125;                <span class="hljs-keyword">for</span> left=left+<span class="hljs-number">1</span>;right&gt;left &amp;&amp;nums[left]==nums[left<span class="hljs-number">-1</span>];left++ &#123;&#125;                     &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：40 ms, 在所有 Go 提交中击败了52.12%的用户<br>   内存消耗：7.3 MB, 在所有 Go 提交中击败了42.04%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十六 最接近的三数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">庆祝自己第一次达到百分之95以上<p>执行用时：4 ms, 在所有 Go 提交中击败了95.59%的用户</p><p>内存消耗：2.7 MB, 在所有 Go 提交中击败了98.89%的用户</p></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</p><p><strong>提示：</strong></p><ul><li><p>3 &lt;&#x3D; nums.length &lt;&#x3D; 10^3</p></li><li><p>-10^3 &lt;&#x3D; nums[i] &lt;&#x3D; 10^3</p></li><li><p>*-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</p></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>和第十五题类似，先排序，后用对撞指针对后面的数字进行扫描，只需注意一点<strong>return的是sum的值，min却是target-sum</strong></p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-comment">//先排序</span>    min:=<span class="hljs-number">999999</span>    <span class="hljs-keyword">var</span> value <span class="hljs-type">int</span>    sort.Ints(nums)    length:=<span class="hljs-built_in">len</span>(nums)    <span class="hljs-comment">//确认好一个数之后用对撞指针</span>     <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;length<span class="hljs-number">-2</span>;k++&#123;        left:=k+<span class="hljs-number">1</span>        right:=length<span class="hljs-number">-1</span>        <span class="hljs-keyword">for</span> left&lt;right&#123;            sum := nums[left]+nums[right]+nums[k]            <span class="hljs-keyword">if</span>(sum==target)&#123;                <span class="hljs-keyword">return</span> sum            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)&#123;                <span class="hljs-keyword">if</span>(target-sum&lt;min)&#123;                    min=target-sum                    value=sum  <span class="hljs-comment">//这里要注意，return的是sum的值，min却是target-sum</span>                &#125;                left++            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(sum-target&lt;min)&#123;                    min=sum-target                    value=sum                &#125;                right--            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> value&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><font size=6px>电话号码的字母组合</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png"></p><p>示例 1：</p><p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p><p>输入：digits &#x3D; “”<br>输出：[]<br>示例 3：</p><p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]</p><p>提示：</p><p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="map的初体验和使用"><a href="#map的初体验和使用" class="headerlink" title="map的初体验和使用"></a>map的初体验和使用</h5><p>还不知道golang里面的map是什么怎么用，上网搜了一下map是哈希表差不读的，有键值对，直接mp：&#x3D;map[string]string出来的是一个空的没开辟地址的map，要mp：&#x3D;make（map[string]string）才是开辟好地址的，在下面代码使用的结束时候别忘记加逗号</p><p>一道典型的dfs搜索算法，先把一个个字母放进path里面，等i&gt;&#x3D;len(digits)后就append到结果里面<br>还学会了自定义函数里面再自定义函数的用法。dfs看着很简洁，递归代码还是不好理解</p><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(digits <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(digits)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;    &#125;    mp:=<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;    <span class="hljs-string">&quot;2&quot;</span>:<span class="hljs-string">&quot;abc&quot;</span>,    <span class="hljs-string">&quot;3&quot;</span>:<span class="hljs-string">&quot;def&quot;</span>,    <span class="hljs-string">&quot;4&quot;</span>:<span class="hljs-string">&quot;ghi&quot;</span>,    <span class="hljs-string">&quot;5&quot;</span>:<span class="hljs-string">&quot;jkl&quot;</span>,    <span class="hljs-string">&quot;6&quot;</span>:<span class="hljs-string">&quot;mno&quot;</span>,    <span class="hljs-string">&quot;7&quot;</span>:<span class="hljs-string">&quot;pqrs&quot;</span>,    <span class="hljs-string">&quot;8&quot;</span>:<span class="hljs-string">&quot;tuv&quot;</span>,    <span class="hljs-string">&quot;9&quot;</span>:<span class="hljs-string">&quot;wxyz&quot;</span>,    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">string</span>)</span></span>    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">string</span>    dfs=<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>,path <span class="hljs-type">string</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-built_in">len</span>(digits)&#123;            ans=<span class="hljs-built_in">append</span>(ans,path)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> mp[<span class="hljs-type">string</span>(digits[i])]&#123;            <span class="hljs-comment">//第一次写的时候把path+string(v)写在了dfs上一行，结果会不对，回溯的时候回溯会不对</span>            dfs(i+<span class="hljs-number">1</span>,path+<span class="hljs-type">string</span>(v))        &#125;    &#125;    <span class="hljs-comment">//这里是dfs进入的入口</span>    dfs(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>)    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了93.14%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣二十：有效的括号</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="力扣二十：有效的括号"><a href="#力扣二十：有效的括号" class="headerlink" title="力扣二十：有效的括号"></a><font size=6px>力扣二十：有效的括号</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p>示例 1：</p><p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p><p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p><p>输入：s &#x3D; “(]”<br>输出：false<br>示例 4：</p><p>输入：s &#x3D; “([)]”<br>输出：false<br>示例 5：</p><p>输入：s &#x3D; “{[]}”<br>输出：true</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s 仅由括号 ‘()[]{}’ 组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="知道的golang语言知识"><a href="#知道的golang语言知识" class="headerlink" title="知道的golang语言知识"></a>知道的golang语言知识</h5><p>1、知道了golang里面没有数组里面++，–的情况，得写出来，比如是s[i++]不可以，i++可以</p><p>2、’a’在golang里面代表的是int类型，就是字母转ascii码之后的数字，string类型的s，s[0]就是int类型的数字，是rune类型。</p><p>讲一下思路把，简单的数组栈，碰到左边的括号就++，碰到右边的括号就判断–后的数组里面的字母是不是他的左括号，代码里面有三种特殊情况要考虑一些</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> str [<span class="hljs-number">5000</span>]<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> k <span class="hljs-type">int</span>    s_len:=<span class="hljs-built_in">len</span>(s)    <span class="hljs-comment">//情况1：如果括号个数不等于2的倍数或者为0 就说明是false</span>    <span class="hljs-keyword">if</span> s_len%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>||s_len==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;s_len;i++&#123;        <span class="hljs-keyword">if</span> s[i]==<span class="hljs-string">&#x27;(&#x27;</span>||s[i]==<span class="hljs-string">&#x27;[&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>&#123;            str[k]=<span class="hljs-type">string</span>(s[i])            k++        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//情况2：如果第一个就是‘）’，‘]’，‘&#125;’就说明的false</span>            <span class="hljs-keyword">if</span> k==<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;            <span class="hljs-keyword">switch</span> s[i]&#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:                    k--                    <span class="hljs-keyword">if</span> str[k]!=<span class="hljs-string">&quot;(&quot;</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>:                    k--                    <span class="hljs-keyword">if</span> str[k]!=<span class="hljs-string">&quot;[&quot;</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>:                    k--                    <span class="hljs-keyword">if</span> str[k]!=<span class="hljs-string">&quot;&#123;&quot;</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                    <span class="hljs-keyword">break</span>            &#125;        &#125;    &#125;    <span class="hljs-comment">//情况3：如果没有做到一一对应k会大于0 就false</span>    <span class="hljs-keyword">if</span> k&gt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了23.58%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣三：无重复字字符的最长字串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:无重复字字符的最长字串</font></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p><p>输入: s &#x3D; “”<br>输出: 0</p><p>提示：</p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>s 由英文字母、数字、符号和空格组成</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>用滑动窗口法，设置一个数组，初始为0，再初设一个left和right，如果一个字母没有用过就把它</p><p>**&#96;&#96;&#96;**<em>freq[s[right+1]-‘a’]++</em></p><p>，并且往右边划，如果在往右边划的时候遇到一个用到过的字母，就left++，把left上面的字母的频率减1，</p><p>`&#96;&#96;freq[s[left]-‘a’]–</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs golang"><span class="hljs-comment">//用滑动窗口法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;  left,right,max:=<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>  <span class="hljs-keyword">var</span> freq[<span class="hljs-number">256</span>] <span class="hljs-type">int</span>  <span class="hljs-keyword">for</span> left&lt;<span class="hljs-built_in">len</span>(s)&#123;​    <span class="hljs-comment">//go语言很严格，单个字符不能用“a”</span>​    <span class="hljs-keyword">if</span> right+<span class="hljs-number">1</span>&lt;<span class="hljs-built_in">len</span>(s)&amp;&amp;freq[s[right+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-number">0</span>&#123;​      freq[s[right+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]++​      right++​    &#125;<span class="hljs-keyword">else</span>&#123;​      freq[s[left]-<span class="hljs-string">&#x27;a&#x27;</span>]--​      left++​    &#125;​    <span class="hljs-keyword">if</span> max&lt;right-left+<span class="hljs-number">1</span>&#123;​      max=right-left+<span class="hljs-number">1</span>​    &#125;  &#125;  <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.5 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-四十一：缺失一个正数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/41.%E7%BC%BA%E5%A4%B1%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/41.%E7%BC%BA%E5%A4%B1%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p> <font size=6px>题目:缺失一个正数</font></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>​    给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><p>输入: [1,2,0]<br>输出: 3</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><p>输入: [3,4,-1,1]<br>输出: 2</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4><p>输入: [7,8,9,11,12]<br>输出: 1</p><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>用map做，先把数放进map里面<code>map_num[v]=v</code>，再用哈希的思想，判断这个下标和值相不相同。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    map_num:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))    <span class="hljs-keyword">for</span> _,v :=<span class="hljs-keyword">range</span> nums&#123;        map_num[v]=v    &#125;    <span class="hljs-comment">//用map来判断这个值在不在确实很方便</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> _,ok:=map_num[i];!ok&#123;            <span class="hljs-keyword">return</span> i        &#125;    &#125;    <span class="hljs-comment">//如果数字全部有序，就输出个数加一</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了9.44%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣四十二：接雨水</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:接雨水</font></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="示例1图片"></p><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：height &#x3D; [4,2,0,3,2,5]<br>输出：9</p><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><li>n == height.length</li><li>0 <= n <= 3 * 104</li><li>0 <= height[i] <= 105</li><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p class="note note-primary">    单词注释：     height[left] left位置上的格子的数量    maxl 左边格子最大的格子</p><p>  这题比较难，用双指针方法代码比较简洁，用示例1举例子，先找height[left]与height[right]中小的数字，然后执行小数字方代码，如果height[left]比maxl还要大,就把maxl&#x3D;height[left]，如果不是，那就说明这一格肯定可以装水（可以看代码的第一个注释的解释），把所有可以装水的格子的装水量加起来就是答案。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    left,right,maxl,maxr,res := <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> left&lt;=right&#123;         <span class="hljs-keyword">if</span> height[left]&lt;height[right]&#123;             <span class="hljs-keyword">if</span> maxl&lt;=height[left]&#123;                maxl=height[left]             &#125;<span class="hljs-keyword">else</span>&#123;                 <span class="hljs-comment">//左边肯定有比height[left]高的墙，右边有maxr＞maxl，右边肯定有比height[left]高的墙，水在这一格的高度就是maxl-height[left]，下面同理</span>                res = res+maxl-height[left]             &#125;             left++         &#125;<span class="hljs-keyword">else</span>&#123;             <span class="hljs-keyword">if</span> maxr&lt;height[right]&#123;                 maxr=height[right]             &#125;<span class="hljs-keyword">else</span>&#123;                 <span class="hljs-comment">//右边肯定有比height[right]高的墙</span>                res = res+maxr-height[right];             &#125;             right--         &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了74.89%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了81.87%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣四十八：旋转图像</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/48.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/48.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:旋转图像</font></p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><p><strong>示例 1:</strong></p><pre><code class="hljs inform7">给定 matrix = <span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[4,5,6]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[7,8,9]</span></span><span class="hljs-comment">]</span>,原地旋转输入矩阵，使其变为:<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[7,4,1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[8,5,2]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[9,6,3]</span></span><span class="hljs-comment">]</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs inform7">给定 matrix =<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[ 5, 1, 9,11]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[ 2, 4, 8,10]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[13, 3, 6, 7]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[15,14,12,16]</span></span><span class="hljs-comment">]</span>, 原地旋转输入矩阵，使其变为:<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[15,13, 2, 5]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[14, 3, 4, 1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[12, 6, 8, 9]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[16, 7,10,11]</span></span><span class="hljs-comment">]</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这题想清楚了不难，找找规律，就是<strong>矩阵转置</strong>再<strong>镜像翻转</strong>一下就得到结果</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;    swap:=<span class="hljs-number">0</span>    a:=<span class="hljs-built_in">len</span>(matrix)     b:=<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])    <span class="hljs-comment">//下面是矩阵转置部分</span>    <span class="hljs-keyword">for</span> k:=a<span class="hljs-number">-1</span>;k&gt;<span class="hljs-number">0</span>;k--&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;            swap=matrix[a-k<span class="hljs-number">-1</span>][a-i<span class="hljs-number">-1</span>]            matrix[a-k<span class="hljs-number">-1</span>][a-i<span class="hljs-number">-1</span>]=matrix[a-i<span class="hljs-number">-1</span>][a-k<span class="hljs-number">-1</span>]            matrix[a-i<span class="hljs-number">-1</span>][a-k<span class="hljs-number">-1</span>]=swap        &#125;    &#125;    <span class="hljs-comment">//下面是矩阵镜像翻转部分</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;a;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=b/<span class="hljs-number">2</span>;j++&#123;            swap = matrix[i][j<span class="hljs-number">-1</span>]            matrix[i][j<span class="hljs-number">-1</span>] = matrix[i][b-j]            matrix[i][b-j] =swap        &#125;    &#125;&#125;</code></pre><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣九十三：复原IP地址</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/93.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/93.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a><font size=6px>复原IP地址</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#x38;&#64;&#x31;&#x2e;&#49;">&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#x38;&#64;&#x31;&#x2e;&#49;</a>“ 是 无效的 IP 地址。</p><p>示例 1：</p><p>输入：s &#x3D; “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]<br>示例 2：</p><p>输入：s &#x3D; “0000”<br>输出：[“0.0.0.0”]<br>示例 3：</p><p>输入：s &#x3D; “1111”<br>输出：[“1.1.1.1”]<br>示例 4：</p><p>输入：s &#x3D; “010010”<br>输出：[“0.10.0.10”,”0.100.1.0”]<br>示例 5：</p><p>输入：s &#x3D; “101023”<br>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p><p>提示：</p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 3000<br>s 仅由数字组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="学到的东西"><a href="#学到的东西" class="headerlink" title="学到的东西"></a>学到的东西</h5><p>1、搞清楚了切片和数组的区别，切片要导入的话得用append，没有大小限制</p><p>2、s[i]-‘0’出来的结果是byte类型的</p><p>3、要重置一个字符串型的变量，var一个新的string变量，然后要它等于新的string变量</p><p>4、要返回一个空的字符串切片，return []string{}</p><p>5、要用len求数字的长度，要用strconv.Itoa把数字转化成字符串才能求</p><p>思路：</p><p>第一步先求长度符不符合标准，第二步求有无非法字符，第三步开始正式处理，这道题好像是一串数字，在里面加上3个点，然后判断被三个点隔开的4个数字符不符合标准，把4个数字取出来，然后分别判断是否小于255，然后判断这4个数字的长度和s的长度一不一样，如果不一样说明数字前面有0，就不符合条件</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-keyword">var</span> s_len <span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> s1 ,s3 <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> s2 []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> n1,n2,n3,n4,sum_len <span class="hljs-type">int</span>    s_len=<span class="hljs-built_in">len</span>(s)    <span class="hljs-comment">//如果长度不达标</span>    <span class="hljs-keyword">if</span> s_len&lt;<span class="hljs-number">4</span> || s_len&gt;<span class="hljs-number">12</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;    &#125;    <span class="hljs-comment">//如果出现非法字符</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;s_len;i++&#123;        <span class="hljs-keyword">if</span> s[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span> || s[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>&#123;            <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;s_len<span class="hljs-number">-3</span>&amp;&amp;i&lt;=<span class="hljs-number">2</span>;i++&#123;        <span class="hljs-keyword">for</span> j:=i+<span class="hljs-number">1</span>;j&lt;s_len<span class="hljs-number">-2</span>&amp;&amp;j-i&lt;=<span class="hljs-number">3</span>;j++&#123;            <span class="hljs-keyword">for</span> k:=j+<span class="hljs-number">1</span>;k&lt;s_len<span class="hljs-number">-1</span>&amp;&amp;k-j&lt;=<span class="hljs-number">3</span>;k++&#123;                n1,n2,n3,n4,sum_len=stio(s,i,j,k)                <span class="hljs-keyword">if</span> n1&lt;=<span class="hljs-number">255</span>&amp;&amp;n2&lt;=<span class="hljs-number">255</span>&amp;&amp;n3&lt;=<span class="hljs-number">255</span>&amp;&amp;n4&lt;=<span class="hljs-number">255</span>&amp;&amp;sum_len==s_len&#123;                    <span class="hljs-keyword">for</span> m:=<span class="hljs-number">0</span>;m&lt;s_len;m++&#123;                        s1=s1+<span class="hljs-type">string</span>(s[m])                        <span class="hljs-keyword">if</span> m==i||m==j||m==k&#123;                            s1=s1+<span class="hljs-string">&quot;.&quot;</span>                        &#125;                    &#125;                    s2=<span class="hljs-built_in">append</span>(s2,s1)                    <span class="hljs-comment">//重置s1</span>                    s1=s3                &#125;                n1,n2,n3=<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> s2&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stio</span><span class="hljs-params">(s <span class="hljs-type">string</span>,a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span> ,c <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">var</span> n1,n2,n3,n4 <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> sum_len <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=a;i++&#123;        n1=n1*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=a+<span class="hljs-number">1</span>;i&lt;=b;i++&#123;        n2=n2*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=b+<span class="hljs-number">1</span>;i&lt;=c;i++&#123;        n3=n3*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=c+<span class="hljs-number">1</span>;i&lt;s_len;i++&#123;        n4=n4*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;        sum_len=<span class="hljs-built_in">len</span>(strconv.Itoa(n1))+<span class="hljs-built_in">len</span>(strconv.Itoa(n2))+<span class="hljs-built_in">len</span>(strconv.Itoa(n3))+<span class="hljs-built_in">len</span>(strconv.Itoa(n4))    <span class="hljs-keyword">return</span> n1,n2,n3,n4,sum_len&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了56.25%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>547. 省份数量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a><font size=6px>省份数量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p>示例 1：</p><p>输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]<br>输出：2<br>示例 2：</p><p>输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]<br>输出：3</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 200<br>n &#x3D;&#x3D; isConnected.length<br>n &#x3D;&#x3D; isConnected[i].length<br>isConnected[i][j] 为 1 或 0<br>isConnected[i][i] &#x3D;&#x3D; 1<br>isConnected[i][j] &#x3D;&#x3D; isConnected[j][i]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用并查集思路，两个城市连起来就把city【i】 &#x3D;j，判断city【i】是否等于i就知道有几个省了，并查集合并有点困难</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(isConnected [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> city [<span class="hljs-number">201</span>]<span class="hljs-type">int</span><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">201</span>; i++ &#123;city[i] = i&#125;<span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> city[x] != x &#123;city[x] = find(city[x])&#125;<span class="hljs-keyword">return</span> city[x]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span> &#123;city[find(i)] = find(j)&#125;&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<span class="hljs-keyword">if</span> city[i] == i &#123;res++&#125;&#125;<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了91.90%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了95.76%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>56. 合并区间</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><font size=6px>合并区间</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p><p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p><p>提示：</p><p>1 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>intervals[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; starti &lt;&#x3D; endi &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>思路很简单，按第一个数字升序排序，然后判断pre的第二个数字是否大于等于cur的第一个数字，如果大就合并</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">//第二版代码</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> b&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]&#125;)pre :=intervals[<span class="hljs-number">0</span>]<span class="hljs-keyword">var</span> arr [][]<span class="hljs-type">int</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> ;i&lt;<span class="hljs-built_in">len</span>(intervals);i++&#123;    cur :=intervals[i]    <span class="hljs-keyword">if</span> pre[<span class="hljs-number">1</span>] &gt;= cur[<span class="hljs-number">0</span>]&#123;        pre [<span class="hljs-number">1</span>] = max(pre[<span class="hljs-number">1</span>],cur[<span class="hljs-number">1</span>])        &#125;<span class="hljs-keyword">else</span>&#123;            arr = <span class="hljs-built_in">append</span>(arr,pre)            pre = cur        &#125;    &#125;    arr = <span class="hljs-built_in">append</span>(arr,pre)    <span class="hljs-keyword">return</span>  arr&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了99.84%的用户<br>   内存消耗：4.5 MB, 在所有 Go 提交中击败了90.14%的用户</p><pre><code class="hljs angelscript"><span class="hljs-comment">//第一版代码，时间很慢，因为是合并数组中把原数组这个数去除的做法太费时间</span>func max (a,b <span class="hljs-built_in">int</span>)<span class="hljs-built_in">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;func merge(<span class="hljs-built_in">int</span>ervals [][]<span class="hljs-built_in">int</span>) [][]<span class="hljs-built_in">int</span> &#123;    <span class="hljs-comment">//sortclass := new(Sort)</span><span class="hljs-comment">//sortclass.arr = intervals</span>    <span class="hljs-comment">//</span><span class="hljs-comment">//sort.Sort(sortclass)</span>    sort.Slice(<span class="hljs-built_in">int</span>ervals, func(i, j <span class="hljs-built_in">int</span>) <span class="hljs-built_in">bool</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &lt;<span class="hljs-built_in">int</span>ervals[j][<span class="hljs-number">0</span>]    &#125;)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; len(<span class="hljs-built_in">int</span>ervals)<span class="hljs-number">-1</span>; i++ &#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>] &gt;= <span class="hljs-built_in">int</span>ervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &#123;            <span class="hljs-built_in">int</span>ervals = mergearray(<span class="hljs-built_in">int</span>ervals, i)            i--        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals&#125;func mergearray(<span class="hljs-built_in">int</span>ervals [][]<span class="hljs-built_in">int</span>, start <span class="hljs-built_in">int</span>) [][]<span class="hljs-built_in">int</span> &#123;    first := <span class="hljs-built_in">int</span>ervals[start][<span class="hljs-number">0</span>]    last := max(<span class="hljs-built_in">int</span>ervals[start][<span class="hljs-number">1</span>],<span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])    <span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = first    <span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = last    <span class="hljs-built_in">int</span>ervals = append(<span class="hljs-built_in">int</span>ervals[:start], <span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>:]...)    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals&#125;</code></pre><p class="note note-primary"; style="font-size:22px">   执行用时：28 ms, 在所有 Go 提交中击败了10.27%的用户<br>   内存消耗：4.4 MB, 在所有 Go 提交中击败了99.10%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>567. 字符串的排列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><font size=6px>字符串的排列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的 子串 。</p><p>示例 1：</p><p>输入: s1 &#x3D; “ab” s2 &#x3D; “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).<br>示例 2：</p><p>输入: s1&#x3D; “ab” s2 &#x3D; “eidboaoo”<br>输出: False</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>判断相不相等就是判断26个字母的个数相不相等，用滑动窗口法，第一次传入len（s1）开始判断，移动一次第一个字母的数量减去，加上最后一个字母的数量</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(s1 <span class="hljs-type">string</span>, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1) &gt; <span class="hljs-built_in">len</span>(s2) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;     mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,<span class="hljs-number">26</span>)    mp2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,<span class="hljs-number">26</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1);i++&#123;        mp[s1[i]]++        mp2[s2[i]]++    &#125;    <span class="hljs-keyword">if</span> check(mp,mp2)==<span class="hljs-literal">true</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(s1);i&lt;<span class="hljs-built_in">len</span>(s2);i++&#123;        mp2[s2[i-<span class="hljs-built_in">len</span>(s1)]]--        mp2[s2[i]]++        <span class="hljs-keyword">if</span> check(mp,mp2)==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(mp1 <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,mp2 <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> i <span class="hljs-type">byte</span>    <span class="hljs-keyword">for</span> i=<span class="hljs-string">&#x27;a&#x27;</span>;i&lt;<span class="hljs-string">&#x27;z&#x27;</span>;i++&#123;        <span class="hljs-keyword">if</span> mp1[i]!=mp2[i]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了43.98%的用户<br>   内存消耗：2.6 MB, 在所有 Go 提交中击败了23.90%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>sting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>60. 排列序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/60.%20%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/60.%20%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="排列序列"><a href="#排列序列" class="headerlink" title="排列序列"></a><font size=6px>排列序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n &#x3D; 3 时, 所有排列如下：</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p><p>示例 1：</p><p>输入：n &#x3D; 3, k &#x3D; 3<br>输出：”213”<br>示例 2：</p><p>输入：n &#x3D; 4, k &#x3D; 9<br>输出：”2314”<br>示例 3：</p><p>输入：n &#x3D; 3, k &#x3D; 1<br>输出：”123”</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 9<br>1 &lt;&#x3D; k &lt;&#x3D; n!</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>难得双百分比，思路是参考题解大神的，是一道类似于数学题，就例子中 3 3举例，第一个数字是怎么判断的呢，是 3 除以 2（1*2）等于1，知道第一个数为2，就是k &#x2F;（n-1）的阶乘就知道第一个数是哪个数，以此类推求出之后的数，记得求出一个数就把这个数从数组中取出</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getPermutation</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;num ,total := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>,<span class="hljs-number">0</span>,n),<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        num = <span class="hljs-built_in">append</span>(num,<span class="hljs-type">byte</span>(i)+<span class="hljs-string">&#x27;0&#x27;</span>)        total *= i    &#125;    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>,<span class="hljs-number">0</span>,n)    <span class="hljs-keyword">for</span> i:=n;i&gt;<span class="hljs-number">0</span>;i--&#123;        t :=total / i           idx := k / t <span class="hljs-number">-1</span>          <span class="hljs-keyword">if</span> k % t !=<span class="hljs-number">0</span>&#123;            idx+=<span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">if</span> idx&lt;<span class="hljs-number">0</span>&#123;            idx = <span class="hljs-number">0</span>        &#125;        res = <span class="hljs-built_in">append</span>(res,num[idx])        total , k = t , k-t*idx        num = <span class="hljs-built_in">append</span>(num[:idx],num[idx+<span class="hljs-number">1</span>:]...)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(res)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>64. 最小路径和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><font size=6px>最小路径和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例 1：</p><p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p><p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以用dfs和动态规划做，我是动态规划</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;       &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> grid == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid)==<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]    &#125;    num := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(grid))    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(grid);i++&#123;        num[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(grid[i]))    &#125;    <span class="hljs-keyword">for</span>  i:=<span class="hljs-built_in">len</span>(grid)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i-- &#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j-- &#123;            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(grid)<span class="hljs-number">-1</span> &#123;                <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>&#123;                    num[i][j] = grid[i][j]                &#125;<span class="hljs-keyword">else</span>&#123;                    num[i][j] = grid[i][j] + num[i][j+<span class="hljs-number">1</span>]                &#125;                        &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>&#123;                    num[i][j] = grid[i][j] + num[i+<span class="hljs-number">1</span>][j]                &#125;<span class="hljs-keyword">else</span>&#123;                    num[i][j] = min(num[i][j+<span class="hljs-number">1</span>],num[i+<span class="hljs-number">1</span>][j]) + grid[i][j]                &#125;                            &#125;        &#125;            &#125;    <span class="hljs-keyword">return</span> num[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   内存消耗：4.3 MB, 在所有 Go 提交中击败了44.17%的用户<br>   内存消耗：4.3 MB, 在所有 Go 提交中击败了44.17%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>674. 最长连续递增序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a><font size=6px>最长连续递增序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;&#x3D; i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。<br>示例 2：</p><p>输入：nums &#x3D; [2,2,2,2,2]<br>输出：1<br>解释：最长连续递增序列是 [2], 长度为1。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    count :=<span class="hljs-number">1</span>    max :=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> nums[i<span class="hljs-number">-1</span>]&lt;nums[i]&#123;            count ++        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> count&gt;max&#123;                max = count            &#125;            count =<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> count&gt;max&#123;            max = count        &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了81.10%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>69. x 的平方根</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: 4<br>输出: 2<br>示例 2:</p><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一般会说不能用sqrt，就用二分法查找最合适的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;     l:=<span class="hljs-number">0</span>     r:=x     <span class="hljs-keyword">for</span> l&lt;=r&#123;        mid := (l+r)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> mid*mid&gt;x&#123;            r=mid<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            l=mid+<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> r&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了99.92%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>695. 岛屿的最大面积</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a><font size=6px>岛屿的最大面积</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><p>示例 1:</p><p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p><p>示例 2:</p><p>[[0,0,0,0,0,0,0,0]]<br>对于上面这个给定的矩阵, 返回 0。</p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典dfs题目，加一个flag【i】【j】，如果访问了就把它置1，这样就不会有回去原来的位置</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>number := <span class="hljs-number">1</span><span class="hljs-keyword">var</span> flag [<span class="hljs-number">51</span>][<span class="hljs-number">51</span>]<span class="hljs-type">int</span>move := [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(grid); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]); j++ &#123;<span class="hljs-keyword">if</span> grid[i][j] != <span class="hljs-number">0</span> &amp;&amp; flag[i][j] == <span class="hljs-number">0</span> &#123;queue := []<span class="hljs-type">int</span>&#123;i, j&#125;flag[i][j] = <span class="hljs-number">1</span><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;tmppoint1 := queue[<span class="hljs-number">0</span>]tmppoint2 := queue[<span class="hljs-number">1</span>]<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> move &#123;<span class="hljs-keyword">if</span> tmppoint1+v[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; tmppoint1+v[<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">len</span>(grid) &amp;&amp; tmppoint2+v[<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; tmppoint2+v[<span class="hljs-number">1</span>] &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) &amp;&amp; grid[tmppoint1+v[<span class="hljs-number">0</span>]][tmppoint2+v[<span class="hljs-number">1</span>]] == <span class="hljs-number">1</span> &amp;&amp; flag[tmppoint1+v[<span class="hljs-number">0</span>]][tmppoint2+v[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span> &#123;queue = <span class="hljs-built_in">append</span>(queue, tmppoint1+v[<span class="hljs-number">0</span>], tmppoint2+v[<span class="hljs-number">1</span>])flag[tmppoint1+v[<span class="hljs-number">0</span>]][tmppoint2+v[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>number++&#125;&#125;queue = <span class="hljs-built_in">append</span>(queue[<span class="hljs-number">2</span>:])&#125;<span class="hljs-keyword">if</span> number &gt; max &#123;max = number&#125;number = <span class="hljs-number">1</span>&#125;&#125;&#125;<span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><font size=6px>爬楼梯</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>斐波那契数列</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> f []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>    &#125;    f = <span class="hljs-built_in">append</span>(f,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>; i&lt;=n;i++&#123;        f = <span class="hljs-built_in">append</span>(f,f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>])    &#125;    <span class="hljs-keyword">return</span> f[n<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了43.50%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>71. 简化路径</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/71.%20%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/71.%20%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a><font size=6px>简化路径</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘&#x2F;‘ 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’&#x2F;&#x2F;‘）都被视为单个斜杠 ‘&#x2F;‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件&#x2F;目录名称。</p><p>请注意，返回的 规范路径 必须遵循下述格式：</p><p>始终以斜杠 ‘&#x2F;‘ 开头。<br>两个目录名之间必须只有一个斜杠 ‘&#x2F;‘ 。<br>最后一个目录名（如果存在）不能 以 ‘&#x2F;‘ 结尾。<br>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。<br>返回简化后得到的 规范路径 。</p><p>示例 1：</p><p>输入：path &#x3D; “&#x2F;home&#x2F;“<br>输出：”&#x2F;home”<br>解释：注意，最后一个目录名后面没有斜杠。<br>示例 2：</p><p>输入：path &#x3D; “&#x2F;..&#x2F;“<br>输出：”&#x2F;“<br>解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。<br>示例 3：</p><p>输入：path &#x3D; “&#x2F;home&#x2F;&#x2F;foo&#x2F;“<br>输出：”&#x2F;home&#x2F;foo”<br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br>示例 4：</p><p>输入：path &#x3D; “&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;“<br>输出：”&#x2F;c”</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>代码参考题解，写的特别巧妙和简洁，先用split函数分成一个切片，用switch-case(判断。。和。)最后再组合</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">simplifyPath</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> path==<span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> path    &#125;    <span class="hljs-keyword">var</span> str []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> strs <span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> _,v :=<span class="hljs-keyword">range</span> strings.Split(path,<span class="hljs-string">&quot;/&quot;</span>)&#123;        <span class="hljs-keyword">switch</span> v &#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&quot;</span>:  <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.&quot;</span>: <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;..&quot;</span>: <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(str)&gt;<span class="hljs-number">0</span>&#123;            str = str[:<span class="hljs-built_in">len</span>(str)<span class="hljs-number">-1</span>]        &#125;        <span class="hljs-keyword">default</span>:str = <span class="hljs-built_in">append</span>(str,v)        &#125;    &#125;    strs = <span class="hljs-string">&quot;/&quot;</span>+strings.Join(str,<span class="hljs-string">&quot;/&quot;</span>)    <span class="hljs-keyword">return</span>  strs&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.1 MB, 在所有 Go 提交中击败了73.61%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>81. 搜索旋转排序数组 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a><font size=6px>搜索旋转排序数组 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0<br>输出：true<br>示例 2：</p><p>输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3<br>输出：false</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p><p>进阶：</p><p>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跟旋转排序数组差不多，就是把重复的前几个数去掉保证第一个和最后一个事不相同</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>&amp;&amp;nums[i]==nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>];&#123;        nums = <span class="hljs-built_in">append</span>(nums[<span class="hljs-number">1</span>:])    &#125;    <span class="hljs-keyword">if</span> search1(nums,target)==<span class="hljs-number">-1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search1</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) ==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] ==target&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;    &#125;        i,j:=<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i&lt;=j&#123;        mid := (i+j)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> nums[mid] == target&#123;            <span class="hljs-keyword">return</span> mid        &#125;        <span class="hljs-keyword">if</span> nums[mid] &gt;=nums[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">if</span> target &lt;nums[mid]&amp;&amp;target&gt;=nums[<span class="hljs-number">0</span>]&#123;                j = mid<span class="hljs-number">-1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                i = mid+<span class="hljs-number">1</span>            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> nums[mid]&lt;target&amp;&amp;target&lt;=nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#123;                i = mid+<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                j = mid<span class="hljs-number">-1</span>            &#125;        &#125;            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了92.09%的用户<br>   内存消耗：3.2 MB, 在所有 Go 提交中击败了99.94%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>84. 柱状图中最大的矩形</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a><font size=6px>柱状图中最大的矩形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><h4 id="思路-‘"><a href="#思路-‘" class="headerlink" title="思路:‘"></a>思路:‘</h4><p>第一种解法，暴力，这道问题的暴力解法比「接雨水」那道题要其实好想得多：可以枚举以每个柱形为高度的最大矩形的面积。</p><p>具体来说就是：依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。（golang会超时）</p><p>第二种解法是哨兵加上单调栈，就是如果出现前一个和后一个都比这个数小，就说明这个数的最大面积已经算出来的，可以出局了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">//第一种解法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heights)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> sum,max,i,j <span class="hljs-type">int</span>     <span class="hljs-keyword">for</span> k,v :=<span class="hljs-keyword">range</span> heights&#123;        <span class="hljs-keyword">for</span> i = k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;<span class="hljs-built_in">len</span>(heights);i--&#123;            <span class="hljs-keyword">if</span> heights[i]&lt;heights[k]&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">for</span> j = k+<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;<span class="hljs-built_in">len</span>(heights);j++&#123;            <span class="hljs-keyword">if</span> heights[j]&lt;heights[k]&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        sum = (j-i<span class="hljs-number">-1</span>) *v        fmt.Println(sum)        <span class="hljs-keyword">if</span> sum&gt;max&#123;            max = sum        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><pre><code class="hljs go"><span class="hljs-comment">//解法二</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heights) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;stack := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(heights))heights = <span class="hljs-built_in">append</span>(heights, <span class="hljs-number">-1</span>)heights = <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;, heights...)<span class="hljs-keyword">var</span> maxsize <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(heights); i++ &#123;<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span>&amp;&amp;heights[Peek(stack)] &gt; heights[i] &#123;stack, v := Pop(stack)<span class="hljs-keyword">if</span> sum := (i - Peek(stack) - <span class="hljs-number">1</span>) * heights[v]; sum &gt; maxsize &#123;maxsize = sum&#125;&#125;stack = <span class="hljs-built_in">append</span>(stack, i)&#125;<span class="hljs-keyword">return</span> maxsize&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> ([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;s := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> stack, s&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Peek</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：108 ms, 在所有 Go 提交中击败了49.43%的用户<br>   内存消耗：9.1 MB, 在所有 Go 提交中击败了30.36%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>85. 最大矩形</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a><font size=6px>最大矩形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p>示例 1：</p><p>输入：matrix &#x3D; [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：6<br>解释：最大矩形如上图所示。<br>示例 2：</p><p>输入：matrix &#x3D; []<br>输出：0<br>示例 3：</p><p>输入：matrix &#x3D; [[“0”]]<br>输出：0<br>示例 4：</p><p>输入：matrix &#x3D; [[“1”]]<br>输出：1<br>示例 5：</p><p>输入：matrix &#x3D; [[“0”,”0”]]<br>输出：0</p><p>提示：</p><p>rows &#x3D;&#x3D; matrix.length<br>cols &#x3D;&#x3D; matrix[0].length<br>0 &lt;&#x3D; row, cols &lt;&#x3D; 200<br>matrix[i][j] 为 ‘0’ 或 ‘1’</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用哨兵和单调栈思路，和84题思路相同，区别是这得一行一行遍历，算出这一行的最大矩阵，最后得出最大矩阵</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> levelheight []<span class="hljs-type">int</span><span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>num := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(matrix);i++&#123;<span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]);j++&#123;<span class="hljs-keyword">for</span> k:=i;k&gt;=<span class="hljs-number">0</span>;k--&#123;                <span class="hljs-keyword">if</span> matrix[k][j]==<span class="hljs-string">&#x27;1&#x27;</span>&#123;                    num++                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">break</span>                &#125;            &#125;levelheight = <span class="hljs-built_in">append</span>(levelheight,num)            num = <span class="hljs-number">0</span>&#125;        <span class="hljs-comment">//fmt.Println(levelheight)</span>linemax :=largestRectangleArea(levelheight)levelheight = levelheight[:<span class="hljs-number">0</span>]<span class="hljs-keyword">if</span> max &lt; linemax&#123;max = linemax&#125;&#125;<span class="hljs-keyword">return</span> max&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heights) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;stack := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(heights))heights = <span class="hljs-built_in">append</span>(heights, <span class="hljs-number">-1</span>)heights = <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;, heights...)<span class="hljs-keyword">var</span> maxsize <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(heights); i++ &#123;<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span>&amp;&amp;heights[Peek(stack)] &gt; heights[i] &#123;s, v := Pop(stack)stack = s<span class="hljs-keyword">if</span> sum := (i - Peek(stack) - <span class="hljs-number">1</span>) * heights[v]; sum &gt; maxsize &#123;maxsize = sum&#125;&#125;stack = <span class="hljs-built_in">append</span>(stack, i)&#125;<span class="hljs-keyword">return</span> maxsize&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> ([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;s := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> stack, s&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Peek</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了86.94%的用户<br>   内存消耗：4.9 MB, 在所有 Go 提交中击败了35.08%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23. 合并K个升序链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a><font size=6px>合并K个升序链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例 1：</p><p>输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>示例 2：</p><p>输入：lists &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：lists &#x3D; [[]]<br>输出：[]</p><p>提示：</p><p>k &#x3D;&#x3D; lists.length<br>0 &lt;&#x3D; k &lt;&#x3D; 10^4<br>0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500<br>-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4<br>lists[i] 按 升序 排列<br>lists[i].length 的总和不超过 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>思路很简单，写一个两个链表合并的函数，每次两个链表合并最后输出</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lists)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lists)&lt;<span class="hljs-number">2</span>&#123;         <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>]            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(lists);i++&#123;        lists[<span class="hljs-number">0</span>] = mergeTwoLists(lists[i],lists[<span class="hljs-number">0</span>])    &#125;    <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> l1==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> l2    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> l1    &#125;    head,l3 := &amp;ListNode&#123;&#125;,&amp;ListNode&#123;&#125;    <span class="hljs-keyword">if</span> l1.Val&gt;l2.Val&#123;        head = l2    &#125;<span class="hljs-keyword">else</span>&#123;        head = l1    &#125;        <span class="hljs-keyword">for</span> l1!=<span class="hljs-literal">nil</span>&amp;&amp;l2!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> l1.Val &gt; l2.Val&#123;            l3.Next=l2            l3 = l2            l2 = l2.Next        &#125;<span class="hljs-keyword">else</span>&#123;            l3.Next=l1            l3 = l1            l1 = l1.Next        &#125;    &#125;    <span class="hljs-keyword">if</span> l1!=<span class="hljs-literal">nil</span>&#123;        l3.Next = l1    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2!=<span class="hljs-literal">nil</span>&#123;        l3.Next = l2    &#125;    <span class="hljs-keyword">return</span> head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：112 ms, 在所有 Go 提交中击败了32.23%的用户<br>   内存消耗：5.3 MB, 在所有 Go 提交中击败了73.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>234. 回文链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><font size=6px>234. 回文链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第一种简单的思路是遍历一遍，将数据保存在数组里面，然后从两边开始遍历</p><p>第二种是进阶算法，用快慢指针，一个指针一次走两步，一个一次走一步，然后快指针走完慢指针刚刚走到一半，将后半链表逆置，然后前半链表和后半比较</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> head.Next==<span class="hljs-literal">nil</span>||head==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">var</span> pre *ListNode=<span class="hljs-literal">nil</span>    fast,slow :=head,head    <span class="hljs-keyword">for</span> fast!=<span class="hljs-literal">nil</span>&amp;&amp;fast.Next!=<span class="hljs-literal">nil</span>&#123;        fast=fast.Next.Next        pre=slow        slow=slow.Next    &#125;    pre.Next=<span class="hljs-literal">nil</span><span class="hljs-comment">//翻转链表</span><span class="hljs-keyword">var</span> head2 *ListNode=<span class="hljs-literal">nil</span><span class="hljs-keyword">for</span>(slow!=<span class="hljs-literal">nil</span>)&#123;    tmp:=slow.Next    slow.Next=head2    head2=slow    slow=tmp&#125;    <span class="hljs-keyword">for</span> head!=<span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> head2.Val!=head.Val&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;<span class="hljs-keyword">else</span>&#123;                head=head.Next                head2=head2.Next            &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：172 ms, 在所有 Go 提交中击败了23.75%的用户<br>   内存消耗：9.3 MB, 在所有 Go 提交中击败了29.47%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>236. 二叉树的最近公共祖先</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><font size=6px>二叉树的最近公共祖先</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例 1：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p><p>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1</p><p>提示：</p><p>树中节点数目在范围 [2, 105] 内。<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用递归的思路做，从下往上找，如果left！&#x3D;nil&amp;&amp;right!&#x3D;nil 则代表找到了，返回那个结点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-keyword">if</span> q.Val==root.Val||p.Val==root.Val&#123;        <span class="hljs-keyword">return</span> root    &#125;    left := lowestCommonAncestor(root.Left,p,q)    right := lowestCommonAncestor(root.Right,p,q)    <span class="hljs-comment">//代表左右结点都找到了</span>    <span class="hljs-keyword">if</span> left!=<span class="hljs-literal">nil</span> &amp;&amp; right!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> root    &#125;    <span class="hljs-keyword">if</span> right==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> left    &#125;    <span class="hljs-keyword">return</span> right&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了91.60%的用户<br>   内存消耗：7.6 MB, 在所有 Go 提交中击败了31.55%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25. K 个一组翻转链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title=" K 个一组翻转链表"></a><font size=6px> K 个一组翻转链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[2,1,4,3,5]<br>示例 2：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3<br>输出：[3,2,1,4,5]<br>示例 3：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1<br>输出：[1,2,3,4,5]<br>示例 4：</p><p>输入：head &#x3D; [1], k &#x3D; 1<br>输出：[1]<br>提示：</p><p>列表中节点的数量在范围 sz 内<br>1 &lt;&#x3D; sz &lt;&#x3D; 5000<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>1 &lt;&#x3D; k &lt;&#x3D; sz</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先遍历k遍判断有没有到终点，遍历之后找到一段的tail和head，然后进入reverse函数，倒转head和tail，表的head和tail连接主表的pre和nex</p><pre><code class="hljs ini"><span class="hljs-attr">pre.Next</span>=head<span class="hljs-attr">tail.Next</span>=nex</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;    hair := &amp;ListNode&#123;Next: head&#125;    pre:=hair    <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> head    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> head!=<span class="hljs-literal">nil</span>&#123;            tail:=pre            <span class="hljs-comment">//判断结点数量大不大于k个</span>            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;                tail=tail.Next                <span class="hljs-keyword">if</span> tail==<span class="hljs-literal">nil</span>&#123;                    <span class="hljs-keyword">return</span> hair.Next                &#125;            &#125;            nex:=tail.Next            head,tail=reverse(head,tail)            pre.Next=head            tail.Next=nex            pre=tail            head=tail.Next                    &#125;    &#125;    <span class="hljs-keyword">return</span> hair.Next&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head,tail *ListNode)</span></span>(*ListNode,*ListNode)&#123;    <span class="hljs-keyword">var</span> head2 *ListNode=<span class="hljs-literal">nil</span>    p:=head    tail.Next=<span class="hljs-literal">nil</span>    <span class="hljs-keyword">for</span> p!=<span class="hljs-literal">nil</span>&#123;        tmp:=p.Next        p.Next=head2        head2=p        p=tmp    &#125;    <span class="hljs-keyword">return</span> head2,head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了90.13%的用户<br>   内存消耗：3.6 MB, 在所有 Go 提交中击败了50.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300. 最长递增子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><font size=6px>最长递增子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p><p>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><p>进阶：</p><p>你可以设计时间复杂度为 O(n2) 的解决方案吗？<br>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>进阶的还没想出来，本方法时间复杂度位O（n^2）</p><p>用动态规划，在 第i个数，arr[i] 比0到第i-1个数大，就找dp[i-1到0]最大的那个数加1，dp数组意思是这个数为结尾的最大递增序列为多少。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> nums==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> dp [<span class="hljs-number">2501</span>]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">2501</span> ;i++&#123;        dp[i]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        max =<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;i;j++&#123;            <span class="hljs-keyword">if</span> nums[i]&gt;nums[j]&#123;                <span class="hljs-keyword">if</span> max&lt;dp[j]+<span class="hljs-number">1</span>&#123;                    max = dp[j]+<span class="hljs-number">1</span>                &#125;            &#125;        &#125;        dp[i] = max            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> max &lt; dp[i]&#123;            max = dp[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：64 ms, 在所有 Go 提交中击败了68.43%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了95.62%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a><font size=6px>搜索旋转排序数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出：4<br>示例 2：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出：-1<br>示例 3：</p><p>输入：nums &#x3D; [1], target &#x3D; 0<br>输出：-1</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第二个是顺序查找的快速版，主要讲第一个二分查找版，因为mid两边肯定有一边是有序的，如果左边有序，并且target大于有序的边的最小数，那就往有序边查，如果没有那就往半有序边查</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">//二分查找版</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) ==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] ==target&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;    &#125;        i,j:=<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i&lt;=j&#123;        mid := (i+j)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> nums[mid] == target&#123;            <span class="hljs-keyword">return</span> mid        &#125;        <span class="hljs-keyword">if</span> nums[mid] &gt;=nums[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">if</span> target &lt;nums[mid]&amp;&amp;target&gt;=nums[<span class="hljs-number">0</span>]&#123;                j = mid<span class="hljs-number">-1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                i = mid+<span class="hljs-number">1</span>            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> nums[mid]&lt;target&amp;&amp;target&lt;=nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#123;                i = mid+<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                j = mid<span class="hljs-number">-1</span>            &#125;        &#125;            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;    <span class="hljs-keyword">if</span> target&gt;nums[<span class="hljs-number">0</span>]&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums)&amp;&amp;nums[i<span class="hljs-number">-1</span>]&lt;nums[i];i++&#123;            <span class="hljs-keyword">if</span> target == nums[i]&#123;                <span class="hljs-keyword">return</span> i            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> target == nums[<span class="hljs-number">0</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> target == nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    &#125; <span class="hljs-keyword">else</span>  &#123;        <span class="hljs-keyword">for</span> j:= <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[j] &lt; nums[j+<span class="hljs-number">1</span>];j--&#123;            <span class="hljs-keyword">if</span> target ==nums[j]&#123;                <span class="hljs-keyword">return</span> j            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>32. 最长有效括号</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><font size=6px>最长有效括号</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>示例 1：</p><p>输入：s &#x3D; “(()”<br>输出：2<br>解释：最长有效括号子串是 “()”<br>示例 2：</p><p>输入：s &#x3D; “)()())”<br>输出：4<br>解释：最长有效括号子串是 “()()”<br>示例 3：</p><p>输入：s &#x3D; “”<br>输出：0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用栈的思想做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> maxnum <span class="hljs-type">int</span>    stack = <span class="hljs-built_in">append</span>(stack,<span class="hljs-number">-1</span>)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;            stack = <span class="hljs-built_in">append</span>(stack,i)        &#125;<span class="hljs-keyword">else</span>&#123;            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack ) == <span class="hljs-number">0</span>&#123;                stack = <span class="hljs-built_in">append</span>(stack,i)            &#125;<span class="hljs-keyword">else</span>&#123;                maxnum = max(maxnum,i-stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> maxnum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">( a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了30.20%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>354. 俄罗斯套娃信封问题</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/354.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/354.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="俄罗斯套娃信封问题"><a href="#俄罗斯套娃信封问题" class="headerlink" title="俄罗斯套娃信封问题"></a><font size=6px>俄罗斯套娃信封问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] &#x3D; [wi, hi] ，表示第 i 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>注意：不允许旋转信封。</p><p>示例 1：</p><p>输入：envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]<br>输出：3<br>解释：最多信封的个数为 3, 组合为: [2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]。<br>示例 2：</p><p>输入：envelopes &#x3D; [[1,1],[1,1],[1,1]]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; envelopes.length &lt;&#x3D; 5000<br>envelopes[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; wi, hi &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把二维排序 先固定一维，就变成了一维问题，先按第一列升序，第二列降序排序，之后就变成第二列的最大升序问题，就可以求出答案</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(envelopes [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    myarr:=&amp;Intarr&#123;envelopes,<span class="hljs-number">0</span>&#125;    sort.Sort(myarr)    max:=lengthOfLIS(envelopes)    <span class="hljs-keyword">return</span> max&#125;<span class="hljs-keyword">type</span> Intarr <span class="hljs-keyword">struct</span> &#123;    marr [][]<span class="hljs-type">int</span>    line <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr *Intarr)</span></span>Len() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(arr.marr)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr *Intarr)</span></span>Swap(i,j <span class="hljs-type">int</span>)  &#123;    arr.marr[i],arr.marr[j]=arr.marr[j],arr.marr[i]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr *Intarr)</span></span>Less(i,j <span class="hljs-type">int</span>)<span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">if</span> arr.marr[i][arr.line] &lt; arr.marr[j][arr.line]&#123;        <span class="hljs-keyword">return</span>  <span class="hljs-literal">true</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> arr.marr[i][arr.line] &gt; arr.marr[j][arr.line]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span> arr.marr[i][<span class="hljs-number">1</span>]&gt;arr.marr[j][<span class="hljs-number">1</span>]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> nums==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> dp [<span class="hljs-number">5001</span>]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">5001</span>;i++&#123;        dp[i]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        max =<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;i;j++&#123;            <span class="hljs-keyword">if</span> nums[i][<span class="hljs-number">1</span>]&gt;nums[j][<span class="hljs-number">1</span>]&#123;                <span class="hljs-keyword">if</span> max&lt;dp[j]+<span class="hljs-number">1</span>&#123;                    max = dp[j]+<span class="hljs-number">1</span>                &#125;            &#125;        &#125;        dp[i] = max            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> max &lt; dp[i]&#123;            max = dp[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：268 ms, 在所有 Go 提交中击败了42.09%的用户<br>   内存消耗：6.3 MB, 在所有 Go 提交中击败了99.65%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39. 组合总和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><font size=6px>组合总和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>示例 1：</p><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。<br>示例 2：</p><p>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]<br>示例 3：</p><p>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []<br>示例 4：</p><p>输入: candidates &#x3D; [1], target &#x3D; 1<br>输出: [[1]]<br>示例 5：</p><p>输入: candidates &#x3D; [1], target &#x3D; 2<br>输出: [[1,1]]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用dfs遍历</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span>temp := []<span class="hljs-type">int</span>&#123;&#125;dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;cpy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(temp))<span class="hljs-built_in">copy</span>(cpy, temp)res = <span class="hljs-built_in">append</span>(res, cpy)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">for</span> i := idx; i &lt; <span class="hljs-built_in">len</span>(candidates); i++ &#123;<span class="hljs-keyword">if</span> target-candidates[i] &gt;= <span class="hljs-number">0</span> &#123;temp = <span class="hljs-built_in">append</span>(temp, candidates[i])dfs(target-candidates[i], i)temp = temp[:<span class="hljs-built_in">len</span>(temp)<span class="hljs-number">-1</span>]&#125;&#125;&#125;dfs(target, <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.7 MB, 在所有 Go 提交中击败了98.82%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>393. UTF-8 编码验证</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/393.%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/393.%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h3 id="UTF-8-编码验证"><a href="#UTF-8-编码验证" class="headerlink" title="UTF-8 编码验证"></a><font size=6px>UTF-8 编码验证</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：</p><p>对于 1 字节的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。<br>对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。<br>这是 UTF-8 编码的工作方式：</p><p>   Char. number range  |        UTF-8 octet sequence<br>      (hexadecimal)    |              (binary)<br>   ——————–+———————————————<br>   0000 0000-0000 007F | 0xxxxxxx<br>   0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。</p><p>注意：<br>输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。</p><p>示例 1：</p><p>data &#x3D; [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.</p><p>返回 true 。<br>这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。<br>示例 2：</p><p>data &#x3D; [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.</p><p>返回 false 。<br>前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。<br>下一个字节是开头为 10 的延续字节，这是正确的。<br>但第二个延续字节不以 10 开头，所以是不符合规则的。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>相信很多人都跟我一样读不懂题目，我稍微讲解一下，要看第一个数字，第一个数字的最后八位如果是110xxxxx，说明之后有1个数是10xxxxxx，0xxxxxx的数字可以有好多个，如果是1110xxxx，说明有2个数字10xxxxxx，0xxxxxxx依旧可以有好多个，理解了题目做起来不难，不会看我的代码</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validUtf8</span><span class="hljs-params">(data []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    count :=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(data);i++&#123;        <span class="hljs-keyword">if</span> count==<span class="hljs-number">0</span>&#123;            count = bitNuber(data[i])        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//等不等于10xxxxxx</span>            <span class="hljs-keyword">if</span> (data[i] &gt;&gt;<span class="hljs-number">6</span>) != <span class="hljs-number">2</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;            count--            <span class="hljs-keyword">if</span> count==<span class="hljs-number">-1</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;                   &#125;    &#125;    <span class="hljs-keyword">return</span> count==<span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bitNuber</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-comment">//0xxxxxxx</span>    <span class="hljs-keyword">if</span> num&gt;&gt;<span class="hljs-number">7</span> ==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-comment">//11110xxx</span>    <span class="hljs-keyword">if</span> num &gt;&gt;<span class="hljs-number">3</span> ==<span class="hljs-number">30</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>    &#125;    <span class="hljs-comment">//1110xxxx</span>    <span class="hljs-keyword">if</span> num &gt;&gt;<span class="hljs-number">4</span> == <span class="hljs-number">14</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>    &#125;    <span class="hljs-comment">//110xxxxx</span>    <span class="hljs-keyword">if</span> num &gt;&gt;<span class="hljs-number">5</span> ==<span class="hljs-number">6</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了75.95%的用户<br>   内存消耗：5.2 MB, 在所有 Go 提交中击败了29.11%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>43. 字符串相乘</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a><font size=6px>字符串相乘</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><p>输入: num1 &#x3D; “2”, num2 &#x3D; “3”<br>输出: “6”<br>示例 2:</p><p>输入: num1 &#x3D; “123”, num2 &#x3D; “456”<br>输出: “56088”<br>说明：</p><p>num1 和 num2 的长度小于110。<br>num1 和 num2 只包含数字 0-9。<br>num1 和 num2 均不以零开头，除非是数字 0 本身。<br>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>很普通的大数相乘，就是golang如果想用【】byte来处理会溢出，记得用数组处理</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> num1[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> || num2[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>&#125;s1, s2 := []<span class="hljs-type">byte</span>(num1), []<span class="hljs-type">byte</span>(num2)s3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s1)+<span class="hljs-built_in">len</span>(s2))<span class="hljs-comment">//string reverse</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s1)/<span class="hljs-number">2</span>; i++ &#123;s1[i], s1[<span class="hljs-built_in">len</span>(s1)<span class="hljs-number">-1</span>-i] = s1[<span class="hljs-built_in">len</span>(s1)<span class="hljs-number">-1</span>-i], s1[i]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s2)/<span class="hljs-number">2</span>; i++ &#123;s2[i], s2[<span class="hljs-built_in">len</span>(s2)<span class="hljs-number">-1</span>-i] = s2[<span class="hljs-built_in">len</span>(s2)<span class="hljs-number">-1</span>-i], s2[i]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s1); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(s2); j++ &#123;s3[i+j] += <span class="hljs-type">int</span>((s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (s2[j] - <span class="hljs-string">&#x27;0&#x27;</span>))&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s1)+<span class="hljs-built_in">len</span>(s2); i++ &#123;<span class="hljs-keyword">if</span> s3[i] &gt;= <span class="hljs-number">10</span> &#123;s3[i+<span class="hljs-number">1</span>] += s3[i] / <span class="hljs-number">10</span>s3[i] = s3[i] % <span class="hljs-number">10</span>&#125;&#125;i := <span class="hljs-built_in">len</span>(s1) + <span class="hljs-built_in">len</span>(s2) - <span class="hljs-number">1</span><span class="hljs-keyword">for</span> s3[i] == <span class="hljs-number">0</span> &#123;i--&#125;s3 = s3[<span class="hljs-number">0</span> : i+<span class="hljs-number">1</span>]<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(s3)/<span class="hljs-number">2</span>; j++ &#123;s3[j], s3[<span class="hljs-built_in">len</span>(s3)<span class="hljs-number">-1</span>-j] = s3[<span class="hljs-built_in">len</span>(s3)<span class="hljs-number">-1</span>-j], s3[j]&#125;<span class="hljs-keyword">var</span> tmp []<span class="hljs-type">byte</span><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s3); i++ &#123;tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-type">byte</span>(s3[i])+<span class="hljs-string">&#x27;0&#x27;</span>)&#125;<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(tmp)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了84.69%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>432. 全 O(1) 的数据结构</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/432.%20%E5%85%A8%20O(1)%20%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/432.%20%E5%85%A8%20O(1)%20%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="全-O-1-的数据结构"><a href="#全-O-1-的数据结构" class="headerlink" title="全 O(1) 的数据结构"></a><font size=6px>全 O(1) 的数据结构</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请你实现一个数据结构支持以下操作：</p><p>Inc(key) - 插入一个新的值为 1 的 key。或者使一个存在的 key 增加一，保证 key 不为空字符串。<br>Dec(key) - 如果这个 key 的值是 1，那么把他从数据结构中移除掉。否则使一个存在的 key 值减一。如果这个 key 不存在，这个函数不做任何事情。key 保证不为空字符串。<br>GetMaxKey() - 返回 key 中值最大的任意一个。如果没有元素存在，返回一个空字符串”” 。<br>GetMinKey() - 返回 key 中值最小的任意一个。如果没有元素存在，返回一个空字符串””。</p><p>挑战：</p><p>你能够以 O(1) 的时间复杂度实现所有操作吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跟LRU类似，用哈希双向链表来做，还有很多不足，代码有些插入和删除可以提取出来写成函数，懒了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> AllOne <span class="hljs-keyword">struct</span> &#123;mp   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*nodetail *nodehead *node&#125;<span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;next  *nodepre   *nodekey   <span class="hljs-type">string</span>value <span class="hljs-type">int</span>&#125;<span class="hljs-comment">/** Initialize your data structure here. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> AllOne &#123;tail := &amp;node&#123;&#125;head := &amp;node&#123;&#125;head.next = tailtail.pre = head<span class="hljs-keyword">return</span> AllOne&#123;mp: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node), tail: tail, head: head&#125;&#125;<span class="hljs-comment">/** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> Inc(key <span class="hljs-type">string</span>) &#123;<span class="hljs-keyword">if</span> _, ok := this.mp[key]; ok &#123;this.mp[key].value++nodeNext := this.mp[key].next<span class="hljs-comment">//delete the node</span>this.mp[key].pre.next = this.mp[key].nextthis.mp[key].next.pre = this.mp[key].pre<span class="hljs-keyword">for</span> this.mp[key].value &gt;= nodeNext.value &amp;&amp; nodeNext != this.tail &#123;nodeNext = nodeNext.next&#125;nodeNext.pre.next = this.mp[key]this.mp[key].pre = nodeNext.prethis.mp[key].next = nodeNextnodeNext.pre = this.mp[key]&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//insert</span>headNext := this.head.nextnode := &amp;node&#123;key: key, value: <span class="hljs-number">1</span>&#125;this.mp[key] = nodethis.head.next = this.mp[key]this.mp[key].pre = this.headthis.mp[key].next = headNextheadNext.pre = this.mp[key]&#125;&#125;<span class="hljs-comment">/* Decrements an existing key by 1. If Key&#x27;s value is 1, remove it from the data structure. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> Dec(key <span class="hljs-type">string</span>) &#123;<span class="hljs-keyword">if</span> this.mp[key].value &gt; <span class="hljs-number">1</span> &#123;this.mp[key].value--&#125; <span class="hljs-keyword">else</span> &#123;this.mp[key].pre.next = this.mp[key].nextthis.mp[key].next.pre = this.mp[key].pre<span class="hljs-built_in">delete</span>(this.mp, key)&#125;&#125;<span class="hljs-comment">/** Returns one of the keys with maximal value. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> GetMaxKey() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> this.tail.pre == this.head &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> this.tail.pre.key&#125;&#125;<span class="hljs-comment">/** Returns one of the keys with Minimal value. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> GetMinKey() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> this.tail.pre == this.head &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> this.head.next.key&#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：36 ms, 在所有 Go 提交中击败了84.78%的用户<br>   内存消耗：9.3 MB, 在所有 Go 提交中击败了99.46%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>46. 全排列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/46.%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/46.%20%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><font size=6px>46. 全排列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一道经典dfs的题目，记得使用完之后得复原之前的样子，为什么要复制一份再append进去，因为这个path所指向的内存空间在之后还得用，所以path所引用的内容会变化</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;    &#125;res := [][]<span class="hljs-type">int</span>&#123;&#125;<span class="hljs-keyword">var</span> recall <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(path []<span class="hljs-type">int</span>,start <span class="hljs-type">int</span>)</span></span>recall = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(path []<span class="hljs-type">int</span>,start <span class="hljs-type">int</span>)</span></span>&#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums)&#123;            temp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<span class="hljs-built_in">copy</span>(temp, path)res = <span class="hljs-built_in">append</span>(res, temp)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">for</span> i:=start;i&lt;<span class="hljs-built_in">len</span>(nums)&amp;&amp;i&gt;=<span class="hljs-number">0</span>;i++&#123;            flag := <span class="hljs-literal">false</span>            <span class="hljs-comment">//看是否有重复的数字</span>            <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> path&#123;                <span class="hljs-keyword">if</span> v ==nums[i]&#123;                    flag = <span class="hljs-literal">true</span>                    <span class="hljs-keyword">break</span>                &#125;            &#125;            <span class="hljs-keyword">if</span> flag==<span class="hljs-literal">true</span>&#123;                <span class="hljs-keyword">continue</span>            &#125;            path = <span class="hljs-built_in">append</span>(path,nums[i])            recall(path,start)            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]        &#125;&#125;    recall([]<span class="hljs-type">int</span>&#123;&#125;,<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.7 MB, 在所有 Go 提交中击败了56.75%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53. 最大子序和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a><font size=6px>最大子序和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例 1：</p><p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p><p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p><p>输入：nums &#x3D; [0]<br>输出：0<br>示例 4：</p><p>输入：nums &#x3D; [-1]<br>输出：-1<br>示例 5：</p><p>输入：nums &#x3D; [-100000]<br>输出：-100000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>就累加，如果小于0就重新累加，如果都是负数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> i,sum,flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>=<span class="hljs-number">-999</span>    max=nums[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        sum+=nums[i]        <span class="hljs-keyword">if</span> sum&lt;<span class="hljs-number">0</span>&#123;            sum=<span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            flag=<span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> max&lt;sum&#123;                max=sum            &#125;        &#125;    &#125;    <span class="hljs-comment">//为了防止都是负数的情况</span>    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;            <span class="hljs-keyword">if</span> max&lt;nums[i]&#123;                max=nums[i]            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了45.81%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分模块刷力扣题</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/0%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E5%8A%9B%E6%89%A3%E9%A2%98/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/0%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E5%8A%9B%E6%89%A3%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><style>table th:first-of-type {    width: 20%;}table th:nth-of-type(2) {    width: 50%;}table th:nth-of-type(3) {    width: 20%;} table th:nth-of-type(4) {    width: 30%;}</style><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">题目</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">两数之和</td><td align="center">c</td><td align="center">Easy</td></tr><tr><td align="center">11</td><td align="center">乘最多的水</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">15.三数之和</td><td align="center">学会了双指针法</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">16</td><td align="center">最接近的三数之和</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">33. 搜索旋转排序数组</td><td align="center">学会半有序的二分查找</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">41</td><td align="center">缺失一个正数</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">42</td><td align="center">接雨水</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">46. 全排列</td><td align="center">学会dfs</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">48</td><td align="center">旋转图像</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">56. 合并区间</td><td align="center">学会简便排序二维数组</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">81. 搜索旋转排序数组 II</td><td align="center">和33题差不多</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">84. 柱状图中最大的矩形</td><td align="center">学会哨兵和单调栈</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">121</td><td align="center">买卖股票的最佳时机</td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">122</td><td align="center">买卖股票的最佳时机||</td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">123</td><td align="center">买卖股票的最佳时机|||</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">128. 最长连续序列</td><td align="center">学会遍历map</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">215. 数组中的第K个最大元素</td><td align="center">学会了堆排序</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">300. 最长递增子序列</td><td align="center">学会了用动态规划求最大子序列</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">393. UTF-8 编码验证</td><td align="center">学会了位运算</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">547. 省份数量</td><td align="center">学会并查集合并</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">674. 最长连续递增序列</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">695. 岛屿的最大面积</td><td align="center">锻炼了dfs</td><td align="center">go</td><td align="center">medium</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">3无重复字符的最长子串</td><td align="center"></td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">13罗马数字转整数</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">43. 字符串相乘</td><td align="center">学会大数乘法</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">71. 简化路径</td><td align="center">学会了split函数和怎么删除切片指定字符串</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">20</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">22</td><td align="center"></td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">14. 最长公共前缀</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">567. 字符串的排列</td><td align="center">复习了移动窗口法</td><td align="center">go</td><td align="center">Medium</td></tr></tbody></table><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">53. 最大子序和</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">85. 最大矩形</td><td align="center">学会单调栈和哨兵的另外一种应用</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">120. 三角形最小路径和</td><td align="center">数塔问题</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">1416 恢复数组</td><td align="center">锻炼了递推思路</td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center">354. 俄罗斯套娃信封问题</td><td align="center">学会自定义快排和求最大升序序列</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">21. 合并两个有序链表</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">23. 合并K个升序链表</td><td align="center"></td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center">25. K 个一组翻转链表</td><td align="center">指针逆置，后面复习，再写一次</td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center">141. 环形链表</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">143. 重排链表</td><td align="center">锻炼了插入链表的顺序，学会了归并排序排序链表</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">160. 相交链表</td><td align="center">学会map的使用</td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">206. 反转链表</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">234. 回文链表</td><td align="center">知道什么原地让指针逆置</td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">236. 二叉树的最近公共祖先</td><td align="center">学会递归找公共祖先结点</td><td align="center">go</td><td align="center">medium</td></tr></tbody></table><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">102. 二叉树的层序遍历</td><td align="center">学会用队列遍历二叉树</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">103. 二叉树的锯齿形层序遍历</td><td align="center">学会把二叉树放进切片里面</td><td align="center">goeasy</td><td align="center">medium</td></tr><tr><td align="center">110. 平衡二叉树</td><td align="center">学会怎么判断平衡二叉树</td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">55. 最小栈</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">146. LRU 缓存机制</td><td align="center">学会了LRU算法，用链表哈希数据结构</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">432. 全 O(1) 的数据结构</td><td align="center">学会哈希双向链表的使用</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">55. 最小栈</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">60. 排列序列</td><td align="center">学会怎么快速知道在全排列中第几个数</td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1020. 飞地的数量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1020.%20%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1020.%20%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="飞地的数量"><a href="#飞地的数量" class="headerlink" title="飞地的数量"></a><font size=6px>飞地的数量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。</p><p>一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。</p><p>返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。</p><p>示例 1：</p><p>输入：grid &#x3D; [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]<br>输出：3<br>解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。<br>示例 2：</p><p>输入：grid &#x3D; [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]<br>输出：0<br>解释：所有 1 都在边界上或可以到达边界。</p><p>提示：</p><p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 500<br>grid[i][j] 的值为 0 或 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>Dfs 题，遍历周边的，然后遍历中间的数有几个岛屿</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numEnclaves</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> dirs = []<span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    vis := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, m)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> vis &#123;        vis[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>,<span class="hljs-type">bool</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r, c <span class="hljs-type">int</span> , flag <span class="hljs-type">bool</span>)</span></span> &#123;        <span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> || r &gt;= m || c &lt; <span class="hljs-number">0</span> || c &gt;= n || grid[r][c] == <span class="hljs-number">0</span> || vis[r][c] &#123;            <span class="hljs-keyword">return</span>        &#125;        vis[r][c] = <span class="hljs-literal">true</span>        <span class="hljs-keyword">if</span> flag&#123;            count++        &#125;        <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;            dfs(r+d.x, c+d.y,flag)        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span> &amp;&amp; vis[<span class="hljs-number">0</span>][i] == <span class="hljs-literal">false</span>&#123;            dfs(<span class="hljs-number">0</span>,i,<span class="hljs-literal">false</span>)        &#125;         <span class="hljs-keyword">if</span> grid[m<span class="hljs-number">-1</span>][i] == <span class="hljs-number">1</span> &amp;&amp; vis[m<span class="hljs-number">-1</span>][i] == <span class="hljs-literal">false</span>&#123;            dfs(m<span class="hljs-number">-1</span>,i,<span class="hljs-literal">false</span>)        &#125;    &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m<span class="hljs-number">-1</span>;i++&#123;        <span class="hljs-keyword">if</span> grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; vis[i][<span class="hljs-number">0</span>] == <span class="hljs-literal">false</span>&#123;            dfs(i,<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>)        &#125;         <span class="hljs-keyword">if</span> grid[i][n<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span> &amp;&amp; vis[i][n<span class="hljs-number">-1</span>] == <span class="hljs-literal">false</span>&#123;            dfs(i,n<span class="hljs-number">-1</span>,<span class="hljs-literal">false</span>)        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m<span class="hljs-number">-1</span>;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;n<span class="hljs-number">-1</span>;j++&#123;            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; vis[i][j] == <span class="hljs-literal">false</span>&#123;                dfs(i,j,<span class="hljs-literal">true</span>)                            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：60 ms, 在所有 Go 提交中击败了35.64%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了75.25%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><font size=6px>从前序与中序遍历序列构造二叉树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p>示例 1:</p><p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p><p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]</p><p>提示:</p><p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用递归写最容易，前序的第一个节点是根结点，找到前序第一个节点在中序中第几个，中序左边的左子树，右边是右子树</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    root := &amp;TreeNode&#123;preorder[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;    i:=<span class="hljs-number">0</span>     <span class="hljs-keyword">for</span> ;i&lt;<span class="hljs-built_in">len</span>(inorder); i++&#123;        <span class="hljs-keyword">if</span> inorder[i] == preorder[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    root.Left = buildTree(preorder[<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>], inorder[:i])    root.Right = buildTree(preorder[i+<span class="hljs-number">1</span>:], inorder[i+<span class="hljs-number">1</span>:])    <span class="hljs-keyword">return</span> root&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.86%的用户<br>   内存消耗：4 MB, 在所有 Go 提交中击败了96.69%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>538. Convert BST to Greater Tree</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1038.%20Convert%20BST%20to%20Greater%20Tree/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1038.%20Convert%20BST%20to%20Greater%20Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="Convert-BST-to-Greater-Tree"><a href="#Convert-BST-to-Greater-Tree" class="headerlink" title="Convert BST to Greater Tree"></a><font size=6px>Convert BST to Greater Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p><p>As a reminder, a binary search tree is a tree that satisfies these constraints:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p><p>Example 1:</p><p>Input: root &#x3D; [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]<br>Example 2:</p><p>Input: root &#x3D; [0,null,1]<br>Output: [1,null,1]</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [0, 104].<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>All the values in the tree are unique.<br>root is guaranteed to be a valid binary search tree.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>dfs 搜索，右中左序列就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertBST</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    <span class="hljs-keyword">var</span> maxNum <span class="hljs-type">int</span>     dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        dfs(root.Right)        root.Val += maxNum        maxNum = root.Val        dfs(root.Left)            &#125;dfs(root)<span class="hljs-keyword">return</span> root&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>112. 路径总和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><font size=6px>路径总和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。<br>示例 2：</p><p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：false<br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 –&gt; 2): 和为 3<br>(1 –&gt; 3): 和为 4<br>不存在 sum &#x3D; 5 的根节点到叶子节点的路径。<br>示例 3：</p><p>输入：root &#x3D; [], targetSum &#x3D; 0<br>输出：false<br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p><p>提示：</p><p>树中节点的数目在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>Dfs 遍历搜查</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> flag  <span class="hljs-type">bool</span>     flag = <span class="hljs-literal">false</span>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> flag    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sum <span class="hljs-type">int</span>,root *TreeNode)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sum <span class="hljs-type">int</span>,root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span>&#123;            dfs(sum+root.Val, root.Left)        &#125;        <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span>&#123;            dfs(sum+root.Val, root.Right)        &#125;        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> sum+root.Val == targetSum&#123;                flag = <span class="hljs-literal">true</span>            &#125;        &#125;    &#125;    dfs(<span class="hljs-number">0</span>, root)    <span class="hljs-keyword">return</span> flag&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了91.38%的用户<br>   内存消耗：4.4 MB, 在所有 Go 提交中击败了96.55%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>114. Flatten Binary Tree to Linked List</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/</url>
    
    <content type="html"><![CDATA[<h3 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a><font size=6px>Flatten Binary Tree to Linked List</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given the root of a binary tree, flatten the tree into a “linked list”:</p><p>The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.<br>The “linked list” should be in the same order as a pre-order traversal of the binary tree.</p><p>Example 1:</p><p>Input: root &#x3D; [1,2,5,3,4,null,6]<br>Output: [1,null,2,null,3,null,4,null,5,null,6]<br>Example 2:</p><p>Input: root &#x3D; []<br>Output: []<br>Example 3:</p><p>Input: root &#x3D; [0]<br>Output: [0]</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [0, 2000].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>Follow up: Can you flatten the tree in-place (with O(1) extra space)?</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;    curr := root    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">if</span> curr.Left != <span class="hljs-literal">nil</span> &#123;            next := curr.Left            predecessor := next            <span class="hljs-keyword">for</span> predecessor.Right != <span class="hljs-literal">nil</span> &#123;                predecessor = predecessor.Right            &#125;            predecessor.Right = curr.Right            curr.Left, curr.Right = <span class="hljs-literal">nil</span>, next        &#125;        curr = curr.Right    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了98.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1186. 删除一次得到子数组最大和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1186.%20%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1%E5%BE%97%E5%88%B0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1186.%20%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1%E5%BE%97%E5%88%B0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="删除一次得到子数组最大和"><a href="#删除一次得到子数组最大和" class="headerlink" title="删除一次得到子数组最大和"></a><font size=6px>删除一次得到子数组最大和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p><p>注意，删除一个元素后，子数组 不能为空。</p><p>示例 1：</p><p>输入：arr &#x3D; [1,-2,0,3]<br>输出：4<br>解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。<br>示例 2：</p><p>输入：arr &#x3D; [1,-2,-2,3]<br>输出：3<br>解释：我们直接选出 [3]，这就是最大和。<br>示例 3：</p><p>输入：arr &#x3D; [-1,-1,-1,-1]<br>输出：-1<br>解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。<br>     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。</p><p>提示：</p><p>1 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; arr[i] &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划题，dp[1][i] &#x3D; max(dp[0][i - 1], dp[1][i - 1] + arr[i])是关键</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumSum</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(arr)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span> , <span class="hljs-number">2</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    &#125;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>]    res := arr[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;        dp[<span class="hljs-number">0</span>][i] = max(dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + arr[i], arr[i])        dp[<span class="hljs-number">1</span>][i] = max(dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + arr[i])        res = max(res, max(dp[<span class="hljs-number">0</span>][i], dp[<span class="hljs-number">1</span>][i]))    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a &gt; b &#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：28 ms, 在所有 Go 提交中击败了85.71%的用户<br>   内存消耗：9.4 MB, 在所有 Go 提交中击败了32.14%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1189. Maximum Number of Balloons</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1189.%20Maximum%20Number%20of%20Balloons/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1189.%20Maximum%20Number%20of%20Balloons/</url>
    
    <content type="html"><![CDATA[<h3 id="Maximum-Number-of-Balloons"><a href="#Maximum-Number-of-Balloons" class="headerlink" title="Maximum Number of Balloons"></a><font size=6px>Maximum Number of Balloons</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given a string text, you want to use the characters of text to form as many instances of the word “balloon” as possible.</p><p>You can use each character in text at most once. Return the maximum number of instances that can be formed.</p><p>Example 1:</p><p>Input: text &#x3D; “nlaebolko”<br>Output: 1<br>Example 2:</p><p>Input: text &#x3D; “loonbalxballpoon”<br>Output: 2<br>Example 3:</p><p>Input: text &#x3D; “leetcode”<br>Output: 0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找这些词的频率，找到最短板的单词即可</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxNumberOfBalloons</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)    <span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-built_in">len</span>(text); i++&#123;        <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;b&#x27;</span>&#123;            s[<span class="hljs-number">0</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;a&#x27;</span>&#123;            s[<span class="hljs-number">1</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;l&#x27;</span>&#123;            s[<span class="hljs-number">2</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;o&#x27;</span>&#123;            s[<span class="hljs-number">3</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;n&#x27;</span>&#123;            s[<span class="hljs-number">4</span>]++        &#125;    &#125;     s[<span class="hljs-number">2</span>] /= <span class="hljs-number">2</span>    s[<span class="hljs-number">3</span>] /= <span class="hljs-number">2</span>    sort.Ints(s)    <span class="hljs-keyword">return</span> s[<span class="hljs-number">0</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1191. K 次串联后最大子数组之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1191.%20K%20%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1191.%20K%20%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="K-次串联后最大子数组之和"><a href="#K-次串联后最大子数组之和" class="headerlink" title="K 次串联后最大子数组之和"></a><font size=6px>K 次串联后最大子数组之和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 arr 和一个整数 k。</p><p>首先，我们要对该数组进行修改，即把原数组 arr 重复 k 次。</p><p>举个例子，如果 arr &#x3D; [1, 2] 且 k &#x3D; 3，那么修改后的数组就是 [1, 2, 1, 2, 1, 2]。</p><p>然后，请你返回修改后的数组中的最大的子数组之和。</p><p>注意，子数组长度可以是 0，在这种情况下它的总和也是 0。</p><p>由于 结果可能会很大，所以需要 模（mod） 10^9 + 7 后再返回。 </p><p>示例 1：</p><p>输入：arr &#x3D; [1,2], k &#x3D; 3<br>输出：9<br>示例 2：</p><p>输入：arr &#x3D; [1,-2,1], k &#x3D; 5<br>输出：2<br>示例 3：</p><p>输入：arr &#x3D; [-1,-2], k &#x3D; 7<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5<br>1 &lt;&#x3D; k &lt;&#x3D; 10^5<br>-10^4 &lt;&#x3D; arr[i] &lt;&#x3D; 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>需要考虑三种情况，k&#x3D;1,k&#x3D;2,k&gt;2,k&#x3D;1就是最大子序列问题，k&#x3D;2是两个连续最大子序列问题，k&gt;2是max(ans2,(ans2+(k-2) * sum) ) ，ans2是k&#x3D;2时最大连续子序列的大小。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kConcatenationMaxSum</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> r ,ans, ans2 <span class="hljs-type">int</span>    base := <span class="hljs-number">1000000007</span>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;        r = max(r+arr[i], arr[i])        ans = max(r, ans)        sum += arr[i]    &#125;    <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> ans %base    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(arr); i++&#123;        r= max(r+arr[i], arr[i])        ans2 = max(r, ans2)    &#125;    <span class="hljs-keyword">if</span> k ==<span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> ans2 % base    &#125;    <span class="hljs-keyword">return</span> max(ans2,(ans2+(k<span class="hljs-number">-2</span>) * sum) % base) % base&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：52 ms, 在所有 Go 提交中击败了85.71%的用户<br>   内存消耗：8.3 MB, 在所有 Go 提交中击败了50.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1219. 黄金矿工</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1219.%20%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1219.%20%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="黄金矿工"><a href="#黄金矿工" class="headerlink" title="黄金矿工"></a><font size=6px>黄金矿工</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。</p><p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p><p>每当矿工进入一个单元，就会收集该单元格中的所有黄金。<br>矿工每次可以从当前位置向上下左右四个方向走。<br>每个单元格只能被开采（进入）一次。<br>不得开采（进入）黄金数目为 0 的单元格。<br>矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。</p><p>示例 1：</p><p>输入：grid &#x3D; [[0,6,0],[5,8,7],[0,9,0]]<br>输出：24<br>解释：<br>[[0,6,0],<br> [5,8,7],<br> [0,9,0]]<br>一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。<br>示例 2：</p><p>输入：grid &#x3D; [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]<br>输出：28<br>解释：<br>[[1,0,7],<br> [2,0,6],<br> [3,4,5],<br> [0,3,0],<br> [9,0,20]]<br>一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>带回溯的dfs题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">var</span> dirs = []<span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMaximumGold</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y, gold <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y, gold <span class="hljs-type">int</span>)</span></span> &#123;        gold += grid[x][y]        <span class="hljs-keyword">if</span> gold &gt; ans &#123;            ans = gold        &#125;        rec := grid[x][y]        grid[x][y] = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;            nx, ny := x+d.x, y+d.y            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &amp;&amp; nx &lt; <span class="hljs-built_in">len</span>(grid) &amp;&amp; <span class="hljs-number">0</span> &lt;= ny &amp;&amp; ny &lt; <span class="hljs-built_in">len</span>(grid[nx]) &amp;&amp; grid[nx][ny] &gt; <span class="hljs-number">0</span> &#123;                dfs(nx, ny, gold)            &#125;        &#125;        grid[x][y] = rec    &#125;    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;        <span class="hljs-keyword">for</span> j, gold := <span class="hljs-keyword">range</span> row &#123;            <span class="hljs-keyword">if</span> gold &gt; <span class="hljs-number">0</span> &#123;                dfs(i, j, <span class="hljs-number">0</span>)            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>124. Binary Tree Maximum Path Sum</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/124.%20Binary%20Tree%20Maximum%20Path%20Sum/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/124.%20Binary%20Tree%20Maximum%20Path%20Sum/</url>
    
    <content type="html"><![CDATA[<h3 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a><font size=6px>Binary Tree Maximum Path Sum</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.</p><p>The path sum of a path is the sum of the node’s values in the path.</p><p>Given the root of a binary tree, return the maximum path sum of any non-empty path.</p><p>Example 1:</p><p>Input: root &#x3D; [1,2,3]<br>Output: 6<br>Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 &#x3D; 6.<br>Example 2:</p><p>Input: root &#x3D; [-10,9,20,null,null,15,7]<br>Output: 42<br>Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [1, 3 * 104].<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用dfs遍历，返回左或者右子树加上自身值的最大值，算最大值的时候需要特殊处理，需要计算左+右子树+自身值是否是最大值，是就更换最大值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    maxNum := <span class="hljs-number">-99999</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><span class="hljs-type">int</span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><span class="hljs-type">int</span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;        l := dfs(root.Left)        r := dfs(root.Right)        maxNum = max(maxNum, max(root.Val, max(root.Val+l,max(root.Val+r, root.Val+r+l))))        root.Val = max(root.Val, max(root.Val+l,root.Val+r))        <span class="hljs-keyword">return</span> root.Val    &#125;    dfs(root)    <span class="hljs-keyword">return</span> maxNum    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> i &gt;j&#123;        <span class="hljs-keyword">return</span> i    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> j    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了80.91%的用户<br>   内存消耗：7.4 MB, 在所有 Go 提交中击败了89.68%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1342. 将数字变成 0 的操作次数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1342.%20%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%90%200%20%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1342.%20%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%90%200%20%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="将数字变成-0-的操作次数"><a href="#将数字变成-0-的操作次数" class="headerlink" title="将数字变成 0 的操作次数"></a><font size=6px>将数字变成 0 的操作次数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p><p>示例 1：</p><p>输入：num &#x3D; 14<br>输出：6<br>解释：<br>步骤 1) 14 是偶数，除以 2 得到 7 。<br>步骤 2） 7 是奇数，减 1 得到 6 。<br>步骤 3） 6 是偶数，除以 2 得到 3 。<br>步骤 4） 3 是奇数，减 1 得到 2 。<br>步骤 5） 2 是偶数，除以 2 得到 1 。<br>步骤 6） 1 是奇数，减 1 得到 0 。<br>示例 2：</p><p>输入：num &#x3D; 8<br>输出：4<br>解释：<br>步骤 1） 8 是偶数，除以 2 得到 4 。<br>步骤 2） 4 是偶数，除以 2 得到 2 。<br>步骤 3） 2 是偶数，除以 2 得到 1 。<br>步骤 4） 1 是奇数，减 1 得到 0 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfSteps</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> num != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> num %<span class="hljs-number">2</span> == <span class="hljs-number">1</span>&#123;            num--        &#125;<span class="hljs-keyword">else</span>&#123;            num /= <span class="hljs-number">2</span>        &#125;        count++    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1380. 矩阵中的幸运数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1380.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1380.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。</p><p>幸运数是指矩阵中满足同时下列两个条件的元素：</p><p>在同一行的所有元素中最小<br>在同一列的所有元素中最大</p><p>示例 1：</p><p>输入：matrix &#x3D; [[3,7,8],[9,11,13],[15,16,17]]<br>输出：[15]<br>解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。<br>示例 2：</p><p>输入：matrix &#x3D; [[1,10,4,2],[9,3,8,7],[15,16,17,12]]<br>输出：[12]<br>解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。<br>示例 3：</p><p>输入：matrix &#x3D; [[7,8],[1,2]]<br>输出：[7]</p><p>提示：</p><p>m &#x3D;&#x3D; mat.length<br>n &#x3D;&#x3D; mat[i].length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 50<br>1 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 10^5<br>矩阵中的所有元素都是不同的</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找到每一行最小的和每一列最大的，他们之间的相同数就是答案，用哈希了，内存占用比较大。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">luckyNumbers</span> <span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    m ,n := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])    hash := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-number">100002</span>)    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        minNUm := matrix[i][<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;n;j++&#123;            minNUm = min(minNUm, matrix[i][j])        &#125;        hash[minNUm] = <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        maxNUm := matrix[<span class="hljs-number">0</span>][i]        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;m;j++&#123;            maxNUm = max(maxNUm, matrix[j][i])        &#125;        <span class="hljs-keyword">if</span> hash[maxNUm] == <span class="hljs-literal">true</span>&#123;            ans = <span class="hljs-built_in">append</span>(ans, maxNUm)        &#125;          &#125;    <span class="hljs-keyword">return</span> ans    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span>  a    &#125;    <span class="hljs-keyword">return</span> b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span>  a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：6.6 MB, 在所有 Go 提交中击败了9.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1405. 最长快乐字符串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1405.%20%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1405.%20%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="最长快乐字符串"><a href="#最长快乐字符串" class="headerlink" title="最长快乐字符串"></a><font size=6px>最长快乐字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>如果字符串中不含有任何 ‘aaa’，’bbb’ 或 ‘ccc’ 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</p><p>给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：</p><p>s 是一个尽可能长的快乐字符串。<br>s 中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。<br>s 中只含有 ‘a’、’b’ 、’c’ 三种字母。<br>如果不存在这样的字符串 s ，请返回一个空字符串 “”。</p><p>示例 1：</p><p>输入：a &#x3D; 1, b &#x3D; 1, c &#x3D; 7<br>输出：”ccaccbcc”<br>解释：”ccbccacc” 也是一种正确答案。<br>示例 2：</p><p>输入：a &#x3D; 2, b &#x3D; 2, c &#x3D; 1<br>输出：”aabbc”<br>示例 3：</p><p>输入：a &#x3D; 7, b &#x3D; 1, c &#x3D; 0<br>输出：”aabaa”<br>解释：这是该测试用例的唯一正确答案。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>贪心算法，每次选择个数最多的一个字母，如果连续两次使用相同字母，下次就需要使用第二多的字母。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestDiverseString</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>, c <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    ans := []<span class="hljs-type">byte</span>&#123;&#125;    cnt := []<span class="hljs-keyword">struct</span>&#123; c <span class="hljs-type">int</span>; ch <span class="hljs-type">byte</span> &#125;&#123;&#123;a, <span class="hljs-string">&#x27;a&#x27;</span>&#125;, &#123;b, <span class="hljs-string">&#x27;b&#x27;</span>&#125;, &#123;c, <span class="hljs-string">&#x27;c&#x27;</span>&#125;&#125;    <span class="hljs-keyword">for</span> &#123;        sort.Slice(cnt, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> cnt[i].c &gt; cnt[j].c &#125;)        <span class="hljs-keyword">if</span> cnt[<span class="hljs-number">0</span>].c == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">break</span>        &#125;        ans = <span class="hljs-built_in">append</span>(ans, cnt[<span class="hljs-number">0</span>].ch)        cnt[<span class="hljs-number">0</span>].c --;        sort.Slice(cnt, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> cnt[i].c &gt; cnt[j].c &#125;)        <span class="hljs-keyword">if</span> cnt[<span class="hljs-number">0</span>].c == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">break</span>        &#125;        ans = <span class="hljs-built_in">append</span>(ans, cnt[<span class="hljs-number">0</span>].ch)        cnt[<span class="hljs-number">0</span>].c--        <span class="hljs-keyword">if</span> ans[<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-1</span>] == ans[<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-2</span>]&#123;            <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">1</span>].c) &gt;<span class="hljs-number">0</span>&#123;                ans = <span class="hljs-built_in">append</span>(ans, cnt[<span class="hljs-number">1</span>].ch)                cnt[<span class="hljs-number">1</span>].c--            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(ans)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了82.41%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1414. 和为 K 的最少斐波那契数字数目</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1414.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1414.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="和为-K-的最少斐波那契数字数目"><a href="#和为-K-的最少斐波那契数字数目" class="headerlink" title="和为 K 的最少斐波那契数字数目"></a><font size=6px>和为 K 的最少斐波那契数字数目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p><p>斐波那契数字定义为：</p><p>F1 &#x3D; 1<br>F2 &#x3D; 1<br>Fn &#x3D; Fn-1 + Fn-2 ， 其中 n &gt; 2 。<br>数据保证对于给定的 k ，一定能找到可行解。</p><p>示例 1：</p><p>输入：k &#x3D; 7<br>输出：2<br>解释：斐波那契数字为：1，1，2，3，5，8，13，……<br>对于 k &#x3D; 7 ，我们可以得到 2 + 5 &#x3D; 7 。<br>示例 2：</p><p>输入：k &#x3D; 10<br>输出：2<br>解释：对于 k &#x3D; 10 ，我们可以得到 2 + 8 &#x3D; 10 。<br>示例 3：</p><p>输入：k &#x3D; 19<br>输出：3<br>解释：对于 k &#x3D; 19 ，我们可以得到 1 + 5 + 13 &#x3D; 19 。</p><p>提示：</p><p>1 &lt;&#x3D; k &lt;&#x3D; 10^9</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>​    先找到斐波那切数列第一个大于k的数字，之后从后往前找减去这个数的第一个大于的数字。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMinFibonacciNumbers</span><span class="hljs-params">(k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> fibo []<span class="hljs-type">int</span>    fibo = <span class="hljs-built_in">append</span>(fibo, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>)    i := <span class="hljs-number">1</span>    count := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> fibo[i] &lt;=k&#123;        fibo = <span class="hljs-built_in">append</span>(fibo, fibo[i<span class="hljs-number">-1</span>]+fibo[i])        i++    &#125;       <span class="hljs-keyword">for</span> k != <span class="hljs-number">0</span>&#123;       <span class="hljs-keyword">if</span> fibo[i]&lt;=k&#123;           k -= fibo[i]             count++       &#125;        i--   &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了33.33%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1447. Simplified Fractions</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1447.%20Simplified%20Fractions/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1447.%20Simplified%20Fractions/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. You can return the answer in any order.</p><p>Example 1:</p><p>Input: n &#x3D; 2<br>Output: [“1&#x2F;2”]<br>Explanation: “1&#x2F;2” is the only unique fraction with a denominator less-than-or-equal-to 2.<br>Example 2:</p><p>Input: n &#x3D; 3<br>Output: [“1&#x2F;2”,”1&#x2F;3”,”2&#x2F;3”]<br>Example 3:</p><p>Input: n &#x3D; 4<br>Output: [“1&#x2F;2”,”1&#x2F;3”,”1&#x2F;4”,”2&#x2F;3”,”3&#x2F;4”]<br>Explanation: “2&#x2F;4” is not a simplified fraction because it can be simplified to “1&#x2F;2”.</p><p>Constraints:</p><p>1 &lt;&#x3D; n &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>两层遍历，不把最大公约数不为1的数放进去就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> gcd(b,a%b)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">simplifiedFractions</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>     <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;i;j++&#123;                        <span class="hljs-keyword">if</span>  gcd(i,j) !=<span class="hljs-number">1</span>&#123;                <span class="hljs-keyword">continue</span>            &#125;            s := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, j)+<span class="hljs-string">&quot;/&quot;</span>+strconv.Itoa(i)            res = <span class="hljs-built_in">append</span>(res, s)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了51.61%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了96.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>151. 翻转字符串里的单词</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/151.%20%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/151.%20%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a><font size=6px>翻转字符串里的单词</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>说明：</p><p>无空格字符构成一个 单词 。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>示例 1：</p><p>输入：”the sky is blue”<br>输出：”blue is sky the”<br>示例 2：</p><p>输入：”  hello world!  “<br>输出：”world! hello”<br>解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p><p>输入：”a good   example”<br>输出：”example good a”<br>解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>示例 4：</p><p>输入：s &#x3D; “  Bob    Loves  Alice   “<br>输出：”Alice Loves Bob”<br>示例 5：</p><p>输入：s &#x3D; “Alice does not even like bob”<br>输出：”bob like even not does Alice”</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>还是自己太垃圾，字符串类型的题目不行了</p><p>要先把前面的空格和后面的空格去掉，这这之间把字符串之间的空格控制在1个，然后用spilt函数分割字符串，然后倒转，再用join合起来</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> s==<span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>    &#125;    str := clearSpace(s)    <span class="hljs-keyword">var</span> str1 <span class="hljs-type">string</span>    ss :=strings.Split(<span class="hljs-type">string</span>(str),<span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(ss)/<span class="hljs-number">2</span>;i++&#123;        ss[i],ss[<span class="hljs-built_in">len</span>(ss)<span class="hljs-number">-1</span>-i] = ss[<span class="hljs-built_in">len</span>(ss)<span class="hljs-number">-1</span>-i],ss[i]    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ss[<span class="hljs-number">0</span>])==<span class="hljs-number">0</span>&#123;ss = <span class="hljs-built_in">append</span>(ss[:<span class="hljs-number">0</span>],ss[<span class="hljs-number">1</span>:]...)    &#125;        str1 = strings.Join(ss,<span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">return</span>  str1&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clearSpace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span>&#123;    <span class="hljs-keyword">var</span> str []<span class="hljs-type">byte</span>    <span class="hljs-keyword">var</span> i <span class="hljs-type">int</span>    j  :=<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i&lt;<span class="hljs-built_in">len</span>(s)&amp;&amp;s[i]==<span class="hljs-string">&#x27; &#x27;</span>&#123;        i++    &#125;    flag :=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> ;i&lt;=j;i++&#123;        <span class="hljs-keyword">if</span> s[i]!=<span class="hljs-string">&#x27; &#x27;</span>&#123;            str = <span class="hljs-built_in">append</span>(str,s[i])            flag=<span class="hljs-number">0</span>        &#125;        <span class="hljs-keyword">if</span> s[i]==<span class="hljs-string">&#x27; &#x27;</span>&amp;&amp;flag==<span class="hljs-number">0</span>&#123;            flag=<span class="hljs-number">1</span>            str = <span class="hljs-built_in">append</span>(str,s[i])        &#125;    &#125;    <span class="hljs-keyword">return</span>  <span class="hljs-type">string</span>(str)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.1 MB, 在所有 Go 提交中击败了63.42%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>152. 乘积最大子数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><font size=6px>乘积最大子数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>示例 1:</p><p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p><p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划做，需要额外一个dp_min数组，用于放最小数，是为了考虑两个负数乘变成正数的情况。</p><p>dp_min[i] &#x3D; min(min(dp_min[i-1]*nums[i],dp_max[i-1]*nums[i] ),nums[i])</p><p> dp_max[i] &#x3D; max(max(dp_max[i-1]*nums[i], dp_min[i-1]*nums[i]),nums[i])</p><p>res &#x3D; max(res,dp_max[i])</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]    &#125;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    dp_min := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    dp_max := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    dp_max[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]    dp_min[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]    res = dp_max[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        dp_min[i] = min(min(dp_min[i<span class="hljs-number">-1</span>]*nums[i],dp_max[i<span class="hljs-number">-1</span>]*nums[i] ),nums[i])        dp_max[i] = max(max(dp_max[i<span class="hljs-number">-1</span>]*nums[i], dp_min[i<span class="hljs-number">-1</span>]*nums[i]),nums[i])        res = max(res,dp_max[i])    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a     &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了80.65%的用户<br>   内存消耗：3.8 MB, 在所有 Go 提交中击败了15.50%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>155. 最小栈</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><font size=6px>最小栈</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>在编写的时候就把这个数到之前数的最小数append进去</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;stack  []<span class="hljs-type">int</span>    minnum []<span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> b&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> a&#125;&#125;<span class="hljs-comment">/** initialize your data structure here. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<span class="hljs-keyword">return</span> MinStack&#123;stack:  []<span class="hljs-type">int</span>&#123;&#125;,minnum: []<span class="hljs-type">int</span>&#123;math.&#125;,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(val <span class="hljs-type">int</span>) &#123;this.stack = <span class="hljs-built_in">append</span>(this.stack, val)this.minnum = <span class="hljs-built_in">append</span>(this.minnum, min(this.minnum[<span class="hljs-built_in">len</span>(this.minnum)<span class="hljs-number">-1</span>],val))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop() &#123;this.stack = <span class="hljs-built_in">append</span>(this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>])this.minnum = <span class="hljs-built_in">append</span>(this.minnum[:<span class="hljs-built_in">len</span>(this.minnum)<span class="hljs-number">-1</span>])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> this.minnum[<span class="hljs-built_in">len</span>(this.minnum)<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了86.09%的用户<br>   内存消耗：8.3 MB, 在所有 Go 提交中击败了81.90%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>160. 相交链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a><font size=6px>相交链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表：</p><p>在节点 c1 开始相交。</p><p>示例 1：</p><p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Reference of the node with value &#x3D; 8<br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Reference of the node with value &#x3D; 2<br>输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p>注意：</p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第一版效率低，讲第二版的思路，相交结点屁股后面结点数量是相同的，先分别遍历两个链表求长度，如果一个长就先遍历这个链表长的部分，之后两个链表就等长了一起遍历。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> headA==<span class="hljs-literal">nil</span>|| headB ==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>)    <span class="hljs-keyword">for</span> headA!=<span class="hljs-literal">nil</span>&amp;&amp;headB!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> mp[headA]==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> headA        &#125;<span class="hljs-keyword">else</span>&#123;            mp[headA] = <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">if</span> mp[headB]==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> headB        &#125;<span class="hljs-keyword">else</span>&#123;            mp[headB] = <span class="hljs-literal">true</span>        &#125;        headA = headA.Next        headB = headB.Next    &#125;    <span class="hljs-keyword">for</span> headA!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> mp[headA]==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> headA        &#125;        headA = headA.Next    &#125;    <span class="hljs-keyword">for</span> headB!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> mp[headB]==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> headB        &#125;        headB = headB.Next    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了28.89%的用户<br>   内存消耗：7.5 MB, 在所有 Go 提交中击败了18.97%的用户</p><pre><code class="hljs go"><span class="hljs-comment">//第二版</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;    l1:=<span class="hljs-number">0</span>    p1:=headA    <span class="hljs-keyword">for</span> p1!=<span class="hljs-literal">nil</span>&#123;        l1++        p1=p1.Next    &#125;    l2:=<span class="hljs-number">0</span>    p2:=headB    <span class="hljs-keyword">for</span> p2!=<span class="hljs-literal">nil</span>&#123;        l2++        p2=p2.Next    &#125;    <span class="hljs-keyword">if</span> l1&gt;l2&#123;        <span class="hljs-keyword">for</span> l1!=l2&#123;            headA=headA.Next            l1--        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> l1!=l2&#123;            headB=headB.Next            l2--        &#125;    &#125;    <span class="hljs-keyword">for</span> headA!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> headA==headB&#123;            <span class="hljs-keyword">return</span> headA        &#125;<span class="hljs-keyword">else</span>&#123;            headA=headA.Next            headB=headB.Next        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;</code></pre><p class="note note-primary"; style="font-size:22px">   执行用时：40 ms, 在所有 Go 提交中击败了71.48%的用户<br>   内存消耗：7.2 MB, 在所有 Go 提交中击败了84.56%的用户</p><pre><code class="hljs vim">//最后贴上大神极简的代码func getIntersectionNode(headA, headB *ListNode) *ListNode &#123;<span class="hljs-keyword">ha</span>, hb := headA, headB<span class="hljs-keyword">for</span> <span class="hljs-keyword">ha</span> != hb &#123;<span class="hljs-keyword">if</span> <span class="hljs-keyword">ha</span> != nil &#123;<span class="hljs-keyword">ha</span> = <span class="hljs-keyword">ha</span>.<span class="hljs-keyword">Next</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">ha</span> = headB&#125;<span class="hljs-keyword">if</span> hb != nil &#123;hb = hb.<span class="hljs-keyword">Next</span>&#125; <span class="hljs-keyword">else</span> &#123;hb = headA&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">ha</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1688. 比赛中的配对次数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1688.%20%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%85%8D%E5%AF%B9%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1688.%20%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%85%8D%E5%AF%B9%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="比赛中的配对次数"><a href="#比赛中的配对次数" class="headerlink" title="比赛中的配对次数"></a><font size=6px>比赛中的配对次数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：</p><p>如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n &#x2F; 2 场比赛，且产生 n &#x2F; 2 支队伍进入下一轮。<br>如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) &#x2F; 2 场比赛，且产生 (n - 1) &#x2F; 2 + 1 支队伍进入下一轮。<br>返回在比赛中进行的配对次数，直到决出获胜队伍为止。</p><p>示例 1：</p><p>输入：n &#x3D; 7<br>输出：6<br>解释：比赛详情：</p><ul><li>第 1 轮：队伍数 &#x3D; 7 ，配对次数 &#x3D; 3 ，4 支队伍晋级。</li><li>第 2 轮：队伍数 &#x3D; 4 ，配对次数 &#x3D; 2 ，2 支队伍晋级。</li><li>第 3 轮：队伍数 &#x3D; 2 ，配对次数 &#x3D; 1 ，决出 1 支获胜队伍。<br>总配对次数 &#x3D; 3 + 2 + 1 &#x3D; 6<br>示例 2：</li></ul><p>输入：n &#x3D; 14<br>输出：13<br>解释：比赛详情：</p><ul><li>第 1 轮：队伍数 &#x3D; 14 ，配对次数 &#x3D; 7 ，7 支队伍晋级。</li><li>第 2 轮：队伍数 &#x3D; 7 ，配对次数 &#x3D; 3 ，4 支队伍晋级。 </li><li>第 3 轮：队伍数 &#x3D; 4 ，配对次数 &#x3D; 2 ，2 支队伍晋级。</li><li>第 4 轮：队伍数 &#x3D; 2 ，配对次数 &#x3D; 1 ，决出 1 支获胜队伍。<br>总配对次数 &#x3D; 7 + 3 + 2 + 1 &#x3D; 13</li></ul><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 200<br>通过</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfMatches</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> n !=<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> n %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;            n = (n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>            res += n<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            res += n/<span class="hljs-number">2</span>            n /= <span class="hljs-number">2</span>        &#125;            &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>169. 多数元素</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><font size=6px>多数元素</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1：</p><p>输入：[3,2,3]<br>输出：3<br>示例 2：</p><p>输入：[2,2,1,1,1,2,2]<br>输出：2</p><p>进阶：</p><p>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用摩尔投票法，如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 <code>0</code>，从结果本身我们可以看出众数比其他数多。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    count := <span class="hljs-number">1</span>    cantidate := nums[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>  ;i&lt;<span class="hljs-built_in">len</span>(nums) ;i++&#123;        <span class="hljs-keyword">if</span> nums[i] == cantidate&#123;            count ++        &#125;<span class="hljs-keyword">else</span>&#123;            count --        &#125;        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>&#123;            count = <span class="hljs-number">1</span>            cantidate = nums[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> cantidate&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了98.28%的用户<br>   内存消耗：5.9 MB, 在所有 Go 提交中击败了98.28%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1706. 球会落何处</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1706.%20%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1706.%20%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<h3 id="球会落何处"><a href="#球会落何处" class="headerlink" title="球会落何处"></a><font size=6px>球会落何处</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。</p><p>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。</p><p>将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。<br>将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。<br>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。</p><p>返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。</p><p>示例 1：</p><p>输入：grid &#x3D; [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]<br>输出：[1,-1,-1,-1,-1]<br>解释：示例如图：<br>b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。<br>b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 “V” 形里。<br>b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 “V” 形里。<br>b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 “V” 形里。<br>b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 “V” 形里。<br>示例 2：</p><p>输入：grid &#x3D; [[-1]]<br>输出：[-1]<br>解释：球被卡在箱子左侧边上。<br>示例 3：</p><p>输入：grid &#x3D; [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]<br>输出：[0,1,2,3,4,-1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用模拟做，如果是1就看看右边是不是1，如果碰墙就返回-1，是-1就看看左边是不是-1，如果是1或者碰墙就返回-1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBall</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> level <span class="hljs-type">int</span>    m,n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        column := i;        <span class="hljs-keyword">for</span> level =<span class="hljs-number">0</span>; level&lt;m; level++&#123;            <span class="hljs-keyword">if</span> grid[level][column] == <span class="hljs-number">1</span>&#123;                <span class="hljs-keyword">if</span> column+<span class="hljs-number">1</span> == n || grid[level][column+<span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>&#123;                    res = <span class="hljs-built_in">append</span>(res, <span class="hljs-number">-1</span>)                    <span class="hljs-keyword">break</span>                &#125;<span class="hljs-keyword">else</span> &#123;                    column++                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span> column<span class="hljs-number">-1</span> == <span class="hljs-number">-1</span> || grid[level][column<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>&#123;                    res = <span class="hljs-built_in">append</span>(res, <span class="hljs-number">-1</span>)                    <span class="hljs-keyword">break</span>                &#125;<span class="hljs-keyword">else</span>&#123;                    column--                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> level == m&#123;            res = <span class="hljs-built_in">append</span>(res, column)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了76.92%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了38.46%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1765. 地图中的最高点</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1765.%20%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1765.%20%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="地图中的最高点"><a href="#地图中的最高点" class="headerlink" title="地图中的最高点"></a><font size=6px>地图中的最高点</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个大小为 m x n 的整数矩阵 isWater ，它代表了一个由 陆地 和 水域 单元格组成的地图。</p><p>如果 isWater[i][j] &#x3D;&#x3D; 0 ，格子 (i, j) 是一个 陆地 格子。<br>如果 isWater[i][j] &#x3D;&#x3D; 1 ，格子 (i, j) 是一个 水域 格子。<br>你需要按照如下规则给每个单元格安排高度：</p><p>每个格子的高度都必须是非负的。<br>如果一个格子是是 水域 ，那么它的高度必须为 0 。<br>任意相邻的格子高度差 至多 为 1 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）<br>找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。</p><p>请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。如果有多种解法，请返回 任意一个 。</p><p>示例 1：</p><p>输入：isWater &#x3D; [[0,1],[0,0]]<br>输出：[[1,0],[2,1]]<br>解释：上图展示了给各个格子安排的高度。<br>蓝色格子是水域格，绿色格子是陆地格。<br>示例 2：</p><p>输入：isWater &#x3D; [[0,0,1],[1,0,0],[0,0,0]]<br>输出：[[1,1,0],[0,1,1],[1,2,2]]<br>解释：所有安排方案中，最高可行高度为 2 。<br>任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。</p><p>提示：</p><p>m &#x3D;&#x3D; isWater.length<br>n &#x3D;&#x3D; isWater[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 1000<br>isWater[i][j] 要么是 0 ，要么是 1 。<br>至少有 1 个水域格子。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用bfs，从每个水面开始bfs便利，每便利到一个就比之前加1 </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">highestPeak</span><span class="hljs-params">(isWater [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span> &#123;x,y <span class="hljs-type">int</span>&#125;    <span class="hljs-keyword">var</span> dirs = []pair&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;    <span class="hljs-keyword">var</span> p []pair    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;<span class="hljs-built_in">len</span>(isWater); i++&#123;        <span class="hljs-keyword">for</span> j:= <span class="hljs-number">0</span>; j&lt;<span class="hljs-built_in">len</span>(isWater[i]); j++&#123;            <span class="hljs-keyword">if</span> isWater[i][j] == <span class="hljs-number">1</span>&#123;                isWater[i][j] = <span class="hljs-number">0</span>                p = <span class="hljs-built_in">append</span>(p, pair&#123;i,j&#125;)            &#125;<span class="hljs-keyword">else</span>&#123;                isWater[i][j] = <span class="hljs-number">-1</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p) != <span class="hljs-number">0</span>&#123;        q := p[<span class="hljs-number">0</span>]        p = p[<span class="hljs-number">1</span>:]        <span class="hljs-keyword">for</span> _,i := <span class="hljs-keyword">range</span> dirs&#123;            x:= q.x + i.x            y := q.y + i.y            <span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;<span class="hljs-built_in">len</span>(isWater) &amp;&amp; y &gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;<span class="hljs-built_in">len</span>(isWater[<span class="hljs-number">0</span>]) &amp;&amp; isWater[x][y] == <span class="hljs-number">-1</span>&#123;                isWater[x][y] = isWater[q.x][q.y]+<span class="hljs-number">1</span>                p = <span class="hljs-built_in">append</span>(p,pair&#123;x,y&#125;)            &#125;                    &#125;    &#125;    <span class="hljs-keyword">return</span> isWater&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1748. 唯一元素的和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1748.%20%E5%94%AF%E4%B8%80%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1748.%20%E5%94%AF%E4%B8%80%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="唯一元素的和"><a href="#唯一元素的和" class="headerlink" title="唯一元素的和"></a><font size=6px>唯一元素的和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。</p><p>请你返回 nums 中唯一元素的 和 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,2]<br>输出：4<br>解释：唯一元素为 [1,3] ，和为 4 。<br>示例 2：</p><p>输入：nums &#x3D; [1,1,1,1,1]<br>输出：0<br>解释：没有唯一元素，和为 0 。<br>示例 3 ：</p><p>输入：nums &#x3D; [1,2,3,4,5]<br>输出：15<br>解释：唯一元素为 [1,2,3,4,5] ，和为 15 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一样的只能减去一次</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumOfUnique</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    count := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-built_in">len</span>(nums); i++&#123;        <span class="hljs-keyword">if</span> _,ok := m[nums[i]]; !ok&#123;            count+= nums[i]            m[nums[i]]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> m[nums[i]] == <span class="hljs-number">1</span>&#123;            m[nums[i]] = <span class="hljs-number">2</span>            count -=nums[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了72.55%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1791. 找出星型图的中心节点</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1791.%20%E6%89%BE%E5%87%BA%E6%98%9F%E5%9E%8B%E5%9B%BE%E7%9A%84%E4%B8%AD%E5%BF%83%E8%8A%82%E7%82%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1791.%20%E6%89%BE%E5%87%BA%E6%98%9F%E5%9E%8B%E5%9B%BE%E7%9A%84%E4%B8%AD%E5%BF%83%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="找出星型图的中心节点"><a href="#找出星型图的中心节点" class="headerlink" title="找出星型图的中心节点"></a><font size=6px>找出星型图的中心节点</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。</p><p>给你一个二维整数数组 edges ，其中 edges[i] &#x3D; [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。</p><p>示例 1：</p><p>输入：edges &#x3D; [[1,2],[2,3],[4,2]]<br>输出：2<br>解释：如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。<br>示例 2：</p><p>输入：edges &#x3D; [[1,2],[5,1],[1,3],[1,4]]<br>输出：1</p><p>提示：</p><p>3 &lt;&#x3D; n &lt;&#x3D; 105<br>edges.length &#x3D;&#x3D; n - 1<br>edges[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; ui, vi &lt;&#x3D; n<br>ui !&#x3D; vi<br>题目数据给出的 edges 表示一个有效的星型图</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找到频率最大的那个数就是中心节点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCenter</span><span class="hljs-params">(edges [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span>    res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">100001</span>)    maxNum := <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(edges);i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++&#123;            res[edges[i][j]]++            <span class="hljs-keyword">if</span> res[edges[i][j]]&gt;maxNum&#123;                maxNum = res[edges[i][j]]                ans = edges[i][j]            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：104 ms, 在所有 Go 提交中击败了98.78%的用户<br>   内存消耗：15.3 MB, 在所有 Go 提交中击败了46.34%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.删除链表倒数第k个节点</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="删除链表倒数第k个节点"><a href="#删除链表倒数第k个节点" class="headerlink" title="删除链表倒数第k个节点"></a><font size=6px>删除链表倒数第k个节点</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>示例 2：</p><p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br>示例 3：</p><p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]</p><p>提示：</p><p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针，先快指针走n步，再快慢指针一起走，快指针下一个是nil的时候慢指针刚好是倒数第n个</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * type ListNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *ListNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> head    &#125;    fastNode,slowNdoe := head,head    <span class="hljs-keyword">for</span>  i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fastNode = fastNode.Next;    &#125;    <span class="hljs-keyword">if</span> fastNode == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> head.Next    &#125;    <span class="hljs-keyword">for</span> fastNode.Next != <span class="hljs-literal">nil</span>  &#123;        fastNode = fastNode.Next        slowNdoe = slowNdoe.Next    &#125;    slowNdoe.Next = slowNdoe.Next.Next<span class="hljs-keyword">return</span> head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1725. 可以形成最大正方形的矩形数目</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1725.%20%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1725.%20%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="可以形成最大正方形的矩形数目"><a href="#可以形成最大正方形的矩形数目" class="headerlink" title="可以形成最大正方形的矩形数目"></a><font size=6px>可以形成最大正方形的矩形数目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个数组 rectangles ，其中 rectangles[i] &#x3D; [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。</p><p>如果存在 k 同时满足 k &lt;&#x3D; li 和 k &lt;&#x3D; wi ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。</p><p>设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。</p><p>请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 数目 。</p><p>示例 1：</p><p>输入：rectangles &#x3D; [[5,8],[3,9],[5,12],[16,5]]<br>输出：3<br>解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。<br>最大正方形的边长为 5 ，可以由 3 个矩形切分得到。<br>示例 2：</p><p>输入：rectangles &#x3D; [[2,3],[3,7],[4,3],[3,7]]<br>输出：3</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countGoodRectangles</span><span class="hljs-params">(rectangles [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    count, max := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,i := <span class="hljs-keyword">range</span> rectangles&#123;        <span class="hljs-keyword">if</span> max == min(i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>])&#123;            count++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> max &lt; min(i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>])&#123;            max = min(i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>])            count = <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> b    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a     &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了95.56%的用户<br>   内存消耗：6.4 MB, 在所有 Go 提交中击败了97.78%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>198. 打家劫舍</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><font size=6px>打家劫舍</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400<br>通过次数453,296提交次数866,676</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，递推方程    全球num[i] &#x3D; max(num[i-2],num[i-3])+nums[i]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> num []<span class="hljs-type">int</span>    num = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;=<span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;            res = max(res,nums[i])        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) ==<span class="hljs-number">3</span>&#123;            res = max(nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">2</span>],res)        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        num[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]        num[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>]        num[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">2</span>]+nums[<span class="hljs-number">0</span>]        res = max(num[<span class="hljs-number">0</span>],num[<span class="hljs-number">1</span>])        res = max(res,num[<span class="hljs-number">2</span>])        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">3</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;            num[i] = max(num[i<span class="hljs-number">-2</span>],num[i<span class="hljs-number">-3</span>])+nums[i]            res = max(res,num[i])        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">( a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1984. Minimum Difference Between Highest and Lowest of K Scores</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1984.%20Minimum%20Difference%20Between%20Highest%20and%20Lowest%20of%20K%20Scores/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1984.%20Minimum%20Difference%20Between%20Highest%20and%20Lowest%20of%20K%20Scores/</url>
    
    <content type="html"><![CDATA[<h3 id="Minimum-Difference-Between-Highest-and-Lowest-of-K-Scores"><a href="#Minimum-Difference-Between-Highest-and-Lowest-of-K-Scores" class="headerlink" title="Minimum Difference Between Highest and Lowest of K Scores"></a><font size=6px>Minimum Difference Between Highest and Lowest of K Scores</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.</p><p>Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.</p><p>Return the minimum possible difference.</p><p>Example 1:</p><p>Input: nums &#x3D; [90], k &#x3D; 1<br>Output: 0<br>Explanation: There is one way to pick score(s) of one student:</p><ul><li>[90]. The difference between the highest and lowest score is 90 - 90 &#x3D; 0.<br>The minimum possible difference is 0.<br>Example 2:</li></ul><p>Input: nums &#x3D; [9,4,1,7], k &#x3D; 2<br>Output: 2<br>Explanation: There are six ways to pick score(s) of two students:</p><ul><li>[9,4,1,7]. The difference between the highest and lowest score is 9 - 4 &#x3D; 5.</li><li>[9,4,1,7]. The difference between the highest and lowest score is 9 - 1 &#x3D; 8.</li><li>[9,4,1,7]. The difference between the highest and lowest score is 9 - 7 &#x3D; 2.</li><li>[9,4,1,7]. The difference between the highest and lowest score is 4 - 1 &#x3D; 3.</li><li>[9,4,1,7]. The difference between the highest and lowest score is 7 - 4 &#x3D; 3.</li><li>[9,4,1,7]. The difference between the highest and lowest score is 7 - 1 &#x3D; 6.<br>The minimum possible difference is 2.</li></ul><p>Constraints:</p><p>1 &lt;&#x3D; k &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>排序一下就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumDifference</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    sort.Ints(nums)    minNum := <span class="hljs-number">999999</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n-k+<span class="hljs-number">1</span>;i++&#123;        minNum = min(minNum, nums[i+k<span class="hljs-number">-1</span>]-nums[i])    &#125;    <span class="hljs-keyword">return</span> minNum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b     &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了94.74%的用户<br>   内存消耗：5 MB, 在所有 Go 提交中击败了89.47%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 两数相加</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><font size=6px>2. 两数相加</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 &#x3D; 807.<br>示例 2：</p><p>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]<br>示例 3：</p><p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p><p>提示：</p><p>每个链表中的节点数在范围 [1, 100] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9<br>题目数据保证列表表示的数字不含前导零</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>这题已经简化很多了，但是还是要考虑挺多情况，最重要的就是进位情况，弄一个新的链表用来存放两个链表的值，如果两个链表不等长，就把长的那个直接放在l3后面，最重要的这个时候要考虑连续进位的情况，记得用循环解决</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> l1.Next==<span class="hljs-literal">nil</span>&amp;&amp;l1.Val==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> l2    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2.Next==<span class="hljs-literal">nil</span>&amp;&amp;l2.Val==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> l1    &#125;    <span class="hljs-keyword">var</span> flag <span class="hljs-type">int</span>    l3 := &amp;ListNode&#123;&#125;    head :=l3    l3 .Val =l1.Val+l2.Val    <span class="hljs-keyword">if</span> l3.Val&gt;=<span class="hljs-number">10</span>&#123;        l3.Val %=<span class="hljs-number">10</span>        flag=<span class="hljs-number">1</span>    &#125;    l1 = l1.Next    l2 = l2.Next     <span class="hljs-keyword">for</span> l1!=<span class="hljs-literal">nil</span>&amp;&amp;l2 !=<span class="hljs-literal">nil</span>&#123;        node := &amp;ListNode&#123;&#125;        l3.Next=node        l3 = node        l3. Val  +=(l1.Val+l2.Val+flag)        <span class="hljs-keyword">if</span> l3.Val&gt;=<span class="hljs-number">10</span>&#123;            l3.Val %= <span class="hljs-number">10</span>            flag =<span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            flag = <span class="hljs-number">0</span>        &#125;        l1 = l1.Next        l2 = l2.Next    &#125;    <span class="hljs-comment">//l2和l1等长</span>    <span class="hljs-keyword">if</span> l2==<span class="hljs-literal">nil</span> &amp;&amp; l1 ==<span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span> &#123;            node := &amp;ListNode&#123;Val: <span class="hljs-number">1</span>&#125;            l3.Next = node        &#125;        <span class="hljs-comment">//l2长</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l1==<span class="hljs-literal">nil</span>&#123;        l3.Next = l2        <span class="hljs-keyword">if</span> flag==<span class="hljs-number">1</span>&#123;            l2.Val++            <span class="hljs-keyword">for</span> l2.Val&gt;=<span class="hljs-number">10</span>&#123;                <span class="hljs-keyword">if</span> l2.Next==<span class="hljs-literal">nil</span>&#123; <span class="hljs-comment">//连续进位情况</span>                    node := &amp;ListNode&#123;Val: <span class="hljs-number">1</span>&#125;                    l2.Val = <span class="hljs-number">0</span>                     l2.Next = node                    <span class="hljs-keyword">break</span>                &#125;                l2.Val %=<span class="hljs-number">10</span>                l2=l2.Next                l2.Val++            &#125;        &#125;        <span class="hljs-comment">//l1长</span>    &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> l2==<span class="hljs-literal">nil</span>&#123;        l3.Next = l1        <span class="hljs-keyword">if</span> flag ==<span class="hljs-number">1</span>&#123;            l1.Val++            <span class="hljs-keyword">for</span> l1.Val&gt;=<span class="hljs-number">10</span>&#123;                <span class="hljs-keyword">if</span> l1.Next == <span class="hljs-literal">nil</span>&#123;                    node := &amp;ListNode&#123;Val: <span class="hljs-number">1</span>&#125;<span class="hljs-comment">//连续进位情况</span>                    l1.Val=<span class="hljs-number">0</span>                    l1.Next= node                              <span class="hljs-keyword">break</span>                &#125;                l1.Val %=<span class="hljs-number">10</span>                l1=l1.Next                                l1.Val++            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了72.47%的用户<br>   内存消耗：4.6 MB, 在所有 Go 提交中击败了97.34%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>200. 岛屿数量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a><font size=6px>岛屿数量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1：</p><p>输入：grid &#x3D; [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：</p><p>输入：grid &#x3D; [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p><p>提示：</p><p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 300<br>grid[i][j] 的值为 ‘0’ 或 ‘1’</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典的dfs题，第一次到达就把flag置1，碰到一次下一次就不再重复碰</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> flag [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> move  =[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;    m,n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    flag = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(grid))    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i &lt; m;i++&#123;        flag[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span>        dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> flag[i][j] == <span class="hljs-number">1</span> || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        flag[i][j] = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++&#123;            x,y := move[k*<span class="hljs-number">2</span>] + i,move[k*<span class="hljs-number">2</span> +<span class="hljs-number">1</span>] + j            <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; flag[x][y] == <span class="hljs-number">0</span> &amp;&amp; grid[x][y] == <span class="hljs-string">&#x27;1&#x27;</span>&#123;                               dfs(x,y)            &#125;          &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j &lt;n; j++&#123;            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; flag[i][j] == <span class="hljs-number">0</span>&#123;                count ++                dfs(i,j)                            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了93.21%的用户<br>   内存消耗：5.1 MB, 在所有 Go 提交中击败了23.18%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2000. 反转单词前缀</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2000.%20%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%89%8D%E7%BC%80/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2000.%20%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h3 id="反转单词前缀"><a href="#反转单词前缀" class="headerlink" title="反转单词前缀"></a><font size=6px>反转单词前缀</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。</p><p>例如，如果 word &#x3D; “abcdefd” 且 ch &#x3D; “d” ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。结果字符串将会是 “dcbaefd” 。<br>返回 结果字符串 。</p><p>示例 1：</p><p>输入：word &#x3D; “abcdefd”, ch &#x3D; “d”<br>输出：”dcbaefd”<br>解释：”d” 第一次出现在下标 3 。<br>反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 “dcbaefd” 。<br>示例 2：</p><p>输入：word &#x3D; “xyxzxe”, ch &#x3D; “z”<br>输出：”zxyxxe”<br>解释：”z” 第一次也是唯一一次出现是在下标 3 。<br>反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 “zxyxxe” 。<br>示例 3：</p><p>输入：word &#x3D; “abcd”, ch &#x3D; “z”<br>输出：”abcd”<br>解释：”z” 不存在于 word 中。<br>无需执行反转操作，结果字符串是 “abcd” 。</p><p>提示：</p><p>1 &lt;&#x3D; word.length &lt;&#x3D; 250<br>word 由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reversePrefix</span><span class="hljs-params">(word <span class="hljs-type">string</span>, ch <span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> temp []<span class="hljs-type">byte</span>       <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(word); i++&#123;        <span class="hljs-keyword">if</span> word[i] == ch&#123;            <span class="hljs-keyword">for</span> j:=i ;j&gt;=<span class="hljs-number">0</span>;j--&#123;                temp = <span class="hljs-built_in">append</span>(temp, word[j])            &#125;            word = word[i+<span class="hljs-number">1</span>:]            <span class="hljs-keyword">break</span>        &#125;    &#125;    word = <span class="hljs-type">string</span>(temp)+word    <span class="hljs-keyword">return</span> word&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了92.98%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2006. 差的绝对值为 K 的数对数目</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2006.%20%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%BA%20K%20%E7%9A%84%E6%95%B0%E5%AF%B9%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2006.%20%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%BA%20K%20%E7%9A%84%E6%95%B0%E5%AF%B9%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="差的绝对值为-K-的数对数目"><a href="#差的绝对值为-K-的数对数目" class="headerlink" title="差的绝对值为 K 的数对数目"></a><font size=6px>差的绝对值为 K 的数对数目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums 和一个整数 k ，请你返回数对 (i, j) 的数目，满足 i &lt; j 且 |nums[i] - nums[j]| &#x3D;&#x3D; k 。</p><p>|x| 的值定义为：</p><p>如果 x &gt;&#x3D; 0 ，那么值为 x 。<br>如果 x &lt; 0 ，那么值为 -x 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,2,1], k &#x3D; 1<br>输出：4<br>解释：差的绝对值为 1 的数对为：</p><ul><li>[1,2,2,1]</li><li>[1,2,2,1]</li><li>[1,2,2,1]</li><li>[1,2,2,1]<br>示例 2：</li></ul><p>输入：nums &#x3D; [1,3], k &#x3D; 3<br>输出：0<br>解释：没有任何数对差的绝对值为 3 。<br>示例 3：</p><p>输入：nums &#x3D; [3,2,1,5,4], k &#x3D; 2<br>输出：3<br>解释：差的绝对值为 2 的数对为：</p><ul><li>[3,2,1,5,4]</li><li>[3,2,1,5,4]</li><li>[3,2,1,5,4]</li></ul><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100<br>1 &lt;&#x3D; k &lt;&#x3D; 99</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用哈希表 +（num+k &#x3D; num2）</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countKDifference</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    ans := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,num := <span class="hljs-keyword">range</span> nums&#123;        ans += (mp[num-k] +mp[num+k])        mp[num]++    &#125;    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了97.00%的用户<br>   内存消耗：4 MB, 在所有 Go 提交中击败了41.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2016. 增量元素之间的最大差值</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2016.%20%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2016.%20%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="增量元素之间的最大差值"><a href="#增量元素之间的最大差值" class="headerlink" title="增量元素之间的最大差值"></a><font size=6px>增量元素之间的最大差值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 &lt;&#x3D; i &lt; j &lt; n 且 nums[i] &lt; nums[j] 。</p><p>返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。</p><p>示例 1：</p><p>输入：nums &#x3D; [7,1,5,4]<br>输出：4<br>解释：<br>最大差值出现在 i &#x3D; 1 且 j &#x3D; 2 时，nums[j] - nums[i] &#x3D; 5 - 1 &#x3D; 4 。<br>注意，尽管 i &#x3D; 1 且 j &#x3D; 0 时 ，nums[j] - nums[i] &#x3D; 7 - 1 &#x3D; 6 &gt; 4 ，但 i &gt; j 不满足题面要求，所以 6 不是有效的答案。<br>示例 2：</p><p>输入：nums &#x3D; [9,4,3,2]<br>输出：-1<br>解释：<br>不存在同时满足 i &lt; j 和 nums[i] &lt; nums[j] 这两个条件的 i, j 组合。<br>示例 3：</p><p>输入：nums &#x3D; [1,5,2,10]<br>输出：9<br>解释：<br>最大差值出现在 i &#x3D; 0 且 j &#x3D; 3 时，nums[j] - nums[i] &#x3D; 10 - 1 &#x3D; 9 。</p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>2 &lt;&#x3D; n &lt;&#x3D; 1000<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从左往右遍历，如果一个数比最小值小那最小值就是这个数，然后如果比这个最小值大那就求最大差值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumDifference</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;=<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;    min := nums[<span class="hljs-number">0</span>]    maxNum := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> min &gt; nums[i]&#123;            min = nums[i]            <span class="hljs-keyword">continue</span>        &#125;        maxNum = max(nums[i] - min, maxNum)    &#125;    <span class="hljs-keyword">if</span> maxNum == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> maxNum    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了80.95%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2029. 石子游戏 IX</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2029.%20%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%20IX/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2029.%20%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%20IX/</url>
    
    <content type="html"><![CDATA[<h3 id="石子游戏-IX"><a href="#石子游戏-IX" class="headerlink" title="石子游戏 IX"></a><font size=6px>石子游戏 IX</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。</p><p>Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。</p><p>如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。<br>如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。<br>假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。</p><p>示例 1：</p><p>输入：stones &#x3D; [2,1]<br>输出：true<br>解释：游戏进行如下：</p><ul><li>回合 1：Alice 可以移除任意一个石子。</li><li>回合 2：Bob 移除剩下的石子。<br>已移除的石子的值总和为 1 + 2 &#x3D; 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。<br>示例 2：</li></ul><p>输入：stones &#x3D; [2]<br>输出：false<br>解释：Alice 会移除唯一一个石子，已移除石子的值总和为 2 。<br>由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。<br>示例 3：</p><p>输入：stones &#x3D; [5,1,2,4,3]<br>输出：false<br>解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：</p><ul><li>回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。</li><li>回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 &#x3D; 1 + 3 &#x3D; 4 。</li><li>回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 &#x3D; 1 + 3 + 4 &#x3D; 8 。</li><li>回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 &#x3D; 1 + 3 + 4 + 2 &#x3D; 10.</li><li>回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 &#x3D; 1 + 3 + 4 + 2 + 5 &#x3D; 15.<br>Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>s&#x3D;0 的石子数量为偶数：此时等价于没有 s &#x3D; 0s&#x3D;0 的石子，我们只需要关心 s &#x3D; 1s&#x3D;1 和 s &#x3D; 2s&#x3D;2 即可：</p><p>s &#x3D; 1s&#x3D;1 的石子数量为 00： 这意味着 A 开始选择的只能是 s &#x3D; 2s&#x3D;2，此时交给 B 的局面为「x &#x3D; 2x&#x3D;2、剩余石子只有 s &#x3D; 2s&#x3D;2」，此时 B 只能选 s &#x3D; 2s&#x3D;2 的石子，由于 x &#x3D; 2x&#x3D;2 且选择的石子 s &#x3D; 2s&#x3D;2，因此交由回 A 的局面为「x &#x3D; 1x&#x3D;1，剩余是在只有 s &#x3D; 2s&#x3D;2」，因此游戏继续的话 A 必败，同时如果在该过程的任何时刻石子被取完，也是 B 直接获胜，即 A 仍为必败；</p><p>s &#x3D; 2s&#x3D;2 的石子数量为 00：分析同理，A 只能选 s &#x3D; 1s&#x3D;1，此时交给 B 的局面为「x &#x3D; 1x&#x3D;1、剩余石子只有 s &#x3D; 1s&#x3D;1」，此时 B 只能选 s &#x3D; 1s&#x3D;1 的石子，由于 x &#x3D; 1x&#x3D;1 且选择的石子 s &#x3D; 1s&#x3D;1，因此交由回 A 的局面为「x &#x3D; 2x&#x3D;2，剩余是在只有 s &#x3D; 1s&#x3D;1」，因此游戏继续的话 A 必败，同时如果在该过程的任何时刻石子被取完，也是 B 直接获胜，即 A 仍为必败；</p><p>s &#x3D; 1s&#x3D;1 和 s &#x3D; 2s&#x3D;2 的石子数量均不为 00：A 选数量不是最多的一类石子，B 下一回合只能选择相同类型的石子（或是无从选择导致失败），然后游戏继续，最终 B 会先进入「只能凑成 33 的倍数」的局面导致失败，即 A 必胜。</p><p>s &#x3D; 0s&#x3D;0 的石子数量为奇数：此时等价于有一次换手机会，该换手机会必然应用在「对必败局面进行转移」才有意义，因此只有 s &#x3D; 1s&#x3D;1 和 s &#x3D; 2s&#x3D;2 的石子数量差大于 22，A 的先手优势不会因为存在换手机会而被转移：</p><p>两者数量差不超过 22：此时 B 可以利用「对方凑成 33 的倍数必败」规则和「优先使用 s &#x3D; 0s&#x3D;0 石子」权利来进入确保自己为必胜态：</p><p>举个 🌰，当 s &#x3D; 1s&#x3D;1 和 s &#x3D; 2s&#x3D;2 的石子数量相等，虽然有 s &#x3D; 0s&#x3D;0 的石子，A 先手，但是 A 的首个回合必然不能选 s &#x3D; 0s&#x3D;0，否则马上失败结束，因此 A 只能选 s &#x3D; 1s&#x3D;1 或 s &#x3D; 2s&#x3D;2，此时 B直接选择 s &#x3D; 0s&#x3D;0 的石子，交由给 A 的局面 xx 没有发生改变，A 只能选择与首个回合相同的 ss 游戏才能继续，因此局面会变为「B 先手、s &#x3D; 1s&#x3D;1 和 s &#x3D; 2s&#x3D;2 的石子数量差为 22」，游戏继续，最终 A 会先遇到「只能凑成 33 的倍数」的局面，即 B 必胜。</p><p>两者数量差不超过 2：此时无论 A 选择数量较少或较多的 s，B 都在第二回合马上使用 s &#x3D; 0 的石子进行换手，A 只能继续选与第一回合相同类型的的石子，游戏才能进行，最终 A 会先遇到「只能凑成 3 的倍数」或「石子被取完」的局面，即 B 必胜。</p><p>两者数量差超过 2 ：此时即使 A 只要确保第一次选择数量较多的 s，不管 B 是否使用「优先使用 s &#x3D; 0s&#x3D;0」的石子，A 都有足够次数数量多 ss 来抵消换手（或是在 B 放弃使用 s &#x3D; 0s&#x3D;0 之后马上使用），最终都是 B 最先遇到「只能凑成 33 的倍数」的局面，即 A 获胜。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stoneGameIX</span><span class="hljs-params">(stones []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> mode_0,mode_1,mode_2 <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> stones&#123;        <span class="hljs-keyword">if</span> v %<span class="hljs-number">3</span> == <span class="hljs-number">0</span>&#123;            mode_0 ++        &#125;        <span class="hljs-keyword">if</span> v %<span class="hljs-number">3</span> == <span class="hljs-number">1</span>&#123;            mode_1 ++        &#125;        <span class="hljs-keyword">if</span> v % <span class="hljs-number">3</span> ==<span class="hljs-number">2</span> &#123;            mode_2 ++        &#125;    &#125;    <span class="hljs-keyword">if</span> mode_0 % <span class="hljs-number">2</span> ==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> mode_1&gt;=<span class="hljs-number">1</span> &amp;&amp; mode_2 &gt;=<span class="hljs-number">1</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> abs(mode_1-mode_2)&gt;<span class="hljs-number">2</span>    &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a &lt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> -a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：8.9 MB, 在所有 Go 提交中击败了73.08%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2047. 句子中的有效单词数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/2047.%20%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/2047.%20%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="句子中的有效单词数"><a href="#句子中的有效单词数" class="headerlink" title="句子中的有效单词数"></a><font size=6px>句子中的有效单词数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>句子仅由小写字母（’a’ 到 ‘z’）、数字（’0’ 到 ‘9’）、连字符（’-‘）、标点符号（’!’、’.’ 和 ‘,’）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。</p><p>如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：</p><p>仅由小写字母、连字符和&#x2F;或标点（不含数字）。<br>至多一个 连字符 ‘-‘ 。如果存在，连字符两侧应当都存在小写字母（”a-b” 是一个有效单词，但 “-ab” 和 “ab-“ 不是有效单词）。<br>至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。<br>这里给出几个有效单词的例子：”a-b.”、”afad”、”ba-c”、”a!” 和 “!” 。</p><p>给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。</p><p>示例 1：</p><p>输入：sentence &#x3D; “cat and  dog”<br>输出：3<br>解释：句子中的有效单词是 “cat”、”and” 和 “dog”<br>示例 2：</p><p>输入：sentence &#x3D; “!this  1-s b8d!”<br>输出：0<br>解释：句子中没有有效单词<br>“!this” 不是有效单词，因为它以一个标点开头<br>“1-s” 和 “b8d” 也不是有效单词，因为它们都包含数字<br>示例 3：</p><p>输入：sentence &#x3D; “alice and  bob are playing stone-game10”<br>输出：5<br>解释：句子中的有效单词是 “alice”、”and”、”bob”、”are” 和 “playing”<br>“stone-game10” 不是有效单词，因为它含有数字<br>示例 4：</p><p>输入：sentence &#x3D; “he bought 2 pencils, 3 erasers, and 1  pencil-sharpener.”<br>输出：6<br>解释：句子中的有效单词是 “he”、”bought”、”pencils,”、”erasers,”、”and” 和 “pencil-sharpener.”</p><p>提示：</p><p>1 &lt;&#x3D; sentence.length &lt;&#x3D; 1000<br>sentence 由小写英文字母、数字（0-9）、以及字符（’ ‘、’-‘、’!’、’.’ 和 ‘,’）组成<br>句子中至少有 1 个 token</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countValidWords</span><span class="hljs-params">(sentence <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    ss := strings.Split(sentence, <span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>        <span class="hljs-keyword">for</span> _,i := <span class="hljs-keyword">range</span> ss&#123;        <span class="hljs-keyword">if</span> iscorrect(i)&#123;            count ++        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">iscorrect</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span><span class="hljs-type">bool</span>&#123;    biaodian := []<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>&#125;    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot; &quot;</span> || s == <span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;     count_ := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">if</span> s[i] &gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;=<span class="hljs-string">&#x27;9&#x27;</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;-&#x27;</span>&#123;            count_ ++            <span class="hljs-keyword">if</span> count_&gt;=<span class="hljs-number">2</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span> || i==<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;                    &#125;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++&#123;            <span class="hljs-keyword">if</span> s[i] == biaodian[j]&#123;                                <span class="hljs-keyword">if</span> i != <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                &#125;                <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> &amp;&amp; s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.9 MB, 在所有 Go 提交中击败了42.33%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>206. 反转链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><h4 id="思路-无"><a href="#思路-无" class="headerlink" title="思路:无"></a>思路:无</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">var</span> head2  *ListNode=<span class="hljs-literal">nil</span>/    <span class="hljs-keyword">for</span> head!=<span class="hljs-literal">nil</span>&#123;        tmp:=head.Next        head.Next=head2        head2=head        head=tmp    &#125;    <span class="hljs-keyword">return</span> head2&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>207. 课程表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a><font size=6px>课程表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p><p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p><p>示例 1：</p><p>输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]<br>输出：true<br>解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。<br>示例 2：</p><p>输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]<br>输出：false<br>解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一个拓扑排序题，寻找有无循环，用dfs做比较合适，找到是否有循环，记得找完一个节点后visit[num ] &#x3D; 2</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    edge := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, numCourses)    visit := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)    <span class="hljs-keyword">var</span> flag <span class="hljs-type">bool</span>     flag = <span class="hljs-literal">false</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span>&#123;        visit[num] = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(edge[num]) ;i++&#123;            <span class="hljs-keyword">if</span> visit[edge[num][i]] ==<span class="hljs-number">0</span> &#123;                dfs(edge[num][i])            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> visit[edge[num][i]] ==<span class="hljs-number">1</span>&#123;                flag = <span class="hljs-literal">true</span>                 <span class="hljs-keyword">return</span>            &#125;        &#125;        visit[num ] = <span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">for</span> _, info := <span class="hljs-keyword">range</span> prerequisites&#123;        edge[info[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(edge[info[<span class="hljs-number">1</span>]], info[<span class="hljs-number">0</span>])    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;numCourses; i++&#123;        <span class="hljs-keyword">if</span> visit[i] == <span class="hljs-number">0</span>&#123;            dfs(i)        &#125;    &#125;    <span class="hljs-keyword">return</span> !flag&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了94.35%的用户<br>   内存消耗：6 MB, 在所有 Go 提交中击败了86.68%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>208. Implement Trie (Prefix Tree)</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/208.%20Implement%20Trie%20(Prefix%20Tree)/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/208.%20Implement%20Trie%20(Prefix%20Tree)/</url>
    
    <content type="html"><![CDATA[<h3 id="Implement-Trie-Prefix-Tree"><a href="#Implement-Trie-Prefix-Tree" class="headerlink" title="Implement Trie (Prefix Tree)"></a><font size=6px>Implement Trie (Prefix Tree)</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p><p>Implement the Trie class:</p><p>Trie() Initializes the trie object.<br>void insert(String word) Inserts the string word into the trie.<br>boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.<br>boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.</p><p>Example 1:</p><p>Input<br>[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”]<br>[[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]<br>Output<br>[null, null, true, false, true, null, true]</p><p>Explanation<br>Trie trie &#x3D; new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   &#x2F;&#x2F; return True<br>trie.search(“app”);     &#x2F;&#x2F; return False<br>trie.startsWith(“app”); &#x2F;&#x2F; return True<br>trie.insert(“app”);<br>trie.search(“app”);     &#x2F;&#x2F; return True</p><p>Constraints:</p><p>1 &lt;&#x3D; word.length, prefix.length &lt;&#x3D; 2000<br>word and prefix consist only of lowercase English letters.<br>At most 3 * 104 calls in total will be made to insert, search, and startsWith.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>26叉树，知道了之后不难</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;    children [<span class="hljs-number">26</span>]*Trie    isEnd    <span class="hljs-type">bool</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie &#123;    <span class="hljs-keyword">return</span> Trie&#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>)  &#123;        trie := this        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(word); i++&#123;            <span class="hljs-keyword">if</span> trie.children[word[i]-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nil</span>&#123;                trie.children[word[i]-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-built_in">new</span>(Trie)            &#125;                        trie = trie.children[word[i]-<span class="hljs-string">&#x27;a&#x27;</span>]        &#125;        trie.isEnd = <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;    trie := this    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(word);i++&#123;        <span class="hljs-keyword">if</span> trie.children[word[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        trie = trie.children[word[i] - <span class="hljs-string">&#x27;a&#x27;</span>]    &#125;    <span class="hljs-keyword">return</span> trie.isEnd&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> StartsWith(prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;    trie := this    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(prefix);i++&#123;        <span class="hljs-keyword">if</span> trie.children[prefix[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        trie = trie.children[prefix[i] - <span class="hljs-string">&#x27;a&#x27;</span>]    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor();</span><span class="hljs-comment"> * obj.Insert(word);</span><span class="hljs-comment"> * param_2 := obj.Search(word);</span><span class="hljs-comment"> * param_3 := obj.StartsWith(prefix);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了96.45%的用户<br>   内存消耗：18 MB, 在所有 Go 提交中击败了21.89%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21. 合并两个有序链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例 1：</p><p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]<br>示例 2：</p><p>输入：l1 &#x3D; [], l2 &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：l1 &#x3D; [], l2 &#x3D; [0]<br>输出：[0]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> l1==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> l2    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> l1    &#125;    head,l3 := &amp;ListNode&#123;&#125;,&amp;ListNode&#123;&#125;    <span class="hljs-keyword">if</span> l1.Val&gt;l2.Val&#123;        head = l2    &#125;<span class="hljs-keyword">else</span>&#123;        head = l1    &#125;        <span class="hljs-keyword">for</span> l1!=<span class="hljs-literal">nil</span>&amp;&amp;l2!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> l1.Val &gt; l2.Val&#123;            l3.Next=l2            l3 = l2            l2 = l2.Next        &#125;<span class="hljs-keyword">else</span>&#123;            l3.Next=l1            l3 = l1            l1 = l1.Next        &#125;    &#125;    <span class="hljs-keyword">if</span> l1!=<span class="hljs-literal">nil</span>&#123;        l3.Next = l1    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2!=<span class="hljs-literal">nil</span>&#123;        l3.Next = l2    &#125;    <span class="hljs-keyword">return</span> head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.5 MB, 在所有 Go 提交中击败了82.71%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>215. 数组中的第K个最大元素</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><font size=6px>数组中的第K个最大元素</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k &#x3D; 2<br>输出: 5<br>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4<br>输出: 4<br>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以用堆排序做，第k个就是堆排序k次之后在顶点的那个数就是第k大的数字</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;        heapSize := <span class="hljs-built_in">len</span>(nums)        start := heapSize/ <span class="hljs-number">2</span>        <span class="hljs-comment">//制造初始大顶堆</span>        <span class="hljs-keyword">for</span> i:=start;i&gt;=<span class="hljs-number">0</span>;i--&#123;           MaxHeaPify(nums,i,heapSize)        &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k<span class="hljs-number">-1</span>;i++&#123;            nums[heapSize<span class="hljs-number">-1</span>] , nums[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>] , nums[heapSize<span class="hljs-number">-1</span>]            heapSize--            MaxHeaPify(nums,<span class="hljs-number">0</span>,heapSize)        &#125;    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MaxHeaPify</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>,i <span class="hljs-type">int</span>,heapSize <span class="hljs-type">int</span>)</span></span>  &#123;    l,r,largest := i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>,i    <span class="hljs-keyword">if</span> l&lt;heapSize &amp;&amp; nums[l] &gt; nums[largest]&#123;        largest = l    &#125;    <span class="hljs-keyword">if</span> r&lt;heapSize &amp;&amp;nums[r] &gt;nums[largest]&#123;        largest = r    &#125;    <span class="hljs-keyword">if</span> i !=largest&#123;        nums[i] ,nums[largest] = nums[largest] ,nums[i]        MaxHeaPify(nums,largest,heapSize)    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了85.94%的用户<br>   内存消耗：3.4 MB, 在所有 Go 提交中击败了89.56%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22. 括号生成</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><font size=6px>括号生成</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：[“()”]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 8<br>通过次数408,548提交次数528,598</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用dfs回溯法遍历所有可能</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(l,r <span class="hljs-type">int</span>,s <span class="hljs-type">string</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(l,r <span class="hljs-type">int</span>,s <span class="hljs-type">string</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> l ==n &amp;&amp; r == n&#123;            res = <span class="hljs-built_in">append</span>(res,s)            <span class="hljs-keyword">return</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l&gt;n || r &gt;n || r&gt;l&#123;            <span class="hljs-keyword">return</span>        &#125;        s = s+<span class="hljs-string">&quot;(&quot;</span>        dfs(l+<span class="hljs-number">1</span>,r,s)        s = s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]        s = s+<span class="hljs-string">&quot;)&quot;</span>        dfs(l,r+<span class="hljs-number">1</span>,s)        s = s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]    &#125;    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,s)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了10.59%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了52.39%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>213. 打家劫舍 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%202/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%202/</url>
    
    <content type="html"><![CDATA[<h3 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="打家劫舍 II"></a><font size=6px>打家劫舍 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 3：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：3</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划和1一样，首位最多只能有一个，所以判断两次就行，一次只有瘦，一次只有尾</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>])    &#125;    <span class="hljs-keyword">return</span> max(_rob(nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]), _rob(nums[<span class="hljs-number">1</span>:]))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]    &#125;    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]    dp[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;        dp[i] = max(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>])    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> x &gt; y &#123;        <span class="hljs-keyword">return</span> x    &#125;    <span class="hljs-keyword">return</span> y&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>221. 最大正方形</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/221.%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/221.%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><font size=6px>最大正方形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p>示例 1：</p><p>输入：matrix &#x3D; [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：4<br>示例 2：</p><p>输入：matrix &#x3D; [[“0”,”1”],[“1”,”0”]]<br>输出：1<br>示例 3：</p><p>输入：matrix &#x3D; [[“0”]]<br>输出：0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以使用动态规划降低时间复杂度。我们用 \textit{dp}(i, j)dp(i,j) 表示以 (i, j)(i,j) 为右下角，且只包含 11 的正方形的边长最大值。如果我们能计算出所有 \textit{dp}(i, j)dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 11 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 \textit{dp}dp 中的每个元素值呢？对于每个位置 (i, j)(i,j)，检查在矩阵中该位置的值：</p><p>如果该位置的值是 00，则 \textit{dp}(i, j) &#x3D; 0dp(i,j)&#x3D;0，因为当前位置不可能在由 11 组成的正方形中；</p><p>如果该位置的值是 11，则 \textit{dp}(i, j)dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 \textit{dp}dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 11，状态转移方程如下：</p><p>dp(i, j)&#x3D;min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1<br>dp(i,j)&#x3D;min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1</p><p>如果读者对这个状态转移方程感到不解，可以参考 1277. 统计全为 1 的正方形子矩阵的官方题解，其中给出了详细的证明。</p><p>此外，还需要考虑边界条件。如果 ii 和 jj 中至少有一个为 00，则以位置 (i, j)(i,j) 为右下角的最大正方形的边长只能是 11，因此 \textit{dp}(i, j) &#x3D; 1dp(i,j)&#x3D;1。</p><p><img src="https://assets.leetcode-cn.com/solution-static/221/221_fig1.png"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min1</span><span class="hljs-params">(a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span>,c <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> min <span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> a&lt;b&#123;        min=a    &#125;<span class="hljs-keyword">else</span>&#123;        min=b    &#125;    <span class="hljs-keyword">if</span> min&gt;c&#123;        min=c    &#125;    <span class="hljs-keyword">return</span> min&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> matrix==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span> =<span class="hljs-number">0</span>    row:=<span class="hljs-built_in">len</span>(matrix)    line:=<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])    <span class="hljs-keyword">var</span> arr[<span class="hljs-number">301</span>][<span class="hljs-number">301</span>]<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;row;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;line;j++&#123;            <span class="hljs-keyword">if</span> matrix[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>&#123;                arr[i][j]=<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&#123;                    <span class="hljs-keyword">if</span> arr[i<span class="hljs-number">-1</span>][j]&gt;=<span class="hljs-number">1</span>&amp;&amp;arr[i][j<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">1</span>&amp;&amp;arr[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">1</span>&#123;                        arr[i][j]=min1(arr[i<span class="hljs-number">-1</span>][j],arr[i][j<span class="hljs-number">-1</span>],arr[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span>                    &#125;                &#125;                <span class="hljs-keyword">if</span> max &lt;arr[i][j]&#123;                    max=arr[i][j]                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> max*max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了73.93%的用户<br>   内存消耗：3.9 MB, 在所有 Go 提交中击败了81.35%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>238. 除自身以外数组的乘积</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/238.%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/238.%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><font size=6px>除自身以外数组的乘积</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p><p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p><p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,2,3,4]<br>输出: [24,12,8,6]<br>示例 2:</p><p>输入: nums &#x3D; [-1,1,0,-3,3]<br>输出: [0,0,9,0,0]</p><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-30 &lt;&#x3D; nums[i] &lt;&#x3D; 30<br>保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内</p><p>进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>结果是乘以左右的所有数字和乘以右边所有数字，构造两个数列，分别是从左往右的乘数结果和从右往左的乘数结果</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> l,r []<span class="hljs-type">int</span>    l,r = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums)),<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    l[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]     r[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] = nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        l[i] = l[i<span class="hljs-number">-1</span>] *nums[i]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        r[i] = r[i+<span class="hljs-number">1</span>] * nums[i]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>&#123;            nums[i] = r[<span class="hljs-number">1</span>]            <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">if</span> i== <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>&#123;            nums[i] = l[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>]            <span class="hljs-keyword">continue</span>        &#125;        nums[i] = l[i<span class="hljs-number">-1</span>] * r[i+<span class="hljs-number">1</span>]    &#125;    <span class="hljs-keyword">return</span> nums&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了82.65%的用户<br>   内存消耗：7.2 MB, 在所有 Go 提交中击败了98.41%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>279. 完全平方数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><font size=6px>完全平方数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例 1：</p><p>输入：n &#x3D; 12<br>输出：3<br>解释：12 &#x3D; 4 + 4 + 4<br>示例 2：</p><p>输入：n &#x3D; 13<br>输出：2<br>解释：13 &#x3D; 4 + 9</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划 d p[i] &#x3D; min(dp[i-j*j]……)+1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>       <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        minNum := <span class="hljs-number">9999</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;i&gt;=j*j;j++&#123;            minNum = min(minNum, dp[i-j*j])        &#125;        <span class="hljs-keyword">if</span> minNum!= <span class="hljs-number">9999</span>&#123;            dp[i] = minNum+<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-comment">// fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> dp[n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了86.13%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了90.94%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>239. 滑动窗口最大值</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><font size=6px>滑动窗口最大值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7<br>示例 2：</p><p>输入：nums &#x3D; [1], k &#x3D; 1<br>输出：[1]</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>构建单调递减队列，</p><p>输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3<br>输出: [3,3,5,5,6,7]</p><p>解释过程中队列中都是具体的值，方便理解，具体见代码。<br>初始状态：L&#x3D;R&#x3D;0,队列:{}<br>i&#x3D;0,nums[0]&#x3D;1。队列为空,直接加入。队列：{1}<br>i&#x3D;1,nums[1]&#x3D;3。队尾值为1，3&gt;1，弹出队尾值，加入3。队列：{3}<br>i&#x3D;2,nums[2]&#x3D;-1。队尾值为3，-1&lt;3，直接加入。队列：{3,-1}。此时窗口已经形成，L&#x3D;0,R&#x3D;2，result&#x3D;[3]<br>i&#x3D;3,nums[3]&#x3D;-3。队尾值为-1，-3&lt;-1，直接加入。队列：{3,-1,-3}。队首3对应的下标为1，L&#x3D;1,R&#x3D;3，有效。result&#x3D;[3,3]<br>i&#x3D;4,nums[4]&#x3D;5。队尾值为-3，5&gt;-3，依次弹出后加入。队列：{5}。此时L&#x3D;2,R&#x3D;4，有效。result&#x3D;[3,3,5]<br>i&#x3D;5,nums[5]&#x3D;3。队尾值为5，3&lt;5，直接加入。队列：{5,3}。此时L&#x3D;3,R&#x3D;5，有效。result&#x3D;[3,3,5,5]<br>i&#x3D;6,nums[6]&#x3D;6。队尾值为3，6&gt;3，依次弹出后加入。队列：{6}。此时L&#x3D;4,R&#x3D;6，有效。result&#x3D;[3,3,5,5,6]<br>i&#x3D;7,nums[7]&#x3D;7。队尾值为6，7&gt;6，弹出队尾值后加入。队列：{7}。此时L&#x3D;5,R&#x3D;7，有效。result&#x3D;[3,3,5,5,6,7]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">var</span> queue []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    queue = <span class="hljs-built_in">append</span>(queue, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> ;i&lt;k;i++&#123;        <span class="hljs-keyword">for</span> j:= <span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span> ;j--&#123;            <span class="hljs-keyword">if</span> nums[queue[j]] &lt; nums[i]&#123;                queue = queue[:<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>]            &#125;<span class="hljs-keyword">else</span>&#123;                queue = <span class="hljs-built_in">append</span>(queue, i)                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue ) == <span class="hljs-number">0</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, i)        &#125;    &#125;    res = <span class="hljs-built_in">append</span>(res, nums[queue[<span class="hljs-number">0</span>]])    l,r := <span class="hljs-number">1</span>,k    <span class="hljs-keyword">for</span> r &lt; n&#123;        <span class="hljs-keyword">for</span> j:= <span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span> ;j--&#123;            <span class="hljs-keyword">if</span> nums[queue[j]] &lt; nums[r]&#123;                queue = queue[:<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>]            &#125;<span class="hljs-keyword">else</span>&#123;                queue = <span class="hljs-built_in">append</span>(queue, r)                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue ) == <span class="hljs-number">0</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, r)        &#125;        <span class="hljs-keyword">for</span> queue[<span class="hljs-number">0</span>] &lt; l&#123;            queue = queue[<span class="hljs-number">1</span>:]        &#125;        res = <span class="hljs-built_in">append</span>(res, nums[queue[<span class="hljs-number">0</span>]])        l++        r++    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：228 ms, 在所有 Go 提交中击败了32.94%的用户<br>   内存消耗：8.7 MB, 在所有 Go 提交中击败了99.72%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>283. 移动零</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><font size=6px>移动零</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1:</p><p>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p><p>输入: nums &#x3D; [0]<br>输出: [0]</p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;=<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span>     &#125;    l, r, n := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">for</span> r &lt;n &#123;        <span class="hljs-keyword">if</span> nums[r] != <span class="hljs-number">0</span>&#123;            nums[l], nums[r] = nums[r], nums[l]            l++        &#125;        r++    &#125;    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了81.98%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了97.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>287. 寻找重复数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a><font size=6px>寻找重复数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p><p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,4,2,2]<br>输出：2<br>示例 2：</p><p>输入：nums &#x3D; [3,1,3,4,2]<br>输出：3</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 105<br>nums.length &#x3D;&#x3D; n + 1<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; n<br>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</p><p>进阶：</p><p>如何证明 nums 中至少存在一个重复的数字?<br>你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>思路没怎么看懂，快慢指针</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    slow, fast := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> slow, fast = nums[slow], nums[nums[fast]]; slow != fast; slow, fast = nums[slow], nums[nums[fast]] &#123; &#125;    slow = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> slow != fast &#123;        slow = nums[slow]        fast = nums[fast]    &#125;    <span class="hljs-keyword">return</span> slow&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：80 ms, 在所有 Go 提交中击败了95.18%的用户<br>   内存消耗：8.3 MB, 在所有 Go 提交中击败了87.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>297. Serialize and Deserialize Binary Tree</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/297.%20Serialize%20and%20Deserialize%20Binary%20Tree/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/297.%20Serialize%20and%20Deserialize%20Binary%20Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="Serialize-and-Deserialize-Binary-Tree"><a href="#Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="Serialize and Deserialize Binary Tree"></a><font size=6px>Serialize and Deserialize Binary Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization&#x2F;deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p>Clarification: The input&#x2F;output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p>Example 1:</p><p>Input: root &#x3D; [1,2,3,null,null,4,5]<br>Output: [1,2,3,null,null,4,5]<br>Example 2:</p><p>Input: root &#x3D; []<br>Output: []</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [0, 104].<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用队列层次遍历一个二叉树变成string，再把string通过逗号分隔，再层次遍历成二叉树.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">struct</span> &#123;     &#125;   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Codec &#123;    <span class="hljs-keyword">return</span> Codec&#123;&#125;&#125;<span class="hljs-comment">// Serializes a tree to a single string.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> serialize(root *TreeNode) <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> queue []*TreeNode   <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;       <span class="hljs-keyword">return</span> s   &#125;   queue = <span class="hljs-built_in">append</span>(queue, root)    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>&#123;        node := queue[<span class="hljs-number">0</span>]        queue = queue[<span class="hljs-number">1</span>:]        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span>&#123;            s += <span class="hljs-string">&quot;,null&quot;</span>            <span class="hljs-keyword">continue</span>        &#125;                s += <span class="hljs-string">&quot;,&quot;</span>+strconv.Itoa(node.Val)        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, node.Left)        &#125;<span class="hljs-keyword">else</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, <span class="hljs-literal">nil</span>)        &#125;        <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, node.Right)        &#125;<span class="hljs-keyword">else</span>&#123;            queue = <span class="hljs-built_in">append</span>(queue, <span class="hljs-literal">nil</span>)        &#125;    &#125;   <span class="hljs-keyword">return</span> s[<span class="hljs-number">1</span>:]&#125;<span class="hljs-comment">// Deserializes your encoded data to tree.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> deserialize(data <span class="hljs-type">string</span>) *TreeNode &#123;        <span class="hljs-keyword">if</span> data == <span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-keyword">var</span> queue []*TreeNode    <span class="hljs-keyword">var</span> datas []<span class="hljs-type">string</span> = strings.Split(data,<span class="hljs-string">&quot;,&quot;</span>)    val,_ := strconv.Atoi(datas[<span class="hljs-number">0</span>])    root := &amp;TreeNode&#123;Val:val&#125;        queue = <span class="hljs-built_in">append</span>(queue, root)    index :=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> index&lt;<span class="hljs-built_in">len</span>(datas)&#123;        node := queue[<span class="hljs-number">0</span>]        queue = queue[<span class="hljs-number">1</span>:]        left := datas[index]        right := datas[index+<span class="hljs-number">1</span>]        <span class="hljs-keyword">if</span> left[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;n&#x27;</span>&#123;            Left, _ := strconv.Atoi(left)            node.Left = &amp;TreeNode&#123;Val:Left&#125;            queue = <span class="hljs-built_in">append</span>(queue, node.Left)        &#125;<span class="hljs-keyword">else</span>&#123;            node.Left = <span class="hljs-literal">nil</span>        &#125;        <span class="hljs-keyword">if</span> right[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;n&#x27;</span>&#123;            Right,_ := strconv.Atoi(right)            node.Right = &amp;TreeNode&#123;Val:Right&#125;            queue = <span class="hljs-built_in">append</span>(queue, node.Right)        &#125;<span class="hljs-keyword">else</span>&#123;            node.Right = <span class="hljs-literal">nil</span>        &#125;        index +=<span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">return</span> root&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your Codec object will be instantiated and called as such:</span><span class="hljs-comment"> * ser := Constructor();</span><span class="hljs-comment"> * deser := Constructor();</span><span class="hljs-comment"> * data := ser.serialize(root);</span><span class="hljs-comment"> * ans := deser.deserialize(data);</span><span class="hljs-comment"> */</span></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：116 ms, 在所有 Go 提交中击败了9.89%的用户<br>   内存消耗：10.8 MB, 在所有 Go 提交中击败了15.04%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>309. 最佳买卖股票时机含冷冻期</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><font size=6px>最佳买卖股票时机含冷冻期</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: prices &#x3D; [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]<br>示例 2:</p><p>输入: prices &#x3D; [1]<br>输出: 0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用动态规划来做，</p><p>&#x2F;&#x2F; dp[0]是持有股票<br>&#x2F;&#x2F; dp[1]是在冷静期<br>&#x2F;&#x2F; dp[2]是不在冷静期也不持有股票</p><p>找出他们的递推公式</p><p>dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][2]-prices[i])   &#x2F;&#x2F; 持有股票的最佳策略是上一个价格买或者继续持有<br>        dp[i][1] &#x3D; dp[i-1][0] + prices[i]。&#x2F;&#x2F; 冷静期上上一个状态加上卖的钱<br>        dp[i][2] &#x3D; max(dp[i-1][1], dp[i-1][2])。&#x2F;&#x2F;不在冷静期的状态最好的情况是选取冷静期和不在冷静期的最大值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(prices)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    dp := <span class="hljs-built_in">make</span>([][<span class="hljs-number">3</span>]<span class="hljs-type">int</span>, n)    <span class="hljs-comment">// dp[0]是持有股票</span>    <span class="hljs-comment">// dp[1]是在冷静期</span>    <span class="hljs-comment">// dp[2]是不在冷静期也不持有股票</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i &lt;<span class="hljs-built_in">len</span>(prices);i++&#123;        dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]-prices[i])        dp[i][<span class="hljs-number">1</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + prices[i]        dp[i][<span class="hljs-number">2</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>])    &#125;    <span class="hljs-keyword">return</span> max(dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>], dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.3 MB, 在所有 Go 提交中击败了74.08%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31. 下一个排列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a><font size=6px>下一个排列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[1,3,2]<br>示例 2：</p><p>输入：nums &#x3D; [3,2,1]<br>输出：[1,2,3]<br>示例 3：</p><p>输入：nums &#x3D; [1,1,5]<br>输出：[1,5,1]<br>示例 4：</p><p>输入：nums &#x3D; [1]<br>输出：[1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p> 先从后往前找到第一个非降序的数字num[i]，再从后往前找到一个比第一个非降序的数字小的数，然后交换，交换完之后把第一个非降序的数字i+1到len（nums）进行倒叙排列。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123; <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;=<span class="hljs-number">1</span>&#123;     <span class="hljs-keyword">return</span>  &#125;  i,j,k := <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> i&gt;=<span class="hljs-number">0</span> &amp;&amp;nums[i] &gt;=nums[j] &#123;     i--     j-- &#125; <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-number">0</span>&#123;     <span class="hljs-keyword">for</span> nums[k] &lt;= nums[i]&#123;         k--     &#125;     nums[k], nums[i] = nums[i], nums[k] &#125;<span class="hljs-keyword">for</span> i,j = j,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i&lt;j; &#123;    nums[i],nums[j] = nums[j],nums[i]    i++    j-- &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>312. 戳气球</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/312.%20%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/312.%20%E6%88%B3%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h3 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><font size=6px>戳气球</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p><p>求所能获得硬币的最大数量。</p><p>示例 1：<br>输入：nums &#x3D; [3,1,5,8]<br>输出：167<br>解释：<br>nums &#x3D; [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; []<br>coins &#x3D;  3<em>1</em>5    +   3<em>5</em>8   +  1<em>3</em>8  + 1<em>8</em>1 &#x3D; 167<br>示例 2：</p><p>输入：nums &#x3D; [1,5]<br>输出：10</p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划做，区级dp，太难了我直接看解析了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">2</span>)    res[<span class="hljs-number">0</span>], res[n+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        res[i] = nums[i<span class="hljs-number">-1</span>]    &#125;    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n+<span class="hljs-number">2</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">2</span>;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">2</span>)    &#125;    <span class="hljs-keyword">for</span> i:=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">for</span> j:=i+<span class="hljs-number">2</span>;j&lt;=n+<span class="hljs-number">1</span>;j++&#123;            <span class="hljs-keyword">for</span> k:=i+<span class="hljs-number">1</span>;k&lt;j;k++&#123;                num := dp[i][k] + dp[k][j] + res[i]*res[j]*res[k]                dp[i][j] = max(dp[i][j], num)            &#125;        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n+<span class="hljs-number">1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：60 ms, 在所有 Go 提交中击败了76.44%的用户<br>   内存消耗：5.4 MB, 在所有 Go 提交中击败了27.56%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>322. Coin Change</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/322.%20Coin%20Change/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/322.%20Coin%20Change/</url>
    
    <content type="html"><![CDATA[<h3 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a><font size=6px>Coin Change</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.</p><p>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>You may assume that you have an infinite number of each kind of coin.</p><p>Example 1:</p><p>Input: coins &#x3D; [1,2,5], amount &#x3D; 11<br>Output: 3<br>Explanation: 11 &#x3D; 5 + 5 + 1<br>Example 2:</p><p>Input: coins &#x3D; [2], amount &#x3D; 3<br>Output: -1<br>Example 3:</p><p>Input: coins &#x3D; [1], amount &#x3D; 0<br>Output: 0</p><p>Constraints:</p><p>1 &lt;&#x3D; coins.length &lt;&#x3D; 12<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; amount &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>背包问题，得出递推公式d p[n] &#x3D; min(dp[coins[0],coins[1]….])+1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;     n := <span class="hljs-built_in">len</span>(coins)    <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">int</span>    ans = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=amount;i++&#123;        minNum := <span class="hljs-number">99999</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            <span class="hljs-keyword">if</span> coins[j] &lt;= i &#123;                <span class="hljs-keyword">if</span> ans[i-coins[j]] == <span class="hljs-number">0</span> &amp;&amp; i != coins[j]&#123;                    <span class="hljs-keyword">continue</span>                &#125;                minNum = min(minNum, ans[i-coins[j]])             &#125;        &#125;        <span class="hljs-keyword">if</span> minNum != <span class="hljs-number">99999</span> &#123;            ans[i] = minNum+<span class="hljs-number">1</span>        &#125;    &#125;        <span class="hljs-keyword">if</span> ans[amount] == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;    <span class="hljs-keyword">return</span> ans[amount]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> b    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了55.09%的用户<br>   内存消耗：6.3 MB, 在所有 Go 提交中击败了93.82%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>337. 打家劫舍 III</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/</url>
    
    <content type="html"><![CDATA[<h3 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a><font size=6px>打家劫舍 III</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。</p><p>除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><p>给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p><p>示例 1:</p><p>输入: root &#x3D; [3,2,3,null,3,null,1]<br>输出: 7<br>解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 &#x3D; 7<br>示例 2:</p><p>输入: root &#x3D; [3,4,5,1,3,null,1]<br>输出: 9<br>解释: 小偷一晚能够盗取的最高金额 4 + 5 &#x3D; 9</p><p>提示：</p><p>树的节点数在 [1, 104] 范围内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，两个map，一个f放本次本选中的最大值，g放本次未被选中的最大值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;        f,g := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*TreeNode]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*TreeNode]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)   <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>   dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;       <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;           <span class="hljs-keyword">return</span>        &#125;       dfs(root.Left)       dfs(root.Right)       f[root] = root.Val + g[root.Left] + g[root.Right]       g[root] = max(f[root.Left], g[root.Left] ) + max(f[root.Right], g[root.Right])   &#125;   dfs(root)    <span class="hljs-keyword">return</span> max(f[root], g[root])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.53%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了13.81%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>338. 比特位计数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a><font size=6px>比特位计数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n ，对于 0 &lt;&#x3D; i &lt;&#x3D; n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：[0,1,1]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>示例 2：</p><p>输入：n &#x3D; 5<br>输出：[0,1,1,2,1,2]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>3 –&gt; 11<br>4 –&gt; 100<br>5 –&gt; 101</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countBits</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n ;i++&#123;        a := i        <span class="hljs-keyword">for</span> a!= <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> a%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>&#123;                count ++            &#125;            a /= <span class="hljs-number">2</span>        &#125;        res = <span class="hljs-built_in">append</span>(res, count)        count = <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了86.24%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了18.58%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><font size=6px>在排序数组中查找元素的第一个和最后一个位置</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p><p>示例 1：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p><p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>二分查找，找到后开始左、右找相同的数字</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> nums == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;    &#125;    l, r := <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> l&lt;=r&#123;        mid := (r+l)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> nums[mid] == target&#123;            l,r = mid<span class="hljs-number">-1</span>,mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> ;l&gt;=<span class="hljs-number">0</span>;l--&#123;                <span class="hljs-keyword">if</span> nums[l] != target&#123;                    <span class="hljs-keyword">break</span>                &#125;            &#125;            <span class="hljs-keyword">for</span> ;r&lt;<span class="hljs-built_in">len</span>(nums);r++&#123;                <span class="hljs-keyword">if</span> nums[r] != target&#123;                    <span class="hljs-keyword">break</span>                &#125;            &#125;            <span class="hljs-keyword">break</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)&#123;            r = mid<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid + <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> l&lt;r&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;l+<span class="hljs-number">1</span>,r<span class="hljs-number">-1</span>&#125;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了97.61%的用户<br>   内存消耗：3.8 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>347. Top K Frequent Elements</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/347.%20Top%20K%20Frequent%20Elements/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/347.%20Top%20K%20Frequent%20Elements/</url>
    
    <content type="html"><![CDATA[<h3 id="Top-K-Frequent-Elements"><a href="#Top-K-Frequent-Elements" class="headerlink" title="Top K Frequent Elements"></a><font size=6px>Top K Frequent Elements</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</p><p>Example 1:</p><p>Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>Output: [1,2]<br>Example 2:</p><p>Input: nums &#x3D; [1], k &#x3D; 1<br>Output: [1]</p><p>Constraints:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>k is in the range [1, the number of unique elements in the array].<br>It is guaranteed that the answer is unique.</p><p>Follow up: Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先排序，然后算出频繁次数构建结构体，结构体的频繁次数排序，最后得出结果</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Num <span class="hljs-keyword">struct</span> &#123;    n,f <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)    n := <span class="hljs-built_in">len</span>(nums)    sort.Ints(nums)    <span class="hljs-keyword">var</span> pairs []Num     pairs = <span class="hljs-built_in">append</span>(pairs, Num&#123;n:nums[<span class="hljs-number">0</span>],f:<span class="hljs-number">1</span>&#125;)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> nums[i] != nums[i<span class="hljs-number">-1</span>]&#123;            pairs = <span class="hljs-built_in">append</span>(pairs, Num&#123;n:nums[i],f:<span class="hljs-number">1</span>&#125;)        &#125;<span class="hljs-keyword">else</span>&#123;            pairs[<span class="hljs-built_in">len</span>(pairs)<span class="hljs-number">-1</span>].f++        &#125;    &#125;    sort.Slice(pairs,<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;        <span class="hljs-keyword">if</span> pairs[i].f  &gt; pairs[j].f&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;        res[i] = pairs[i].n    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了90.99%的用户<br>   内存消耗：4.9 MB, 在所有 Go 提交中击败了99.82%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>394. 字符串解码</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a><font size=6px>字符串解码</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>示例 1：</p><p>输入：s &#x3D; “3[a]2[bc]”<br>输出：”aaabcbc”<br>示例 2：</p><p>输入：s &#x3D; “3[a2[c]]”<br>输出：”accaccacc”<br>示例 3：</p><p>输入：s &#x3D; “2[abc]3[cd]ef”<br>输出：”abcabccdcdcdef”<br>示例 4：</p><p>输入：s &#x3D; “abc3[cd]xyz”<br>输出：”abccdcdcdxyz”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 30<br>s 由小写英文字母、数字和方括号 ‘[]’ 组成<br>s 保证是一个 有效 的输入。<br>s 中所有整数的取值范围为 [1, 300]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用递归思路做，碰到【就进行递归，碰到】就退出递归</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    i = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> run(s)&#125;<span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    res := <span class="hljs-string">&quot;&quot;</span>    num := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;        <span class="hljs-keyword">if</span> s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;            num = num*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> &#123;            res += <span class="hljs-type">string</span>(s[i])        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;[&#x27;</span> &#123;            i++            tmp := run(s)            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; num; j++ &#123;                res += tmp            &#125;            num = <span class="hljs-number">0</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了35.95%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>399. Evaluate Division</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/399.%20Evaluate%20Division/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/399.%20Evaluate%20Division/</url>
    
    <content type="html"><![CDATA[<h3 id="Evaluate-Division"><a href="#Evaluate-Division" class="headerlink" title="Evaluate Division"></a><font size=6px>Evaluate Division</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>ou are given an array of variable pairs equations and an array of real numbers values, where equations[i] &#x3D; [Ai, Bi] and values[i] represent the equation Ai &#x2F; Bi &#x3D; values[i]. Each Ai or Bi is a string that represents a single variable.</p><p>You are also given some queries, where queries[j] &#x3D; [Cj, Dj] represents the jth query where you must find the answer for Cj &#x2F; Dj &#x3D; ?.</p><p>Return the answers to all queries. If a single answer cannot be determined, return -1.0.</p><p>Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p><p>Example 1:</p><p>Input: equations &#x3D; [[“a”,”b”],[“b”,”c”]], values &#x3D; [2.0,3.0], queries &#x3D; [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]<br>Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]<br>Explanation:<br>Given: a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0<br>queries are: a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ?<br>return: [6.0, 0.5, -1.0, 1.0, -1.0 ]<br>Example 2:</p><p>Input: equations &#x3D; [[“a”,”b”],[“b”,”c”],[“bc”,”cd”]], values &#x3D; [1.5,2.5,5.0], queries &#x3D; [[“a”,”c”],[“c”,”b”],[“bc”,”cd”],[“cd”,”bc”]]<br>Output: [3.75000,0.40000,5.00000,0.20000]<br>Example 3:</p><p>Input: equations &#x3D; [[“a”,”b”]], values &#x3D; [0.5], queries &#x3D; [[“a”,”b”],[“b”,”a”],[“a”,”c”],[“x”,”y”]]<br>Output: [0.50000,2.00000,-1.00000,-1.00000]</p><p>Constraints:</p><p>1 &lt;&#x3D; equations.length &lt;&#x3D; 20<br>equations[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; Ai.length, Bi.length &lt;&#x3D; 5<br>values.length &#x3D;&#x3D; equations.length<br>0.0 &lt; values[i] &lt;&#x3D; 20.0<br>1 &lt;&#x3D; queries.length &lt;&#x3D; 20<br>queries[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; Cj.length, Dj.length &lt;&#x3D; 5<br>Ai, Bi, Cj, Dj consist of lower case English letters and digits.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以两种方法做，并查集和bfs，把a&#x2F;b &#x3D;2 看成 a-&gt;b &#x3D; 2,b-&gt;a &#x3D; 1&#x2F;2,用图的思想做。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcEquation</span><span class="hljs-params">(equations [][]<span class="hljs-type">string</span>, values []<span class="hljs-type">float64</span>, queries [][]<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">float64</span> &#123;        <span class="hljs-keyword">var</span> res []<span class="hljs-type">float64</span>    graph := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span>&#123;&#125;    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> equations&#123;        <span class="hljs-keyword">if</span> _,ok := graph[v[<span class="hljs-number">0</span>]];!ok&#123;            graph[v[<span class="hljs-number">0</span>]] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span>, <span class="hljs-number">0</span>)        &#125;        <span class="hljs-keyword">if</span> _,ok := graph[v[<span class="hljs-number">1</span>]];!ok&#123;            graph[v[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span>, <span class="hljs-number">0</span>)        &#125;        graph[v[<span class="hljs-number">0</span>]][v[<span class="hljs-number">1</span>]] = values[k]        graph[v[<span class="hljs-number">1</span>]][v[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>/values[k]        graph[v[<span class="hljs-number">0</span>]][v[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>        graph[v[<span class="hljs-number">1</span>]][v[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">var</span> calc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">string</span>, visit <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)</span></span><span class="hljs-type">float64</span>    calc = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a,b <span class="hljs-type">string</span>, visit <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)</span></span><span class="hljs-type">float64</span>&#123;        <span class="hljs-keyword">if</span> _,ok := graph[a];!ok&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;        <span class="hljs-keyword">if</span> _,ok := graph[b];!ok&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;        <span class="hljs-keyword">if</span> v,ok := graph[a][b];ok&#123;            <span class="hljs-keyword">return</span> v        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span> key,value := <span class="hljs-keyword">range</span> graph[a]&#123;                <span class="hljs-comment">// 防止重复</span>                <span class="hljs-keyword">if</span> _,ok := (visit)[key];ok&#123;                    <span class="hljs-keyword">continue</span>                &#125;                visit[a] = <span class="hljs-literal">true</span>                ans := calc(key,b,visit)                <span class="hljs-keyword">if</span> ans != <span class="hljs-number">-1</span>&#123;                    <span class="hljs-keyword">return</span> ans *value                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>            &#125;    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> queries&#123;        res = <span class="hljs-built_in">append</span>(res, calc(v[<span class="hljs-number">0</span>],v[<span class="hljs-number">1</span>], <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>&#123;&#125;))    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 寻找两个正序数组的中位数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><font size=6px>寻找两个正序数组的中位数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]<br>输出：2.00000<br>解释：合并数组 &#x3D; [1,2,3] ，中位数 2<br>示例 2：</p><p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]<br>输出：2.50000<br>解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5<br>示例 3：</p><p>输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]<br>输出：0.00000<br>示例 4：</p><p>输入：nums1 &#x3D; [], nums2 &#x3D; [1]<br>输出：1.00000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>最简单的思路</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;    flag := <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(nums1)+<span class="hljs-built_in">len</span>(nums2)) % <span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;        flag = <span class="hljs-number">0</span>    &#125;<span class="hljs-keyword">else</span>&#123;        flag = <span class="hljs-number">1</span>    &#125;    mid := (<span class="hljs-built_in">len</span>(nums1)+<span class="hljs-built_in">len</span>(nums2))/<span class="hljs-number">2</span>    nums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums1)+ <span class="hljs-built_in">len</span>(nums2))    <span class="hljs-keyword">var</span> i,j <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i ,j = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums1) &amp;&amp; j &lt;<span class="hljs-built_in">len</span>(nums2);&#123;        <span class="hljs-keyword">if</span> nums1[i] &lt; nums2[j]&#123;            nums[i+j] = nums1[i]            i++        &#125;<span class="hljs-keyword">else</span>&#123;            nums[i+j] = nums2[j]            j++        &#125;    &#125;    <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(nums1) &amp;&amp; j&lt;<span class="hljs-built_in">len</span>(nums2)&#123;        <span class="hljs-keyword">for</span> ;j&lt;<span class="hljs-built_in">len</span>(nums2);j++&#123;            nums[i+j] = nums2[j]        &#125;    &#125;    <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(nums2) &amp;&amp; i &lt;<span class="hljs-built_in">len</span>(nums1)&#123;        <span class="hljs-keyword">for</span> ;i&lt;<span class="hljs-built_in">len</span>(nums1);i++&#123;            nums[i+j] = nums1[i]        &#125;    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;     <span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(nums[mid])    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span>  (<span class="hljs-type">float64</span>(nums[mid])+<span class="hljs-type">float64</span>(nums[mid<span class="hljs-number">-1</span>]))/<span class="hljs-number">2</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了88.16%的用户<br>   内存消耗：5.4 MB, 在所有 Go 提交中击败了41.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>406. Queue Reconstruction by Height</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/406.%20Queue%20Reconstruction%20by%20Height/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/406.%20Queue%20Reconstruction%20by%20Height/</url>
    
    <content type="html"><![CDATA[<h3 id="Queue-Reconstruction-by-Height"><a href="#Queue-Reconstruction-by-Height" class="headerlink" title="Queue Reconstruction by Height"></a><font size=6px>Queue Reconstruction by Height</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] &#x3D; [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.</p><p>Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] &#x3D; [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</p><p>Example 1:</p><p>Input: people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br>Explanation:<br>Person 0 has height 5 with no other people taller or the same height in front.<br>Person 1 has height 7 with no other people taller or the same height in front.<br>Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.<br>Person 3 has height 6 with one person taller or the same height in front, which is person 1.<br>Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.<br>Person 5 has height 7 with one person taller or the same height in front, which is person 1.<br>Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.<br>Example 2:</p><p>Input: people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p><p>Constraints:</p><p>1 &lt;&#x3D; people.length &lt;&#x3D; 2000<br>0 &lt;&#x3D; hi &lt;&#x3D; 106<br>0 &lt;&#x3D; ki &lt; people.length<br>It is guaranteed that the queue can be reconstructed.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先排序，身高从低到高，k从高到低。【4，2】代表前面有2个比他大的，在原来的序列找到比他大的两个就插入</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reconstructQueue</span><span class="hljs-params">(people [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    sort.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;        a,b := people[i], people[j]        <span class="hljs-keyword">if</span> a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &gt; b[<span class="hljs-number">1</span>]        &#125;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>]    &#125;)    ans  := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(people))    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> people&#123;        distance := p[<span class="hljs-number">1</span>] +<span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ans&#123;                    <span class="hljs-keyword">if</span> ans[i] == <span class="hljs-literal">nil</span>&#123;                    distance --                    <span class="hljs-keyword">if</span> distance ==<span class="hljs-number">0</span>&#123;                        ans[i] = p                    &#125;                &#125;            &#125;    &#125;    <span class="hljs-keyword">return</span> ans    &#125;    </code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了43.12%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了90.52%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>416. Partition Equal Subset Sum</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/416.%20Partition%20Equal%20Subset%20Sum/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/416.%20Partition%20Equal%20Subset%20Sum/</url>
    
    <content type="html"><![CDATA[<h3 id="Partition-Equal-Subset-Sum"><a href="#Partition-Equal-Subset-Sum" class="headerlink" title="Partition Equal Subset Sum"></a><font size=6px>Partition Equal Subset Sum</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p>Example 1:</p><p>Input: nums &#x3D; [1,5,11,5]<br>Output: true<br>Explanation: The array can be partitioned as [1, 5, 5] and [11].<br>Example 2:</p><p>Input: nums &#x3D; [1,2,3,5]<br>Output: false<br>Explanation: The array cannot be partitioned into equal sum subsets.</p><p>Constraints:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100<br>通过次数208,856提交次数407,742</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划题，把题目转化成01背包问题是关键，只有数字组合能达到sum的一半就算true</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    sum := <span class="hljs-number">0</span>    n := <span class="hljs-built_in">len</span>(nums)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        sum += nums[i]    &#125;    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    sum /= <span class="hljs-number">2</span>    dp  := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, sum+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        num := nums[i]        <span class="hljs-keyword">for</span> j:=sum;j &gt;= num;j--&#123;            dp[j] |= dp[j - num]        &#125;    &#125;    <span class="hljs-keyword">if</span> dp[sum] == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了99.43%的用户<br>   内存消耗：3.2 MB, 在所有 Go 提交中击败了70.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>437. 路径总和 III</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/</url>
    
    <content type="html"><![CDATA[<h3 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a><font size=6px>路径总和 III</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>示例 1：</p><p>输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8<br>输出：3<br>解释：和等于 8 的路径有 3 条，如图所示。<br>示例 2：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：3</p><p>提示:</p><p>二叉树的节点个数的范围是 [0,1000]<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把遍历每个结点，并把每个节点当作根节点进行dfs遍历，时间会比较久。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    ans := <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span> root.Val == targetSum&#123;        ans ++    &#125;    ans += dfs(root.Left, targetSum-root.Val)    ans +=dfs(root.Right, targetSum-root.Val)    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    res := dfs(root, targetSum)    res += pathSum(root.Left, targetSum)    res += pathSum(root.Right, targetSum)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：28 ms, 在所有 Go 提交中击败了29.36%的用户<br>   内存消耗：4 MB, 在所有 Go 提交中击败了91.28%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>438. 找到字符串中所有字母异位词</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><font size=6px>找到字符串中所有字母异位词</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p>示例 1:</p><p>输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。<br> 示例 2:</p><p>输入: s &#x3D; “abab”, p &#x3D; “ab”<br>输出: [0,1,2]<br>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p><p>提示:</p><p>1 &lt;&#x3D; s.length, p.length &lt;&#x3D; 3 * 104<br>s 和 p 仅包含小写字母</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>就把数字放进map里面，遇到一次就减去这个字母的频数一次，直到map里面所有数字都是0就代表是字母异味词。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findAnagrams</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p) &gt;<span class="hljs-built_in">len</span>(s)&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(p);i++&#123;        m[p[i]] ++    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(p);i++&#123;        m[s[i]]--    &#125;    <span class="hljs-keyword">var</span> check <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><span class="hljs-type">bool</span>    check = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><span class="hljs-type">bool</span>&#123;        <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> m&#123;            <span class="hljs-keyword">if</span> v != <span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">if</span> check()&#123;        res = <span class="hljs-built_in">append</span>(res,<span class="hljs-number">0</span>)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(s)-<span class="hljs-built_in">len</span>(p);i++&#123;        m[s[i<span class="hljs-number">-1</span>]] ++        m[s[i+<span class="hljs-built_in">len</span>(p)<span class="hljs-number">-1</span>]]--        <span class="hljs-keyword">if</span> check()&#123;            res = <span class="hljs-built_in">append</span>(res, i)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了31.08%的用户<br>   内存消耗：5 MB, 在所有 Go 提交中击败了91.62%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>448. 找到所有数组中消失的数字</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a><font size=6px>找到所有数组中消失的数字</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,3,2,7,8,2,3,1]<br>输出：[5,6]<br>示例 2：</p><p>输入：nums &#x3D; [1,1]<br>输出：[2]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">for</span> _,i := <span class="hljs-keyword">range</span> nums&#123;        nums[(i<span class="hljs-number">-1</span>) % n] += n    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> k,i := <span class="hljs-keyword">range</span> nums&#123;        <span class="hljs-keyword">if</span> i &lt;= n&#123;            res = <span class="hljs-built_in">append</span>(res, k+<span class="hljs-number">1</span>)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：7.8 MB, 在所有 Go 提交中击败了34.89%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>49. Group Anagrams</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/49.%20Group%20Anagrams/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/49.%20Group%20Anagrams/</url>
    
    <content type="html"><![CDATA[<h3 id="Group-Anagrams"><a href="#Group-Anagrams" class="headerlink" title="Group Anagrams"></a><font size=6px>Group Anagrams</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.</p><p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p>Example 1:</p><p>Input: strs &#x3D; [“eat”,”tea”,”tan”,”ate”,”nat”,”bat”]<br>Output: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>Example 2:</p><p>Input: strs &#x3D; [“”]<br>Output: [[“”]]<br>Example 3:</p><p>Input: strs &#x3D; [“a”]<br>Output: [[“a”]]</p><p>Constraints:</p><p>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] consists of lowercase English letters.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用哈希表，之后把哈希表连接成数字</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">string</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(strs) &lt;= <span class="hljs-number">1</span>&#123;        res = <span class="hljs-built_in">append</span>(res, strs)        <span class="hljs-keyword">return</span> res    &#125;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int64</span>][]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">var</span> num <span class="hljs-type">int64</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> strs&#123;        freq := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int64</span>, <span class="hljs-number">27</span>)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(v);i++&#123;            freq[v[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++        &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++&#123;            num = num*<span class="hljs-number">10</span> +freq[i]        &#125;        mp[num] = <span class="hljs-built_in">append</span>(mp[num], v)        num = <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> mp&#123;        res = <span class="hljs-built_in">append</span>(res, v)    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了99.78%的用户<br>   内存消耗：7 MB, 在所有 Go 提交中击败了98.23%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>461. 汉明距离</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a><font size=6px>汉明距离</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p><p>示例 1：</p><p>输入：x &#x3D; 1, y &#x3D; 4<br>输出：2<br>解释：<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑<br>上面的箭头指出了对应二进制位不同的位置。<br>示例 2：</p><p>输入：x &#x3D; 3, y &#x3D; 1<br>输出：1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> x != <span class="hljs-number">0</span> &amp;&amp; y != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> x %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span> &amp;&amp; y %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;            count++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> &amp;&amp; y %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;            count++        &#125;        x /=<span class="hljs-number">2</span>        y/= <span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">for</span> x != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> x %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;            count++        &#125;        x/=<span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">for</span> y != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> y %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;            count++        &#125;        y/=<span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>494. Target Sum</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/494.%20Target%20Sum/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/494.%20Target%20Sum/</url>
    
    <content type="html"><![CDATA[<h3 id="Target-Sum"><a href="#Target-Sum" class="headerlink" title="Target Sum"></a><font size=6px>Target Sum</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given an integer array nums and an integer target.</p><p>You want to build an expression out of nums by adding one of the symbols ‘+’ and ‘-‘ before each integer in nums and then concatenate all the integers.</p><p>For example, if nums &#x3D; [2, 1], you can add a ‘+’ before 2 and a ‘-‘ before 1 and concatenate them to build the expression “+2-1”.<br>Return the number of different expressions that you can build, which evaluates to target.</p><p>Example 1:</p><p>Input: nums &#x3D; [1,1,1,1,1], target &#x3D; 3<br>Output: 5<br>Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.<br>-1 + 1 + 1 + 1 + 1 &#x3D; 3<br>+1 - 1 + 1 + 1 + 1 &#x3D; 3<br>+1 + 1 - 1 + 1 + 1 &#x3D; 3<br>+1 + 1 + 1 - 1 + 1 &#x3D; 3<br>+1 + 1 + 1 + 1 - 1 &#x3D; 3<br>Example 2:</p><p>Input: nums &#x3D; [1], target &#x3D; 1<br>Output: 1</p><p>Constraints:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 20<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>0 &lt;&#x3D; sum(nums[i]) &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; target &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>我用dfs做，做起来简单，但是效率低，用动态规划做会比较好</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sum, index <span class="hljs-type">int</span>)</span></span>     count := <span class="hljs-number">0</span>    n := <span class="hljs-built_in">len</span>(nums)    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sum, index <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> sum == target &amp;&amp; index == n&#123;            count++            <span class="hljs-keyword">return</span>         &#125;        <span class="hljs-keyword">if</span> index &gt;= n &#123;            <span class="hljs-keyword">return</span>         &#125;        dfs(sum+nums[index],index+<span class="hljs-number">1</span>)        dfs(sum+<span class="hljs-number">-1</span>*nums[index],index+<span class="hljs-number">1</span>)    &#125;    dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：644 ms, 在所有 Go 提交中击败了23.74%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了98.67%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>537. 复数乘法</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/537.%20%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/537.%20%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="复数乘法"><a href="#复数乘法" class="headerlink" title="复数乘法"></a><font size=6px>复数乘法</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>复数 可以用字符串表示，遵循 “实部+虚部i” 的形式，并满足下述条件：</p><p>实部 是一个整数，取值范围是 [-100, 100]<br>虚部 也是一个整数，取值范围是 [-100, 100]<br>i2 &#x3D;&#x3D; -1<br>给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。</p><p>示例 1：</p><p>输入：num1 &#x3D; “1+1i”, num2 &#x3D; “1+1i”<br>输出：”0+2i”<br>解释：(1 + i) * (1 + i) &#x3D; 1 + i2 + 2 * i &#x3D; 2i ，你需要将它转换为 0+2i 的形式。<br>示例 2：</p><p>输入：num1 &#x3D; “1+-1i”, num2 &#x3D; “1+-1i”<br>输出：”0+-2i”<br>解释：(1 - i) * (1 - i) &#x3D; 1 + i2 - 2 * i &#x3D; -2i ，你需要将它转换为 0+-2i 的形式。 </p><p>提示：</p><p>num1 和 num2 都是有效的复数表示。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>简单题，模拟就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">complexNumberMultiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">string</span>    num1s := strings.Split(num1,<span class="hljs-string">&quot;+&quot;</span>)    num2s := strings.Split(num2,<span class="hljs-string">&quot;+&quot;</span>)    num1s_1,_ := strconv.Atoi(num1s[<span class="hljs-number">0</span>])    num2s_1,_ := strconv.Atoi(num2s[<span class="hljs-number">0</span>])    num1s_2,_ := strconv.Atoi(num1s[<span class="hljs-number">1</span>][:<span class="hljs-built_in">len</span>(num1s[<span class="hljs-number">1</span>])<span class="hljs-number">-1</span>])     num2s_2,_ := strconv.Atoi(num2s[<span class="hljs-number">1</span>][:<span class="hljs-built_in">len</span>(num2s[<span class="hljs-number">1</span>])<span class="hljs-number">-1</span>])     a := strconv.Itoa(num1s_1*num2s_1-num1s_2*num2s_2)    b := strconv.Itoa(num1s_1*num2s_2+num1s_2*num2s_1)    res =  a+ <span class="hljs-string">&quot;+&quot;</span>+b+<span class="hljs-string">&quot;i&quot;</span>    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了94.74%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>538. Convert BST to Greater Tree</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/538.%20Convert%20BST%20to%20Greater%20Tree/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/538.%20Convert%20BST%20to%20Greater%20Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="Convert-BST-to-Greater-Tree"><a href="#Convert-BST-to-Greater-Tree" class="headerlink" title="Convert BST to Greater Tree"></a><font size=6px>Convert BST to Greater Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p><p>As a reminder, a binary search tree is a tree that satisfies these constraints:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p><p>Example 1:</p><p>Input: root &#x3D; [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]<br>Example 2:</p><p>Input: root &#x3D; [0,null,1]<br>Output: [1,null,1]</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [0, 104].<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>All the values in the tree are unique.<br>root is guaranteed to be a valid binary search tree.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>dfs 搜索，右中左序列就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertBST</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    <span class="hljs-keyword">var</span> maxNum <span class="hljs-type">int</span>     dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        dfs(root.Right)        root.Val += maxNum        maxNum = root.Val        dfs(root.Left)            &#125;dfs(root)<span class="hljs-keyword">return</span> root&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了79.69%的用户<br>   内存消耗：6.6 MB, 在所有 Go 提交中击败了96.11%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>540. Single Element in a Sorted Array</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/540.%20Single%20Element%20in%20a%20Sorted%20Array/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/540.%20Single%20Element%20in%20a%20Sorted%20Array/</url>
    
    <content type="html"><![CDATA[<h3 id="Single-Element-in-a-Sorted-Array"><a href="#Single-Element-in-a-Sorted-Array" class="headerlink" title="Single Element in a Sorted Array"></a><font size=6px>Single Element in a Sorted Array</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</p><p>Return the single element that appears only once.</p><p>Your solution must run in O(log n) time and O(1) space.</p><p>Example 1:</p><p>Input: nums &#x3D; [1,1,2,3,3,4,4,8,8]<br>Output: 2<br>Example 2:</p><p>Input: nums &#x3D; [3,3,7,7,10,11,11]<br>Output: 10</p><p>Constraints:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用二分搜索做，看第二个相同数字的下标是奇数还是偶数就可以判断</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]    &#125;    l,r := <span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> l&lt;=r&#123;        mid := (l+r)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> mid&lt;n<span class="hljs-number">-1</span>&#123;            <span class="hljs-keyword">if</span> nums[mid] == nums[mid+<span class="hljs-number">1</span>]&#123;                mid++            &#125;        &#125;        <span class="hljs-keyword">if</span> mid % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;            r = mid<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid+<span class="hljs-number">1</span>        &#125;    &#125;        <span class="hljs-keyword">return</span> nums[l]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了73.93%的用户<br>   内存消耗：7.8 MB, 在所有 Go 提交中击败了86.32%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>543. 二叉树的直径</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/543.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/543.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a><font size=6px>二叉树的直径</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>Dfs 递归判断，每一次都需要判断最大直径是否比已经找寻的最大直径大</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><span class="hljs-type">int</span>    ans := <span class="hljs-number">0</span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><span class="hljs-type">int</span>&#123;        <span class="hljs-keyword">if</span>  root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;        L := dfs(root.Left)        R :=dfs(root.Right)        ans = max(ans, L+R)        <span class="hljs-keyword">return</span> max(L,R) +<span class="hljs-number">1</span>    &#125;    dfs(root)    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a &gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了91.28%的用户<br>   内存消耗：4.2 MB, 在所有 Go 提交中击败了92.36%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>55. 跳跃游戏</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/55.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/55.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><font size=6px>跳跃游戏</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br>示例 2：</p><p>输入：nums &#x3D; [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从后往前遍历，能到的就为true</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    isarrive := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))    isarrive[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] = <span class="hljs-literal">true</span>    <span class="hljs-keyword">for</span> i:= <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span> ;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">for</span> j:=nums[i];j&gt;<span class="hljs-number">0</span>;j--&#123;            <span class="hljs-keyword">if</span> j+i&lt;<span class="hljs-built_in">len</span>(nums) &amp;&amp; isarrive[j+i] == <span class="hljs-literal">true</span>&#123;                isarrive[i] = <span class="hljs-literal">true</span>                <span class="hljs-keyword">break</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> isarrive[<span class="hljs-number">0</span>] == <span class="hljs-literal">true</span> &amp;&amp; isarrive[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]==<span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：760 ms, 在所有 Go 提交中击败了5.05%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>553. 最优除法</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/553.%20%E6%9C%80%E4%BC%98%E9%99%A4%E6%B3%95/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/553.%20%E6%9C%80%E4%BC%98%E9%99%A4%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="最优除法"><a href="#最优除法" class="headerlink" title="最优除法"></a><font size=6px>最优除法</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -&gt; 2 &#x2F; 3 &#x2F; 4 。</p><p>但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。</p><p>示例：</p><p>输入: [1000,100,10,2]<br>输出: “1000&#x2F;(100&#x2F;10&#x2F;2)”<br>解释:<br>1000&#x2F;(100&#x2F;10&#x2F;2) &#x3D; 1000&#x2F;((100&#x2F;10)&#x2F;2) &#x3D; 200<br>但是，以下加粗的括号 “1000&#x2F;((100&#x2F;10)&#x2F;2)” 是冗余的，<br>因为他们并不影响操作的优先级，所以你需要返回 “1000&#x2F;(100&#x2F;10&#x2F;2)”。</p><p>其他用例:<br>1000&#x2F;(100&#x2F;10)&#x2F;2 &#x3D; 50<br>1000&#x2F;(100&#x2F;(10&#x2F;2)) &#x3D; 50<br>1000&#x2F;100&#x2F;10&#x2F;2 &#x3D; 0.5<br>1000&#x2F;100&#x2F;(10&#x2F;2) &#x3D; 2<br>说明:</p><p>输入数组的长度在 [1, 10] 之间。<br>数组中每个元素的大小都在 [2, 1000] 之间。<br>每个测试用例只有一个最优除法解。<br>通过次数6,961提交次数11,341</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一串 &gt;&#x3D;1的数字相除，怎么除才能得到最小的答案呢？</p><p>答案就是从头除到尾，因为这样会导致分子越来越小，从而答案越来越小。</p><p>如果你局部先除，那么会导致分母变小，从而导致答案变大。</p><p>所以这道题，最终的解法就是，第一个 &#x2F; (第二个&#x2F;第三个….第n个)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">optimalDivision</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;        <span class="hljs-keyword">return</span> strconv.Itoa(nums[<span class="hljs-number">0</span>])    &#125;    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d/%d&quot;</span>, nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])    &#125;    ans := &amp;strings.Builder&#123;&#125;    ans.WriteString(fmt.Sprintf(<span class="hljs-string">&quot;%d/(%d&quot;</span>, nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]))    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums[<span class="hljs-number">2</span>:] &#123;        ans.WriteByte(<span class="hljs-string">&#x27;/&#x27;</span>)        ans.WriteString(strconv.Itoa(num))    &#125;    ans.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)    <span class="hljs-keyword">return</span> ans.String()&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>560. 和为 K 的子数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/560.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/560.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><font size=6px>和为 K 的子数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,1], k &#x3D; 2<br>输出：2<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3], k &#x3D; 3<br>输出：2</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>-107 &lt;&#x3D; k &lt;&#x3D; 107</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>Pre[i] &#x3D; pre[i-1] + nums[i]</p><p>可以转化成 pre[i] - k &#x3D; pre[j]，我们要求的就是j是多少，配合map可以以O（n）的复杂度解决</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>    m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    count, pre := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">len</span>(nums); i++&#123;        pre += nums[i]        <span class="hljs-keyword">if</span> _,ok := m[pre-k];ok&#123;            count += m[pre-k]        &#125;        m[pre] += <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：36 ms, 在所有 Go 提交中击败了96.01%的用户<br>   内存消耗：7.5 MB, 在所有 Go 提交中击败了45.67%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>581. 最短无序连续子数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a><font size=6px>最短无序连续子数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 最短 子数组，并输出它的长度。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,6,4,8,10,9,15]<br>输出：5<br>解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3,4]<br>输出：0<br>示例 3：</p><p>输入：nums &#x3D; [1]<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>排序一遍，找出不在有序位置第一个和最后一个位置，减一下就是答案</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    sortNum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))    <span class="hljs-built_in">copy</span>(sortNum, nums)    sort.Ints(sortNum)    numFlag := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> nums[i] == sortNum[i]&#123;            numFlag[i] = <span class="hljs-literal">true</span>        &#125;    &#125;    l, r := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> numFlag[i] == <span class="hljs-literal">false</span>&#123;            l = i            <span class="hljs-keyword">break</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>;i&gt;= <span class="hljs-number">0</span> ;i--&#123;        <span class="hljs-keyword">if</span> numFlag[i] == <span class="hljs-literal">false</span>&#123;            r = i            <span class="hljs-keyword">break</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> r ==<span class="hljs-number">0</span>&amp;&amp; l==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">return</span> r-l+<span class="hljs-number">1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了84.01%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了37.67%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>617. Merge Two Binary Trees</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/617.%20Merge%20Two%20Binary%20Trees/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/617.%20Merge%20Two%20Binary%20Trees/</url>
    
    <content type="html"><![CDATA[<h3 id="Merge-Two-Binary-Trees"><a href="#Merge-Two-Binary-Trees" class="headerlink" title="Merge Two Binary Trees"></a><font size=6px>Merge Two Binary Trees</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>You are given two binary trees root1 and root2.</p><p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p><p>Return the merged tree.</p><p>Note: The merging process must start from the root nodes of both trees.</p><p>Example 1:</p><p>Input: root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]<br>Output: [3,4,5,5,4,null,7]<br>Example 2:</p><p>Input: root1 &#x3D; [1], root2 &#x3D; [1,2]<br>Output: [2,2]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>dfs题，递归合成二叉树</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTrees</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root1, root2 *TreeNode)</span></span>*TreeNode    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root1, root2 *TreeNode)</span></span>*TreeNode&#123;        <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span> || root2 == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span>&#123;                <span class="hljs-keyword">return</span> root2            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> root1            &#125;        &#125;        root1.Val += root2.Val        root1.Left = dfs(root1.Left, root2.Left)        root1.Right = dfs(root1.Right, root2.Right)                <span class="hljs-keyword">return</span> root1    &#125;    <span class="hljs-keyword">return</span> dfs(root1, root2)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了95.45%的用户<br>   内存消耗：6.7 MB, 在所有 Go 提交中击败了91.63%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>621. 任务调度器</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/621.%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/621.%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a><font size=6px>任务调度器</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 最短时间 。</p><p>示例 1：</p><p>输入：tasks &#x3D; [“A”,”A”,”A”,”B”,”B”,”B”], n &#x3D; 2<br>输出：8<br>解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B<br>     在本示例中，两个相同类型任务之间必须间隔长度为 n &#x3D; 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。<br>示例 2：</p><p>输入：tasks &#x3D; [“A”,”A”,”A”,”B”,”B”,”B”], n &#x3D; 0<br>输出：6<br>解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n &#x3D; 0<br>[“A”,”A”,”A”,”B”,”B”,”B”]<br>[“A”,”B”,”A”,”B”,”A”,”B”]<br>[“B”,”B”,”B”,”A”,”A”,”A”]<br>…<br>诸如此类<br>示例 3：</p><p>输入：tasks &#x3D; [“A”,”A”,”A”,”A”,”A”,”A”,”B”,”C”,”D”,”E”,”F”,”G”], n &#x3D; 2<br>输出：16<br>解释：一种可能的解决方案是：<br>     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A</p><p>提示：</p><p>1 &lt;&#x3D; task.length &lt;&#x3D; 104<br>tasks[i] 是大写英文字母<br>n 的取值范围为 [0, 100]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用桶思想<strong>总排队时间 &#x3D; (桶个数 - 1) * (n + 1) + 最后一桶的任务数</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(tasks []<span class="hljs-type">byte</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    words := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)    count := <span class="hljs-number">1</span>    words_count:=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(tasks); i++&#123;        <span class="hljs-keyword">if</span> words[tasks[i]-<span class="hljs-string">&#x27;A&#x27;</span>] == <span class="hljs-number">0</span>&#123;            words_count++        &#125;        words[tasks[i]-<span class="hljs-string">&#x27;A&#x27;</span>]++    &#125;    sort.Slice(words, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;        <span class="hljs-keyword">if</span> words[i] &gt; words[j]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(words);i++&#123;        <span class="hljs-keyword">if</span> words[i] != words[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">break</span>        &#125;        count++    &#125;    <span class="hljs-keyword">return</span> max(<span class="hljs-built_in">len</span>(tasks), count+(n+<span class="hljs-number">1</span>)* (words[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>))    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了92.34%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>647. 回文子串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/647.%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/647.%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><font size=6px>回文子串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><p>输入：s &#x3D; “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”<br>示例 2：</p><p>输入：s &#x3D; “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用马拉车算法，时间复杂度o（n），动态维护左边界和右边界</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;   n := <span class="hljs-built_in">len</span>(s)   t := <span class="hljs-string">&quot;$#&quot;</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;n; i++&#123;        t+=<span class="hljs-type">string</span>(s[i])+<span class="hljs-string">&quot;#&quot;</span>    &#125;    n = <span class="hljs-built_in">len</span>(t)    t+=<span class="hljs-string">&quot;!&quot;</span>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    iMax,rMax,ans := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> rMax &gt;=i&#123;            dp[i] = min(rMax-i+<span class="hljs-number">1</span>, dp[iMax*<span class="hljs-number">2</span>-i])        &#125;<span class="hljs-keyword">else</span>&#123;            dp[i] = <span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">for</span> t[dp[i]+i] == t[i-dp[i]]&#123;            dp[i] = dp[i]+<span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">if</span> i+dp[i] <span class="hljs-number">-1</span> &gt;rMax&#123;            iMax = i            rMax = dp[i]+i<span class="hljs-number">-1</span>        &#125;        ans += dp[i]/<span class="hljs-number">2</span>    &#125;    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a , b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：4.7 MB, 在所有 Go 提交中击败了10.15%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>688. 骑士在棋盘上的概率</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/688.%20%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/688.%20%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<h3 id="骑士在棋盘上的概率"><a href="#骑士在棋盘上的概率" class="headerlink" title="骑士在棋盘上的概率"></a><font size=6px>骑士在棋盘上的概率</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。</p><p>象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。</p><p>每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。</p><p>骑士继续移动，直到它走了 k 步或离开了棋盘。</p><p>返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用动态规划做最省力了，dp[i][j][p] +&#x3D; dp[i-1][x][y]&#x2F;8，这个位置的概率等于周围8个的概率分别处以8再相加。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">var</span> dirs = []<span class="hljs-keyword">struct</span>&#123; i, j <span class="hljs-type">int</span> &#125;&#123;&#123;<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">knightProbability</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>, row <span class="hljs-type">int</span>, column <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;    <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;    dp := <span class="hljs-built_in">make</span>([][][]<span class="hljs-type">float64</span>, k+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=k;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">float64</span>, n)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>; j&lt;n;j++&#123;            dp[i][j] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">float64</span>, n)            <span class="hljs-keyword">for</span> p:=<span class="hljs-number">0</span>; p&lt;n; p++&#123;                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>&#123;                    dp[i][j][p] = <span class="hljs-number">1</span>                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> dirs&#123;                        x := j+v.i                        y := p+v.j                        <span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp;y &lt;n&#123;                            dp[i][j][p] += dp[i<span class="hljs-number">-1</span>][x][y]/<span class="hljs-number">8</span>                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[k][row][column]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了77.42%的用户<br>   内存消耗：3.6 MB, 在所有 Go 提交中击败了70.97%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>717. 1比特与2比特字符</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/717.%201%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/717.%201%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="1比特与2比特字符"><a href="#1比特与2比特字符" class="headerlink" title="1比特与2比特字符"></a><font size=6px>1比特与2比特字符</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有两种特殊字符：</p><p>第一种字符可以用一个比特 0 来表示<br>第二种字符可以用两个比特(10 或 11)来表示、<br>给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。</p><p>示例 1:</p><p>输入: bits &#x3D; [1, 0, 0]<br>输出: true<br>解释: 唯一的编码方式是一个两比特字符和一个一比特字符。<br>所以最后一个字符是一比特字符。<br>示例 2:</p><p>输入: bits &#x3D; [1, 1, 1, 0]<br>输出: false<br>解释: 唯一的编码方式是两比特字符和两比特字符。<br>所以最后一个字符不是一比特字符。</p><p>提示:</p><p>1 &lt;&#x3D; bits.length &lt;&#x3D; 1000<br>bits[i] &#x3D;&#x3D; 0 or 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>遇到1肯定会吃掉下一个0或者1，判断能不能访问最后一个0就可以解出这道题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isOneBitCharacter</span><span class="hljs-params">(bits []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(bits) == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">var</span> i <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(bits);&#123;        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(bits)<span class="hljs-number">-1</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">if</span> bits[i] == <span class="hljs-number">1</span>&#123;            i+=<span class="hljs-number">2</span>        &#125;<span class="hljs-keyword">else</span>&#123;            i ++        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了55.93%的用户<br>   内存消耗：2.6 MB, 在所有 Go 提交中击败了93.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>72. 编辑距离</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><font size=6px>编辑距离</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>示例 1：</p><p>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)<br>示例 2：</p><p>输入：word1 &#x3D; “intention”, word2 &#x3D; “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><p>提示：</p><p>0 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 500<br>word1 和 word2 由小写英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第一眼 看就是动态规划题，递推公式推导是比较左边+1，上边+1，左上+check(字母是否相同)三个的最小值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(word1),<span class="hljs-built_in">len</span>(word2)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=m;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)        dp[i][<span class="hljs-number">0</span>] = i    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=n;i++&#123;        dp[<span class="hljs-number">0</span>][i] = i    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=n;j++&#123;            left := dp[i<span class="hljs-number">-1</span>][j] +<span class="hljs-number">1</span>            top := dp[i][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>            pre := dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]  + check(word1[i<span class="hljs-number">-1</span>],word2[j<span class="hljs-number">-1</span>])            dp[i][j] = min(left,min(top, pre))        &#125;    &#125;      <span class="hljs-keyword">return</span> dp[m][n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(a,b <span class="hljs-type">byte</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a == b&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了81.82%的用户<br>   内存消耗：5.4 MB, 在所有 Go 提交中击败了94.24%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>739. 每日温度</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/739.%20Daily%20Temperatures/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/739.%20Daily%20Temperatures/</url>
    
    <content type="html"><![CDATA[<h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><font size=6px>每日温度</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>示例 1:</p><p>输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]<br>示例 2:</p><p>输入: temperatures &#x3D; [30,40,50,60]<br>输出: [1,1,1,0]<br>示例 3:</p><p>输入: temperatures &#x3D; [30,60,90]<br>输出: [1,1,0]</p><p>提示：</p><p>1 &lt;&#x3D; temperatures.length &lt;&#x3D; 105<br>30 &lt;&#x3D; temperatures[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从后往前动态规划，从后一个开始找第一个比他大的，每次跳后一个数的第一个比他大的数的跳数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(temperatures []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    j := <span class="hljs-number">0</span>    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(temperatures))    num[<span class="hljs-built_in">len</span>(temperatures)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:= <span class="hljs-built_in">len</span>(temperatures)<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">if</span> temperatures[i] &lt; temperatures[i+<span class="hljs-number">1</span>]&#123;            num[i] = <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            j = i+<span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(temperatures) &amp;&amp; num[j] != <span class="hljs-number">0</span>&#123;                j = num[j]+j                <span class="hljs-keyword">if</span> temperatures[j] &gt; temperatures[i]&#123;                    num[i] = j-i                    <span class="hljs-keyword">break</span>                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> num&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：128 ms, 在所有 Go 提交中击败了82.30%的用户<br>   内存消耗：10 MB, 在所有 Go 提交中击败了6.86%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>76. 最小覆盖子串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/76.%20%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/76.%20%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><font size=6px>最小覆盖子串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：</p><p>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”<br>示例 2：</p><p>输入：s &#x3D; “a”, t &#x3D; “a”<br>输出：”a”<br>示例 3:</p><p>输入: s &#x3D; “a”, t &#x3D; “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p><p>提示：</p><p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 105<br>s 和 t 由英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用滑动窗口法来做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    l,r := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    minl, minr := <span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>    lens := <span class="hljs-number">999999</span>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    cnt := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">var</span> checked <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span>    <span class="hljs-comment">// 判断是不是字母都齐了</span>    checked = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span>&#123;        <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m&#123;            <span class="hljs-keyword">if</span> cnt[k] &lt; v&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(t); i++&#123;        m[t[i]] += <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span>  ;r &lt;<span class="hljs-built_in">len</span>(s) ;r++&#123;        <span class="hljs-keyword">if</span> m[s[r]] &gt;<span class="hljs-number">0</span>&#123;            cnt[s[r]] ++        &#125;        <span class="hljs-keyword">for</span> checked() &amp;&amp; l&lt;=r&#123;            <span class="hljs-keyword">if</span> r-l +<span class="hljs-number">1</span> &lt;lens&#123;                lens = r-l+<span class="hljs-number">1</span>                minl, minr = l,l+lens            &#125;            <span class="hljs-keyword">if</span> _,ok := m[s[l]];ok&#123;                cnt[s[l]]--            &#125;            l++        &#125;    &#125;    <span class="hljs-keyword">if</span> minl == <span class="hljs-number">-1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>    &#125;    <span class="hljs-keyword">return</span> s[minl:minr]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：108 ms, 在所有 Go 提交中击败了32.41%的用户<br>   内存消耗：2.7 MB, 在所有 Go 提交中击败了98.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>78. 子集</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/78.%20%E5%AD%90%E9%9B%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/78.%20%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a><font size=6px>子集</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p><p>输入：nums &#x3D; [0]<br>输出：[[],[0]]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典d f s</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> temp []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>        <span class="hljs-keyword">if</span> nums == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> res    &#125;    <span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(temp []<span class="hljs-type">int</span>, idx <span class="hljs-type">int</span>)</span></span>    f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(temp []<span class="hljs-type">int</span>, idx <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> idx &gt; <span class="hljs-built_in">len</span>(nums)&#123;            <span class="hljs-keyword">return</span>         &#125;        copy_temp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span> , <span class="hljs-built_in">len</span>(temp))        <span class="hljs-built_in">copy</span>(copy_temp, temp)        res = <span class="hljs-built_in">append</span>(res, copy_temp)        <span class="hljs-keyword">for</span> i:=idx;i&lt; <span class="hljs-built_in">len</span>(nums); i++&#123;            temp = <span class="hljs-built_in">append</span>(temp, nums[i])            f(temp, i+<span class="hljs-number">1</span>)            temp = temp[:<span class="hljs-built_in">len</span>(temp)<span class="hljs-number">-1</span>]        &#125;    &#125;    f(temp, <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>79. 单词搜索</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a><font size=6px>单词搜索</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例 1：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”<br>输出：true<br>示例 2：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “SEE”<br>输出：true<br>示例 3：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCB”<br>输出：false</p><p>提示：</p><p>m &#x3D;&#x3D; board.length<br>n &#x3D; board[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 6<br>1 &lt;&#x3D; word.length &lt;&#x3D; 15<br>board 和 word 仅由大小写英文字母组成</p><p>进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典dfs题，visit访问时要置1，最后访问完后重新置0</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    m,n := <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])     visit := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(board))    valid := <span class="hljs-literal">false</span>    move := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(board); i++&#123;        visit[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(board[i]))    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num, x,y <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(count,x,y <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> count == <span class="hljs-built_in">len</span>(word)&#123;            valid = <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">if</span> valid&#123;            <span class="hljs-keyword">return</span>         &#125;        visit[x][y] = <span class="hljs-literal">true</span>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>;i++&#123;            new_x := x+move[i*<span class="hljs-number">2</span>]            new_y := y+move[i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> new_x &gt;= <span class="hljs-number">0</span> &amp;&amp; new_x &lt; m &amp;&amp; new_y &gt;=<span class="hljs-number">0</span> &amp;&amp; new_y &lt;n &amp;&amp; visit[new_x][new_y] == <span class="hljs-literal">false</span> &amp;&amp; board[new_x][new_y ] == word[count]&#123;                                dfs(count+<span class="hljs-number">1</span>, new_x,new_y)            &#125;        &#125;        visit[x][y] = <span class="hljs-literal">false</span>    &#125;        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(board); i++&#123;        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j&lt;<span class="hljs-built_in">len</span>(board[i]); j++&#123;            count := <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> board[i][j] == word[<span class="hljs-number">0</span>] &amp;&amp; !valid&#123;                                dfs(count, i, j)            &#125;                    &#125;     &#125;    <span class="hljs-keyword">return</span> valid&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：92 ms, 在所有 Go 提交中击败了59.42%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了91.92%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>838. 推多米诺</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/838.%20%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/838.%20%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="推多米诺"><a href="#推多米诺" class="headerlink" title="推多米诺"></a><font size=6px>推多米诺</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。</p><p>每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。</p><p>如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。</p><p>就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。</p><p>给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中：</p><p>dominoes[i] &#x3D; ‘L’，表示第 i 张多米诺骨牌被推向左侧，<br>dominoes[i] &#x3D; ‘R’，表示第 i 张多米诺骨牌被推向右侧，<br>dominoes[i] &#x3D; ‘.’，表示没有推动第 i 张多米诺骨牌。<br>返回表示最终状态的字符串。</p><p>示例 1：</p><p>输入：dominoes &#x3D; “RR.L”<br>输出：”RR.L”<br>解释：第一张多米诺骨牌没有给第二张施加额外的力。<br>示例 2：</p><p>输入：dominoes &#x3D; “.L.R…LR..L..”<br>输出：”LL.RR.LLRRLL..”</p><p>提示：</p><p>n &#x3D;&#x3D; dominoes.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用一种很简单巧妙的替换思路来做，一看就懂</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pushDominoes</span><span class="hljs-params">(dominoes <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    old := <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">for</span> old != dominoes&#123;        old = dominoes        dominoes =  strings.Replace(dominoes,<span class="hljs-string">&quot;R.L&quot;</span>,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-number">-1</span>)        dominoes = strings.Replace(dominoes,<span class="hljs-string">&quot;.L&quot;</span>,<span class="hljs-string">&quot;LL&quot;</span>,<span class="hljs-number">-1</span>)        dominoes = strings.Replace(dominoes,<span class="hljs-string">&quot;R.&quot;</span>,<span class="hljs-string">&quot;RR&quot;</span>,<span class="hljs-number">-1</span>)        dominoes = strings.Replace(dominoes,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;R.L&quot;</span>,<span class="hljs-number">-1</span>)    &#125;    <span class="hljs-keyword">return</span> dominoes&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：112 ms, 在所有 Go 提交中击败了6.67%的用户<br>   内存消耗：6.9 MB, 在所有 Go 提交中击败了46.67%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>884. 两句话中的不常见单词</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/884.%20%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/884.%20%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="两句话中的不常见单词"><a href="#两句话中的不常见单词" class="headerlink" title="两句话中的不常见单词"></a><font size=6px>两句话中的不常见单词</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。</p><p>如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。</p><p>给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。</p><p>示例 1：</p><p>输入：s1 &#x3D; “this apple is sweet”, s2 &#x3D; “this apple is sour”<br>输出：[“sweet”,”sour”]<br>示例 2：</p><p>输入：s1 &#x3D; “apple apple”, s2 &#x3D; “banana”<br>输出：[“banana”]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用map来做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uncommonFromSentences</span><span class="hljs-params">(s1 <span class="hljs-type">string</span>, s2 <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    s1_s := strings.Split(s1,<span class="hljs-string">&quot; &quot;</span>)    s2_s := strings.Split(s2, <span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1_s);i++&#123;        m[s1_s[i]] +=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s2_s);i++&#123;        m[s2_s[i]] +=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m&#123;        <span class="hljs-keyword">if</span> v ==<span class="hljs-number">1</span>&#123;            res = <span class="hljs-built_in">append</span>(res, k)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>917. 仅仅反转字母</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/917.%20%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/917.%20%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="917-仅仅反转字母"><a href="#917-仅仅反转字母" class="headerlink" title="917. 仅仅反转字母"></a><font size=6px>917. 仅仅反转字母</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 s ，根据下述规则反转字符串：</p><p>所有非英文字母保留在原有位置。<br>所有英文字母（小写或大写）位置反转。<br>返回反转后的 s 。</p><p>示例 1：</p><p>输入：s &#x3D; “ab-cd”<br>输出：”dc-ba”<br>示例 2：</p><p>输入：s &#x3D; “a-bC-dEf-ghIj”<br>输出：”j-Ih-gfE-dCba”<br>示例 3：</p><p>输入：s &#x3D; “Test1ng-Leet&#x3D;code-Q!”<br>输出：”Qedo1ct-eeLg&#x3D;ntse-T!”</p><p>提示</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 仅由 ASCII 值在范围 [33, 122]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>创建两个数组，一个放非字母的index，另一个放字母，放字母的逆序输出，放非字母的原索引地址输出</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> str []<span class="hljs-type">byte</span>    <span class="hljs-keyword">var</span> biaodianIndex []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">byte</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">if</span> (s[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)|| (s[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)&#123;            str = <span class="hljs-built_in">append</span>(str,s[i])        &#125;<span class="hljs-keyword">else</span>&#123;            biaodianIndex = <span class="hljs-built_in">append</span>(biaodianIndex, i)        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s); i++&#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(biaodianIndex)&gt;<span class="hljs-number">0</span> &amp;&amp; biaodianIndex[<span class="hljs-number">0</span>] == i&#123;            res = <span class="hljs-built_in">append</span>(res, s[biaodianIndex[<span class="hljs-number">0</span>]])            biaodianIndex = biaodianIndex[<span class="hljs-number">1</span>:]        &#125;<span class="hljs-keyword">else</span>&#123;            res = <span class="hljs-built_in">append</span>(res, str[<span class="hljs-built_in">len</span>(str)<span class="hljs-number">-1</span>])            str = str[:<span class="hljs-built_in">len</span>(str)<span class="hljs-number">-1</span>]        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(res)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了56.52%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>96. Unique Binary Search Trees</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/96.%20Unique%20Binary%20Search%20Trees/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/96.%20Unique%20Binary%20Search%20Trees/</url>
    
    <content type="html"><![CDATA[<h3 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a><font size=6px>Unique Binary Search Trees</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given an integer n, return the number of structurally unique BST’s (binary search trees) which has exactly n nodes of unique values from 1 to n.</p><p>Example 1:</p><p>Input: n &#x3D; 3<br>Output: 5<br>Example 2:</p><p>Input: n &#x3D; 1<br>Output: 1</p><p>Constraints:</p><p>1 &lt;&#x3D; n &lt;&#x3D; 19</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>数学题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    res[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>; i&lt;=n ;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j&lt;=i;j++&#123;            res[i] += res[j<span class="hljs-number">-1</span>] * res[i-j]        &#125;    &#125;    <span class="hljs-keyword">return</span> res[n]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了87.51%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>969. 煎饼排序</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/969.%20%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/969.%20%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="煎饼排序"><a href="#煎饼排序" class="headerlink" title="煎饼排序"></a><font size=6px>煎饼排序</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。</p><p>一次煎饼翻转的执行过程如下：</p><p>选择一个整数 k ，1 &lt;&#x3D; k &lt;&#x3D; arr.length<br>反转子数组 arr[0…k-1]（下标从 0 开始）<br>例如，arr &#x3D; [3,2,1,4] ，选择 k &#x3D; 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr &#x3D; [1,2,3,4] 。</p><p>以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。</p><p>示例 1：</p><p>输入：[3,2,4,1]<br>输出：[4,2,4,3]<br>解释：<br>我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。<br>初始状态 arr &#x3D; [3, 2, 4, 1]<br>第一次翻转后（k &#x3D; 4）：arr &#x3D; [1, 4, 2, 3]<br>第二次翻转后（k &#x3D; 2）：arr &#x3D; [4, 1, 2, 3]<br>第三次翻转后（k &#x3D; 4）：arr &#x3D; [3, 2, 1, 4]<br>第四次翻转后（k &#x3D; 3）：arr &#x3D; [1, 2, 3, 4]，此时已完成排序。<br>示例 2：</p><p>输入：[1,2,3]<br>输出：[]<br>解释：<br>输入已经排序，因此不需要翻转任何内容。<br>请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。</p><p>提示：</p><p>1 &lt;&#x3D; arr.length &lt;&#x3D; 100<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; arr.length<br>arr 中的所有整数互不相同（即，arr 是从 1 到 arr.length 整数的一个排列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先把最大的数字翻转到第一个，然后再整个数组翻转，持续n次然后数字就有序看</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pancakeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(arr)    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> reverse <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span> <span class="hljs-type">int</span>)</span></span>    reverse =<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span> <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>/<span class="hljs-number">2</span>;i++&#123;            arr[i],arr[<span class="hljs-built_in">len</span>-i<span class="hljs-number">-1</span>] = arr[<span class="hljs-built_in">len</span>-i<span class="hljs-number">-1</span>],arr[i]        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n; i++&#123;        numLen := n-i;        maxIndex := <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;numLen; j++&#123;            <span class="hljs-keyword">if</span> arr[maxIndex] &lt; arr[j]&#123;                maxIndex = j            &#125;        &#125;        reverse(arr, maxIndex+<span class="hljs-number">1</span>)                reverse(arr,numLen)        res = <span class="hljs-built_in">append</span>(res,maxIndex+<span class="hljs-number">1</span>,numLen)    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了86.11%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98. 验证二叉搜索树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><font size=6px>验证二叉搜索树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：</p><p>输入：root &#x3D; [2,1,3]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。</p><p>提示：</p><p>树中节点数目范围在[1, 104] 内<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>二叉树中序遍历是升序的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        f(root.Left)        res = <span class="hljs-built_in">append</span>(res, root.Val)        f(root.Right)    &#125;    f(root)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(res); i++&#123;        <span class="hljs-keyword">if</span> res[i<span class="hljs-number">-1</span>] &gt;= res[i]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.42%的用户<br>   内存消耗：5.9 MB, 在所有 Go 提交中击败了12.03%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>110. 平衡二叉树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><font size=6px>平衡二叉树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [1,2,2,3,3,null,null,4,4]<br>输出：false<br>示例 3：</p><p>输入：root &#x3D; []<br>输出：true</p><p>提示：</p><p>树中的节点数在范围 [0, 5000] 内<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>自底向上判断，判断这个结点的两个子结点的高度差是否大于1，大于1就说明不是平衡二叉树</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> root ==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span> heigth(root)&gt;=<span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heigth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    leftheight := heigth(root.Left)    rightheight := heigth(root.Right)    <span class="hljs-keyword">if</span> abs(leftheight-rightheight)&gt;=<span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-9999</span>    &#125;    <span class="hljs-keyword">return</span> max(leftheight,rightheight)+<span class="hljs-number">1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a&lt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>*a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了85.62%的用户<br>   内存消耗：5.7 MB, 在所有 Go 提交中击败了99.51%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>120. 三角形最小路径和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><font size=6px>三角形最小路径和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p><p>示例 1：</p><p>输入：triangle &#x3D; [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br>  3 4<br> 6 5 7<br>4 1 8 3<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。<br>示例 2：</p><p>输入：triangle &#x3D; [[-10]]<br>输出：-10</p><p>提示：</p><p>1 &lt;&#x3D; triangle.length &lt;&#x3D; 200<br>triangle[0].length &#x3D;&#x3D; 1<br>triangle[i].length &#x3D;&#x3D; triangle[i - 1].length + 1<br>-104 &lt;&#x3D; triangle[i][j] &lt;&#x3D; 104</p><p>进阶：</p><p>你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>这个就是一个数塔问题，要从下往上计算，从倒数第二层开始，开始算倒数第二层和最后一层的最小路径合，带着这个合和倒数第三层开始计算最小路径合，直到第一层</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(triangle [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(triangle)<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(triangle[i]);j++&#123;            <span class="hljs-keyword">if</span> triangle[i+<span class="hljs-number">1</span>][j]&lt;triangle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]&#123;                triangle[i][j]+=triangle[i+<span class="hljs-number">1</span>][j]            &#125;<span class="hljs-keyword">else</span>&#123;                triangle[i][j]+=triangle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.70%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣一二二： 买卖股票的最佳时机 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><font size=6px>买卖股票的最佳时机 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。<br>示例 2:</p><p>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>在7 3 2 4 9 3 1中，先按递减找到最低，然后按递增找到最高，就买和卖，递减找到2，然后递增找到9，买和卖，最大7。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>    i:=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i&lt;<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>&#123;        <span class="hljs-keyword">for</span> i&lt;<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>&amp;&amp;prices[i]&gt;=prices[i+<span class="hljs-number">1</span>]&#123;            i++        &#125;        min:=prices[i]        <span class="hljs-keyword">for</span> i&lt;<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>&amp;&amp;(prices[i]&lt;=prices[i+<span class="hljs-number">1</span>])&#123;            i++        &#125;        max:=prices[i]        sum+=max-min    &#125;    <span class="hljs-keyword">return</span> sum&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了93.86%的用户<br>   内存消耗：3 MB, 在所有 Go 提交中击败了66.37%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>121. 买卖股票的最佳时机</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><font size=6px>买卖股票的最佳时机</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：</p><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p><p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>提示：</p><p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从后往前，如果是负号就说明是前面那个数大哨兵就变成前面那个数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>    k:=<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--&#123;        num:=prices[k]-prices[i<span class="hljs-number">-1</span>]        <span class="hljs-keyword">if</span> num&lt;<span class="hljs-number">0</span>&#123;            k=i<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> max&lt;num&#123;                max = num            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：144 ms, 在所有 Go 提交中击败了62.88%的用户<br>   执行用时：144 ms, 在所有 Go 提交中击败了62.88%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>123. 买卖股票的最佳时机 III</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/123.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20III/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/123.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20III/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a><font size=6px>买卖股票的最佳时机 III</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入：prices &#x3D; [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。<br>     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。<br>示例 2：</p><p>输入：prices &#x3D; [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3：</p><p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这个情况下, 没有交易完成, 所以最大利润为 0。<br>示例 4：</p><p>输入：prices &#x3D; [1]<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>有四个状态，买一次 ，卖一次，买第二次，卖第二次，看官方的思路，用动态规划做，如果是自己买自己卖收益为0，不用考虑，寻找buy1，2的最小（因为是负数），sell1，2最大，看代码把，我也是抄代码勉强理解一下，官方代码太优雅了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    buy1, sell1 := -prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>    buy2, sell2 := -prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;        buy1 = max(buy1, -prices[i])        sell1 = max(sell1, buy1+prices[i])        buy2 = max(buy2, sell1-prices[i])        sell2 = max(sell2, buy2+prices[i])    &#125;    <span class="hljs-keyword">return</span> sell2&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a &gt; b &#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：140 ms, 在所有 Go 提交中击败了62.50%的用户<br>   内存消耗：8.7 MB, 在所有 Go 提交中击败了94.15%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>128. 最长连续序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><font size=6px>最长连续序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？</p><p>示例 1：</p><p>输入：nums &#x3D; [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。<br>示例 2：</p><p>输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]<br>输出：9</p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先去重，创造一个map把列表中的数子放进去，把重复数字去掉，再遍历这个map，如果他的num-1&#x3D;&#x3D;false，说明num-1这个数不在列表里面，是一个根结点，再从这个数开始遍历，每次加一判断这个数在不在map里面。</p><pre><code class="hljs apache"><span class="hljs-attribute">if</span> !flag[k-<span class="hljs-number">1</span>]&#123;</code></pre><p>如果把上面这句代码改成true，就遍历到根节点上面一个结点开始找相邻的结点，时间会大大增加，开始没理解算法写错了，时间到1144ms 。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;flag := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<span class="hljs-keyword">for</span> _,v :=<span class="hljs-keyword">range</span>  nums&#123;flag[v] =<span class="hljs-literal">true</span>&#125;length,max :=<span class="hljs-number">0</span>,<span class="hljs-number">1</span><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> flag&#123;<span class="hljs-keyword">if</span> !flag[k<span class="hljs-number">-1</span>]&#123;    length++            <span class="hljs-keyword">for</span> flag[k+<span class="hljs-number">1</span>]==<span class="hljs-literal">true</span>&#123;                length++                k++            &#125;            <span class="hljs-keyword">if</span> length&gt;max&#123;            max =length            &#125;length=<span class="hljs-number">0</span>&#125;&#125;<span class="hljs-keyword">return</span>  max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了96.13%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了66.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14. 最长公共前缀</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a><font size=6px>最长公共前缀</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1：</p><p>输入：strs &#x3D; [“flower”,”flow”,”flight”]<br>输出：”fl”<br>示例 2：</p><p>输入：strs &#x3D; [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先判断各个数是不是空，找出各个数中长度最小的数，之后就每次循环判断一位，记得长度超过最小长度就return</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> min <span class="hljs-type">int</span>     <span class="hljs-keyword">var</span> maxstr []<span class="hljs-type">byte</span>    <span class="hljs-keyword">var</span> i,line <span class="hljs-type">int</span>        min =<span class="hljs-number">999</span>    <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(strs);j++&#123;        <span class="hljs-keyword">if</span> strs[j]==<span class="hljs-string">&quot;&quot;</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> min&gt;<span class="hljs-built_in">len</span>(strs[j])&#123;                min = <span class="hljs-built_in">len</span>(strs[j])            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(strs)==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>]    &#125;    <span class="hljs-keyword">for</span> &#123;        <span class="hljs-keyword">if</span> line==min&#123;            <span class="hljs-keyword">break</span>        &#125;        <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(strs);i++&#123;            <span class="hljs-keyword">if</span> strs[<span class="hljs-number">0</span>][line]!=strs[i][line]&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> i!=<span class="hljs-built_in">len</span>(strs)&#123;            <span class="hljs-keyword">break</span>        &#125;<span class="hljs-keyword">else</span>&#123;            maxstr = <span class="hljs-built_in">append</span>(maxstr,strs[<span class="hljs-number">0</span>][line])            line++        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(maxstr)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.3 MB, 在所有 Go 提交中击败了32.68%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>141. 环形链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><font size=6px>141. 环形链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。</p><p>提示：</p><p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 为 -1 或者链表中的一个 有效索引 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>遇到一个数，就加100000，如果下一次遇到的数大于100000，就说明上次遇到过了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> head==<span class="hljs-literal">nil</span>||head.Next==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">for</span> head.Next!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> head.Val&lt;=<span class="hljs-number">100000</span>&#123;            head.Val+=<span class="hljs-number">1000002</span>            head=head.Next        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了81.97%的用户<br>   内存消耗：4.3 MB, 在所有 Go 提交中击败了24.58%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>142. 环形链表 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="环形链表-II"><a href="#环形链表-II" class="headerlink" title="环形链表 II"></a><font size=6px>环形链表 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O(1) 空间解决此题？</p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>还是和1一样，每个结点加1000000，如果遇到下一个数字大于100000，就说明这个结点之前遇到过了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> head==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;        <span class="hljs-keyword">for</span> head!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> head.Val&gt;<span class="hljs-number">100000</span>&#123;            <span class="hljs-keyword">return</span> head        &#125;        head.Val+=<span class="hljs-number">1000002</span>        head=head.Next    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了98.84%的用户<br>   内存消耗：3.7 MB, 在所有 Go 提交中击败了31.10%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1416. 恢复数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1416.%20%E6%81%A2%E5%A4%8D%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1416.%20%E6%81%A2%E5%A4%8D%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="1416-恢复数组"><a href="#1416-恢复数组" class="headerlink" title="1416. 恢复数组"></a><font size=6px>1416. 恢复数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 [1, k] 之间，且数组中的数字都没有前导 0 。</p><p>给你字符串 s 和整数 k 。可能会有多种不同的数组恢复结果。</p><p>按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。</p><p>由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。</p><p>示例 1：</p><p>输入：s &#x3D; “1000”, k &#x3D; 10000<br>输出：1<br>解释：唯一一种可能的数组方案是 [1000]<br>示例 2：</p><p>输入：s &#x3D; “1000”, k &#x3D; 10<br>输出：0<br>解释：不存在任何数组方案满足所有整数都 &gt;&#x3D; 1 且 &lt;&#x3D; 10 同时输出结果为 s 。<br>示例 3：</p><p>输入：s &#x3D; “1317”, k &#x3D; 2000<br>输出：8<br>解释：可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]<br>示例 4：</p><p>输入：s &#x3D; “2020”, k &#x3D; 30<br>输出：1<br>解释：唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 &gt; 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。<br>示例 5：</p><p>输入：s &#x3D; “1234567890”, k &#x3D; 90<br>输出：34</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^5.<br>s 只包含数字且不包含前导 0 。<br>1 &lt;&#x3D; k &lt;&#x3D; 10^9.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>我摊牌了，我不会做，是看懂大佬的代码的，<a href="https://leetcode-cn.com/problems/restore-the-array/solution/dong-tai-gui-hua-zhu-zi-fu-jie-xi-pan-duan-you-duo/">https://leetcode-cn.com/problems/restore-the-array/solution/dong-tai-gui-hua-zhu-zi-fu-jie-xi-pan-duan-you-duo/</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfArrays</span><span class="hljs-params">(s <span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> mod <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> dp[<span class="hljs-number">100002</span>] <span class="hljs-type">int</span>    mod = <span class="hljs-number">1000000007</span>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">for</span> j:=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--&#123;            <span class="hljs-keyword">if</span> s[j]==<span class="hljs-string">&#x27;0&#x27;</span>&#123;                <span class="hljs-keyword">continue</span>            &#125;            s1:=s[j:i]            num,err:=strconv.Atoi(s1)            <span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;                            &#125;            <span class="hljs-keyword">if</span> num&lt;=k&#123;                dp[i]+=dp[j]            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span> s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;dp[i]==<span class="hljs-number">0</span>&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                &#125;                <span class="hljs-keyword">break</span>            &#125;        &#125;        dp[i]%=mod    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]%mod&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了30.77%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>143. 重排链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/143.%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/143.%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a><font size=6px>重排链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用快慢指针，找到链表的中间结点，让后面的结点逆置，然后后面的结点一个个插入</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(head *ListNode)</span></span>  &#123;    <span class="hljs-keyword">if</span> head==<span class="hljs-literal">nil</span>||head.Next==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">var</span> fast,slow,head2,pre *ListNode    fast,slow=head,head    <span class="hljs-keyword">for</span> fast!=<span class="hljs-literal">nil</span>&amp;&amp;fast.Next!=<span class="hljs-literal">nil</span>&#123;        fast=fast.Next.Next        pre = slow        slow=slow.Next    &#125;    pre.Next=<span class="hljs-literal">nil</span>    head2=<span class="hljs-literal">nil</span>    <span class="hljs-keyword">for</span> slow!=<span class="hljs-literal">nil</span>&#123;        tmp := slow.Next        slow.Next=head2        head2=slow        slow=tmp    &#125;    <span class="hljs-comment">//fmt.Println(head2.Val,head2.Next.Val)</span>    true_head := head    <span class="hljs-keyword">for</span> head.Next!=<span class="hljs-literal">nil</span>&#123;        tmp:=head2.Next        head2.Next=head.Next        head.Next=head2        head=head2.Next        head2=tmp    &#125;      <span class="hljs-keyword">if</span> head2!=<span class="hljs-literal">nil</span>&#123;        head.Next=head2    &#125;    head=true_head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了76.58%的用户<br>   内存消耗：5.3 MB, 在所有 Go 提交中击败了79.64%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>148. 排序链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a><font size=6px>排序链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>进阶：</p><p>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><p>示例 1：</p><p>输入：head &#x3D; [4,2,1,3]<br>输出：[1,2,3,4]<br>示例 2：</p><p>输入：head &#x3D; [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br>示例 3：</p><p>输入：head &#x3D; []<br>输出：[]</p><p>提示：</p><p>链表中节点的数目在范围 [0, 5 * 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>通过次数159,543提交次数237,674</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用归并排序，用递归写更加简洁易懂一些</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> head&#125;fast, slow := head, head<span class="hljs-keyword">var</span> pre *ListNode    <span class="hljs-comment">//用快慢指针</span><span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;pre = slowslow = slow.Nextfast = fast.Next.Next&#125;pre.Next = <span class="hljs-literal">nil</span>l := sortList(head)r := sortList(slow)<span class="hljs-keyword">return</span> mergeList(l, r)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(l, r *ListNode)</span></span> *ListNode &#123;    <span class="hljs-comment">//制造头节点方便操作</span>head := &amp;ListNode&#123;Val: <span class="hljs-number">0</span>&#125;pre := head<span class="hljs-keyword">for</span> l != <span class="hljs-literal">nil</span> &amp;&amp; r != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> l.Val &gt; r.Val &#123;pre.Next = rr = r.Next&#125; <span class="hljs-keyword">else</span> &#123;pre.Next = ll = l.Next&#125;pre = pre.Next&#125;<span class="hljs-keyword">if</span> l != <span class="hljs-literal">nil</span> &#123;pre.Next = l&#125;<span class="hljs-keyword">if</span> r != <span class="hljs-literal">nil</span> &#123;pre.Next = r&#125;    <span class="hljs-comment">//这才是真正的开始</span><span class="hljs-keyword">return</span> head.Next&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：32 ms, 在所有 Go 提交中击败了91.30%的用户<br>   内存消耗：7.1 MB, 在所有 Go 提交中击败了90.61%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146. LRU 缓存机制</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/146.%20LRU%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/146.%20LRU%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="LRU-缓存机制"><a href="#LRU-缓存机制" class="headerlink" title="LRU 缓存机制"></a><font size=6px>LRU 缓存机制</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例：</p><p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p><p>解释<br>LRUCache lRUCache &#x3D; new LRUCache(2);<br>lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 {1&#x3D;1}<br>lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 {1&#x3D;1, 2&#x3D;2}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 1<br>lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 {1&#x3D;1, 3&#x3D;3}<br>lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 {4&#x3D;4, 3&#x3D;3}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.get(3);    &#x2F;&#x2F; 返回 3<br>lRUCache.get(4);    &#x2F;&#x2F; 返回 4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>为了做到都是o（1）的复杂度，用哈希和链表结合的数据结构，链表弄一个head和tail，中间放数据，head和tail不放数据，这样的好处是不用判断只有一个结点的情况，方便很多，我能力很差，也是参考大佬的代码，写的很简洁优雅。</p><p><a href="https://leetcode-cn.com/problems/lru-cache/solution/golang-lru-cache-dai-ma-chao-ji-rong-yi-li-jie-by-/">链接在这里</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>head     *LRUCacheNodetail     *LRUCacheNodeMap      <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*LRUCacheNode&#125;<span class="hljs-keyword">type</span> LRUCacheNode <span class="hljs-keyword">struct</span> &#123;k    <span class="hljs-type">int</span>v    <span class="hljs-type">int</span>pre  *LRUCacheNodenext *LRUCacheNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;LRU := <span class="hljs-built_in">new</span>(LRUCache)LRU.Map = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*LRUCacheNode)LRU.<span class="hljs-built_in">cap</span> = capacityLRU.head = &amp;LRUCacheNode&#123;&#125;LRU.tail = &amp;LRUCacheNode&#123;&#125;LRU.head.next = LRU.tailLRU.tail.pre = LRU.head<span class="hljs-keyword">return</span> *LRU&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> node, ok := this.Map[key]; ok &#123;deleteNode(node)this.moveToTail(this.Map[key])<span class="hljs-keyword">return</span> node.v&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;node, ok := this.Map[key]<span class="hljs-keyword">if</span> ok &#123;deleteNode(node)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.Map) == this.<span class="hljs-built_in">cap</span> &#123;<span class="hljs-built_in">delete</span>(this.Map, this.head.next.k)deleteNode(this.head.next)&#125;node = &amp;LRUCacheNode&#123;k: key, v: value&#125;this.Map[key] = node&#125;node.v = valuethis.moveToTail(node)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> moveToTail(node *LRUCacheNode) &#123;tmp := this.tail.pretmp.next = nodenode.pre = tmpnode.next = this.tailthis.tail.pre = node&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(node *LRUCacheNode)</span></span> &#123;node.pre.next = node.nextnode.next.pre = node.pre&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：120 ms, 在所有 Go 提交中击败了76.27%的用户<br>   内存消耗：11.7 MB, 在所有 Go 提交中击败了86.78%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15. 三数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><font size=6px>三数之和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：</p><p>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>示例 2：</p><p>输入：nums &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：nums &#x3D; [0]<br>输出：[]</p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 3000<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>双指针加上两面夹逼，先确定一个数，之后两个数开始双指针往中间靠</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sort&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;<span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;    &#125;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    sort.Ints(nums)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;i++&#123;        <span class="hljs-keyword">if</span>  i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i<span class="hljs-number">-1</span>]==nums[i]&#123;                <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">if</span> nums[i]&gt;<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">break</span>        &#125;        j:=i+<span class="hljs-number">1</span>        k:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">for</span> j&lt;k&#123;            n2 :=nums[j]            n3 :=nums[k]            <span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k]==<span class="hljs-number">0</span>&#123;                res = <span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;nums[i],nums[j],nums[k]&#125;)                <span class="hljs-keyword">for</span> j&lt;k &amp;&amp;nums[j]==n2&#123;                    j++                &#125;                <span class="hljs-keyword">for</span> j&lt;k &amp;&amp;nums[k]==n3&#123;                    k--                &#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k]&lt;<span class="hljs-number">0</span>&#123;                j++            &#125;<span class="hljs-keyword">else</span>&#123;                k--            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：40 ms, 在所有 Go 提交中击败了49.59%的用户<br>   内存消耗：7.5 MB, 在所有 Go 提交中击败了27.30%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makedown基础语法</title>
    <link href="/2022/01/21/makedown%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/01/21/makedown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1、字体大小"><a href="#1、字体大小" class="headerlink" title="1、字体大小"></a>1、字体大小</h1><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><pre><code class="hljs clean"># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><h6 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h6><p><strong>加粗</strong></p><pre><code class="hljs *">**加粗**</code></pre><p><em>斜体</em></p><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体*</span></code></pre><p>输入代码</p><pre><code class="hljs autohotkey">直接输入”```“然后按下回车键（`在英文情况加按左上角波浪号可打出）</code></pre><p>3、url</p><p>图片导入</p><p>![](C:\Users\89500\Desktop\HTML\my storys\hexo\themes\fluid\source\img\avatar.png)</p><pre><code class="hljs scss">绝对路径： !<span class="hljs-selector-attr">[这里输入图片名字]</span>(这里输入绝对路径)</code></pre>]]></content>
    
    
    <categories>
      
      <category>makedown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>makedown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/01/21/hello-world/"/>
    <url>/2022/01/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">这是我第一 篇blog，正式开启我的博客之路啦。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a><font size=6px>04. 二维数组中的查找</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p><p>给定 target &#x3D; 5，返回 true。</p><p>给定 target &#x3D; 20，返回 false。</p><p>限制：</p><p>0 &lt;&#x3D; n &lt;&#x3D; 1000</p><p>0 &lt;&#x3D; m &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从最右上开始，如果比target大就往左，小就往下</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-type">bool</span> findNumberIn2DArray(<span class="hljs-type">int</span>** matrix, <span class="hljs-type">int</span> matrixSize, <span class="hljs-type">int</span>* matrixColSize, <span class="hljs-type">int</span> target)&#123;    <span class="hljs-keyword">if</span>(matrixSize==<span class="hljs-number">0</span> || *matrixColSize==<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;    <span class="hljs-type">int</span> j=*matrixColSize<span class="hljs-number">-1</span>;    while(i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;matrixSize &amp;&amp;j&gt;=<span class="hljs-number">0</span> &amp;&amp;j&lt;*matrixColSize)&#123;        <span class="hljs-keyword">if</span>(matrix[i][j] == target)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target)&#123;            i++;        &#125;<span class="hljs-keyword">else</span>&#123;            j--;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：32 ms, 在所有 C 提交中击败了99.19% 的用户<br>   内存消耗：8 MB, 在所有 C 提交中击败了99.73% 的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a><font size=6px>05. 替换空格</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">char* replaceSpace(char* s)&#123;    char* s1;    s1 = (char *)malloc(sizeof(char)*<span class="hljs-number">10000</span>);    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;strlen(s); i++)&#123;        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;            s1[j++] = <span class="hljs-string">&#x27;%&#x27;</span>;            s1[j++] = <span class="hljs-string">&#x27;2&#x27;</span>;            s1[j++] = <span class="hljs-string">&#x27;0&#x27;</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            s1[j] = s[i];            j++;        &#125;    &#125;    s1[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;    <span class="hljs-keyword">return</span> s1;    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 C 提交中击败了16.70% 的用户<br>   内存消耗：5.6 MB, 在所有 C 提交中击败了31.01% 的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a><font size=6px>06. 从尾到头打印链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span>输出：<span class="hljs-comment">[2,3,1]</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先将链表逆置，在逆置过程中算出长度，最后赋值给数组中</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">struct</span> ListNode* reverse(<span class="hljs-keyword">struct</span> ListNode *head,<span class="hljs-type">int</span> *<span class="hljs-built_in">len</span>)&#123;     <span class="hljs-keyword">struct</span> ListNode *head1=NULL;     <span class="hljs-keyword">struct</span> ListNode *tmp =NULL;     while(head!=NULL)&#123;         tmp = head-&gt;next;         head-&gt;next = head1;         head1 = head;         head = tmp;         *<span class="hljs-built_in">len</span>+=<span class="hljs-number">1</span>;     &#125;     <span class="hljs-keyword">return</span> head1; &#125;<span class="hljs-type">int</span>* reversePrint(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span>* returnSize)&#123;    <span class="hljs-type">int</span> *num;    <span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>;    head = reverse(head, &amp;<span class="hljs-built_in">len</span>);    num = (<span class="hljs-type">int</span> *)malloc(sizeof(<span class="hljs-type">int</span>)*<span class="hljs-number">10000</span>);    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;    while(head!=NULL)&#123;                num[i++] = head-&gt;val;        head = head-&gt;next;    &#125;        *returnSize = <span class="hljs-built_in">len</span>;    <span class="hljs-keyword">return</span> num;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 C 提交中击败了57.35% 的用户<br>   内存消耗：7.4 MB, 在所有 C 提交中击败了20.63% 的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1030 Travel Plan (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1030%20Travel%20Plan%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1030%20Travel%20Plan%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Travel-Plan"><a href="#Travel-Plan" class="headerlink" title="Travel Plan"></a><font size=6px>Travel Plan</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his&#x2F;her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing 4 positive integers <em>N</em>, <em>M</em>, <em>S</em>, and <em>D</em>, where <em>N</em> (≤500) is the number of cities (and hence the cities are numbered from 0 to <em>N</em>−1); <em>M</em> is the number of highways; <em>S</em> and <em>D</em> are the starting and the destination cities, respectively. Then <em>M</em> lines follow, each provides the information of a highway, in the format:</p><pre><code class="hljs arcade">City1 City2 <span class="hljs-built_in">Distance</span> Cost</code></pre><p>where the numbers are all integers no more than 500, and are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">4 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">0 2 3 3 40</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用狄杰斯特拉算法做，再加上一个pre数组来记录前一个数，再dfs来遍历最小cost</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;string.h&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#define inf <span class="hljs-number">0x3f3f3f</span>using  namespace std;<span class="hljs-type">int</span> dest[<span class="hljs-number">501</span>][<span class="hljs-number">501</span>];vector&lt;<span class="hljs-type">int</span>&gt; pre[<span class="hljs-number">501</span>];vector&lt;<span class="hljs-type">int</span>&gt;temp, res;<span class="hljs-type">int</span> costs[<span class="hljs-number">501</span>][<span class="hljs-number">501</span>];<span class="hljs-type">int</span> vis[<span class="hljs-number">501</span>];<span class="hljs-type">int</span> dis[<span class="hljs-number">501</span>];<span class="hljs-type">int</span> n,m,s,d;<span class="hljs-type">int</span> minCost = inf;<span class="hljs-comment">// 得到最短距离结果之后从后往前遍历最小花费</span>void dfs(<span class="hljs-type">int</span> v)&#123;    temp.push_back(v);    <span class="hljs-keyword">if</span>(v == s)&#123;        <span class="hljs-type">int</span> tempCost = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;temp.size(); i++)&#123;            tempCost += costs[temp[i<span class="hljs-number">-1</span>]][temp[i]];        &#125;        <span class="hljs-keyword">if</span>(minCost &gt; tempCost)&#123;            res = temp;            minCost = tempCost;        &#125;        temp.pop_back();        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pre[v].size(); i++)        dfs(pre[v][i]);    temp.pop_back();&#125;<span class="hljs-type">int</span> main()&#123;    memset(dis,inf, sizeof (dis));    fill(dest[<span class="hljs-number">0</span>],dest[<span class="hljs-number">0</span>]+<span class="hljs-number">501</span>*<span class="hljs-number">501</span>, inf);    cin &gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d;    memset(vis,<span class="hljs-number">0</span>, sizeof(vis));    <span class="hljs-type">int</span> a,b,distance,cost;    while(m--)&#123;        cin &gt;&gt;a&gt;&gt;b&gt;&gt;distance&gt;&gt;cost;        dest[a][b] = dest[b][a] = distance;        costs[a][b] = costs[b][a] = cost;    &#125;    dis[s] = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n ;i++)&#123;       <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>,minn = inf;       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)&#123;           <span class="hljs-keyword">if</span>(vis[j] == <span class="hljs-number">0</span> &amp;&amp; ( minn &gt; dis[j]))&#123;               minn = dis[j];               u = j;           &#125;       &#125;       <span class="hljs-keyword">if</span>(u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;       vis[u] = <span class="hljs-number">1</span>;       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n;j++)&#123;           <span class="hljs-keyword">if</span>( !vis[j] &amp;&amp; dest[u][j] != inf)&#123;               <span class="hljs-keyword">if</span> (dis[j] &gt; dis[u] + dest[u][j])&#123;                   dis[j] = dis[u] + dest[u][j];                   pre[j].clear();                   pre[j].push_back(u);               &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[j] == dis[u] + dest[u][j])&#123;                   pre[j].push_back(u);               &#125;           &#125;       &#125;   &#125;    dfs(d);   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=res.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;       <span class="hljs-keyword">if</span>(i == res.size()<span class="hljs-number">-1</span>) cout &lt;&lt;res[i];       <span class="hljs-keyword">else</span> cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;res[i];   &#125;   cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;dis[d]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;minCost;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1080 Graduate Admission (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1080%20Graduate%20Admission%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1080%20Graduate%20Admission%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Graduate-Admission"><a href="#Graduate-Admission" class="headerlink" title="Graduate Admission"></a><font size=6px>Graduate Admission</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.</p><p>Each applicant will have to provide two grades: the national entrance exam grade <em>G**E</em>, and the interview grade <em>G**I</em>. The final grade of an applicant is (<em>G**E</em>+<em>G**I</em>)&#x2F;2. The admission rules are:</p><ul><li>The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.</li><li>If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade <em>G**E</em>. If still tied, their ranks must be the same.</li><li>Each applicant may have <em>K</em> choices and the admission will be done according to his&#x2F;her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.</li><li>If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, <strong>even if its quota will be exceeded</strong>.</li></ul><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case.</p><p>Each case starts with a line containing three positive integers: <em>N</em> (≤40,000), the total number of applicants; <em>M</em> (≤100), the total number of graduate schools; and <em>K</em> (≤5), the number of choices an applicant may have.</p><p>In the next line, separated by a space, there are <em>M</em> positive integers. The <em>i</em>-th integer is the quota of the <em>i</em>-th graduate school respectively.</p><p>Then <em>N</em> lines follow, each contains 2+<em>K</em> integers separated by a space. The first 2 integers are the applicant’s <em>G**E</em> and <em>G**I</em>, respectively. The next <em>K</em> integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to <em>M</em>−1, and the applicants are numbered from 0 to <em>N</em>−1.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">11 6 32 1 2 2 2 3100 100 0 1 260 60 2 3 5100 90 0 3 490 100 1 2 090 90 5 1 380 90 1 0 280 80 0 1 280 80 0 1 280 70 1 3 270 80 1 2 3100 100 0 2 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">0 1035 6 72 81 4</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>根据总成绩和第一个成绩开始降序排序，根据名额把序号进行push中数组中。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;algorithm&quot;</span>using namespace std;<span class="hljs-type">int</span> m,n,k;<span class="hljs-keyword">struct</span> Stu&#123;    <span class="hljs-type">int</span> no;    float score;    <span class="hljs-type">int</span> ge;    <span class="hljs-type">int</span> pre_sch[<span class="hljs-number">6</span>];&#125;;<span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">struct</span> Stu a, <span class="hljs-keyword">struct</span> Stu b)&#123;    <span class="hljs-keyword">if</span>(a.score == b.score)&#123;        <span class="hljs-keyword">return</span> a.ge &gt; b.ge;    &#125;    <span class="hljs-keyword">return</span> a.score &gt; b.score;&#125;<span class="hljs-type">int</span> main()&#123;    cin &gt;&gt;m&gt;&gt;n&gt;&gt;k;    <span class="hljs-type">int</span> a,b;    <span class="hljs-keyword">struct</span> Stu stu[m+<span class="hljs-number">1</span>];    <span class="hljs-type">int</span> sch[n];    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sch_grad;    <span class="hljs-comment">// 输入学校的容量</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        cin &gt;&gt;sch[i];        vector&lt;<span class="hljs-type">int</span>&gt; c;        sch_grad.push_back(c);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m; i++)&#123;        cin &gt;&gt;a&gt;&gt;b;        stu[i].ge = a;        stu[i].score = float (a+b)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;k; j++)&#123;            cin &gt;&gt;stu[i].pre_sch[j];        &#125;        stu[i].no = i;    &#125;    sort(stu, stu+m, cmp);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;k;j++)&#123;            <span class="hljs-comment">//找到一个符合的学校</span>            <span class="hljs-keyword">if</span>(sch[stu[i].pre_sch[j]] &gt;<span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">// 把合适的节点加入</span>                sch_grad[stu[i].pre_sch[j]].push_back(stu[i].no);                sch[stu[i].pre_sch[j]]--;                <span class="hljs-keyword">if</span>(i&lt;m<span class="hljs-number">-1</span> &amp;&amp;stu[i].score == stu[i+<span class="hljs-number">1</span>].score &amp;&amp; stu[i].ge == stu[i+<span class="hljs-number">1</span>].ge)&#123;                    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;p&lt;k;p++)&#123;                        <span class="hljs-keyword">if</span>(stu[i].pre_sch[p] != stu[i+<span class="hljs-number">1</span>].pre_sch[p] )&#123;                            flag = <span class="hljs-literal">false</span>;                            <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                    <span class="hljs-comment">// 和后一个成绩和意愿都一样</span>                    <span class="hljs-keyword">if</span> (flag)&#123;                        <span class="hljs-keyword">if</span>(sch[stu[i].pre_sch[j]] == <span class="hljs-number">0</span>)&#123;                            sch[stu[i].pre_sch[j]]++;                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n;i++)&#123;        sort(sch_grad[i].begin(),sch_grad[i].end() );        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;sch_grad[i].size(); j++)&#123;            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;                cout &lt;&lt; sch_grad[i][j];            &#125;<span class="hljs-keyword">else</span>&#123;                cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;sch_grad[i][j];            &#125;        &#125;        cout&lt;&lt;endl;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1087 All Roads Lead to Rome (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1087%20All%20Roads%20Lead%20to%20Rome%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1087%20All%20Roads%20Lead%20to%20Rome%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="All-Roads-Lead-to-Rome"><a href="#All-Roads-Lead-to-Rome" class="headerlink" title="All Roads Lead to Rome"></a><font size=6px>All Roads Lead to Rome</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 2 positive integers <em>N</em> (2≤<em>N</em>≤200), the number of cities, and <em>K</em>, the total number of routes between pairs of cities; followed by the name of the starting city. The next <em>N</em>−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then <em>K</em> lines follow, each describes a route between two cities in the format <code>City1 City2 Cost</code>. Here the name of a city is a string of 3 capital English letters, and the destination is always <code>ROM</code> which represents Rome.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.</p><p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format <code>City1-&gt;City2-&gt;...-&gt;ROM</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">6 7 HZHROM 100PKN 40GDN 55PRS 95BLN 80ROM GDN 1BLN ROM 1HZH PKN 1PRS ROM 2BLN HZH 2PKN GDN 1HZH PRS 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">3 3 195 97HZH-&gt;PRS-&gt;ROM</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>和1030题很像，动态规划➕dfs，用pre数组存储这个节点之前的节点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;string.h&quot;</span>#include <span class="hljs-string">&quot;map&quot;</span>using namespace std;#define inf <span class="hljs-number">0x3f3f3f3f</span><span class="hljs-type">int</span> dis[<span class="hljs-number">201</span>][<span class="hljs-number">201</span>];<span class="hljs-type">int</span> dest[<span class="hljs-number">201</span>];<span class="hljs-type">int</span> vis[<span class="hljs-number">201</span>];vector&lt;<span class="hljs-type">int</span>&gt; pre[<span class="hljs-number">201</span>],temp,res;<span class="hljs-type">int</span> maxHappy = <span class="hljs-number">0</span>;<span class="hljs-keyword">struct</span> City&#123;    <span class="hljs-type">int</span> no,happy;    <span class="hljs-type">string</span> name;&#125;;<span class="hljs-type">int</span> m,n;<span class="hljs-type">string</span> start;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">string</span>, City&gt; mapCity;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">int</span>, City&gt; mapCityNo;<span class="hljs-type">int</span> pathNumber=<span class="hljs-number">0</span>;void dfs(<span class="hljs-type">int</span> v)&#123;    temp.push_back(v);    <span class="hljs-keyword">if</span>(v == mapCity[start].no)&#123;        pathNumber ++;        <span class="hljs-type">int</span> tempHappy = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.size(); i++)&#123;            tempHappy += mapCityNo[temp[i]].happy;        &#125;        <span class="hljs-keyword">if</span>(tempHappy &gt; maxHappy)&#123;            maxHappy = tempHappy;            res = temp;        &#125;        temp.pop_back();        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i: pre[v]) dfs(i);    temp.pop_back();&#125;<span class="hljs-type">int</span> main()&#123;    memset(dis,inf, sizeof(dis));    memset(dest,inf, sizeof(dest));    memset(vis,<span class="hljs-number">0</span>, sizeof(vis));    cin &gt;&gt;m&gt;&gt;n&gt;&gt;start;    City city;    city.no = <span class="hljs-number">0</span>;    city.name = start;    city.happy = <span class="hljs-number">0</span>;    mapCity[start] = city;    mapCityNo[<span class="hljs-number">0</span>] = city;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;        City node;        cin &gt;&gt;node.name &gt;&gt;node.happy;        node.no = i;        mapCity[node.name] = node;        mapCityNo[node.no] = node;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;        <span class="hljs-type">string</span> a,b;        <span class="hljs-type">int</span> c;        cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;        dis[mapCity[a].no][mapCity[b].no] =dis[mapCity[b].no][mapCity[a].no]= c;    &#125;    dest[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m; i++)&#123;        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>, minn = inf;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;            <span class="hljs-keyword">if</span>( vis[j] == <span class="hljs-number">0</span> &amp;&amp; dest[j] &lt; minn)&#123;                minn = dest[j];                u = j;            &#125;        &#125;        <span class="hljs-keyword">if</span>(u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;        vis[u] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m ; j++)&#123;            <span class="hljs-keyword">if</span>(vis[j] == <span class="hljs-number">0</span> &amp;&amp; dis[u][j] != inf)&#123;                <span class="hljs-keyword">if</span>(dest[j] &gt;dest[u] + dis[u][j])&#123;                    dest[j] = dest[u] + dis[u][j];                    pre[j].clear();                    pre[j].push_back(u);                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dest[j] == dest[u] + dis[u][j])&#123;                    pre[j].push_back(u);                &#125;            &#125;        &#125;    &#125;    dfs(mapCity[<span class="hljs-string">&quot;ROM&quot;</span>].no);    cout &lt;&lt; pathNumber&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;dest[mapCity[<span class="hljs-string">&quot;ROM&quot;</span>].no]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;maxHappy&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;maxHappy/(res.size()<span class="hljs-number">-1</span>)&lt;&lt;endl;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=res.size()<span class="hljs-number">-1</span>;i &gt;=<span class="hljs-number">0</span> ;i--)&#123;        <span class="hljs-keyword">if</span>(i == res.size()<span class="hljs-number">-1</span>)&#123;            cout &lt;&lt; mapCityNo[res[i]].name;        &#125;<span class="hljs-keyword">else</span>&#123;           cout &lt;&lt;  <span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt; mapCityNo[res[i]].name;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1091 Acute Stroke (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1091%20Acute%20Stroke%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1091%20Acute%20Stroke%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Acute-Stroke-30-分"><a href="#Acute-Stroke-30-分" class="headerlink" title="Acute Stroke (30 分)"></a><font size=6px>Acute Stroke (30 分)</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>One important factor to identify acute stroke (急性脑卒中) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 4 positive integers: <em>M</em>, <em>N</em>, <em>L</em> and <em>T</em>, where <em>M</em> and <em>N</em> are the sizes of each slice (i.e. pixels of a slice are in an <em>M</em>×<em>N</em> matrix, and the maximum resolution is 1286 by 128); <em>L</em> (≤60) is the number of slices of a brain; and <em>T</em> is the integer threshold (i.e. if the volume of a connected core is less than <em>T</em>, then that core must not be counted).</p><p>Then <em>L</em> slices are given. Each slice is represented by an <em>M</em>×<em>N</em> matrix of 0’s and 1’s, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1’s to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than <em>T</em> are counted. Two pixels are <strong>connected</strong> and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one.</p><p><img src="https://images.ptausercontent.com/f85c00cc-62ce-41ff-8dd0-d1c288d87409.jpg" alt="figstroke.jpg"></p><p>Figure 1</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output in a line the total volume of the stroke core.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">3 4 5 21 1 1 11 1 1 11 1 1 10 0 1 10 0 1 10 0 1 11 0 1 10 1 0 00 0 0 01 0 1 10 0 0 00 0 0 00 0 0 10 0 0 11 0 0 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">26</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一个三维bfs题，题目不难，细节难，dfs会爆栈不行，bfs不能用vector要用queue，不然会超时。bfs细节是vis[endd.x][endd.y][endd.z] &#x3D; true;这句话放的位置很重要</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;<span class="hljs-keyword">map</span>&gt;#include&lt;queue&gt;using namespace std;<span class="hljs-type">int</span> maze[<span class="hljs-number">60</span>][<span class="hljs-number">1286</span>][<span class="hljs-number">128</span>];<span class="hljs-type">int</span> vis[<span class="hljs-number">60</span>][<span class="hljs-number">1286</span>][<span class="hljs-number">128</span>];<span class="hljs-type">int</span> n,m,l,t;<span class="hljs-type">int</span> nxt[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<span class="hljs-keyword">struct</span> node&#123;    <span class="hljs-type">int</span> x,y,z;&#125;;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;void BFS(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> k)&#123;    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;    queue&lt;node&gt;qu;    node s = &#123;i,j,k&#125;;    qu.push(s);    vis[i][j][k] = <span class="hljs-literal">true</span>;    while(!qu.empty())    &#123;        node tmp = qu.front();        qu.pop();        node endd;        cnt++;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">6</span>; i++)        &#123;            endd.x = tmp.x + nxt[i][<span class="hljs-number">0</span>];            endd.y = tmp.y + nxt[i][<span class="hljs-number">1</span>];            endd.z = tmp.z + nxt[i][<span class="hljs-number">2</span>];            <span class="hljs-keyword">if</span>(endd.x &gt;=<span class="hljs-number">0</span> &amp;&amp; endd.x &lt; l &amp;&amp; endd.y &gt;= <span class="hljs-number">0</span> &amp;&amp; endd.y &lt; n &amp;&amp; endd.z &gt;= <span class="hljs-number">0</span> &amp;&amp; endd.z &lt; m               &amp;&amp; vis[endd.x][endd.y][endd.z] == <span class="hljs-literal">false</span>  &amp;&amp; maze[endd.x][endd.y][endd.z] == <span class="hljs-number">1</span>)            &#123;                vis[endd.x][endd.y][endd.z] = <span class="hljs-literal">true</span>;                qu.push(endd);            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(cnt &gt;= t)        total += cnt;&#125;<span class="hljs-type">int</span> main()&#123;    scanf(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;l,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; m; k++)                scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;maze[i][j][k]);        &#125;    &#125;<span class="hljs-comment">//表示输入</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; m; k++)            &#123;                node s = &#123;i,j,k&#125;;                <span class="hljs-keyword">if</span>(maze[i][j][k] == <span class="hljs-number">1</span> &amp;&amp; !vis[i][j][k])<span class="hljs-comment">//首先这个东西是1? 其次还没有走过它</span>                    BFS(i,j,k);            &#125;        &#125;    &#125;    printf(<span class="hljs-string">&quot;%d\n&quot;</span>,total);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1099 Build A Binary Search Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1099%20Build%20A%20Binary%20Search%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1099%20Build%20A%20Binary%20Search%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Build-A-Binary-Search-Tree"><a href="#Build-A-Binary-Search-Tree" class="headerlink" title="Build A Binary Search Tree "></a><font size=6px>Build A Binary Search Tree </font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2.</p><p><img src="https://images.ptausercontent.com/24c2521f-aaed-4ef4-bac8-3ff562d80a1b.jpg" alt="figBST.jpg"></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤100) which is the total number of nodes in the tree. The next <em>N</em> lines each contains the left and the right children of a node in the format <code>left_index right_index</code>, provided that the nodes are numbered from 0 to <em>N</em>−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally <em>N</em> distinct integer keys are given in the last line.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">91 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">58 25 82 11 38 67 45 73 42</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先按照序列构造二叉树，再讲数组排序用中序插入数字</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;<span class="hljs-keyword">struct</span> node &#123;    <span class="hljs-type">int</span> data, left, right;&#125;tree[<span class="hljs-number">99999</span>];<span class="hljs-type">int</span> ele[<span class="hljs-number">99999</span>], N, l, r, ele_i = <span class="hljs-number">0</span>, start = <span class="hljs-literal">true</span>;void inorder(<span class="hljs-type">int</span> root) &#123;    <span class="hljs-keyword">if</span>(tree[root].left !=  <span class="hljs-number">-1</span>) inorder(tree[root].left);    tree[root].data = ele[ele_i++];    <span class="hljs-keyword">if</span>(tree[root].right !=  <span class="hljs-number">-1</span>) inorder(tree[root].right);&#125;void levelorder(<span class="hljs-type">int</span> root) &#123;    queue&lt;<span class="hljs-type">int</span>&gt; que;    que.push(root);    while(!que.empty()) &#123;        node n = tree[que.front()];        <span class="hljs-keyword">if</span>(start) printf(<span class="hljs-string">&quot;%d&quot;</span>, n.data);        <span class="hljs-keyword">else</span> printf(<span class="hljs-string">&quot; %d&quot;</span>, n.data);        start = <span class="hljs-literal">false</span>;        que.pop();        <span class="hljs-keyword">if</span>(n.left != <span class="hljs-number">-1</span>) que.push(n.left);        <span class="hljs-keyword">if</span>(n.right != <span class="hljs-number">-1</span>) que.push(n.right);    &#125;&#125;<span class="hljs-type">int</span> main() &#123;    scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) scanf(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;tree[i].left, &amp;tree[i].right);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ele[i]);    sort(ele, ele + N);    inorder(<span class="hljs-number">0</span>);    levelorder(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1103 Integer Factorization (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1103%20Integer%20Factorization%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1103%20Integer%20Factorization%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Integer-Factorization"><a href="#Integer-Factorization" class="headerlink" title="Integer Factorization "></a><font size=6px>Integer Factorization </font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>The <em>K</em>−<em>P</em> factorization of a positive integer <em>N</em> is to write <em>N</em> as the sum of the <em>P</em>-th power of <em>K</em> positive integers. You are supposed to write a program to find the <em>K</em>−<em>P</em> factorization of <em>N</em> for any positive integers <em>N</em>, <em>K</em> and <em>P</em>.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which gives in a line the three positive integers <em>N</em> (≤400), <em>K</em> (≤<em>N</em>) and <em>P</em> (1&lt;<em>P</em>≤7). The numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, if the solution exists, output in the format:</p><pre><code class="hljs excel"><span class="hljs-built_in">N</span> = <span class="hljs-built_in">n</span>[<span class="hljs-number">1</span>]^P + ... <span class="hljs-built_in">n</span>[K]^P</code></pre><p>where <code>n[i]</code> (<code>i</code> &#x3D; 1, …, <code>K</code>) is the <code>i</code>-th factor. All the factors must be printed in non-increasing order.</p><p>Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 122+42+22+22+12, or 112+62+22+22+22, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen – sequence { <em>a</em>1,<em>a</em>2,⋯,<em>a**K</em> } is said to be <strong>larger</strong> than { <em>b</em>1,<em>b</em>2,⋯,<em>b**K</em> } if there exists 1≤<em>L</em>≤<em>K</em> such that <em>a**i</em>&#x3D;<em>b**i</em> for <em>i</em>&lt;*L* and *a<em><em>L</em>&gt;*b**L</em>.</p><p>If there is no solution, simple output <code>Impossible</code>.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><pre><code class="hljs in">169 5 2</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><pre><code class="hljs out">169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2</code></pre><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><pre><code class="hljs in">169 167 3</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><pre><code class="hljs out">Impossible</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用dfs 遍历所有可能性，并且选择合最大的一组组合</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;math.h&quot;</span>using namespace std;<span class="hljs-type">int</span> n,p,k;vector&lt;<span class="hljs-type">int</span>&gt; res,temp,fac;<span class="hljs-type">int</span> indexSum = <span class="hljs-number">-9999</span>;void dfs(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> nowK,<span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> facSum)&#123;    <span class="hljs-keyword">if</span>(nowK &gt; k || sum &gt;n) <span class="hljs-keyword">return</span> ;    <span class="hljs-keyword">if</span> (sum == n &amp;&amp; nowK == k)&#123;        <span class="hljs-keyword">if</span>(facSum &gt; indexSum )&#123;            indexSum = facSum;            res = temp;        &#125;        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">if</span> (index &gt;=<span class="hljs-number">1</span>)&#123;        temp.push_back(index);        dfs(index, nowK+<span class="hljs-number">1</span>, sum+fac[index], facSum+index);        temp.pop_back();        dfs(index<span class="hljs-number">-1</span>, nowK, sum , facSum );    &#125;&#125;<span class="hljs-type">int</span> main()&#123;    cin &gt;&gt; n&gt;&gt;k&gt;&gt;p;        <span class="hljs-type">int</span> tmp =<span class="hljs-number">0</span>;    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;    while(tmp &lt;= n)&#123;        fac.push_back(tmp);        tmp = <span class="hljs-type">int</span>(pow(j++,p));    &#125;    dfs(fac.size()<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.size(); i++)&#123;        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; n&lt;&lt;<span class="hljs-string">&quot; = &quot;</span>;            cout &lt;&lt; res[i] &lt;&lt;<span class="hljs-string">&quot;^&quot;</span>&lt;&lt;p;        &#125;<span class="hljs-keyword">else</span>            cout &lt;&lt;<span class="hljs-string">&quot; + &quot;</span> &lt;&lt; res[i] &lt;&lt;<span class="hljs-string">&quot;^&quot;</span>&lt;&lt;p;    &#125;    <span class="hljs-keyword">if</span>(indexSum == <span class="hljs-number">-9999</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Impossible&quot;</span>&lt;&lt;endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1107 Social Clusters (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1107%20Social%20Clusters%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1107%20Social%20Clusters%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Social-Clusters"><a href="#Social-Clusters" class="headerlink" title="Social Clusters"></a><font size=6px>Social Clusters</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A <strong>social cluster</strong> is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains a positive integer <em>N</em> (≤1000), the total number of people in a social network. Hence the people are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each gives the hobby list of a person in the format:</p><p><em>K**i</em>: <em>h**i</em>[1] <em>h**i</em>[2] … <em>h**i</em>[<em>K**i</em>]</p><p>where <em>K**i</em> (&gt;0) is the number of hobbies, and <em>h**i</em>[<em>j</em>] is the index of the <em>j</em>-th hobby, which is an integer in [1, 1000].</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">83: 2 7 101: 42: 5 31: 41: 31: 44: 6 8 1 51: 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">34 3 1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>纯纯的并查集题目</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;string.h&quot;</span>#include <span class="hljs-string">&quot;algorithm&quot;</span>using namespace std;<span class="hljs-type">int</span> father[<span class="hljs-number">1001</span>],hobby[<span class="hljs-number">1001</span>];<span class="hljs-type">int</span> num[<span class="hljs-number">1001</span>];<span class="hljs-type">int</span> find(<span class="hljs-type">int</span> a)&#123;    while(a != father[a])&#123;        a = father[a];    &#125;    <span class="hljs-keyword">return</span> a;&#125;void Union(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-type">int</span> fa = find(a);    <span class="hljs-type">int</span> fb = find(b);    <span class="hljs-keyword">if</span>(fa != fb)&#123;        father[fb] = fa;    &#125;&#125;<span class="hljs-type">bool</span> cmp(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-keyword">return</span> a&gt;b;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt;n;    memset(hobby, <span class="hljs-number">0</span> ,sizeof (hobby));    memset(num, <span class="hljs-number">0</span> ,sizeof (hobby));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n ;i++)&#123;        father[i] = i;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> num1;        scanf(<span class="hljs-string">&quot;%d: &quot;</span>,&amp;num1);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j &lt; num1; j++)&#123;            <span class="hljs-type">int</span> t ;            cin &gt;&gt;t;            <span class="hljs-keyword">if</span>( hobby[t] == <span class="hljs-number">0</span>)  hobby[t] = i;            <span class="hljs-keyword">else</span> &#123;               Union(hobby[t], i);           &#125;        &#125;    &#125;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;        <span class="hljs-type">int</span> temp = find(i);        <span class="hljs-keyword">if</span> (i == temp) sum++;        num[temp]++;    &#125;    sort(num,num+<span class="hljs-number">1000</span>,cmp);    cout &lt;&lt; sum&lt;&lt;endl;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sum;i++)&#123;        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;            cout&lt;&lt;num[i];        &#125;<span class="hljs-keyword">else</span>&#123;            cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;num[i];        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1111 Online Map (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1111%20Online%20Map%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1111%20Online%20Map%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Online-Map"><a href="#Online-Map" class="headerlink" title="Online Map "></a><font size=6px>Online Map </font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers <em>N</em> (2≤<em>N</em>≤500), and <em>M</em>, being the total number of streets intersections on a map, and the number of streets, respectively. Then <em>M</em> lines follow, each describes a street in the format:</p><pre><code class="hljs livecodeserver">V1 V2 <span class="hljs-literal">one</span>-way <span class="hljs-built_in">length</span> <span class="hljs-built_in">time</span></code></pre><p>where <code>V1</code> and <code>V2</code> are the indices (from 0 to <em>N</em>−1) of the two ends of the street; <code>one-way</code> is 1 if the street is one-way from <code>V1</code> to <code>V2</code>, or 0 if not; <code>length</code> is the length of the street; and <code>time</code> is the time taken to pass the street.</p><p>Finally a pair of source and destination is given.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, first print the shortest path from the source to the destination with distance <code>D</code> in the format:</p><pre><code class="hljs xl">D<span class="hljs-function"><span class="hljs-title">istance</span> = D: source -&gt;</span> <span class="hljs-function"><span class="hljs-title">v1</span> -&gt;</span> ... -&gt; destination</code></pre><p>Then in the next line print the fastest path with total time <code>T</code>:</p><pre><code class="hljs coq"><span class="hljs-keyword">Time</span> = T: source -&gt; w1 -&gt; ... -&gt; destination</code></pre><p>In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique.</p><p>In case the shortest and the fastest paths are identical, print them in one line in the format:</p><pre><code class="hljs coq">Distance = D; <span class="hljs-keyword">Time</span> = T: source -&gt; u1 -&gt; ... -&gt; destination</code></pre><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><pre><code class="hljs in">10 150 1 0 1 18 0 0 1 14 8 1 1 13 4 0 3 23 9 1 4 10 6 0 1 17 5 1 2 18 5 1 2 12 3 0 2 22 1 1 1 11 3 0 3 11 4 0 1 19 7 1 3 15 1 0 5 26 5 1 1 23 5</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><pre><code class="hljs out">Distance = 6: 3 -&gt; 4 -&gt; 8 -&gt; 5Time = 3: 3 -&gt; 1 -&gt; 5</code></pre><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><pre><code class="hljs in">7 90 4 1 1 11 6 1 1 32 6 1 1 12 5 1 2 23 0 0 1 13 1 1 1 33 2 1 1 24 5 0 2 26 5 1 1 23 5</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><pre><code class="hljs"></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>比普通dijstra多一个单路和双路，思路是两个dijstra算法和前缀算出最短路径的最短时间和最短时间路径最短。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">999999999</span>;<span class="hljs-type">int</span> dis[<span class="hljs-number">510</span>], Time[<span class="hljs-number">510</span>], e[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>], w[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>], dispre[<span class="hljs-number">510</span>],Timepre[<span class="hljs-number">510</span>], weight[<span class="hljs-number">510</span>],NodeNum[<span class="hljs-number">510</span>];<span class="hljs-type">bool</span> visit[<span class="hljs-number">510</span>];vector&lt;<span class="hljs-type">int</span>&gt; dispath, Timepath, temppath;<span class="hljs-type">int</span> st, fin, minnode = inf;void dfsdispath(<span class="hljs-type">int</span> v) &#123;    dispath.push_back(v);    <span class="hljs-keyword">if</span>(v == st) <span class="hljs-keyword">return</span> ;    dfsdispath(dispre[v]);&#125;void dfsTimepath(<span class="hljs-type">int</span> v) &#123;    Timepath.push_back(v);    <span class="hljs-keyword">if</span>(v == st) <span class="hljs-keyword">return</span> ;    dfsTimepath(Timepre[v]);&#125;<span class="hljs-type">int</span> main() &#123;    fill(dis, dis + <span class="hljs-number">510</span>, inf);    fill(Time, Time + <span class="hljs-number">510</span>, inf);    fill(weight, weight + <span class="hljs-number">510</span>, inf);    fill(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">0</span>] + <span class="hljs-number">510</span> * <span class="hljs-number">510</span>, inf);    fill(w[<span class="hljs-number">0</span>], w[<span class="hljs-number">0</span>] + <span class="hljs-number">510</span> * <span class="hljs-number">510</span>, inf);    <span class="hljs-type">int</span> n, m;    scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-type">int</span> a, b, flag, <span class="hljs-built_in">len</span>, t;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        scanf(<span class="hljs-string">&quot;%d %d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;flag, &amp;<span class="hljs-built_in">len</span>, &amp;t);        e[a][b] = <span class="hljs-built_in">len</span>;        w[a][b] = t;        <span class="hljs-keyword">if</span>(flag != <span class="hljs-number">1</span>) &#123;            e[b][a] = <span class="hljs-built_in">len</span>;            w[b][a] = t;        &#125;    &#125;    scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;st, &amp;fin);    dis[st] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        dispre[i] = i;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>, minn = inf;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span>(visit[j] == <span class="hljs-literal">false</span> &amp;&amp; dis[j] &lt; minn) &#123;                u = j;                minn = dis[j];            &#125;        &#125;        <span class="hljs-keyword">if</span>(u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;        visit[u] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;            <span class="hljs-keyword">if</span>(visit[v] == <span class="hljs-literal">false</span> &amp;&amp; e[u][v] != inf) &#123;                <span class="hljs-keyword">if</span>(e[u][v] + dis[u] &lt; dis[v]) &#123;                    dis[v] = e[u][v] + dis[u];                    dispre[v] = u;                    weight[v] = weight[u] + w[u][v];                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e[u][v] + dis[u] == dis[v] &amp;&amp; weight[v] &gt; weight[u] + w[u][v]) &#123;                    weight[v] = weight[u] + w[u][v];                    dispre[v] = u;                &#125;            &#125;        &#125;    &#125;    dfsdispath(fin);    Time[st] = <span class="hljs-number">0</span>;    fill(visit, visit + <span class="hljs-number">510</span>, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>, minn = inf;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span>(visit[j] == <span class="hljs-literal">false</span> &amp;&amp; minn &gt; Time[j]) &#123;                u = j;                minn = Time[j];            &#125;        &#125;        <span class="hljs-keyword">if</span>(u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;        visit[u] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;            <span class="hljs-keyword">if</span>(visit[v] == <span class="hljs-literal">false</span> &amp;&amp; w[u][v] != inf) &#123;                <span class="hljs-keyword">if</span>(w[u][v] + Time[u] &lt; Time[v]) &#123;                    Time[v] = w[u][v] + Time[u];                    Timepre[v]= u;                    NodeNum[v]=NodeNum[u]+<span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(w[u][v] + Time[u] == Time[v]&amp;&amp;NodeNum[u]+<span class="hljs-number">1</span>&lt;NodeNum[v]) &#123;                    Timepre[v]= u;                    NodeNum[v]=NodeNum[u]+<span class="hljs-number">1</span>;                &#125;            &#125;        &#125;    &#125;    dfsTimepath(fin);    printf(<span class="hljs-string">&quot;Distance = %d&quot;</span>, dis[fin]);    <span class="hljs-keyword">if</span>(dispath == Timepath) &#123;        printf(<span class="hljs-string">&quot;; Time = %d: &quot;</span>, Time[fin]);    &#125; <span class="hljs-keyword">else</span> &#123;        printf(<span class="hljs-string">&quot;: &quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = dispath.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            printf(<span class="hljs-string">&quot;%d&quot;</span>, dispath[i]);            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) printf(<span class="hljs-string">&quot; -&gt; &quot;</span>);        &#125;        printf(<span class="hljs-string">&quot;\nTime = %d: &quot;</span>, Time[fin]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = Timepath.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        printf(<span class="hljs-string">&quot;%d&quot;</span>, Timepath[i]);        <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) printf(<span class="hljs-string">&quot; -&gt; &quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1115 Counting Nodes in a BST (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1115%20Counting%20Nodes%20in%20a%20BST%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1115%20Counting%20Nodes%20in%20a%20BST%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Counting-Nodes-in-a-BST"><a href="#Counting-Nodes-in-a-BST" class="headerlink" title="Counting Nodes in a BST"></a><font size=6px>Counting Nodes in a BST</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than or equal to the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>Insert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤1000) which is the size of the input sequence. Then given in the next line are the <em>N</em> integers in [−1000,1000] which are supposed to be inserted into an initially empty binary search tree.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format:</p><pre><code class="hljs gcode"><span class="hljs-symbol">n1</span> + <span class="hljs-symbol">n2</span> = <span class="hljs-symbol">n</span></code></pre><p>where <code>n1</code> is the number of nodes in the lowest level, <code>n2</code> is that of the level above, and <code>n</code> is the sum.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">925 30 42 16 20 20 35 -5 28</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">2 + 4 = 6</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>递归构建二叉树之后，层次遍历各个层的数量，最后输出最后两层。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;queue&quot;</span>using namespace std;<span class="hljs-keyword">struct</span> Node &#123;    Node * left,*right;    <span class="hljs-type">int</span> num;&#125;;Node *buildNode(<span class="hljs-type">int</span> a)&#123;    Node* node = (Node *)malloc(sizeof(Node));    node-&gt;num = a;    node-&gt;right = nullptr;    node-&gt;left = nullptr;    <span class="hljs-keyword">return</span> node;&#125;;Node *build(Node * root, <span class="hljs-type">int</span> a)&#123;    <span class="hljs-keyword">if</span>(root == nullptr)&#123;        <span class="hljs-keyword">return</span> buildNode(a);    &#125;    <span class="hljs-keyword">if</span>(a &gt; root-&gt;num) root-&gt;right = build(root-&gt;right, a);    <span class="hljs-keyword">else</span>  root-&gt;left = build(root-&gt;left, a);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;    cin &gt;&gt; n ;    Node * root = nullptr;    while(n--)&#123;        <span class="hljs-type">int</span> a;        cin &gt;&gt;a;        root = build(root, a);    &#125;    vector&lt;<span class="hljs-type">int</span>&gt; level;    queue&lt;Node *&gt; que1,que2;    que1.push(root);    while(!que1.empty()  )&#123;        <span class="hljs-type">int</span> levels = <span class="hljs-number">0</span>;        while(!que1.empty())&#123;            Node* node = que1.front();            levels++;            que1.pop();            <span class="hljs-keyword">if</span>(node-&gt;left != nullptr)&#123;                que2.push(node-&gt;left);            &#125;            <span class="hljs-keyword">if</span>(node-&gt;right != nullptr)&#123;                que2.push(node-&gt;right);            &#125;        &#125;        level.push_back(levels);        que1 = que2;        while(!que2.empty()) que2.pop();    &#125;    cout&lt;&lt; level[level.size()<span class="hljs-number">-1</span>]&lt;&lt;<span class="hljs-string">&quot; + &quot;</span>&lt;&lt;level[level.size()<span class="hljs-number">-2</span>]&lt;&lt;<span class="hljs-string">&quot; = &quot;</span>&lt;&lt;level[level.size()<span class="hljs-number">-1</span>]+level[level.size()<span class="hljs-number">-2</span>]&lt;&lt;endl;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1123 Is It a Complete AVL Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1123%20Is%20It%20a%20Complete%20AVL%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1123%20Is%20It%20a%20Complete%20AVL%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Is-It-a-Complete-AVL-Tre"><a href="#Is-It-a-Complete-AVL-Tre" class="headerlink" title="Is It a Complete AVL Tre"></a><font size=6px>Is It a Complete AVL Tre</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p><table><thead><tr><th><img src="https://images.ptausercontent.com/fb337acb-93b0-4af2-9838-deff5ce98058.jpg" alt="F1.jpg"></th><th><img src="https://images.ptausercontent.com/d1635de7-3e3f-4aaa-889b-ba29f35890db.jpg" alt="F2.jpg"></th></tr></thead><tbody><tr><td><img src="https://images.ptausercontent.com/e868e4b9-9fea-4f70-b7a7-1f5d8a3be4ef.jpg" alt="F3.jpg"></td><td><img src="https://images.ptausercontent.com/98aa1782-cea5-4792-8736-999436cf43a9.jpg" alt="F4.jpg"></td></tr></tbody></table><p>Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print <code>YES</code> if the tree is complete, or <code>NO</code> if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><pre><code class="hljs in">588 70 61 63 65</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><pre><code class="hljs out">70 63 88 61 65YES</code></pre><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><pre><code class="hljs in">888 70 61 96 120 90 65 68</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><pre><code class="hljs out">88 65 96 61 70 90 120 68NO</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>构建avl树，测试点2，3是来判断是否是完全二叉树的情况的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;queue&quot;</span>using namespace std;<span class="hljs-type">int</span> n;<span class="hljs-keyword">struct</span> Node &#123;    Node *left, *right;    <span class="hljs-type">int</span> num;&#125;;<span class="hljs-type">int</span> getHeight(Node *tree) &#123;    <span class="hljs-keyword">if</span> (tree == nullptr) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> l = getHeight(tree-&gt;left);    <span class="hljs-type">int</span> r = getHeight(tree-&gt;right);    <span class="hljs-keyword">return</span> max(l, r) + <span class="hljs-number">1</span>;&#125;<span class="hljs-type">bool</span> isBalanced(Node *left, Node *right) &#123;    <span class="hljs-keyword">return</span> abs(getHeight(left) - getHeight(right)) &lt; <span class="hljs-number">2</span>;&#125;Node * LeftLeft(Node* t)&#123;    Node * x = t-&gt;right;    Node * y = x-&gt;left;    x-&gt;left = t;    t-&gt;right = y;    <span class="hljs-keyword">return</span> x;&#125;Node * RightRight(Node* t)&#123;    Node * x = t-&gt;left;    Node * y = x-&gt;right;    x-&gt;right = t;    t-&gt;left = y;    <span class="hljs-keyword">return</span> x;&#125;Node * LeftRight(Node *t)&#123;    t-&gt;left = LeftLeft(t-&gt;left);    <span class="hljs-keyword">return</span> RightRight(t);&#125;Node * RightLeft(Node *t)&#123;    t-&gt;right = RightRight(t-&gt;right);    <span class="hljs-keyword">return</span> LeftLeft(t);&#125;Node *buildNode(<span class="hljs-type">int</span> num) &#123;    Node *node = (Node *) malloc(sizeof(Node));    node-&gt;left = node-&gt;right = nullptr;    node-&gt;num = num;    <span class="hljs-keyword">return</span> node;&#125;Node *buildAvl(Node *root, <span class="hljs-type">int</span> num) &#123;    <span class="hljs-keyword">if</span> (root == nullptr) &#123;        <span class="hljs-keyword">return</span> buildNode(num);    &#125;    <span class="hljs-keyword">if</span> (num &gt; root-&gt;num) &#123;        root-&gt;right = buildAvl(root-&gt;right, num);        <span class="hljs-keyword">if</span>(!isBalanced(root-&gt;left, root-&gt;right))&#123;            <span class="hljs-keyword">if</span>(num &gt; root-&gt;right-&gt;num)&#123;                root = LeftLeft(root);            &#125;<span class="hljs-keyword">else</span>&#123;                root = RightLeft(root);            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        root-&gt;left = buildAvl(root-&gt;left, num);        <span class="hljs-keyword">if</span>(!isBalanced(root-&gt;left, root-&gt;right))&#123;            <span class="hljs-keyword">if</span> (num &lt; root-&gt;left-&gt;num)&#123;                root = RightRight(root);            &#125;<span class="hljs-keyword">else</span>&#123;                root = LeftRight(root);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main() &#123;    cin &gt;&gt; n;    Node *root = nullptr;    while (n--) &#123;        <span class="hljs-type">int</span> a;        cin &gt;&gt; a;        root = buildAvl(root, a);    &#125;    queue&lt;Node *&gt; queue;    queue.push(root);    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> treeComplete = <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> after = <span class="hljs-number">0</span>;    while(!queue.empty())&#123;        Node * node = queue.front();        queue.pop();        <span class="hljs-keyword">if</span>(!flag)&#123;            cout &lt;&lt; node-&gt;num;            flag = <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span>&#123;            cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; node-&gt;num;        &#125;        <span class="hljs-comment">//if((node-&gt;right != nullptr &amp;&amp; node-&gt;left == nullptr) || (node-&gt;right == nullptr &amp;&amp; node-&gt;left != nullptr)) treeComplete = 0;</span>        <span class="hljs-keyword">if</span>(node-&gt;left != nullptr)&#123;            queue.push(node-&gt;left);            <span class="hljs-keyword">if</span>(after) treeComplete = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            after = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(node-&gt;right != nullptr)&#123;            queue.push(node-&gt;right);            <span class="hljs-keyword">if</span>(after) treeComplete = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            after = <span class="hljs-number">1</span>;        &#125;    &#125;    cout &lt;&lt;endl;    <span class="hljs-keyword">if</span>(treeComplete) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;    <span class="hljs-keyword">else</span> cout &lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1135 Is It A Red-Black Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1135%20Is%20It%20A%20Red-Black%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1135%20Is%20It%20A%20Red-Black%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Is-It-A-Red-Black-Tree"><a href="#Is-It-A-Red-Black-Tree" class="headerlink" title="Is It A Red-Black Tree"></a><font size=6px>Is It A Red-Black Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>There is a kind of balanced binary search tree named <strong>red-black tree</strong> in the data structure. It has the following 5 properties:</p><ul><li>(1) Every node is either red or black.</li><li>(2) The root is black.</li><li>(3) Every leaf (NULL) is black.</li><li>(4) If a node is red, then both its children are black.</li><li>(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</li></ul><p>For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not.</p><table><thead><tr><th><img src="https://images.ptausercontent.com/eff80bd4-c833-4818-9786-81680d1b304a.jpg" alt="rbf1.jpg"></th><th><img src="https://images.ptausercontent.com/b11184df-eaab-451c-b7d4-7fc1dc82b028.jpg" alt="rbf2.jpg"></th><th><img src="https://images.ptausercontent.com/625c532b-22fc-47b9-80ea-0537cf00d922.jpg" alt="rbf3.jpg"></th></tr></thead><tbody><tr><td>Figure 1</td><td>Figure 2</td><td>Figure 3</td></tr></tbody></table><p>For each given binary search tree, you are supposed to tell if it is a legal red-black tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains several test cases. The first line gives a positive integer K (≤30) which is the total number of cases. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if the given tree is a red-black tree, or “No” if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">397 -2 1 5 -4 -11 8 14 -15911 -2 1 -7 5 -4 8 14 -15810 -7 5 -6 8 15 -11 17</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">YesNoNo</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>只有三种情况不符合，根结点是负值，连续两个红色，每条path的黑色节点数量不同，其他都是yes</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>using namespace std;<span class="hljs-type">int</span> m;<span class="hljs-type">int</span> num[<span class="hljs-number">31</span>];<span class="hljs-type">bool</span> is_valid;<span class="hljs-keyword">struct</span> Node &#123;    Node *left, *right;    <span class="hljs-type">int</span> num;    <span class="hljs-type">bool</span> isRed;&#125;;Node *buildNode(<span class="hljs-type">int</span> a, <span class="hljs-type">bool</span> is_red) &#123;    Node *node = (Node *) malloc(sizeof(Node));    node-&gt;num = a;    node-&gt;isRed = is_red;    node-&gt;right = nullptr;    node-&gt;left = nullptr;    <span class="hljs-keyword">return</span> node;&#125;;Node *build(Node *root, <span class="hljs-type">int</span> a, <span class="hljs-type">bool</span> is_red) &#123;    <span class="hljs-keyword">if</span> (root == nullptr) &#123;        <span class="hljs-keyword">return</span> buildNode(a, is_red);    &#125;    <span class="hljs-keyword">if</span> (a &gt; root-&gt;num) root-&gt;right = build(root-&gt;right, a, is_red);    <span class="hljs-keyword">else</span> root-&gt;left = build(root-&gt;left, a, is_red);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> blackNodeNums = <span class="hljs-number">0</span>;void dfs(Node *root, <span class="hljs-type">int</span> blackNodeNum) &#123;    <span class="hljs-comment">//如果知道错的就直接return</span>    <span class="hljs-keyword">if</span> (is_valid) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (root == nullptr) &#123;        <span class="hljs-keyword">if</span> (blackNodeNums == <span class="hljs-number">0</span>) blackNodeNums = blackNodeNum;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (blackNodeNums != blackNodeNum) is_valid = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (!root-&gt;isRed) &#123;        dfs(root-&gt;left, blackNodeNum + <span class="hljs-number">1</span>);        dfs(root-&gt;right, blackNodeNum + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        dfs(root-&gt;left, blackNodeNum);        dfs(root-&gt;right, blackNodeNum);    &#125;&#125;void dfsRed(Node *root) &#123;    <span class="hljs-keyword">if</span> (root-&gt;left != nullptr) &#123;        <span class="hljs-keyword">if</span> (root-&gt;isRed &amp;&amp; root-&gt;left-&gt;isRed) is_valid = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">else</span> dfsRed(root-&gt;left);    &#125;    <span class="hljs-keyword">if</span> (root-&gt;right != nullptr) &#123;        <span class="hljs-keyword">if</span> (root-&gt;isRed &amp;&amp; root-&gt;right-&gt;isRed) is_valid = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">else</span> dfsRed(root-&gt;left);    &#125;&#125;<span class="hljs-type">int</span> main() &#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    while (n--) &#123;        cin &gt;&gt; m;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            cin &gt;&gt; num[i];        &#125;        is_valid = <span class="hljs-literal">false</span>;        blackNodeNums = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span>) &#123;            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">continue</span>;        &#125;        Node *root = nullptr;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">if</span> (num[i] &lt; <span class="hljs-number">0</span>) root = build(root, -num[i], <span class="hljs-literal">true</span>);            <span class="hljs-keyword">else</span> root = build(root, num[i], <span class="hljs-literal">false</span>);        &#125;        dfs(root, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (is_valid) &#123;            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">continue</span>;        &#125;        dfsRed(root);        <span class="hljs-keyword">if</span> (is_valid) &#123;            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">continue</span>;        &#125;        cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1127 ZigZagging on a Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1127%20ZigZagging%20on%20a%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1127%20ZigZagging%20on%20a%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="ZigZagging-on-a-Tree"><a href="#ZigZagging-on-a-Tree" class="headerlink" title="ZigZagging on a Tree"></a><font size=6px>ZigZagging on a Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in “zigzagging order” – that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.</p><p><img src="https://images.ptausercontent.com/337cbfb0-a7b2-4500-9664-318e9ffc870e.jpg" alt="zigzag.jpg"></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">812 11 20 17 1 15 8 512 20 17 11 15 8 5 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">1 11 5 8 17 12 20 15</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先根据后序和中序构建二叉树，再层次遍历。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;using namespace std;<span class="hljs-type">int</span> inorder[<span class="hljs-number">31</span>], postorder[<span class="hljs-number">31</span>];<span class="hljs-type">int</span> n ;<span class="hljs-keyword">struct</span> Node&#123;    <span class="hljs-type">int</span> num;    <span class="hljs-keyword">struct</span> Node *left,*right;&#125;;<span class="hljs-type">int</span> find(<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> val)&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size; i++)&#123;        <span class="hljs-keyword">if</span> (val == nums[i])&#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;&#125;Node * buildTree(<span class="hljs-type">int</span> afterOrder[],<span class="hljs-type">int</span> inOrder[], <span class="hljs-type">int</span> size)&#123;    <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> nullptr;    &#125;    Node *root = (Node *)malloc(sizeof(Node));    <span class="hljs-type">int</span> postIndex = find(inOrder,size,afterOrder[size<span class="hljs-number">-1</span>]);    root-&gt;num = afterOrder[size<span class="hljs-number">-1</span>];    root-&gt;left = buildTree(afterOrder,inOrder, postIndex);    root-&gt;right = buildTree(afterOrder+postIndex,inOrder+ postIndex + <span class="hljs-number">1</span>, size - postIndex - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main()&#123;    cin &gt;&gt;n;    vector&lt;Node *&gt; vec1,vec2;    vector&lt;<span class="hljs-type">int</span>&gt; temp;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        cin &gt;&gt; inorder[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        cin &gt;&gt; postorder[i];    &#125;    Node* root  = buildTree(postorder,inorder,n);    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;    <span class="hljs-type">bool</span> first = <span class="hljs-literal">true</span>;    vec1.insert(vec1.begin(),root);    while(!vec1.empty()  || !vec2.empty())&#123;        temp.clear();        while(!vec1.empty())&#123;            Node * node = vec1[vec1.size()<span class="hljs-number">-1</span>];            temp.push_back(node-&gt;num);            vec1.pop_back();            <span class="hljs-keyword">if</span>(node-&gt;left != nullptr)&#123;                vec2.insert(vec2.begin(), node-&gt;left);            &#125;            <span class="hljs-keyword">if</span>(node-&gt;right != nullptr)&#123;                vec2.insert(vec2.begin(), node-&gt;right);            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag)&#123;            std::reverse(temp.begin(), temp.end());        &#125;        flag = !flag;        vec1 = vec2;        vec2.clear();        <span class="hljs-keyword">if</span>(first)&#123;            cout &lt;&lt; temp[<span class="hljs-number">0</span>];            first = <span class="hljs-literal">false</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt; temp.size(); j++)&#123;                cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;temp[j];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1155 Heap Paths (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1155%20Heap%20Paths%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1155%20Heap%20Paths%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Heap-Paths"><a href="#Heap-Paths" class="headerlink" title="Heap Paths"></a><font size=6px>Heap Paths</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>In computer science, a <strong>heap</strong> is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">https://en.wikipedia.org/wiki/Heap_(data_structure)</a>)</p><p>One thing for sure is that all the keys along any path from the root to a leaf in a max&#x2F;min heap must be in non-increasing&#x2F;non-decreasing order.</p><p>Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (1&lt;<em>N</em>≤1,000), the number of keys in the tree. Then the next line contains <em>N</em> distinct integer keys (all in the range of <strong>int</strong>), which gives the level order traversal sequence of a complete binary tree.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.</p><p>Finally print in a line <code>Max Heap</code> if it is a max heap, or <code>Min Heap</code> for a min heap, or <code>Not Heap</code> if it is not a heap at all.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><pre><code class="hljs in">898 72 86 60 65 12 23 50</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><pre><code class="hljs out">98 86 2398 86 1298 72 6598 72 60 50Max Heap</code></pre><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><pre><code class="hljs in">88 38 25 58 52 82 70 60</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><pre><code class="hljs out">8 25 708 25 828 38 528 38 58 60Min Heap</code></pre><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3:"></a>Sample Input 3:</h3><pre><code class="hljs in">810 28 15 12 34 9 8 56</code></pre><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3:"></a>Sample Output 3:</h3><pre><code class="hljs out">10 15 810 15 910 28 3410 28 12 56Not Heap</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先构建堆，再用dfs右边优先遍历，到子节点就输出，并且判断是升序还是降序还是错误序列。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>#include <span class="hljs-string">&quot;algorithm&quot;</span>using namespace std;<span class="hljs-keyword">struct</span> Node &#123;    <span class="hljs-type">int</span> num;    <span class="hljs-keyword">struct</span> Node *left;    <span class="hljs-keyword">struct</span> Node *right;&#125;;<span class="hljs-type">int</span> num[<span class="hljs-number">1002</span>];<span class="hljs-type">int</span> n;<span class="hljs-type">bool</span> maxFlag = <span class="hljs-literal">false</span>, minFlag = <span class="hljs-literal">false</span>,validFlag= <span class="hljs-literal">false</span>;Node *NewNode(<span class="hljs-type">int</span> idx) &#123;    Node *node = (Node *) malloc(sizeof(Node));    node-&gt;num = num[idx];    node-&gt;left = nullptr;    node-&gt;right = nullptr;    <span class="hljs-keyword">return</span> node;&#125;<span class="hljs-type">bool</span> check(vector&lt;<span class="hljs-keyword">struct</span> Node&gt; res)&#123;    <span class="hljs-keyword">if</span>(minFlag)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;res.size();i++)&#123;            <span class="hljs-keyword">if</span>(res[i].num &lt; res[i<span class="hljs-number">-1</span>].num)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxFlag)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;res.size();i++)&#123;            <span class="hljs-keyword">if</span>(res[i].num &gt; res[i<span class="hljs-number">-1</span>].num)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;Node *build(<span class="hljs-type">int</span> idx) &#123;    <span class="hljs-keyword">if</span> (idx &gt;= n) &#123;        <span class="hljs-keyword">return</span> nullptr;    &#125;    Node *root = NewNode(idx);    root-&gt;left = build(idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);    root-&gt;right = build((idx * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>));    <span class="hljs-keyword">return</span> root;&#125;void dfs(Node *root, vector&lt;<span class="hljs-keyword">struct</span> Node&gt; res) &#123;    <span class="hljs-keyword">if</span> (root == nullptr) &#123;        <span class="hljs-keyword">return</span>;    &#125;    res.push_back(*root);    dfs(root-&gt;right, res);    dfs(root-&gt;left, res);    <span class="hljs-keyword">if</span> (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size(); i++) &#123;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                cout &lt;&lt; res[i].num;            &#125; <span class="hljs-keyword">else</span> &#123;                cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; res[i].num;            &#125;        &#125;        cout &lt;&lt; endl;        <span class="hljs-keyword">if</span>(!check(res))&#123;            validFlag = <span class="hljs-literal">true</span>;        &#125;    &#125;&#125;<span class="hljs-type">int</span> main() &#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        cin &gt;&gt; num[i];    &#125;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;        cout &lt;&lt; num[<span class="hljs-number">0</span>] &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">&quot;Not Heap&quot;</span> &lt;&lt; endl;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    Node *root = build(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] &gt; num[<span class="hljs-number">1</span>]) &#123;        maxFlag = <span class="hljs-literal">true</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        minFlag = <span class="hljs-literal">true</span>;    &#125;    vector&lt;<span class="hljs-keyword">struct</span> Node&gt; res;    dfs(root, res);    <span class="hljs-keyword">if</span>(validFlag)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Not Heap&quot;</span> &lt;&lt; endl;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxFlag)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Max Heap&quot;</span> &lt;&lt;endl;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minFlag)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Min Heap&quot;</span> &lt;&lt;endl;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1159 Structure of a Binary Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1159%20Structure%20of%20a%20Binary%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1159%20Structure%20of%20a%20Binary%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Structure-of-a-Binary-Tree"><a href="#Structure-of-a-Binary-Tree" class="headerlink" title="Structure of a Binary Tree"></a><font size=6px>Structure of a Binary Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined.</p><p>Now given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following:</p><ul><li>A is the root</li><li>A and B are siblings</li><li>A is the parent of B</li><li>A is the left child of B</li><li>A is the right child of B</li><li>A and B are on the same level</li><li>It is a full tree</li></ul><p>Note:</p><ul><li>Two nodes are <strong>on the same level</strong>, means that they have the same depth.</li><li>A <strong>full binary tree</strong> is a tree in which every node other than the leaves has two children.</li></ul><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than 103 and are separated by a space.</p><p>Then another positive integer <em>M</em> (≤30) is given, followed by <em>M</em> lines of statements. It is guaranteed that both <code>A</code> and <code>B</code> in the statements are in the tree.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each statement, print in a line <code>Yes</code> if it is correct, or <code>No</code> if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">916 7 11 32 28 2 23 8 1516 23 7 32 11 2 28 15 8715 is the root8 and 2 are siblings32 is the parent of 1123 is the left child of 1628 is the right child of 27 and 11 are on the same levelIt is a full tree</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">YesNoYesNoYesYesYes</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先按照后序和中序遍历构造出二叉树，二叉树是特殊的，里面有指向父节点的和深度数据，string字符串中得出数字也有很巧妙的方式，看代码</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;map&quot;</span>using namespace  std;typedef <span class="hljs-keyword">struct</span> Node&#123;    <span class="hljs-type">int</span> value;    <span class="hljs-keyword">struct</span> Node *left;    <span class="hljs-keyword">struct</span> Node *right;    <span class="hljs-keyword">struct</span> Node *father;    <span class="hljs-type">int</span> depth;&#125;Node;<span class="hljs-keyword">map</span>&lt;<span class="hljs-type">int</span> ,  Node *&gt; mp ;<span class="hljs-type">bool</span> full = <span class="hljs-literal">true</span>;<span class="hljs-type">int</span>  Find(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> v)&#123;<span class="hljs-comment">//找的始终是中序</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;        <span class="hljs-keyword">if</span> (array[i] == v)&#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;Node * BuildTree(<span class="hljs-type">int</span> afterorder[], <span class="hljs-type">int</span> inorder[], <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> depth)&#123;    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span>  nullptr;    &#125;    <span class="hljs-type">int</span> rootValue = afterorder[size<span class="hljs-number">-1</span>];    <span class="hljs-type">int</span> leftSize = Find(inorder, size, rootValue);<span class="hljs-comment">//i的返回值就是左子树的个数</span>    <span class="hljs-comment">//根</span>    Node *root = (Node *)malloc(sizeof(Node));    root-&gt;value = rootValue;    <span class="hljs-comment">//左子树</span>    root-&gt;left = BuildTree(afterorder , inorder, leftSize, depth+<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(root-&gt;left != nullptr)&#123;        root-&gt;left-&gt;father = root;    &#125;    <span class="hljs-comment">//右子树</span>    root-&gt;right = BuildTree(afterorder + leftSize, inorder + leftSize + <span class="hljs-number">1</span>, size - <span class="hljs-number">1</span> - leftSize, depth+<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (root-&gt;right != nullptr)&#123;        root-&gt;right -&gt;father = root;    &#125;    mp[rootValue] = root;    <span class="hljs-keyword">if</span> ((root-&gt;left &amp;&amp; !root-&gt;right) || !root-&gt;left &amp;&amp; root-&gt;right) full = <span class="hljs-literal">false</span>;    root-&gt;depth = depth;    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt;n;    <span class="hljs-type">int</span> postorder[n],inorder[n];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        cin &gt;&gt;postorder[i];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        cin &gt;&gt;inorder[i];    &#125;    Node * root = BuildTree(postorder,inorder, n, <span class="hljs-number">0</span>);    <span class="hljs-type">int</span> n2;    cin &gt;&gt; n2;    getchar();    while (n2--)&#123;        <span class="hljs-type">string</span> s;        <span class="hljs-type">int</span> a,b ;        getline(cin, s);        <span class="hljs-keyword">if</span> (s.find(<span class="hljs-string">&quot;root&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d is the root&quot;</span>, &amp;a);            <span class="hljs-keyword">if</span> (root-&gt;value == a)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            &#125;<span class="hljs-keyword">else</span>&#123;                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;siblings&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d and %d are siblings&quot;</span>, &amp;a, &amp;b);            <span class="hljs-keyword">if</span> (mp[a]-&gt;father == mp[b]-&gt;father)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            &#125;<span class="hljs-keyword">else</span>&#123;                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;parent&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d is the parent of %d&quot;</span>, &amp;a, &amp;b);            <span class="hljs-keyword">if</span>(mp[b]-&gt;father == mp[a])&#123;                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            &#125;<span class="hljs-keyword">else</span>&#123;                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;left&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d is the left child of %d&quot;</span>, &amp;a, &amp;b);            <span class="hljs-keyword">if</span> (mp[b]-&gt;left == mp[a]) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;right&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d is the right child of %d&quot;</span>, &amp;a, &amp;b);            <span class="hljs-keyword">if</span> (mp[b]-&gt;right == mp[a]) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;level&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            sscanf(s.c_str(), <span class="hljs-string">&quot;%d and %d are on the same level&quot;</span>, &amp;a, &amp;b);            <span class="hljs-keyword">if</span> (mp[b]-&gt;depth == mp[a]-&gt;depth) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.find(<span class="hljs-string">&quot;full&quot;</span>) != <span class="hljs-type">string</span>::npos)&#123;            <span class="hljs-keyword">if</span> (full) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1165 Block Reversing (25 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1165%20Block%20Reversing%20(25%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1165%20Block%20Reversing%20(25%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Block-Reversing"><a href="#Block-Reversing" class="headerlink" title="Block Reversing"></a><font size=6px>Block Reversing</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given a singly linked list <em>L</em>. Let us consider every <em>K</em> nodes as a <strong>block</strong> (if there are less than <em>K</em> nodes at the end of the list, the rest of the nodes are still considered as a block). Your job is to reverse all the blocks in <em>L</em>. For example, given <em>L</em> as 1→2→3→4→5→6→7→8 and <em>K</em> as 3, your output must be 7→8→4→5→6→1→2→3.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the size of a block. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.</p><p>Then <em>N</em> lines follow, each describes a node in the format:</p><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span></code></pre><p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">00100 8 371120 7 8866600000 4 9999900100 1 1230968237 6 7112033218 3 0000099999 5 6823788666 8 -112309 2 33218</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">71120 7 8866688666 8 0000000000 4 9999999999 5 6823768237 6 0010000100 1 1230912309 2 3321833218 3 -1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>有两种思路做，一种是链表反转，一种是模拟成结果想要的状态，我是第二种</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;<span class="hljs-keyword">struct</span> node&#123;    <span class="hljs-type">int</span> id,dat,next;&#125;;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> begin, n, k;    scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;begin,&amp;n,&amp;k);    node a[<span class="hljs-number">100010</span>];     <span class="hljs-comment">//特别注意数组大小</span>    vector&lt;node&gt; v, ans;    <span class="hljs-type">int</span> s,d,e;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;        scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;s,&amp;d,&amp;e);        a[s]=&#123;s,d,e&#125;;    &#125;    <span class="hljs-keyword">for</span>(; begin!=<span class="hljs-number">-1</span>; begin=a[begin].next)&#123;        v.push_back(a[begin]);    &#125;    <span class="hljs-type">int</span> num=n/k;    <span class="hljs-keyword">if</span>(n%k) num++;    <span class="hljs-type">int</span> <span class="hljs-built_in">len</span>=v.size();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=num<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;k; j++)&#123;            <span class="hljs-type">int</span> t=i*k+j;            <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-built_in">len</span>) ans.push_back(v[t]);<span class="hljs-comment">//注意插入的写法</span>        &#125;    &#125;    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ans.size()<span class="hljs-number">-1</span>; i++)&#123;        printf(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, ans[i].id, ans[i].dat, ans[i+<span class="hljs-number">1</span>].id);    &#125;    printf(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>, ans[i].id, ans[i].dat);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1167 Cartesian Tree (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1167%20Cartesian%20Tree%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1167%20Cartesian%20Tree%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Cartesian-Tree"><a href="#Cartesian-Tree" class="headerlink" title="Cartesian Tree"></a><font size=6px>Cartesian Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A <strong>Cartesian tree</strong> is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal returns the original sequence. For example, given the sequence { 8, 15, 3, 4, 1, 5, 12, 10, 18, 6 }, the min-heap Cartesian tree is shown by the figure.</p><p><img src="https://images.ptausercontent.com/6a99f68a-6578-46e0-9232-fbf0adf3691f.jpg" alt="CTree.jpg"></p><p>Your job is to output the level-order traversal sequence of the min-heap Cartesian tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts from giving a positive integer <em>N</em> (≤30), and then <em>N</em> distinct numbers in the next line, separated by a space. All the numbers are in the range of <strong>int</strong>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line the level-order traversal sequence of the min-heap Cartesian tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">108 15 3 4 1 5 12 10 18 6</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">1 3 5 8 4 6 15 10 12 18</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>别管他什么inorder，先找到序列的最小值，左边是它的左子树，右边是它的右子树，然后构造好树然后层次遍历。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;math.h&quot;</span>#include <span class="hljs-string">&quot;vector&quot;</span>using namespace  std;<span class="hljs-keyword">struct</span> Node&#123;    <span class="hljs-type">int</span> val;    <span class="hljs-keyword">struct</span> Node * left;    <span class="hljs-keyword">struct</span> Node * right;&#125;;<span class="hljs-type">int</span> findMin(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> size)&#123;    <span class="hljs-type">int</span> mini = <span class="hljs-number">0</span> ;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;size; i++)&#123;        <span class="hljs-keyword">if</span> (nums[mini] &gt; nums[i])&#123;            mini = i;        &#125;    &#125;    <span class="hljs-keyword">return</span> mini;&#125;Node * build(<span class="hljs-type">int</span> nums [],<span class="hljs-type">int</span> size)&#123;    <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> nullptr;    &#125;    <span class="hljs-type">int</span> mini = findMin(nums, size);    Node *root = (Node *)malloc(sizeof(Node));    root-&gt;val = nums[mini];    root-&gt;left = build(nums, mini);    root-&gt;right = build(nums+mini+<span class="hljs-number">1</span>, size-mini<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-type">int</span> inorder[n];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;        cin &gt;&gt; inorder[i];    &#125;    Node * root = build(inorder, n);    vector&lt;Node *&gt; vec;    vec.push_back(root);    cout &lt;&lt; root-&gt;val;    while (!vec.empty())&#123;        Node * node = vec.back();        vec.pop_back();        <span class="hljs-keyword">if</span>(node-&gt;left != nullptr)&#123;            vec.insert(vec.begin(),node-&gt;left );            cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;node-&gt;left-&gt;val;        &#125;        <span class="hljs-keyword">if</span>(node-&gt;right != nullptr)&#123;            vec.insert(vec.begin(),node-&gt;right );            cout &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;node-&gt;right-&gt;val;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1163 Dijkstra Sequence (30 分)</title>
    <link href="/2022/01/21/PAT%E7%94%B2/1163%20Dijkstra%20Sequence%20(30%20%E5%88%86)/"/>
    <url>/2022/01/21/PAT%E7%94%B2/1163%20Dijkstra%20Sequence%20(30%20%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h3 id="Dijkstra-Sequence"><a href="#Dijkstra-Sequence" class="headerlink" title="Dijkstra Sequence"></a><font size=6px>Dijkstra Sequence</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Dijkstra’s algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</p><p>In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let’s call it <strong>Dijkstra sequence</strong>, is generated by Dijkstra’s algorithm.</p><p>On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two positive integers <em>N**v</em> (≤103) and <em>N**e</em> (≤105), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to <em>N**v</em>.</p><p>Then <em>N**e</em> lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤100) of the edge. It is guaranteed that the given graph is connected.</p><p>Finally the number of queries, <em>K</em>, is given as a positive integer no larger than 100, followed by <em>K</em> lines of sequences, each contains a permutationof the <em>N**v</em> vertices. It is assumed that the first vertex is the source for each sequence.</p><p>All the inputs in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each of the <em>K</em> sequences, print in a line <code>Yes</code> if it is a Dijkstra sequence, or <code>No</code> if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="hljs in">5 71 2 21 5 12 3 12 4 12 5 23 5 13 4 145 1 3 4 25 3 1 2 42 3 4 5 13 2 1 5 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="hljs out">YesYesYesNo</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>题目大意是问下面给出的序列符不符合狄杰斯特拉序列，用狄杰斯特拉算法去做就行。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include <span class="hljs-string">&quot;iostream&quot;</span>#include <span class="hljs-string">&quot;string.h&quot;</span>using namespace std;#define Inf <span class="hljs-number">0x3f3f3f</span>#define size <span class="hljs-number">1002</span><span class="hljs-type">int</span> dis[size][size];<span class="hljs-type">int</span> ans[size];<span class="hljs-type">int</span> m,n,k;<span class="hljs-type">bool</span> check()&#123;    <span class="hljs-type">int</span> used[size] = &#123;<span class="hljs-number">0</span>&#125;,dist[size] = &#123;<span class="hljs-number">0</span>&#125;;    memset(dist,<span class="hljs-number">0x3f</span>,sizeof (dist));    dist[ans[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>;        <span class="hljs-comment">// 先找到最小值</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;= m;j++)&#123;            <span class="hljs-keyword">if</span>( !used[j] &amp;&amp; (u==<span class="hljs-number">-1</span> || dist[u] &gt; dist[j]) ) u = j;        &#125;        <span class="hljs-keyword">if</span> (dist[u] != dist[ans[i]])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++)&#123;            <span class="hljs-keyword">if</span> (j == u) <span class="hljs-keyword">continue</span>;            dist[j] = min(dist[j], dist[u] + dis[u][j]);        &#125;        used[u] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-type">int</span> main()&#123;    cin &gt;&gt;m&gt;&gt;n;    <span class="hljs-type">int</span> a,b,c;    memset(dis,Inf, sizeof(dis));    while(n--)&#123;        cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;        dis[a][b] = dis[b][a] = c;    &#125;    cin &gt;&gt;k;    while(k--)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;            cin &gt;&gt;ans[i];        &#125;        <span class="hljs-keyword">if</span> (check())&#123;            cout &lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;        &#125;<span class="hljs-keyword">else</span>&#123;            cout &lt;&lt;<span class="hljs-string">&quot;No&quot;</span> &lt;&lt;endl;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>去PAT考试需要记忆的东西</title>
    <link href="/2022/01/21/PAT%E4%B9%99/%E5%8E%BBPAT%E4%B9%99%E7%BA%A7%E8%80%83%E8%AF%95%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BF%86%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <url>/2022/01/21/PAT%E4%B9%99/%E5%8E%BBPAT%E4%B9%99%E7%BA%A7%E8%80%83%E8%AF%95%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BF%86%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
    
    <content type="html"><![CDATA[<h4 id="1、使用map"><a href="#1、使用map" class="headerlink" title="1、使用map"></a>1、使用map</h4><h5 id="需要引入头"><a href="#需要引入头" class="headerlink" title="需要引入头"></a>需要引入头</h5><p>using namespace std;</p><h5 id="使用时定义"><a href="#使用时定义" class="headerlink" title="使用时定义"></a>使用时定义</h5><p>map&lt;char[6],struct Output&gt; Map;</p><p>要使用string得导入开头 #include <iostream></p><h4 id="2、使用strupr（）来小写转大写，strlwr来大写转小写"><a href="#2、使用strupr（）来小写转大写，strlwr来大写转小写" class="headerlink" title="2、使用strupr（）来小写转大写，strlwr来大写转小写"></a>2、使用strupr（）来小写转大写，strlwr来大写转小写</h4><p>需要导入#include&lt;string.h&gt;</p><h4 id="3、使用sort函数"><a href="#3、使用sort函数" class="headerlink" title="3、使用sort函数"></a>3、使用sort函数</h4><p>需要头文件：using namespace std;   #include<algorithm></p><p>例子</p><pre><code class="hljs stata">struct Info&#123;int id;int <span class="hljs-keyword">de</span> ;int cai ;int <span class="hljs-keyword">total</span> ;&#125;;<span class="hljs-comment">//按total降序</span>bool cmp(Info a,Info b)&#123;<span class="hljs-keyword">if</span> (a.<span class="hljs-keyword">total</span>!=b.<span class="hljs-keyword">total</span>)&#123;<span class="hljs-keyword">return</span> a.<span class="hljs-keyword">total</span>&gt;b.<span class="hljs-keyword">total</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.<span class="hljs-keyword">de</span>!=b.<span class="hljs-keyword">de</span>)&#123;<span class="hljs-keyword">return</span> a.<span class="hljs-keyword">de</span>&gt;b.<span class="hljs-keyword">de</span>;&#125; <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> a.id&lt;b.id;&#125;&#125; <span class="hljs-keyword">sort</span>(first,first+a,cmp);</code></pre><h4 id="3、会用gcd和gcm，和swap"><a href="#3、会用gcd和gcm，和swap" class="headerlink" title="3、会用gcd和gcm，和swap"></a>3、会用gcd和gcm，和swap</h4><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:<span class="hljs-built_in">gcd</span>(b,a%b);&#125; <span class="hljs-comment">//最大公约数 </span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-built_in">gcd</span>(a,b);<span class="hljs-keyword">return</span> a*b/c; &#125;</code></pre><p>用swap要导入using namespace std； #include<iostream></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我为什么不用golang写PAT了</title>
    <link href="/2022/01/21/PAT%E4%B9%99/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8golang%E5%86%99PTA%E4%BA%86/"/>
    <url>/2022/01/21/PAT%E4%B9%99/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8golang%E5%86%99PTA%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h4 id="先说说我为什么要用golang写算法题"><a href="#先说说我为什么要用golang写算法题" class="headerlink" title="先说说我为什么要用golang写算法题"></a>先说说我为什么要用golang写算法题</h4><ul><li>第一是想让我熟练使用golang语言的各种库，熟悉基础语法，比如go没while循环。。。</li><li>第二是go语言的性能比较高效，最快能与c语言相同，并且与c语言比较，golang库完善编写比如排序只需要调用函数就行，比较简单，c语言就要用到c++的东西，挺麻烦的，还要手写cmp函数。</li></ul><h4 id="再说说为什么我不再用golang写PAT了"><a href="#再说说为什么我不再用golang写PAT了" class="headerlink" title="再说说为什么我不再用golang写PAT了"></a>再说说为什么我不再用golang写PAT了</h4><ul><li>第一是因为你网上找不到用golang写PAT的人（力扣倒是挺多的，而且力扣比较人性化，会把测试用例错误答案和正确答案给你列出来，而且有社区，但是PAT锻炼了你的独立思考能力，自己思考错哪边了），就算写错了自己找不出原因的时候也没地方借鉴，而且PAT在考试的时候<strong>只支持c&#x2F;c++调试环境</strong></li><li>第二因为golang他速度只是最快能到c，有些时候会不达到，然后PAT他的<strong>运行时间卡的比较紧</strong>，举例一道简单题PAT乙级 <a herf="sets/994805260223102976/problems/994805289432236032)"> 1032挖掘技术那家强 </a></li></ul><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,a,b,maxi <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> score [<span class="hljs-number">120000</span>]<span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)     <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scanf(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a,&amp;b)        score[a]+=b    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        <span class="hljs-keyword">if</span> score[maxi]&lt;score[i]&#123;            maxi = i        &#125;    &#125;    fmt.Println(maxi,score[maxi])&#125;</code></pre><p>这道题用golang写最后一个测试点会是运行超时，如果要做的话得考虑用并发实现了，这样做一道题太费时间了，考场里面用这种方法不太可行，也用golang写了30多道题目了，锻炼效果应该差不多，现在开始用c语言写题目温习一下c语言技巧和排序的使用，加油考试吧，虽然只是个对别人来说简简单单的乙级。</p>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>101. 对称二叉树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><font size=6px>对称二叉树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false</p><p>提示：</p><p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用两个指针，一个往左边，一个往右边，判断p和q相不相等</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> root== <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">var</span> p,q *TreeNode    p,q = root,root    <span class="hljs-keyword">if</span> root.Left==<span class="hljs-literal">nil</span> &amp;&amp; root.Right== <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span> is(p,q)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">is</span><span class="hljs-params">(p,q *TreeNode)</span></span> <span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &amp;&amp; q == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">if</span> p==<span class="hljs-literal">nil</span> || q == <span class="hljs-literal">nil</span>&#123;               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> p.Val != q.Val&#123;               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    flag := is(p.Left,q.Right)    flag2 :=is(p.Right,q.Left)    <span class="hljs-keyword">return</span> flag &amp;&amp; flag2    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.9 MB, 在所有 Go 提交中击败了69.43%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><font size=6px>102. 二叉树的层序遍历</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p><p>​    3<br>   &#x2F; <br>  9  20<br>​    &#x2F;  <br>   15   7<br>返回其层序遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>我用广度优先搜索来做，用队列的思想来做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> arr [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> arr    &#125;    qu:=[]*TreeNode&#123;root&#125;    <span class="hljs-keyword">for</span> level:=<span class="hljs-number">0</span>;<span class="hljs-built_in">len</span>(qu)&gt;<span class="hljs-number">0</span>;level++ &#123;        arr=<span class="hljs-built_in">append</span>(arr,[]<span class="hljs-type">int</span>&#123;&#125;)        p:=[]*TreeNode&#123;&#125;        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(qu); i++ &#123;            arr[level]=<span class="hljs-built_in">append</span>(arr[level],qu[i].Val)            <span class="hljs-keyword">if</span> qu[i].Left != <span class="hljs-literal">nil</span> &#123;                p = <span class="hljs-built_in">append</span>(p, qu[i].Left)            &#125;            <span class="hljs-keyword">if</span> qu[i].Right != <span class="hljs-literal">nil</span> &#123;                p = <span class="hljs-built_in">append</span>(p, qu[i].Right)            &#125;        &#125;        qu=p    &#125;    <span class="hljs-keyword">return</span>  arr&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了96.60%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>103. 二叉树的锯齿形层序遍历</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a><font size=6px>二叉树的锯齿形层序遍历</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>返回锯齿形层序遍历如下：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跟102很相似，用队列来做，就是输入到arr的时候输入次序</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> arr [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> arr    &#125;    qu:=[]*TreeNode&#123;root&#125;    <span class="hljs-keyword">for</span> level:=<span class="hljs-number">0</span>;<span class="hljs-built_in">len</span>(qu)&gt;<span class="hljs-number">0</span>;level++&#123;        arr=<span class="hljs-built_in">append</span>(arr,[]<span class="hljs-type">int</span>&#123;&#125;)        p:=[]*TreeNode&#123;&#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(qu);i++&#123;            <span class="hljs-keyword">if</span> qu[i].Left!=<span class="hljs-literal">nil</span>&#123;                p=<span class="hljs-built_in">append</span>(p,qu[i].Left)            &#125;            <span class="hljs-keyword">if</span> qu[i].Right !=<span class="hljs-literal">nil</span>&#123;                p=<span class="hljs-built_in">append</span>(p,qu[i].Right)            &#125;        &#125;        <span class="hljs-keyword">if</span> level%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>&#123;            <span class="hljs-keyword">for</span> j:=<span class="hljs-built_in">len</span>(qu)<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--&#123;                arr[level]=<span class="hljs-built_in">append</span>(arr[level],qu[j].Val)            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(qu);j++&#123;                arr[level]=<span class="hljs-built_in">append</span>(arr[level],qu[j].Val)            &#125;        &#125;        qu=p    &#125;    <span class="hljs-keyword">return</span> arr&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.5 MB, 在所有 Go 提交中击败了79.52%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1070 结绳</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1070%20%E7%BB%93%E7%BB%B3/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1070%20%E7%BB%93%E7%BB%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="结绳"><a href="#结绳" class="headerlink" title=" 结绳"></a><font size=6px> 结绳</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。</p><p><img src="https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg" alt="rope.jpg"></p><p>给定 <em>N</em> 段绳子的长度，你需要找出它们能串成的绳子的最大长度。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 <em>N</em> (2≤<em>N</em>≤104)；第 2 行给出 <em>N</em> 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过104。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">810 15 12 3 4 13 1 15</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">14</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>题目理解了代码很简单，先说思路，第二次折的时候会把第一次折的再折一次，所以要从最小的开始选，要小的多折几次，所以排序过后选最小的和第二小的开始折就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>   <span class="hljs-string">&quot;sort&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> a,result <span class="hljs-type">float64</span>    fmt.Scan(&amp;n)    num:= <span class="hljs-built_in">make</span>([]<span class="hljs-type">float64</span>,n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scanf(<span class="hljs-string">&quot;%f&quot;</span>,&amp;a)        num[i] = a    &#125;    sort.Float64s(num)    result =num[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        result = (result+num[i])/<span class="hljs-number">2</span>    &#125;    fmt.Println(<span class="hljs-type">int</span>(result))&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1072 开学寄语</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1072%20%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1072%20%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="开学寄语"><a href="#开学寄语" class="headerlink" title="开学寄语"></a><font size=6px>开学寄语</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p><p><img src="https://images.ptausercontent.com/3b1d9f4a-778b-4942-a9e2-836262f363aa.JPG" alt="jiyu.JPG"></p><p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）：</p><pre><code class="hljs makefile"><span class="hljs-section">姓名缩写: 物品编号1 物品编号2 ……</span></code></pre><p>最后一行输出存在问题的学生的总人数和被查缴物品的总数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">4 22333 6666CYLL 3 1234 2345 3456U 4 9966 6666 8888 6666GG 2 2333 7777JJ 3 0012 6666 2333</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">U: 6666 6666GG: 2333JJ: 6666 23333 5</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第一次提交被最后两个测试点卡住，仔细看了下题目这个数字前面是有0的，所以要用string去接受和输出，问题解决，用暴力解最容易，判断每一个学生的物品编号是不是违禁物品就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> c,stuNum,forbidNum,countStuNum,countTotalNum,flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> s,a,b <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> forbid []<span class="hljs-type">string</span>    fmt.Scan(&amp;stuNum,&amp;forbidNum)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;forbidNum;i++&#123;        fmt.Scan(&amp;a)        forbid =<span class="hljs-built_in">append</span>(forbid,a)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;stuNum;i++&#123;        fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s)        fmt.Scan(&amp;c)        <span class="hljs-comment">//检测学生的物品是否是违禁物品</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;c;j++&#123;            fmt.Scan(&amp;b)            <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> forbid&#123;                <span class="hljs-keyword">if</span> v==b&#123;                    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;                        flag=<span class="hljs-number">1</span>                        fmt.Printf(<span class="hljs-string">&quot;%s:&quot;</span>,s)                        countStuNum++                    &#125;                    fmt.Printf(<span class="hljs-string">&quot; %s&quot;</span>,b)                    countTotalNum++                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> flag==<span class="hljs-number">1</span>&#123;            flag=<span class="hljs-number">0</span>            fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)        &#125;    &#125;    fmt.Printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,countStuNum,countTotalNum)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1075 链表元素分类</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1075%20%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1075%20%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="链表元素分类"><a href="#链表元素分类" class="headerlink" title="链表元素分类"></a><font size=6px>链表元素分类</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤105)；以及正整数K (≤103)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 N 行，每行格式为：</p><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span></code></pre><p>其中 <code>Address</code> 是结点地址；<code>Data</code> 是该结点保存的数据，为 [−105,105] 区间内的整数；<code>Next</code> 是下一结点的地址。题目保证给出的链表不为空。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">00100 9 1023333 10 2777700000 0 9999900100 18 1230968237 -6 2333333218 -4 0000048652 -2 -199999 5 6823727777 11 4865212309 7 33218</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">33218 -4 6823768237 -6 4865248652 -2 1230912309 7 0000000000 0 9999999999 5 2333323333 10 0010000100 18 2777727777 11 -1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>代码参考网上，写的很巧妙，用了vector包，分三个部分，小于0，小于k，和大于k的，然后保存他们的地址，最后在输出的时候也巧妙，先输出现在的地址和数据，下一个地址和数据在下一次输出。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;using namespace std;<span class="hljs-keyword">struct</span> list&#123;<span class="hljs-type">int</span> data;<span class="hljs-type">int</span> next;&#125;l[<span class="hljs-number">100002</span>];vector&lt;<span class="hljs-type">int</span>&gt; v[<span class="hljs-number">3</span>];<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> first,n,k,a,flag;scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;first,&amp;n,&amp;k);while(n--)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l[a].data,&amp;l[a].next);&#125;<span class="hljs-comment">//分3个部分，把每个部分的地址传进去 </span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=first;i!=<span class="hljs-number">-1</span>;i=l[i].next)&#123;<span class="hljs-keyword">if</span> (l[i].data&lt;<span class="hljs-number">0</span>)&#123;v[<span class="hljs-number">0</span>].push_back(i);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l[i].data&gt;k)&#123;v[<span class="hljs-number">2</span>].push_back(i) ;&#125;<span class="hljs-keyword">else</span>&#123;v[<span class="hljs-number">1</span>].push_back(i);&#125;&#125;    flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;v[i].size();j++)&#123;            <span class="hljs-comment">//很巧妙的解决了不知道下一个地址的问题</span><span class="hljs-keyword">if</span> (flag==<span class="hljs-number">0</span>)&#123;printf(<span class="hljs-string">&quot;%05d %d &quot;</span>,v[i][j],l[v[i][j]].data);flag=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%05d\n%05d %d &quot;</span>,v[i][j],v[i][j],l[v[i][j]].data);&#125;&#125;&#125;printf(<span class="hljs-string">&quot;-1\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1078 字符串压缩与解压</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1078%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1078%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串压缩与解压"><a href="#字符串压缩与解压" class="headerlink" title="字符串压缩与解压"></a><font size=6px>字符串压缩与解压</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 <code>ccccc</code> 就用 <code>5c</code> 来表示。如果字符没有重复，就原样输出。例如 <code>aba</code> 压缩后仍然是 <code>aba</code>。</p><p>解压方法就是反过来，把形如 <code>5c</code> 这样的表示恢复为 <code>ccccc</code>。</p><p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个字符，如果是 <code>C</code> 就表示下面的字符串需要被压缩；如果是 <code>D</code> 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>根据要求压缩或解压字符串，并在一行中输出结果。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">CTTTTThhiiiis isssss a   tesssst CAaaa as</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">5T2h4is i5s a3 te4st CA3a as</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">D5T2h4is i5s a3 te4st CA3a as10Z</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">TTTTThhiiiis isssss a   tesssst CAaaa asZZZZZZZZZZ</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>坑点，得用getchar（）弄掉C&#x2F;D后面的换行符，用get（b）接受有空格的字符串。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;<span class="hljs-type">int</span> main()&#123;char a;<span class="hljs-type">int</span> count=<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;a);    getchar();char b[<span class="hljs-number">100002</span>];gets(b);<span class="hljs-keyword">if</span> (a==<span class="hljs-string">&#x27;C&#x27;</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strlen(b);i++)&#123;<span class="hljs-keyword">if</span>(b[i]==b[i+<span class="hljs-number">1</span>])&#123;count++;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (count==<span class="hljs-number">1</span>)&#123;printf(<span class="hljs-string">&quot;%c&quot;</span>,b[i]);&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%d%c&quot;</span>,count,b[i]);count=<span class="hljs-number">1</span>;&#125;&#125;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a==<span class="hljs-string">&#x27;D&#x27;</span>)&#123;count=<span class="hljs-number">0</span>;while(k&lt;strlen(b))&#123;<span class="hljs-keyword">if</span>(b[k]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;b[k]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;while(b[k]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;b[k]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;count=count*<span class="hljs-number">10</span>+(b[k]-<span class="hljs-string">&#x27;0&#x27;</span>);k++;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;count;j++)&#123;printf(<span class="hljs-string">&quot;%c&quot;</span>,b[k]);&#125;count=<span class="hljs-number">0</span>;k=k+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%c&quot;</span>,b[k]);k++;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1079 延迟的回文数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1079%20%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1079%20%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="延迟的回文数"><a href="#延迟的回文数" class="headerlink" title="延迟的回文数"></a><font size=6px>延迟的回文数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 <em>k</em>+1 位的正整数 <em>N</em>，写成 <em>a**k</em>⋯<em>a</em>1<em>a</em>0 的形式，其中对所有 <em>i</em> 有 0≤<em>a**i</em>&lt;10 且 <em>a*<em>k</em>&gt;0。</em>N* 被称为一个<strong>回文数</strong>，当且仅当对所有 <em>i</em> 有 <em>a**i</em>&#x3D;<em>a**k</em>−<em>i</em>。零也被定义为一个回文数。</p><p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为<strong>延迟的回文数</strong>。（定义翻译自 <a href="https://en.wikipedia.org/wiki/Palindromic_number">https://en.wikipedia.org/wiki/Palindromic_number</a> ）</p><p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个不超过1000位的正整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对给定的整数，一行一行输出其变出回文数的过程。每行格式如下</p><pre><code class="hljs armasm">A + <span class="hljs-keyword">B</span> = C</code></pre><p>其中 <code>A</code> 是原始的数字，<code>B</code> 是 <code>A</code> 的逆转数，<code>C</code> 是它们的和。<code>A</code> 从输入的整数开始。重复操作直到 <code>C</code> 在 10 步以内变成回文数，这时在一行中输出 <code>C is a palindromic number.</code>；或者如果 10 步都没能得到回文数，最后就在一行中输出 <code>Not found in 10 iterations.</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">97152</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">97152 + 25179 = 122331122331 + 133221 = 255552255552 is a palindromic number.</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">196</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">196 + 691 = 887887 + 788 = 16751675 + 5761 = 74367436 + 6347 = 1378313783 + 38731 = 5251452514 + 41525 = 9403994039 + 93049 = 187088187088 + 880781 = 10678691067869 + 9687601 = 1075547010755470 + 07455701 = 18211171Not found in 10 iterations.</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>写三个函数，分别是数字倒置，判断是不是回文数（逆置数和原来数一不一样），两数相加，记得是string来接受值，最后一个结点是好多位树，超过int64.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> n,n1,n2 <span class="hljs-type">string</span>    fmt.Scan(&amp;n)    <span class="hljs-keyword">if</span> Palindrome(n)==<span class="hljs-literal">true</span>&#123;        fmt.Printf(<span class="hljs-string">&quot;%s is a palindromic number.\n&quot;</span>,n)        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++&#123;        n1=inverse(n)        n2=add(n,n1)        fmt.Printf(<span class="hljs-string">&quot;%s + %s = %s\n&quot;</span>,n,n1,n2)        <span class="hljs-keyword">if</span> Palindrome(n2)==<span class="hljs-literal">true</span>&#123;            flag=<span class="hljs-number">1</span>            fmt.Printf(<span class="hljs-string">&quot;%s is a palindromic number.\n&quot;</span>,n2)            <span class="hljs-keyword">break</span>        &#125;        n= n2    &#125;    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;        fmt.Println(<span class="hljs-string">&quot;Not found in 10 iterations.&quot;</span>)    &#125;&#125;<span class="hljs-comment">//数字倒置</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inverse</span><span class="hljs-params">(n <span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> s []<span class="hljs-type">rune</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(n)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        s=<span class="hljs-built_in">append</span>(s,<span class="hljs-type">rune</span>(n[i]))    &#125;    <span class="hljs-keyword">return</span>  <span class="hljs-type">string</span>(s)&#125;<span class="hljs-comment">//判断是不是回文数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Palindrome</span><span class="hljs-params">(n <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(n)/<span class="hljs-number">2</span>;i++&#123;        <span class="hljs-keyword">if</span> n[i]!=n[<span class="hljs-built_in">len</span>(n)-i<span class="hljs-number">-1</span>]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">//两数相加</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(n,n1 <span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span>  &#123;    <span class="hljs-keyword">var</span> jinwei <span class="hljs-type">uint8</span>    <span class="hljs-keyword">var</span> result <span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(n)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        <span class="hljs-keyword">if</span> <span class="hljs-type">int</span>(n1[i]<span class="hljs-number">-48</span>+n[i]<span class="hljs-number">-48</span>+jinwei)&lt;<span class="hljs-number">10</span>&#123;            result=strconv.Itoa(<span class="hljs-type">int</span>(n1[i]<span class="hljs-number">-48</span>+n[i]<span class="hljs-number">-48</span>+jinwei))+result            jinwei=<span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            result=strconv.Itoa(<span class="hljs-type">int</span>(n1[i]<span class="hljs-number">-48</span>+n[i]<span class="hljs-number">-48</span>+jinwei<span class="hljs-number">-10</span>))+result            jinwei=<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> jinwei==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>+<span class="hljs-type">string</span>(result)    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(result)    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1082 射击比赛</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1082%20%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1082%20%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="射击比赛"><a href="#射击比赛" class="headerlink" title="射击比赛"></a><font size=6px>射击比赛</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">ID x y</span></code></pre><p>其中 <code>ID</code> 是运动员的编号（由 4 位数字组成）；<code>x</code> 和 <code>y</code> 是其打出的弹洞的平面坐标(<code>x</code>,<code>y</code>)，均为整数，且 0 ≤ |<code>x</code>|, |<code>y</code>| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">30001 5 71020 -1 30233 0 -1</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">0233 0001</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>创立一个10002的数组，记得是float类型的，输入完成之后就遍历这10000个数字找最大最小值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> b,id,n,c,maxi,mini <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max,min <span class="hljs-type">float64</span>    max = <span class="hljs-number">0</span>    min = <span class="hljs-number">10000</span>    <span class="hljs-keyword">var</span> score [<span class="hljs-number">10002</span>]<span class="hljs-type">float64</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10000</span>;i++&#123;        score[i]= <span class="hljs-number">-1</span>    &#125;    fmt.Scan(&amp;n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;id,&amp;b,&amp;c)        score[id]=math.Sqrt(<span class="hljs-type">float64</span>(c*c+b*b))    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++&#123;        <span class="hljs-keyword">if</span> score[i]!=<span class="hljs-number">-1</span>&#123;            <span class="hljs-keyword">if</span> score[i]&gt;max&#123;                max = score[i]                maxi =i            &#125;            <span class="hljs-keyword">if</span> score[i]&lt;min&#123;                min = score[i]                mini = i            &#125;        &#125;    &#125;    fmt.Printf(<span class="hljs-string">&quot;%04d %04d\n&quot;</span>,mini,maxi)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1085 PAT单位排行</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1085%20PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1085%20PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="PAT单位排行"><a href="#PAT单位排行" class="headerlink" title="PAT单位排行"></a><font size=6px>PAT单位排行</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 N（≤105），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息：</p><pre><code class="hljs">准考证号 得分 学校</code></pre><p>其中<code>准考证号</code>是由 6 个字符组成的字符串，其首字母表示考试的级别：<code>B</code>代表乙级，<code>A</code>代表甲级，<code>T</code>代表顶级；<code>得分</code>是 [0, 100] 区间内的整数；<code>学校</code>是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜：</p><pre><code class="hljs">排名 学校 加权总分 考生人数</code></pre><p>其中<code>排名</code>是该单位的排名（从 1 开始）；<code>学校</code>是全部按小写字母输出的单位码；<code>加权总分</code>定义为<code>乙级总分/1.5 + 甲级总分 + 顶级总分*1.5</code>的<strong>整数部分</strong>；<code>考生人数</code>是该属于单位的考生的总人数。</p><p>学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">10A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypu</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">51 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>实现思路：这里从一开始就摒弃了在输入的过程中进行学校控制，即循环对已存在学校代码进行匹配的算法，因为前面有题验证过，会导致超时，这里采用了另外的方法，即先将所有数据输入，然后依据学校代码排序，这样相同的学校必定相邻，直接循环验证即可，不同的学校存放在结果数组，相同的就将分数相加，最后得到结果数组，再进行快速排序，即可。最后一题完美依次通过，哈哈。</p><p>1.定义学校结构体，包含学校代码，分数，学生人数；</p><p>2.定义指定数量的结构体数组两个，一个存放输入数据，一个存放结果数据，都分别初始化；</p><p>3.逐个输入数据，过程中把输入分数直接进行加权，学生数统一置为1；</p><p>4.按照学校代码进行快速排序；</p><p>5.遍历数组，按照前后项是否相等决定是向结果数组中写入新学校还是增加旧学校分数，得到结果数组；</p><p>6.按照学校分数、考生人数、学校字典序进行快速排序；</p><p>7.输出。</p><h5 id="说说踩过的坑："><a href="#说说踩过的坑：" class="headerlink" title="说说踩过的坑："></a>说说踩过的坑：</h5><p>1、最后两个都是段错误，怎么样都找不出错误，段错误先找是否是数组越界，然后后来看别人知道<strong>把c++的cin和cout全部换成scanf和printf就可以</strong></p><p>2、两个字符串的比较，不能直接比较，因为字符串是地址，比较是比较地址，而这两个地址是不一样的，所以就算名字一样地址不一样就是不一样，得用strcmp，并且字符串不能赋值给字符串，得用strcpy。</p><p>3、计算的综合成绩得用小数保存，最后输出用int</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std; <span class="hljs-keyword">struct</span> Input&#123;char id[<span class="hljs-number">6</span>];double score;char school[<span class="hljs-number">6</span>];&#125;;<span class="hljs-keyword">struct</span> Output&#123;char id[<span class="hljs-number">6</span>];double score;<span class="hljs-type">int</span> num;<span class="hljs-type">int</span> xuhao;&#125;;<span class="hljs-comment">//把所有的学校名都改成小写 </span>void tolower(char *a)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<span class="hljs-keyword">if</span> (a[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;a[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)&#123;a[i]+=<span class="hljs-number">32</span>;&#125;&#125;&#125;<span class="hljs-comment">//计算分数，记得用double最后再相加 </span>double Calculate_score(char *id,double score)&#123;    <span class="hljs-keyword">if</span> (strlen(id)&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">if</span> (id[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;A&#x27;</span>)&#123;<span class="hljs-keyword">return</span> score;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;B&#x27;</span>)&#123;<span class="hljs-keyword">return</span> score/<span class="hljs-number">1.5</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> score*<span class="hljs-number">1.5</span>;&#125;&#125;&#125;<span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">struct</span> Output a,<span class="hljs-keyword">struct</span> Output b)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-type">int</span>(a.score)!=<span class="hljs-type">int</span>(b.score))&#123;<span class="hljs-keyword">return</span> a.score&gt;b.score;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.num!=b.num) &#123;<span class="hljs-keyword">return</span> a.num&lt;b.num;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> strcmp(a.id,b.id)&lt;<span class="hljs-number">0</span>;<span class="hljs-comment">//别用下面的那个，字符串比较无脑用strcp </span><span class="hljs-comment">//return a.id&lt;b.id;</span>&#125;&#125;<span class="hljs-type">bool</span> cmp1(<span class="hljs-keyword">struct</span> Input a,<span class="hljs-keyword">struct</span> Input b) &#123;<span class="hljs-keyword">return</span> strcmp(a.school,b.school)&lt;<span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n,i,k=<span class="hljs-number">0</span>;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">struct</span> Output output[n];<span class="hljs-keyword">struct</span> Input input[n];<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;output[i].num=<span class="hljs-number">0</span>;output[i].score=<span class="hljs-number">0</span>;&#125;i=<span class="hljs-number">0</span>;<span class="hljs-comment">//输入数据 </span>while(i&lt;n)&#123;scanf(<span class="hljs-string">&quot;%s%lf%s&quot;</span>,input[i].id,&amp;input[i].score,input[i].school);tolower(input[i].school);i++;&#125;sort(input,input+n,cmp1);<span class="hljs-comment">//为了测试数据而输出 </span><span class="hljs-comment">//for(i=0;i&lt;n;i++)&#123;</span><span class="hljs-comment">//printf(&quot;%s\n&quot;,input[i].school);</span><span class="hljs-comment">//&#125;</span><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;strcpy(output[i].id,input[i].school);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span>(strcmp(input[i].school,input[i<span class="hljs-number">-1</span>].school)!=<span class="hljs-number">0</span>)&#123;k++;strcpy(output[k].id,input[i].school);&#125;&#125;output[k].num++;output[k].score+=Calculate_score(input[i].id,input[i].score);&#125;k++;sort(output,output+k,cmp);<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;output[i].xuhao=i+<span class="hljs-number">1</span>;&#125;printf(<span class="hljs-string">&quot;%d\n&quot;</span>,k);<span class="hljs-comment">//输出环节 </span><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-type">int</span>(output[i].score)==<span class="hljs-type">int</span>(output[i<span class="hljs-number">-1</span>].score))&#123;output[i].xuhao=output[i<span class="hljs-number">-1</span>].xuhao;printf(<span class="hljs-string">&quot;%d &quot;</span>,output[i<span class="hljs-number">-1</span>].xuhao);&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%d &quot;</span>,output[i].xuhao);&#125;&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%d &quot;</span>,output[i].xuhao);&#125;printf(<span class="hljs-string">&quot;%s %d %d\n&quot;</span>,output[i].id,<span class="hljs-type">int</span>(output[i].score),output[i].num);<span class="hljs-comment">//cout &lt;&lt;output[i].id&lt;&lt;&quot; &quot;&lt;&lt;int(output[i].score)&lt;&lt;&quot; &quot;&lt;&lt;output[i].num&lt;&lt;endl;</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>参考地址:<a href="https://blog.csdn.net/bawangtu/article/details/81544845">https://blog.csdn.net/bawangtu/article/details/81544845</a></p>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1087 有多少不同的值</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1087%20%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1087%20%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="有多少不同的值"><a href="#有多少不同的值" class="headerlink" title="有多少不同的值"></a><font size=6px>有多少不同的值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>1087 有多少不同的值 (20 分)</p><p>当自然数 <em>n</em> 依次取 1、2、3、……、<em>N</em> 时，算式 ⌊<em>n</em>&#x2F;2⌋+⌊<em>n</em>&#x2F;3⌋+⌊<em>n</em>&#x2F;5⌋ 有多少个不同的值？（注：⌊<em>x</em>⌋ 为取整函数，表示不超过 <em>x</em> 的最大自然数，即 <em>x</em> 的整数部分。）</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入给出一个正整数 <em>N</em>（2≤<em>N</em>≤104）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出题面中算式取到的不同值的个数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">2017</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">1480</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> hash [<span class="hljs-number">25000</span>]<span class="hljs-type">int</span>    fmt.Scan(&amp;a)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=a;i++&#123;        hash[i/<span class="hljs-number">2</span>+i/<span class="hljs-number">3</span>+i/<span class="hljs-number">5</span>]++    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">25000</span>;i++&#123;        <span class="hljs-keyword">if</span> hash[i]&gt;=<span class="hljs-number">1</span>&#123;            b++        &#125;    &#125;    fmt.Println(b)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1088 三人行</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1088%20%E4%B8%89%E4%BA%BA%E8%A1%8C/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1088%20%E4%B8%89%E4%BA%BA%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="三人行"><a href="#三人行" class="headerlink" title="三人行"></a><font size=6px>三人行</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”</p><p>本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 <code>Cong</code>；平等则输出 <code>Ping</code>；比你弱则输出 <code>Gai</code>。其间以 1 个空格分隔，行首尾不得有多余空格。</p><p>注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 <code>No Solution</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">48 3 7</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">48 Ping Cong Gai</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">48 11 6</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">No Solution</code></pre><h4 id="思路-题目简单好理解，有两个易错点讲一下，第一个是丙是甲和乙能力的绝对插值，丙应该是个float64类型的数字，不是int类型的。"><a href="#思路-题目简单好理解，有两个易错点讲一下，第一个是丙是甲和乙能力的绝对插值，丙应该是个float64类型的数字，不是int类型的。" class="headerlink" title="思路:题目简单好理解，有两个易错点讲一下，第一个是丙是甲和乙能力的绝对插值，丙应该是个float64类型的数字，不是int类型的。"></a>思路:题目简单好理解，有两个易错点讲一下，第一个是丙是甲和乙能力的绝对插值，丙应该是个float64类型的数字，不是int类型的。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> a,b,c,x,y,flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> z <span class="hljs-type">float64</span>    fmt.Scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">99</span>;i&gt;=<span class="hljs-number">10</span>;i--&#123;        x=i        y=(i/<span class="hljs-number">10</span>)+(i % <span class="hljs-number">10</span>)*<span class="hljs-number">10</span>        z = math.Abs(<span class="hljs-type">float64</span>(x-y)) / <span class="hljs-type">float64</span>(b)            <span class="hljs-keyword">if</span> <span class="hljs-type">float64</span>(c) * z==<span class="hljs-type">float64</span>(y)&#123;                fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,x)                compare(<span class="hljs-type">float64</span>(a),<span class="hljs-type">float64</span>(x))                compare(<span class="hljs-type">float64</span>(a),<span class="hljs-type">float64</span>(y))                compare(<span class="hljs-type">float64</span>(a),z)                flag=<span class="hljs-number">1</span>                <span class="hljs-keyword">break</span>            &#125;    &#125;    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;        fmt.Println(<span class="hljs-string">&quot;No Solution&quot;</span>)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compare</span><span class="hljs-params">(a,b <span class="hljs-type">float64</span>)</span></span>  &#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        fmt.Printf(<span class="hljs-string">&quot; Gai&quot;</span>)    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a==b&#123;        fmt.Printf(<span class="hljs-string">&quot; Ping&quot;</span>)    &#125;<span class="hljs-keyword">else</span>&#123;        fmt.Printf(<span class="hljs-string">&quot; Cong&quot;</span>)    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1093 字符串A+B</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1093%E5%AD%97%E7%AC%A6%E4%B8%B2A+B/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1093%E5%AD%97%E7%AC%A6%E4%B8%B2A+B/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串A-B"><a href="#字符串A-B" class="headerlink" title="字符串A+B"></a><font size=6px>字符串A+B</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个字符串 <em>A</em> 和 <em>B</em>，本题要求你输出 <em>A</em>+<em>B</em>，即两个字符串的并集。要求先输出 <em>A</em>，再输出 <em>B</em>，但<strong>重复的字符必须被剔除</strong>。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在两行中分别给出 <em>A</em> 和 <em>B</em>，均为长度不超过 106的、由可见 ASCII 字符 (即码值为32~126)和空格组成的、由回车标识结束的非空字符串。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出题面要求的 <em>A</em> 和 <em>B</em> 的和。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">This is a sample testto show you_How it works</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">This ampletowyu_Hrk</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>这题不能用fmt.Scanf或者fmt.Scan来输入，因为这两个是用空格或者换行符间隔的，得用bufio来做输入，bufio输入的时候会把字符串最后一个‘\n’也输入，记得去掉即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;bufio&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> s1,s2,s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> mp=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint8</span>]<span class="hljs-type">int</span>,<span class="hljs-number">129</span>)    read:= bufio.NewReader(os.Stdin)    s1,_ = read.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)    s2,_ = read.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1)<span class="hljs-number">-1</span>;i++&#123;        mp[s1[i]]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s2)<span class="hljs-number">-1</span>;i++&#123;        mp[s2[i]]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1);i++&#123;        <span class="hljs-keyword">if</span> mp[s1[i]]==<span class="hljs-number">1</span>&#123;            s=s+<span class="hljs-type">string</span>(s1[i])            mp[s1[i]]=<span class="hljs-number">0</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s2);i++&#123;        <span class="hljs-keyword">if</span> mp[s2[i]]==<span class="hljs-number">1</span>&#123;            s=s+<span class="hljs-type">string</span>(s2[i])            mp[s2[i]]=<span class="hljs-number">0</span>        &#125;    &#125;    fmt.Println(s)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1091 N-自守数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1091%20N-%E8%87%AA%E5%AE%88%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1091%20N-%E8%87%AA%E5%AE%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="N-自守数"><a href="#N-自守数" class="headerlink" title="N-自守数"></a><font size=6px>N-自守数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>如果某个数 <em>K</em> 的平方乘以 <em>N</em> 以后，结果的末尾几位数等于 <em>K</em>，那么就称这个数为“<em>N</em>-自守数”。例如 3×922&#x3D;25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。</p><p>本题就请你编写程序判断一个给定的数字是否关于某个 <em>N</em> 是 <em>N</em>-自守数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>M</em>（≤20），随后一行给出 <em>M</em> 个待检测的、不超过 1000 的正整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个需要检测的数字，如果它是 <em>N</em>-自守数就在一行中输出最小的 <em>N</em> 和 <em>N**K</em>2 的值，以一个空格隔开；否则输出 <code>No</code>。注意题目保证 <em>N</em>&lt;10。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">392 5 233</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">3 253921 25No</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把n从1到9遍历，如果哪个N的后几位等于自守数，就输出，简单题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> n,a,flag <span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++&#123;            len_a := getlen(a)            <span class="hljs-keyword">if</span> a*a*i % <span class="hljs-type">int</span>(math.Pow(<span class="hljs-number">10</span>,<span class="hljs-type">float64</span>(len_a)))==a&#123;                fmt.Printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,a*a*i)                flag = <span class="hljs-number">1</span>                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> flag ==<span class="hljs-number">1</span>&#123;            flag=<span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Println(<span class="hljs-string">&quot;No&quot;</span>)        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getlen</span><span class="hljs-params">(n <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">len</span>(strconv.Itoa(n))&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT题目合集</title>
    <link href="/2022/01/21/PAT%E4%B9%99/PAT%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
    <url>/2022/01/21/PAT%E4%B9%99/PAT%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<style>table th:first-of-type {    width: 30%;}table th:nth-of-type(2) {    width: 30%;}table th:nth-of-type(3) {    width: 10%;} table th:nth-of-type(4) {    width: 15%;table th:nth-of-type(5) {    width: 30%;}</style><div style="font-size:20px"><table><thead><tr><th align="center">题目</th><th align="center">收获</th><th align="center">语言</th><th align="center">分数</th><th>是否做完</th></tr></thead><tbody><tr><td align="center"><a href="http://www.hkctfsys.com/2021/03/02/PAT/1010%20%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/">1010 一元多项式求导</a></td><td align="center"></td><td align="center">go</td><td align="center">25</td><td>是</td></tr><tr><td align="center">1025 反转链表</td><td align="center">知道怎么反转链表</td><td align="center">c</td><td align="center">25</td><td>是</td></tr><tr><td align="center">1038 统计同成绩学生</td><td align="center"></td><td align="center">c</td><td align="center">20</td><td>是</td></tr><tr><td align="center">1049 数列的片段和</td><td align="center">知道double是不是精确的</td><td align="center">c</td><td align="center">25</td><td>是</td></tr><tr><td align="center">1062 最简分数</td><td align="center">学会gcd与gcm（最大公因数公约数），与swap。</td><td align="center">c</td><td align="center">20</td><td>是</td></tr><tr><td align="center">1060 爱丁顿数</td><td align="center"></td><td align="center">c</td><td align="center">25</td><td>是</td></tr><tr><td align="center">1078 字符串压缩与解压</td><td align="center">学会了用gets（）接收有空格的字符必</td><td align="center">c</td><td align="center">20</td><td>是</td></tr><tr><td align="center">1075 链表元素分类</td><td align="center">学会用vector，v[1].push_back(i),v[1].size()</td><td align="center">c&#x2F;c++</td><td align="center">25</td><td>是</td></tr><tr><td align="center">1085 PAT单位排行</td><td align="center">学会字符串比较和赋值（strcmp，strcpy），学会段错误的特殊原因</td><td align="center">c&#x2F;c++</td><td align="center">25</td><td>是</td></tr></tbody></table></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1038 统计同成绩学生</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1038%20%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1038%20%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="统计同成绩学生"><a href="#统计同成绩学生" class="headerlink" title="统计同成绩学生"></a><font size=6px>统计同成绩学生</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题要求读入 <em>N</em> 名学生的成绩，将获得某一给定分数的学生人数输出。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第 1 行给出不超过 105 的正整数 <em>N</em>，即学生总人数。随后一行给出 <em>N</em> 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 <em>K</em>（不超过 <em>N</em> 的正整数），随后是 <em>K</em> 个分数，中间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">1060 75 90 55 75 99 82 90 75 503 75 90 88</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">3 2 0</code></pre><h4 id="思路-无"><a href="#思路-无" class="headerlink" title="思路:无"></a>思路:无</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n,a;<span class="hljs-type">int</span> sco[<span class="hljs-number">101</span>],flag=<span class="hljs-number">0</span>;memset(sco,<span class="hljs-number">0</span>,sizeof(sco));scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);sco[a]++;&#125;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<span class="hljs-keyword">if</span> (flag==<span class="hljs-number">0</span>)&#123;printf(<span class="hljs-string">&quot;%d&quot;</span>,sco[a]);flag=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot; %d&quot;</span>,sco[a]);&#125;&#125;printf(<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1044 火星数字</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1044%20%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1044%20%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="火星数字"><a href="#火星数字" class="headerlink" title="火星数字"></a><font size=6px>火星数字</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>火星人是以 13 进制计数的：</p><ul><li>地球人的 0 被火星人称为 tret。</li><li>地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。</li><li>火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。</li></ul><p>例如地球人的数字 <code>29</code> 翻译成火星文就是 <code>hel mar</code>；而火星文 <code>elo nov</code> 对应地球数字 <code>115</code>。为了方便交流，请你编写程序实现地球和火星数字之间的互译。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 <em>N</em>（&lt;100），随后 <em>N</em> 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对应输入的每一行，在一行中输出翻译后的另一种语言的数字。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">4295elo novtam</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">hel marmay11513</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>题目不难，我用switch-case做就显得冗长，但是好理解，用c[0]判断是数字还是字符，然后分别判断</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;bufio&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;os&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>    <span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,result <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    r:=bufio.NewReader(os.Stdin)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        c,_:=r.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)        <span class="hljs-comment">//如果是数字，就转换成字母</span>        <span class="hljs-keyword">if</span> c[<span class="hljs-number">0</span>] &gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c[<span class="hljs-number">0</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&#123;            <span class="hljs-comment">//把c最后换行符取消掉</span>            c=strings.Replace(c,<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">-1</span>)            num,_ :=strconv.Atoi(c)            <span class="hljs-comment">//如果可以用13整除</span>            <span class="hljs-keyword">if</span> num % <span class="hljs-number">13</span>==<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">switch</span> (num/<span class="hljs-number">13</span>) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                    fmt.Printf(<span class="hljs-string">&quot;tret\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                    fmt.Printf(<span class="hljs-string">&quot;tam\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                    fmt.Printf(<span class="hljs-string">&quot;hel\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                    fmt.Printf(<span class="hljs-string">&quot;maa\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                    fmt.Printf(<span class="hljs-string">&quot;huh\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                    fmt.Printf(<span class="hljs-string">&quot;tou\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:                    fmt.Printf(<span class="hljs-string">&quot;kes\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:                    fmt.Printf(<span class="hljs-string">&quot;hei\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:                    fmt.Printf(<span class="hljs-string">&quot;elo\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:                    fmt.Printf(<span class="hljs-string">&quot;syy\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                    fmt.Printf(<span class="hljs-string">&quot;lok\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:                    fmt.Printf(<span class="hljs-string">&quot;mer\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:                    fmt.Printf(<span class="hljs-string">&quot;jou\n&quot;</span>)                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span> num/<span class="hljs-number">13</span>!=<span class="hljs-number">0</span>&#123;                    <span class="hljs-keyword">switch</span> (num/<span class="hljs-number">13</span>) &#123;                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                        fmt.Printf(<span class="hljs-string">&quot;tam &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                        fmt.Printf(<span class="hljs-string">&quot;hel &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                        fmt.Printf(<span class="hljs-string">&quot;maa &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                        fmt.Printf(<span class="hljs-string">&quot;huh &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                        fmt.Printf(<span class="hljs-string">&quot;tou &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:                        fmt.Printf(<span class="hljs-string">&quot;kes &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:                        fmt.Printf(<span class="hljs-string">&quot;hei &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:                        fmt.Printf(<span class="hljs-string">&quot;elo &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:                        fmt.Printf(<span class="hljs-string">&quot;syy &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                        fmt.Printf(<span class="hljs-string">&quot;lok &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:                        fmt.Printf(<span class="hljs-string">&quot;mer &quot;</span>)                    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:                        fmt.Printf(<span class="hljs-string">&quot;jou &quot;</span>)                    &#125;                &#125;                <span class="hljs-keyword">switch</span> (num % <span class="hljs-number">13</span>) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                    fmt.Printf(<span class="hljs-string">&quot;jan\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                    fmt.Printf(<span class="hljs-string">&quot;feb\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                    fmt.Printf(<span class="hljs-string">&quot;mar\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                    fmt.Printf(<span class="hljs-string">&quot;apr\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                    fmt.Printf(<span class="hljs-string">&quot;may\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:                    fmt.Printf(<span class="hljs-string">&quot;jun\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:                    fmt.Printf(<span class="hljs-string">&quot;jly\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:                    fmt.Printf(<span class="hljs-string">&quot;aug\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:                    fmt.Printf(<span class="hljs-string">&quot;sep\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                    fmt.Printf(<span class="hljs-string">&quot;oct\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:                    fmt.Printf(<span class="hljs-string">&quot;nov\n&quot;</span>)                <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:                    fmt.Printf(<span class="hljs-string">&quot;dec\n&quot;</span>)                &#125;            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//是字符串怎么办</span>            c:=strings.Replace(c,<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">-1</span>)            c1:=strings.Split(c,<span class="hljs-string">&quot; &quot;</span>)            <span class="hljs-keyword">for</span> _,v:= <span class="hljs-keyword">range</span> c1&#123;                <span class="hljs-keyword">switch</span> (v) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;tam&quot;</span>:                    result+=<span class="hljs-number">1</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hel&quot;</span>:                    result+=<span class="hljs-number">2</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;maa&quot;</span>:                    result+=<span class="hljs-number">3</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;huh&quot;</span>:                    result+=<span class="hljs-number">4</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;tou&quot;</span>:                    result+=<span class="hljs-number">5</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;kes&quot;</span>:                    result+=<span class="hljs-number">6</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hei&quot;</span>:                    result+=<span class="hljs-number">7</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;elo&quot;</span>:                    result+=<span class="hljs-number">8</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;syy&quot;</span>:                    result+=<span class="hljs-number">9</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;lok&quot;</span>:                    result+=<span class="hljs-number">10</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mer&quot;</span>:                    result+=<span class="hljs-number">11</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jou&quot;</span>:                    result+=<span class="hljs-number">12</span>*<span class="hljs-number">13</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;tret&quot;</span>:                    result+=<span class="hljs-number">0</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jan&quot;</span>:                    result+=<span class="hljs-number">1</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;feb&quot;</span>:                    result+=<span class="hljs-number">2</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mar&quot;</span>:                    result+=<span class="hljs-number">3</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;apr&quot;</span>:                    result+=<span class="hljs-number">4</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;may&quot;</span>:                    result+=<span class="hljs-number">5</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jun&quot;</span>:                    result+=<span class="hljs-number">6</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jly&quot;</span>:                    result+=<span class="hljs-number">7</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;aug&quot;</span>:                    result+=<span class="hljs-number">8</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sep&quot;</span>:                    result+=<span class="hljs-number">9</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;oct&quot;</span>:                    result+=<span class="hljs-number">10</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;nov&quot;</span>:                    result+=<span class="hljs-number">11</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;dec&quot;</span>:                    result+=<span class="hljs-number">12</span>                &#125;            &#125;            fmt.Println(result)            result=<span class="hljs-number">0</span>        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1048 数字加密</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1048%20%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1048%20%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="数字加密"><a href="#数字加密" class="headerlink" title="数字加密"></a><font size=6px>数字加密</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出加密后的结果。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">1234567 368782971</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">3695Q8118</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>这个题目没有讲明白，如果两个字串长度不一样长，要在短的那个字符前面前面补零，还有一个坑的地方就是他题目说的第一个数字就是字符串的最后一个数字，所以要逆置接受，然后长度不相等在后面补零，得出结果再逆置输出</p><pre><code class="hljs armasm"><span class="hljs-comment">//这段代码在输入样例里面只会执行一次，因为一次s1=&quot;0&quot;+s1会使s1长度增加使for语句实际执行次数少一半，和c语言不同</span><span class="hljs-symbol">for</span> i:<span class="hljs-number">=0</span><span class="hljs-comment">;i&lt;len(s2)-len(s1);i++&#123;</span>            fmt.Println(<span class="hljs-built_in">s1</span>)            <span class="hljs-built_in">s1</span>=<span class="hljs-string">&quot;0&quot;</span>+<span class="hljs-built_in">s1</span>        &#125;</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> s1,s2,s3 <span class="hljs-type">string</span>    list :=[<span class="hljs-number">13</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>&#125;    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>    fmt.Scan(&amp;s1,&amp;s2)    s1=reverse(s1)    s2=reverse(s2)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1)&lt;<span class="hljs-built_in">len</span>(s2)&#123;        a:=<span class="hljs-built_in">len</span>(s2)-<span class="hljs-built_in">len</span>(s1)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;a;i++&#123;            s1+=<span class="hljs-string">&quot;0&quot;</span>        &#125;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1)&gt;<span class="hljs-built_in">len</span>(s2)&#123;        a:=<span class="hljs-built_in">len</span>(s1)-<span class="hljs-built_in">len</span>(s2)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;a;i++&#123;            s2+=<span class="hljs-string">&quot;0&quot;</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1);i++&#123;        <span class="hljs-comment">//如果为个位</span>        <span class="hljs-keyword">if</span> i %<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&#123;            sum = (<span class="hljs-type">int</span>(s1[i]-<span class="hljs-string">&#x27;0&#x27;</span>)+<span class="hljs-type">int</span>(s2[i]-<span class="hljs-string">&#x27;0&#x27;</span>))%<span class="hljs-number">13</span>            s3+=list[sum]        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果为偶位</span>            sum = <span class="hljs-type">int</span>(s2[i]-<span class="hljs-string">&#x27;0&#x27;</span>)-<span class="hljs-type">int</span>(s1[i]-<span class="hljs-string">&#x27;0&#x27;</span>)            <span class="hljs-keyword">if</span> sum&lt;<span class="hljs-number">0</span>&#123;                sum+=<span class="hljs-number">10</span>            &#125;            s3+=strconv.Itoa(sum)        &#125;    &#125;    fmt.Println(reverse(s3))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span>&#123;    re:=[]<span class="hljs-type">rune</span>(s)    n:=<span class="hljs-built_in">len</span>(re)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++&#123;        temp:=re[i]        re[i]=re[n-i<span class="hljs-number">-1</span>]        re[n-i<span class="hljs-number">-1</span>]=temp    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(re)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1049 数列的片段和</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1049%20%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1049%20%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="数列的片段和"><a href="#数列的片段和" class="headerlink" title="数列的片段和"></a><font size=6px>数列的片段和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。</p><p>给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 &#x3D; 5.0。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个不超过 105 的正整数 <em>N</em>，表示数列中数的个数，第二行给出 <em>N</em> 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">40.1 0.2 0.3 0.4</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">5.00</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>与其说是个程序题，不如说是个数学题，找到规律，但是要考虑的一点是doube类型的精度在数字大了之后是不够的，比如4.182，在计算机里面是4.18200000000000000004121532，数字大了之后就不行了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n;long long sum;double a;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;scanf(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a);sum+=(long long)(a*<span class="hljs-number">1000</span>)*i*(n-i+<span class="hljs-number">1</span>);&#125; printf(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,sum/<span class="hljs-number">1000.0</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1050 螺旋矩阵</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1050%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1050%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20/</url>
    
    <content type="html"><![CDATA[<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a><font size=6px>螺旋矩阵</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题要求将给定的 <em>N</em> 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 <em>m</em> 行 <em>n</em> 列，满足条件：<em>m</em>×<em>n</em> 等于 <em>N</em>；<em>m</em>≥<em>n</em>；且 <em>m</em>−<em>n</em> 取所有可能值中的最小值。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第 1 行中给出一个正整数 <em>N</em>，第 2 行给出 <em>N</em> 个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出螺旋矩阵。每行 <em>n</em> 个数字，共 <em>m</em> 行。相邻数字以 1 个空格分隔，行末不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">1237 76 20 98 76 42 53 95 60 81 58 93</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">98 95 9342 37 8153 20 7658 60 76</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>最后一直有个最后的测试点是<strong>非零返回</strong>，最后查资料大神说最后一个测试点的数据是9773，真狠，最后结果是9773行1列，非零返回是因为flag数组开小了。</p><p><img src="/img/PAT1050.png"></p><p>level是外层循环，计算公式是m&#x2F;2+m%2，再加上四层内层循环，数字一定要是右-下-左-上的顺序。</p><p>学习了新东西：</p><pre><code class="hljs arcade"><span class="hljs-built_in">sort</span>.<span class="hljs-built_in">Sort</span>(<span class="hljs-built_in">sort</span>.<span class="hljs-built_in">Reverse</span>(<span class="hljs-built_in">sort</span>.IntSlice(num)))</code></pre><p>将一个数字切片逆序排序</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>    <span class="hljs-string">&quot;sort&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> nu, a,m,n,count,level <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> num []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> flag [<span class="hljs-number">10000</span>][<span class="hljs-number">200</span>]<span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nu)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nu; i++ &#123;        fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a)        num = <span class="hljs-built_in">append</span>(num, a)    &#125;    sort.Sort(sort.Reverse(sort.IntSlice(num)))    <span class="hljs-comment">//求m和n，确定长和宽,m是几行，n是几列</span>    <span class="hljs-keyword">for</span> i := <span class="hljs-type">int</span>(math.Sqrt(<span class="hljs-type">float64</span>(nu))); i &gt;=<span class="hljs-number">1</span>; i-- &#123;            <span class="hljs-keyword">if</span> nu % i == <span class="hljs-number">0</span> &#123;                n = i                m = nu / i                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-comment">//fmt.Println(m,n)</span>   level = m/<span class="hljs-number">2</span> +m % <span class="hljs-number">2</span>   <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;level;i++&#123;       <span class="hljs-comment">//第一行</span>       <span class="hljs-keyword">for</span> j:=i;j&lt;n-i&amp;&amp;count&lt;nu;j++&#123;           flag[i][j] = num[count]           count++       &#125;       <span class="hljs-comment">//最后一列</span>       <span class="hljs-keyword">for</span> j:=i+<span class="hljs-number">1</span>;j&lt;m-i<span class="hljs-number">-1</span>&amp;&amp;count&lt;nu;j++&#123;           flag[j][n<span class="hljs-number">-1</span>-i] = num[count]           count++       &#125;       <span class="hljs-comment">//最后一行</span>       <span class="hljs-keyword">for</span> j:=n-i<span class="hljs-number">-1</span>;j&gt;=i&amp;&amp;count&lt;nu;j--&#123;           flag[m-i<span class="hljs-number">-1</span>][j] = num[count]           count++       &#125;       <span class="hljs-comment">//第一列</span>       <span class="hljs-keyword">for</span> j:=m-i<span class="hljs-number">-2</span>;j&gt;i&amp;&amp;count&lt;nu;j--&#123;           flag[j][i] = num[count]           count++       &#125;   &#125;   <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;       <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;           fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,flag[i][j])           <span class="hljs-keyword">if</span> j!=n<span class="hljs-number">-1</span>&#123;               fmt.Printf(<span class="hljs-string">&quot; &quot;</span>)           &#125;<span class="hljs-keyword">else</span> &#123;               fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)           &#125;       &#125;   &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1060 爱丁顿数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1060%20%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1060%20%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="爱丁顿数"><a href="#爱丁顿数" class="headerlink" title="爱丁顿数"></a><font size=6px>爱丁顿数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” <em>E</em> ，即满足有 <em>E</em> 天骑车超过 <em>E</em> 英里的最大整数 <em>E</em>。据说爱丁顿自己的 <em>E</em> 等于87。</p><p>现给定某人 <em>N</em> 天的骑车距离，请你算出对应的爱丁顿数 <em>E</em>（≤<em>N</em>）。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 <em>N</em> (≤105)，即连续骑车的天数；第二行给出 <em>N</em> 个非负整数，代表每天的骑车距离。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中给出 <em>N</em> 天的爱丁顿数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">106 7 6 9 3 10 8 2 7 8</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">6</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>题目好理解，讲讲思路，先从大到小sort，按题目的例子，用序号10比较最小的2，是序号大，然后用序号9比较第二小的3，这样比较直到数字比序号大，就输出，别忘了数字都是0 的特殊情况，测试点4就是这样的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;<span class="hljs-type">bool</span> cmp(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;<span class="hljs-keyword">return</span> a&gt;b;&#125;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n,count,flag=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> arr[<span class="hljs-number">100002</span>];scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;arr[i]);&#125;sort(arr,arr+n,cmp);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<span class="hljs-keyword">if</span>(arr[i<span class="hljs-number">-1</span>]&gt;i)&#123;printf(<span class="hljs-string">&quot;%d\n&quot;</span>,i);            flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;    <span class="hljs-keyword">if</span> (flag!=<span class="hljs-number">1</span>)&#123;        printf(<span class="hljs-string">&quot;0\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1065 单身狗</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1065%20%E5%8D%95%E8%BA%AB%E7%8B%97/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1065%20%E5%8D%95%E8%BA%AB%E7%8B%97/</url>
    
    <content type="html"><![CDATA[<h3 id="单身狗"><a href="#单身狗" class="headerlink" title="单身狗"></a><font size=6px>单身狗</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻&#x2F;伴侣的对数；随后 N 行，每行给出一对夫妻&#x2F;伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">510000 23333 44444 55555 88888</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-comment">//最后两个测试点会超时</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;sort&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> s1,s2 <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> id []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> flag [<span class="hljs-number">10001</span>]<span class="hljs-type">int</span>    mp:= <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>,<span class="hljs-number">50001</span>)    fmt.Scan(&amp;n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scan(&amp;s1,&amp;s2)        <span class="hljs-keyword">if</span> s1&gt;s2&#123;            mp[s2]=s1        &#125;<span class="hljs-keyword">else</span> &#123;            mp[s1]=s2        &#125;    &#125;    fmt.Scan(&amp;n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scan(&amp;s1)        id = <span class="hljs-built_in">append</span>(id,s1)    &#125;    sort.Strings(id)    result:=n    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> flag[i]==<span class="hljs-number">0</span>&amp;&amp;mp[id[i]]!=<span class="hljs-string">&quot;0&quot;</span>&#123;            <span class="hljs-keyword">for</span> k:=i+<span class="hljs-number">1</span>;k&lt;n;k++&#123;                <span class="hljs-keyword">if</span> mp[id[i]]==id[k]&#123;                    flag[i]=<span class="hljs-number">1</span>                    flag[k]=<span class="hljs-number">1</span>                    result-=<span class="hljs-number">2</span>                    <span class="hljs-keyword">break</span>                &#125;            &#125;        &#125;    &#125;    fmt.Println(result)    first:=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> flag[i]==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> first==<span class="hljs-number">0</span>&#123;                fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,id[i])                first=<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                fmt.Printf(<span class="hljs-string">&quot; %s&quot;</span>,id[i])            &#125;        &#125;    &#125;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1067 试密码</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1067%20%E8%AF%95%E5%AF%86%E7%A0%81/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1067%20%E8%AF%95%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="试密码"><a href="#试密码" class="headerlink" title="试密码"></a><font size=6px>试密码</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 <code>Welcome in</code>，并结束程序；如果是错误的，则在一行中按格式输出 <code>Wrong password: 用户输入的错误密码</code>；当错误尝试达到 N 次时，再输出一行 <code>Account locked</code>，并结束程序。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">Correct%pw 3correct%pwCorrect@PWwhatisthepassword!Correct%pw#</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">Wrong password: correct%pwWrong password: Correct@PWWrong password: whatisthepassword!Account locked</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">cool@gplt 3coolman@gpltcoollady@gpltcool@gplttry again#</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">Wrong password: coolman@gpltWrong password: coollady@gpltWelcome in</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>有个地方需要注意一下，输入的密码有可能包含空格，所以要用bufio来输入</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;bufio&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;os&quot;</span>    <span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> s,password <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> n,flag <span class="hljs-type">int</span>    fmt.Scan(&amp;password,&amp;n)    r:=bufio.NewReader(os.Stdin)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        s,_=r.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)        s=strings.Replace(s,<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">-1</span>)        <span class="hljs-keyword">if</span> s==<span class="hljs-string">&quot;#&quot;</span>&#123;            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">if</span> s==password&#123;            fmt.Println(<span class="hljs-string">&quot;Welcome in&quot;</span>)            flag=<span class="hljs-number">1</span>            <span class="hljs-keyword">break</span>        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;Wrong password: %s\n&quot;</span>,s)        &#125;    &#125;    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;        fmt.Println(<span class="hljs-string">&quot;Account locked&quot;</span>)    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1069 微博转发抽奖</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1069%20%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1069%20%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96/</url>
    
    <content type="html"><![CDATA[<h3 id="微博转发抽奖"><a href="#微博转发抽奖" class="headerlink" title="微博转发抽奖"></a><font size=6px>微博转发抽奖</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。</p><p>注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 <code>Keep going...</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">9 3 2Imgonnawin!PickMePickMeMeMeeeLookHereImgonnawin!TryAgainAgainTryAgainAgainImgonnawin!TryAgainAgain</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">PickMeImgonnawin!TryAgainAgain</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">2 3 5Imgonnawin!PickMe</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">Keep going...</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先输出第一个数，开始计数，每隔n个输出人名，并用map判断有没有之前就拿奖。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> m,n,s,interval <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> name <span class="hljs-type">string</span>    mp:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>,<span class="hljs-number">1001</span>)    fmt.Scan(&amp;m,&amp;n,&amp;s)    <span class="hljs-keyword">if</span> s&gt;m&#123;        fmt.Println(<span class="hljs-string">&quot;Keep going...&quot;</span>)        <span class="hljs-keyword">return</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;            <span class="hljs-comment">//先输出第一个</span>            <span class="hljs-keyword">if</span> i==s&#123;                fmt.Scan(&amp;name)                fmt.Println(name)                mp[name]=<span class="hljs-number">1</span>                <span class="hljs-comment">//输出一个个之后开始计数</span>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i&gt;s&#123;                fmt.Scan(&amp;name)                interval++                <span class="hljs-keyword">if</span> interval ==n&#123;                    <span class="hljs-keyword">if</span> mp[name]==<span class="hljs-number">1</span>&#123;                        interval--                    &#125;<span class="hljs-keyword">else</span>&#123;                        fmt.Println(name)                        mp[name]=<span class="hljs-number">1</span>                        interval=<span class="hljs-number">0</span>                    &#125;                &#125;            &#125;<span class="hljs-keyword">else</span> &#123;                fmt.Scan(&amp;name)            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1062 最简分数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1062%20%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1062%20%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="最简分数"><a href="#最简分数" class="headerlink" title="最简分数"></a><font size=6px>最简分数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一个分数一般写成两个整数相除的形式：<em>N</em>&#x2F;<em>M</em>，其中 <em>M</em> 不为0。最简分数是指分子和分母没有公约数的分数表示形式。</p><p>现给定两个不相等的正分数 <em>N</em>1&#x2F;<em>M</em>1 和 <em>N</em>2&#x2F;<em>M</em>2，要求你按从小到大的顺序列出它们之间分母为 <em>K</em> 的最简分数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中按 <em>N</em>&#x2F;<em>M</em> 的格式给出两个正分数，随后是一个正整数分母 <em>K</em>，其间以空格分隔。题目保证给出的所有整数都不超过 1000。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中按 <em>N</em>&#x2F;<em>M</em> 的格式列出两个给定分数之间分母为 <em>K</em> 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">7/18 13/20 12</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">5/12 7/12</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="题目解释：开始我题目都读不懂，我解释一下，把7-x2F-18转换成4-66-x2F-12，把13-x2F-20转换成7-8-x2F-12，就是求4-66到7-8之间的整数之间有无与12最大公因数为1的数"><a href="#题目解释：开始我题目都读不懂，我解释一下，把7-x2F-18转换成4-66-x2F-12，把13-x2F-20转换成7-8-x2F-12，就是求4-66到7-8之间的整数之间有无与12最大公因数为1的数" class="headerlink" title="题目解释：开始我题目都读不懂，我解释一下，把7&#x2F;18转换成4.66&#x2F;12，把13&#x2F;20转换成7.8&#x2F;12，就是求4.66到7.8之间的整数之间有无与12最大公因数为1的数"></a>题目解释：开始我题目都读不懂，我解释一下，把7&#x2F;18转换成4.66&#x2F;12，把13&#x2F;20转换成7.8&#x2F;12，就是求4.66到7.8之间的整数之间有无与12最大公因数为1的数</h5><p>把先求出18，20，12三个数的最大公约数，把两个数转换成相同底，就是70&#x2F;180，117&#x2F;180，就是求70到117之间有无能被15（180&#x2F;12）整除然后整除的数与12最大公因数为1.</p><p><strong>注意区间为（70，117），边界取不到</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>using namespace <span class="hljs-built_in">std</span>;<span class="hljs-comment">//求最大公因数 </span><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);&#125; <span class="hljs-comment">//最大公约数 </span><span class="hljs-type">int</span> <span class="hljs-title function_">gcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<span class="hljs-type">int</span> c=gcd(a,b);<span class="hljs-keyword">return</span> a*b/c; &#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-type">int</span> a,b,c,e,d,j=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> num[<span class="hljs-number">1000</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d/%d%d/%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e);<span class="hljs-type">int</span> t=gcm(b,d);<span class="hljs-type">int</span> t1=gcm(t,e);<span class="hljs-type">int</span> g=t1/e;<span class="hljs-type">int</span> first=t1/b*a;<span class="hljs-type">int</span> last = t1/d*c;<span class="hljs-keyword">if</span> (first&gt;last)&#123;swap(first,last);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=first+<span class="hljs-number">1</span>;i&lt;last;i++)&#123;<span class="hljs-keyword">if</span> (i%g==<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>(gcd(i/g,e)==<span class="hljs-number">1</span>)&#123;num[j++]=i/g;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;j;i++)&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d/%d&quot;</span>,num[i],e);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d/%d&quot;</span>,num[i],e);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1006 换个格式输出整数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1006%20%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1006%20%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1006-换个格式输出整数"><a href="#1006-换个格式输出整数" class="headerlink" title="1006 换个格式输出整数"></a><font size=6px><strong>1006 换个格式输出整数</strong></font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>让我们用字母 <code>B</code> 来表示“百”、字母 <code>S</code> 表示“十”，用 <code>12...n</code> 来表示不为零的个位数字 <code>n</code>（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 <code>234</code> 应该被输出为 <code>BBSSS1234</code>，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，给出正整数 <em>n</em>（&lt;1000）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，用规定的格式输出 <em>n</em>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="hljs in">234</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="hljs out">BBSSS1234</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="hljs in">23</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="hljs out">SS123</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把每个数的百位十位个位求出来就可以</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,a,b,c <span class="hljs-type">int</span><span class="hljs-comment">//a代表百位，b代表十位，c代表各位</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    a=n/<span class="hljs-number">100</span>    b=n/<span class="hljs-number">10</span> %<span class="hljs-number">10</span>    c=n%<span class="hljs-number">10</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;a;i++&#123;        fmt.Printf(<span class="hljs-string">&quot;B&quot;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;b;i++&#123;        fmt.Printf(<span class="hljs-string">&quot;S&quot;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;c;i++&#123;        fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,i+<span class="hljs-number">1</span>)    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1007 素数对猜想</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1007%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1007%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="1007-素数对猜想"><a href="#1007-素数对猜想" class="headerlink" title="1007 素数对猜想"></a><font size=6px><strong>1007 素数对猜想</strong></font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>让我们定义<em>d**n</em>为：<em>d**n</em>&#x3D;<em>p**n</em>+1−<em>p**n</em>，其中<em>p**i</em>是第<em>i</em>个素数。显然有<em>d</em>1&#x3D;1，且对于<em>n</em>&gt;1有<em>d**n</em>是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p><p>现给定任意正整数<code>N</code>(&lt;105)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出正整数<code>N</code>。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code class="hljs in">20</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code class="hljs out">4</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先把素数求出来放一个切片里面，然后让每个相邻的切片相减看看是不是等于2</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,sum,num <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> p []<span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">3</span>&#123;        fmt.Println(<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n;i++&#123;        <span class="hljs-keyword">if</span> prime(i)==<span class="hljs-literal">true</span>&#123;            p=<span class="hljs-built_in">append</span>(p,i)            num++        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;num<span class="hljs-number">-1</span>;i++&#123;        <span class="hljs-keyword">if</span> p[i+<span class="hljs-number">1</span>]-p[i]==<span class="hljs-number">2</span>&#123;            sum++        &#125;    &#125;    fmt.Println(sum)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prime</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-type">int</span>(math.Sqrt(<span class="hljs-type">float64</span>(n)));i++&#123;        <span class="hljs-keyword">if</span> n%i==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1008 数组元素循环右移问题</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1008%20%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1008%20%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="数组元素循环右移问题"><a href="#数组元素循环右移问题" class="headerlink" title="数组元素循环右移问题"></a><font size=6px>数组元素循环右移问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>一个数组<em>A</em>中存有<em>N</em>（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移<em>M</em>（≥0）个位置，即将<em>A</em>中的数据由（<em>A</em>0<em>A</em>1⋯<em>A**N</em>−1）变换为（<em>A**N</em>−<em>M</em>⋯<em>A**N</em>−1<em>A</em>0<em>A</em>1⋯<em>A**N</em>−<em>M</em>−1）（最后<em>M</em>个数循环移至最前面的<em>M</em>个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每个输入包含一个测试用例，第1行输入<em>N</em>（1≤<em>N</em>≤100）和<em>M</em>（≥0）；第2行输入<em>N</em>个整数，之间用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出循环右移<em>M</em>位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code class="hljs in">6 21 2 3 4 5 6</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code class="hljs out">5 6 1 2 3 4</code></pre><h4 id="思路-题目简单，可是用golang始终有个测试点过不了-换c"><a href="#思路-题目简单，可是用golang始终有个测试点过不了-换c" class="headerlink" title="思路:题目简单，可是用golang始终有个测试点过不了,换c"></a>思路:题目简单，可是用golang始终有个测试点过不了,换c</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-type">int</span> a[<span class="hljs-number">201</span>],i,j,n,m;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">if</span>(m&gt;n) m=m%n;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);a[i+n]=a[i];&#125;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;a[i]=a[<span class="hljs-number">2</span>*n-m+i];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);&#125;<span class="hljs-keyword">for</span>(i=m;i&lt;n;i++)&#123;a[i]=a[n-m+i];<span class="hljs-keyword">if</span>(i!=n<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[i]);&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1009 说反话</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1009%20%E8%AF%B4%E5%8F%8D%E8%AF%9D/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1009%20%E8%AF%B4%E5%8F%8D%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="说反话"><a href="#说反话" class="headerlink" title="说反话"></a><font size=6px>说反话</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，输出倒序后的句子。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">Hello World Here I Come</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">Come I Here World Hello</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>go语言思路就是先接受一个个单词放到shting切片里面，然后从后往前print</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> s []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> s1 <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>    <span class="hljs-keyword">var</span> k <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> &#123;        _,err=fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s1)        <span class="hljs-keyword">if</span> err==<span class="hljs-literal">nil</span>&#123;            s=<span class="hljs-built_in">append</span>(s,s1)            k++        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,s[k<span class="hljs-number">-1</span>])    <span class="hljs-keyword">for</span> i:=k<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        fmt.Printf(<span class="hljs-string">&quot; %s&quot;</span>,s[i])    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1011 A+B 和 C</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1011%20A+B%E5%92%8CC/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1011%20A+B%E5%92%8CC/</url>
    
    <content type="html"><![CDATA[<h3 id="A-B-和-C"><a href="#A-B-和-C" class="headerlink" title="A+B 和 C"></a><font size=6px>A+B 和 C</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定区间 [−231,231] 内的 3 个整数 <em>A</em>、<em>B</em> 和 <em>C</em>，请判断 <em>A</em>+<em>B</em> 是否大于 <em>C</em>。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第 1 行给出正整数 <em>T</em> (≤10)，是测试用例的个数。随后给出 <em>T</em> 组测试用例，每组占一行，顺序给出 <em>A</em>、<em>B</em> 和 <em>C</em>。整数间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出 <code>Case #X: true</code> 如果 <em>A</em>+<em>B</em>&gt;<em>C</em>，否则输出 <code>Case #X: false</code>，其中 <code>X</code> 是测试用例的编号（从 1 开始）。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">41 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">Case #1: falseCase #2: trueCase #3: trueCase #4: false</code></pre><h4 id="思路-无"><a href="#思路-无" class="headerlink" title="思路:无"></a>思路:无</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,i <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> a,b,c <span class="hljs-type">int64</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">for</span> i&lt;n&#123;        fmt.Scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c)        fmt.Printf(<span class="hljs-string">&quot;Case #%d: &quot;</span>,i+<span class="hljs-number">1</span>)        <span class="hljs-comment">//fmt.Println(&quot;%d  %d&quot;,a+b,c)</span>        <span class="hljs-keyword">if</span> a+b&gt;c&#123;            fmt.Printf(<span class="hljs-string">&quot;true&quot;</span>)        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;false&quot;</span>)        &#125;        fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)        i++    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1013 数素数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1013%20%E6%95%B0%E7%B4%A0%E6%95%B0%20/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1013%20%E6%95%B0%E7%B4%A0%E6%95%B0%20/</url>
    
    <content type="html"><![CDATA[<h3 id="数素数"><a href="#数素数" class="headerlink" title="数素数"></a><font size=6px>数素数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>令 <em>P**i</em> 表示第 <em>i</em> 个素数。现任给两个正整数 <em>M</em>≤<em>N</em>≤104，请输出 <em>P**M</em> 到 <em>P**N</em> 的所有素数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出 <em>M</em> 和 <em>N</em>，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出从 <em>P**M</em> 到 <em>P**N</em> 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">5 27</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">11 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103</code></pre><h4 id="思路-先预处理求出前10000个素数，然后再输出想要的素数"><a href="#思路-先预处理求出前10000个素数，然后再输出想要的素数" class="headerlink" title="思路:先预处理求出前10000个素数，然后再输出想要的素数"></a>思路:先预处理求出前10000个素数，然后再输出想要的素数</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,i,a,b,k <span class="hljs-type">int</span>    k=<span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> primenumber []<span class="hljs-type">int</span>    i=<span class="hljs-number">2</span>    <span class="hljs-comment">//求前10000个素数</span>    <span class="hljs-keyword">for</span> n&lt;<span class="hljs-number">10000</span>&#123;        <span class="hljs-keyword">if</span> prime(i)==<span class="hljs-literal">true</span>&#123;            primenumber=<span class="hljs-built_in">append</span>(primenumber,i)            n++        &#125;        i++    &#125;    fmt.Scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)    <span class="hljs-keyword">for</span> i=a;i&lt;=b;i++&#123;        k++        <span class="hljs-keyword">if</span> i==b&#123;            fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,primenumber[i<span class="hljs-number">-1</span>])        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//为了满足十个数字换行</span>            <span class="hljs-keyword">if</span> k==<span class="hljs-number">10</span>&#123;                fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>,primenumber[i<span class="hljs-number">-1</span>])                k=<span class="hljs-number">0</span>            &#125;<span class="hljs-keyword">else</span>&#123;                fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>,primenumber[i<span class="hljs-number">-1</span>])            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">//判断素数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prime</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span>  <span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-type">int</span>(math.Sqrt(<span class="hljs-type">float64</span>(n)));i++&#123;        <span class="hljs-keyword">if</span> n% i==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1010 一元多项式求导</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1010%20%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1010%20%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="一元多项式求导"><a href="#一元多项式求导" class="headerlink" title="一元多项式求导"></a><font size=6px>一元多项式求导</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设计函数求一元多项式的导数。（注：<em>x**n</em>（<em>n</em>为整数）的一阶导数为<em>n<strong>x</strong>n</em>−1。）</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 <code>0 0</code>。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code class="hljs in">3 4 -5 2 6 1 -2 0</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code class="hljs out">12 3 -10 1 6 0</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>感觉题目没有说的很清楚，就是最后一个是阶乘是0的话就结束，然后有测试点不是以阶乘为0结束</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-comment">//golang版</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">int</span>        fmt.Scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)        <span class="hljs-keyword">if</span> b==<span class="hljs-number">0</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;0 0&quot;</span>)            <span class="hljs-keyword">return</span>        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;%d %d&quot;</span>,a*b,b<span class="hljs-number">-1</span>)        &#125;        <span class="hljs-keyword">for</span>&#123;            _,err:=fmt.Scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)            <span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;                <span class="hljs-keyword">break</span>            &#125;            <span class="hljs-keyword">if</span> b==<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">break</span>            &#125;<span class="hljs-keyword">else</span>&#123;                fmt.Printf(<span class="hljs-string">&quot; %d %d&quot;</span>,a*b,b<span class="hljs-number">-1</span>)            &#125;        &#125;&#125;</code></pre><pre><code class="hljs c"><span class="hljs-comment">//c语言版</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> a,b;         <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);        <span class="hljs-keyword">if</span> (b==<span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 0&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,a*b,b<span class="hljs-number">-1</span>);        &#125;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)!=EOF)&#123;            <span class="hljs-keyword">if</span> (b==<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d %d&quot;</span>,a*b,b<span class="hljs-number">-1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1015 德才论</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1015%20%E5%BE%B7%E6%89%8D%E8%AE%BA/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1015%20%E5%BE%B7%E6%89%8D%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="德才论"><a href="#德才论" class="headerlink" title="德才论"></a><font size=6px>德才论</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p><p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出 3 个正整数，分别为：<em>N</em>（≤105），即考生总数；<em>L</em>（≥60），为录取最低分数线，即德分和才分均不低于 <em>L</em> 的考生才有资格被考虑录取；<em>H</em>（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 <em>H</em>，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 <em>L</em> 的考生也按总分排序，但排在第三类考生之后。</p><p>随后 <em>N</em> 行，每行给出一位考生的信息，包括：<code>准考证号 德分 才分</code>，其中<code>准考证号</code>为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出第一行首先给出达到最低分数线的考生人数 <em>M</em>，随后 <em>M</em> 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">14 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">1210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跟着题目思路，分好四类，并把数据存入结构体，排序条件要注意一下，题目没有给全，应该是在同一类总分相同，再按德分降序，在按编号升序。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;<span class="hljs-keyword">struct</span> Info&#123;<span class="hljs-type">int</span> id;<span class="hljs-type">int</span> de ;<span class="hljs-type">int</span> cai ;<span class="hljs-type">int</span> total ;&#125;;<span class="hljs-type">bool</span> cmp(Info a,Info b)&#123;<span class="hljs-keyword">if</span> (a.total!=b.total)&#123;<span class="hljs-keyword">return</span> a.total&gt;b.total;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.de!=b.de)&#123;<span class="hljs-keyword">return</span> a.de&gt;b.de;&#125; <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> a.id&lt;b.id;&#125;&#125; <span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> num,a,b,c,d,m,n;scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;num,&amp;m,&amp;n);<span class="hljs-keyword">struct</span> Info info[num];<span class="hljs-keyword">struct</span> Info first[num];<span class="hljs-keyword">struct</span> Info second[num];<span class="hljs-keyword">struct</span> Info third[num];<span class="hljs-keyword">struct</span> Info forth[num];<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;d=<span class="hljs-number">0</span>;while(num--)&#123;scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;info[i].id,&amp;info[i].de,&amp;info[i].cai);info[i].total=info[i].cai+info[i].de;<span class="hljs-keyword">if</span> (info[i].cai&gt;=n&amp;&amp;info[i].de&gt;=n)&#123;first[a++]=info[i];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(info[i].de&gt;=n&amp;&amp;info[i].cai&gt;=m)&#123;second[b++]=info[i];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(info[i].de&gt;=m&amp;&amp;info[i].cai&gt;=m&amp;&amp;info[i].de&gt;=info[i].cai)&#123;third[c++]=info[i];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(info[i].de&gt;=m&amp;&amp;info[i].cai&gt;=m)&#123;forth[d++]=info[i];&#125;i++;&#125;<span class="hljs-comment">//进行排序</span>sort(first,first+a,cmp);sort(second,second+b,cmp);sort(third,third+c,cmp);sort(forth,forth+d,cmp);printf(<span class="hljs-string">&quot;%d\n&quot;</span>,a+b+c+d);i=<span class="hljs-number">0</span>;while(a--)&#123;printf(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,first[i].id,first[i].de,first[i].cai);i++;&#125;i=<span class="hljs-number">0</span>;while(b--)&#123;printf(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,second[i].id,second[i].de,second[i].cai);i++;&#125;i=<span class="hljs-number">0</span>;while(c--)&#123;printf(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,third[i].id,third[i].de,third[i].cai);i++;&#125;i=<span class="hljs-number">0</span>;while(d--)&#123;printf(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,forth[i].id,forth[i].de,forth[i].cai);i++;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1017 A除以B</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1017%20A%E9%99%A4%E4%BB%A5B/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1017%20A%E9%99%A4%E4%BB%A5B/</url>
    
    <content type="html"><![CDATA[<h3 id="A除以B"><a href="#A除以B" class="headerlink" title="A除以B"></a><font size=6px>A除以B</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题要求计算 <em>A</em>&#x2F;<em>B</em>，其中 <em>A</em> 是不超过 1000 位的正整数，<em>B</em> 是 1 位正整数。你需要输出商数 <em>Q</em> 和余数 <em>R</em>，使得 <em>A</em>&#x3D;<em>B</em>×<em>Q</em>+<em>R</em> 成立。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中依次给出 <em>A</em> 和 <em>B</em>，中间以 1 空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中依次输出 <em>Q</em> 和 <em>R</em>，中间以 1 空格分隔。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">123456789050987654321 7</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">17636684150141093474 3</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> s,q <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> num,sum <span class="hljs-type">int</span>    fmt.Scan(&amp;s,&amp;num)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        sum=sum*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s)&gt;<span class="hljs-number">1</span>&#123;            <span class="hljs-keyword">if</span> i!=<span class="hljs-number">0</span>&#123;                q=q+strconv.Itoa(sum/num)                sum %= num            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            q=q+strconv.Itoa(sum/num)            sum %= num        &#125;    &#125;    fmt.Printf(<span class="hljs-string">&quot;%s %d\n&quot;</span>,q,sum)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1025 反转链表</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1025%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1025%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><font size=6px>反转链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个常数 <em>K</em> 以及一个单链表 <em>L</em>，请编写程序将 <em>L</em> 中每 <em>K</em> 个结点反转。例如：给定 <em>L</em> 为 1→2→3→4→5→6，<em>K</em> 为 3，则输出应该为 3→2→1→6→5→4；如果 <em>K</em> 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 <em>K</em> 个元素不反转。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em> (≤<em>N</em>)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span></code></pre><p>其中 <code>Address</code> 是结点地址，<code>Data</code> 是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">00100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">00000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用l接收初始数据，用l1接收标好序号的数据，用l2去接收倒序后的数据，用空间换时间，代码很烂，但是能过。</p><p>坑点：最后一个测试点有部分数据是无用的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;using namespace std;<span class="hljs-keyword">struct</span> list&#123;<span class="hljs-type">int</span> add;<span class="hljs-type">int</span> data;<span class="hljs-type">int</span> next;&#125;l[<span class="hljs-number">100002</span>],l1[<span class="hljs-number">100002</span>],l2[<span class="hljs-number">100002</span>];<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> first,n,k,a,flag,num;scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;first,&amp;n,&amp;k);<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;while(m&lt;n)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l[a].data,&amp;l[a].next);l[a].add=a;m++;&#125;<span class="hljs-type">int</span> linshi=first;m=<span class="hljs-number">0</span>;<span class="hljs-comment">//使他有序化 </span>while(l[linshi].next!=<span class="hljs-number">-1</span>)&#123;l1[m]=l[linshi];m++;linshi=l[linshi].next;num++;&#125;n=num+<span class="hljs-number">1</span>;l1[m] = l[linshi];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n/k;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*k;j&lt;i*k+k;j++)&#123;<span class="hljs-type">int</span> y=i*k+k-(j-i*k)<span class="hljs-number">-1</span>;l2[y]=l1[j];&#125;  &#125; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-(n%k);i++)&#123;<span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>)&#123;printf(<span class="hljs-string">&quot;%05d %d &quot;</span>,l2[i].add,l2[i].data);&#125;<span class="hljs-keyword">else</span>&#123;printf(<span class="hljs-string">&quot;%05d\n%05d %d &quot;</span>,l2[i].add,l2[i].add,l2[i].data);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-(n%k);i&lt;n;i++)&#123;printf(<span class="hljs-string">&quot;%05d\n%05d %d &quot;</span>,l1[i].add,l1[i].add,l1[i].data);&#125;printf(<span class="hljs-string">&quot;-1\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1027 打印沙漏</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1027%20%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1027%20%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="打印沙漏"><a href="#打印沙漏" class="headerlink" title="打印沙漏"></a><font size=6px>打印沙漏</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p><pre><code class="hljs asciidoc">***** ***  * ********</code></pre><p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p><p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code class="hljs in">19 *</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code class="hljs out">***** ***  * ********2</code></pre><h4 id="思路-简答题，无"><a href="#思路-简答题，无" class="headerlink" title="思路:简答题，无"></a>思路:简答题，无</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> num,sum,i <span class="hljs-type">int</span>    fmt.Scan(&amp;num,&amp;s)    sum=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">2</span>;i&lt;<span class="hljs-number">1001</span>;i++&#123;        <span class="hljs-keyword">if</span> sum&gt;num&#123;            sum=sum-(<span class="hljs-number">4</span>*i)+<span class="hljs-number">6</span>            <span class="hljs-keyword">break</span>        &#125;        sum+=<span class="hljs-number">4</span>*i<span class="hljs-number">-2</span>    &#125;    i=i<span class="hljs-number">-2</span>   <span class="hljs-comment">//打印上面的三角</span>    <span class="hljs-keyword">for</span> j:=i;j&gt;<span class="hljs-number">0</span>;j--&#123;        <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;i-j;k++&#123;            fmt.Printf(<span class="hljs-string">&quot; &quot;</span>)        &#125;        <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;j*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;k++&#123;            fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,s)        &#125;        fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)    &#125;   <span class="hljs-comment">//打印下面的三角</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">2</span>;j&lt;=i;j++&#123;       <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;i-j;k++&#123;           fmt.Printf(<span class="hljs-string">&quot; &quot;</span>)       &#125;       <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;j*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;k++&#123;           fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>,s)       &#125;       fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)   &#125;   <span class="hljs-comment">//输出剩下没用掉的符号数</span>   fmt.Println(num-sum)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1030 完美数列</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1030%20%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1030%20%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="完美数列"><a href="#完美数列" class="headerlink" title="完美数列"></a><font size=6px>完美数列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个正整数数列，和正整数 <em>p</em>，设这个数列中的最大值是 <em>M</em>，最小值是 <em>m</em>，如果 <em>M</em>≤<em>m**p</em>，则称这个数列是完美数列。</p><p>现在给定参数 <em>p</em> 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数 <em>N</em> 和 <em>p</em>，其中 <em>N</em>（≤105）是输入的正整数的个数，<em>p</em>（≤109）是给定的参数。第二行给出 <em>N</em> 个正整数，每个数不超过 109。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">10 82 3 20 4 5 1 6 7 8 9</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">8</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从第一个开始找，找到最大可以符合完美数列的数，下标为i，然后从第二个开始找，直接从i+1个下标的数开始找是否还有符合完美数列的数存在，如果有就把值赋给result，注意加上如果条件不成立就break节省时间，不然倒数第二个测试点过不去</p><p><strong>注意点</strong>：p和num数组是个长整型，输入和输出格式注意一下</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;<span class="hljs-type">bool</span> cmp(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;<span class="hljs-keyword">return</span> a&lt;b;&#125;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n,i,temp;long long p;scanf(<span class="hljs-string">&quot;%d %lld&quot;</span>,&amp;n,&amp;p);long long num[n+<span class="hljs-number">1</span>];i=<span class="hljs-number">0</span>;while(i&lt;n)&#123;scanf(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;num[i]);i++;&#125;<span class="hljs-type">int</span> result=<span class="hljs-number">0</span>;sort(num,num+n,cmp);<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+result;j&lt;n;j++)&#123;<span class="hljs-keyword">if</span>(num[i]*p&gt;=num[j])&#123;temp=j-i+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(temp&gt;result)&#123;result = temp;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125; printf(<span class="hljs-string">&quot;%d\n&quot;</span>,result);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1033 旧键盘打字</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1033%20%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1033%20%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="旧键盘打字"><a href="#旧键盘打字" class="headerlink" title="旧键盘打字"></a><font size=6px>旧键盘打字</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 105 个字符的串。可用的字符包括字母 [<code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>]、数字 <code>0</code>-<code>9</code>、以及下划线 <code>_</code>（代表空格）、<code>,</code>、<code>.</code>、<code>-</code>、<code>+</code>（代表上档键）。题目保证第 2 行输入的文字串非空。</p><p>注意：如果上档键坏掉了，那么大写的英文字母无法被打出。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">7+IE.7_This_is_a_test.</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">_hs_s_a_tst</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h6 id="题读错了，我以为、-、-、-、-（代表上档键）代表上档键，其实只有加号才代表上挡键，s1有可能是空行。"><a href="#题读错了，我以为、-、-、-、-（代表上档键）代表上档键，其实只有加号才代表上挡键，s1有可能是空行。" class="headerlink" title="题读错了，我以为、,、.、-、+（代表上档键）代表上档键，其实只有加号才代表上挡键，s1有可能是空行。"></a>题读错了，我以为、<code>,</code>、<code>.</code>、<code>-</code>、<code>+</code>（代表上档键）代表上档键，其实只有加号才代表上挡键，s1有可能是空行。</h6><h6 id="思路：只要这个字母出现过，就把acs【i】置1，最后判断s2中的字母的asc值是否为1，是0就输出。"><a href="#思路：只要这个字母出现过，就把acs【i】置1，最后判断s2中的字母的asc值是否为1，是0就输出。" class="headerlink" title="思路：只要这个字母出现过，就把acs【i】置1，最后判断s2中的字母的asc值是否为1，是0就输出。"></a>思路：只要这个字母出现过，就把acs【i】置1，最后判断s2中的字母的asc值是否为1，是0就输出。</h6><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> asc [<span class="hljs-number">128</span>]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> s1,s2,s3 <span class="hljs-type">string</span>    fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s1)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1);i++&#123;        <span class="hljs-keyword">if</span> s1[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;s1[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>&#123;            asc[s1[i]+<span class="hljs-number">32</span>]=<span class="hljs-number">1</span>        &#125;        asc[s1[i]]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">if</span> asc[<span class="hljs-string">&#x27;+&#x27;</span>]==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-string">&#x27;A&#x27;</span>;i&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>;i++&#123;            asc[i]=<span class="hljs-number">1</span>        &#125;    &#125;    fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s2)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s2);i++&#123;        <span class="hljs-keyword">if</span> asc[s2[i]]==<span class="hljs-number">0</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>,s2[i])        &#125;    &#125;    fmt.Print(s3)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1001 害死人不偿命的3n+1猜想</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1001%20%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%843n+1%E7%8C%9C%E6%83%B3%20/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1001%20%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%843n+1%E7%8C%9C%E6%83%B3%20/</url>
    
    <content type="html"><![CDATA[<h3 id="害死人不偿命的3n-1猜想"><a href="#害死人不偿命的3n-1猜想" class="headerlink" title="害死人不偿命的3n+1猜想 "></a><font size=6px>害死人不偿命的3n+1猜想 </font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>卡拉兹(Callatz)猜想：</p><p>对任何一个正整数 <em>n</em>，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3<em>n</em>+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 <em>n</em>&#x3D;1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3<em>n</em>+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p><p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 <em>n</em>，简单地数一下，需要多少步（砍几下）才能得到 <em>n</em>&#x3D;1？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em> 的值。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出从 <em>n</em> 计算到 1 需要的步数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">3</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">5</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无，看代码</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> a,k <span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a)    <span class="hljs-keyword">for</span> a!=<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> a%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&#123;            a=a/<span class="hljs-number">2</span>        &#125;<span class="hljs-keyword">else</span>&#123;            a=(<span class="hljs-number">3</span>*a+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>        &#125;        k++    &#125;    fmt.Println(k)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1002 写出这个数</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1002%20%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1002%20%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="写出这个数"><a href="#写出这个数" class="headerlink" title="写出这个数"></a><font size=6px>写出这个数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>读入一个正整数 <em>n</em>，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出自然数 <em>n</em> 的值。这里保证 <em>n</em> 小于 10100。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行内输出 <em>n</em> 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">1234567890987654321123456789</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">yi san wu</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>思路还是很简单的，用string接受，然后一位位加起来成sum，最后把sum转化成切片，再转化成中文输出（这一步用map会更好）写’jiu‘的时候写成了’qiu‘，卡了我半天，我是憨批，而且写的很冗长，比较烂</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>    fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s)    <span class="hljs-comment">//转化成合数</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        sum=sum+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    sumLen:=<span class="hljs-built_in">len</span>(strconv.Itoa(sum))    sumSlice:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,sumLen)    <span class="hljs-comment">//转换成切片</span>    <span class="hljs-keyword">for</span> i:=sumLen;i&gt;<span class="hljs-number">0</span>;i--&#123;        sumSlice[sumLen-i]=sum / <span class="hljs-type">int</span>(math.Pow(<span class="hljs-number">10</span>,<span class="hljs-type">float64</span> (i)<span class="hljs-number">-1</span>)) %<span class="hljs-number">10</span>    &#125;    <span class="hljs-comment">//fmt.Println(sumSlice)</span>    <span class="hljs-keyword">switch</span> (sumSlice[<span class="hljs-number">0</span>]) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: fmt.Print(<span class="hljs-string">&quot;ling&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: fmt.Print(<span class="hljs-string">&quot;yi&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: fmt.Print(<span class="hljs-string">&quot;er&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: fmt.Print(<span class="hljs-string">&quot;san&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: fmt.Print(<span class="hljs-string">&quot;si&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: fmt.Print(<span class="hljs-string">&quot;wu&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: fmt.Print(<span class="hljs-string">&quot;liu&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: fmt.Print(<span class="hljs-string">&quot;qi&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: fmt.Print(<span class="hljs-string">&quot;ba&quot;</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: fmt.Print(<span class="hljs-string">&quot;jiu&quot;</span>)        <span class="hljs-keyword">break</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;sumLen;i++&#123;        <span class="hljs-keyword">switch</span> (sumSlice[i]) &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: fmt.Print(<span class="hljs-string">&quot; ling&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: fmt.Print(<span class="hljs-string">&quot; yi&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: fmt.Print(<span class="hljs-string">&quot; er&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: fmt.Print(<span class="hljs-string">&quot; san&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: fmt.Print(<span class="hljs-string">&quot; si&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: fmt.Print(<span class="hljs-string">&quot; wu&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: fmt.Print(<span class="hljs-string">&quot; liu&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: fmt.Print(<span class="hljs-string">&quot; qi&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: fmt.Print(<span class="hljs-string">&quot; ba&quot;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: fmt.Print(<span class="hljs-string">&quot; jiu&quot;</span>)            <span class="hljs-keyword">break</span>        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1003 我要通过</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1003%20%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1003%20%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h3 id="我要通过"><a href="#我要通过" class="headerlink" title="我要通过"></a><font size=6px>我要通过</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>“<strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。</p><p>得到“<strong>答案正确</strong>”的条件是：</p><ol><li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li><li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li><li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。</li></ol><p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 <em>n</em> (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">8PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">YESYESYESYESNONONONO</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先读懂题目，只能有P A T三个字母，其他字母不行</p><p><strong>3、如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。</strong>最重要是第三个条件，设P前面的A的数量为counta，P和T中间A的数量为countb，T之后的A的数量为countc，找规律就可以知道countc&#x3D;counta*countb，这个规律知道之后就好写了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n , i ,j , counta ,countb,countc,flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">for</span> i&lt;n&#123;                fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s)        <span class="hljs-comment">//判断有无其他字符</span>        <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;<span class="hljs-built_in">len</span>(s);k++&#123;            <span class="hljs-keyword">if</span> s[k]!=<span class="hljs-string">&#x27;P&#x27;</span>&amp;&amp;s[k]!=<span class="hljs-string">&#x27;T&#x27;</span>&amp;&amp;s[k]!=<span class="hljs-string">&#x27;A&#x27;</span>&#123;                i++                flag=<span class="hljs-number">1</span>                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> flag==<span class="hljs-number">1</span>&#123;            flag=<span class="hljs-number">0</span>            fmt.Printf(<span class="hljs-string">&quot;NO\n&quot;</span>)            <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">for</span> j&lt;<span class="hljs-built_in">len</span>(s)&amp;&amp;s[j]!=<span class="hljs-string">&#x27;P&#x27;</span>&#123;            counta++            j++        &#125;        j++        <span class="hljs-keyword">for</span> j&lt;<span class="hljs-built_in">len</span>(s)&amp;&amp;s[j]!=<span class="hljs-string">&#x27;T&#x27;</span>&#123;            countb++            j++        &#125;        countc=<span class="hljs-built_in">len</span>(s)-countb-counta<span class="hljs-number">-2</span>        <span class="hljs-comment">//println(counta ,countb ,countc)</span>        <span class="hljs-keyword">if</span> countb==<span class="hljs-number">0</span>||counta*countb!=countc&#123;            fmt.Printf(<span class="hljs-string">&quot;NO\n&quot;</span>)        &#125;<span class="hljs-keyword">else</span> &#123;            fmt.Printf(<span class="hljs-string">&quot;YES\n&quot;</span>)        &#125;        <span class="hljs-comment">//清零</span>        countc=<span class="hljs-number">0</span>        counta=<span class="hljs-number">0</span>        countb=<span class="hljs-number">0</span>        j=<span class="hljs-number">0</span>        i++    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1004 成绩排名</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1004%20%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1004%20%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="成绩排名"><a href="#成绩排名" class="headerlink" title="成绩排名"></a><font size=6px>成绩排名</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>读入 <em>n</em>（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，格式为</p><pre><code class="hljs tap">第<span class="hljs-number"> 1 </span>行：正整数 n第<span class="hljs-number"> 2 </span>行：第<span class="hljs-number"> 1 </span>个学生的姓名 学号 成绩第<span class="hljs-number"> 3 </span>行：第<span class="hljs-number"> 2 </span>个学生的姓名 学号 成绩  ... ... ...第 n+1 行：第 n 个学生的姓名 学号 成绩</code></pre><p>其中<code>姓名</code>和<code>学号</code>均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">3Joe Math990112 89Mike CS991301 100Mary EE990830 95</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">Mike CS991301Joe Math990112</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>挺简单的题目，用map来写，注意map要写101个大小，因为有0分和100分，如果n&#x3D;&#x3D;1时要输入两遍一样的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> s1 ,s2,s <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> score,n,i <span class="hljs-type">int</span>    mp:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>,<span class="hljs-number">101</span>)    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">1</span>&#123;        fmt.Scanf(<span class="hljs-string">&quot;%s%s%d&quot;</span>,&amp;s1,&amp;s2,&amp;score)        fmt.Println(s1+<span class="hljs-string">&quot; &quot;</span>+s2)        fmt.Println(s1+<span class="hljs-string">&quot; &quot;</span>+s2)    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> i&lt;n&#123;            fmt.Scanf(<span class="hljs-string">&quot;%s%s%d&quot;</span>,&amp;s1,&amp;s2,&amp;score)            s=s1+<span class="hljs-string">&quot; &quot;</span>+s2            mp[score]=s            i++        &#125;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">100</span>;j&gt;=<span class="hljs-number">0</span>;j--&#123;            <span class="hljs-keyword">if</span> mp[j]!=<span class="hljs-string">&quot;&quot;</span>&#123;                fmt.Println(mp[j])                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">100</span>;j++&#123;            <span class="hljs-keyword">if</span> mp[j]!=<span class="hljs-string">&quot;&quot;</span>&#123;                fmt.Println(mp[j])                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1005 继续3n+1猜想</title>
    <link href="/2022/01/21/PAT%E4%B9%99/1005%20%E7%BB%A7%E7%BB%AD3n+1%E7%8C%9C%E6%83%B3%20/"/>
    <url>/2022/01/21/PAT%E4%B9%99/1005%20%E7%BB%A7%E7%BB%AD3n+1%E7%8C%9C%E6%83%B3%20/</url>
    
    <content type="html"><![CDATA[<h3 id="继续3n-1猜想"><a href="#继续3n-1猜想" class="headerlink" title="继续3n+1猜想 "></a><font size=6px>继续3n+1猜想 </font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p><p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 <em>n</em>&#x3D;3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 <em>n</em>&#x3D;5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 <em>n</em> 为“关键数”，如果 <em>n</em> 不能被数列中的其他数字所覆盖。</p><p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 <em>K</em> (&lt;100)，第 2 行给出 <em>K</em> 个互不相同的待验证的正整数 <em>n</em> (1&lt;<em>n</em>≤100)的值，数字间用空格隔开。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs in">63 5 6 7 8 11</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs out">7 6</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>输出的时候一个变量名字打错竟然卡了我1个钟头？</p><p>题目理解就是在给出的k个正整数里面找到不是卡拉兹猜想的中间数，</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    <span class="hljs-keyword">var</span> n,i ,a <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> array [<span class="hljs-number">101</span>]<span class="hljs-type">int</span>    mp:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,<span class="hljs-number">101</span>)    fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)    <span class="hljs-keyword">for</span> i&lt;n&#123;        fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a)        array[i]=a        <span class="hljs-comment">//mp[]=101代表没有被覆盖</span>        mp[a]=<span class="hljs-number">101</span>        i++    &#125;    <span class="hljs-comment">//把每个数字能覆盖的都覆盖了</span>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        flag:=array[i]        <span class="hljs-keyword">for</span> array[i]!=<span class="hljs-number">1</span>&#123;            <span class="hljs-keyword">if</span> array[i]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>&#123;                array[i]=(array[i]*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>            &#125;<span class="hljs-keyword">else</span>&#123;                array[i]/=<span class="hljs-number">2</span>            &#125;            mp[array[i]]=flag        &#125;    &#125;    <span class="hljs-comment">//下面是为了使最后一个没有空格</span>    <span class="hljs-keyword">var</span> j <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> j=<span class="hljs-number">100</span>;j&gt;<span class="hljs-number">0</span>;j--&#123;        <span class="hljs-keyword">if</span> mp[j]==<span class="hljs-number">101</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,j)            <span class="hljs-keyword">break</span>        &#125;    &#125;    <span class="hljs-keyword">for</span> k:=j<span class="hljs-number">-1</span>;k&gt;<span class="hljs-number">0</span>;k--&#123;        <span class="hljs-keyword">if</span> mp[k]==<span class="hljs-number">101</span>&#123;            fmt.Printf(<span class="hljs-string">&quot; %d&quot;</span>,k)        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>PAT刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
