---
title: 字节跳动2017客户端工程师实习生笔试题
tags: [c++,array]
categories: 牛客刷题
banner_img: /img/壁纸.jpg
---

### <font size=6px>4、或与加</font>

#### 题目描述：

给定 x, k ，求满足 x + y = x | y 的第 k 小的正整数 y 。 | 是二进制的或(or)运算，例如 3 | 5 = 7。

比如当 x=5，k=1时返回 2，因为5+1=6 不等于 5|1=5，而 5+2=7 等于 5 | 2 = 7。



##### **输入描述:**

```
每组测试用例仅包含一组数据，每组数据为两个正整数 x , k。 满足 0 < x , k ≤ 2,000,000,000。
```



##### **输出描述:**

```
输出一个数y。
```



##### **输入例子1:**

```
5 1
```



##### **输出例子1:**

```
2
```

#### 思路:

x+y=x|y 

  这里可以推出一个结论，x&y=0。也就是说，在二进制上看，x取1的地方，y必定不能取1。从最低位考虑，若x与y在某一位上同时取1，则x+y在该位上为0，x|y在该位上为1，前面说这是最低一位x  y同时取1，也就是说没有更低位加法的进位，所以这里两个结果不相等，出现了矛盾。 

  例子： 

  x = 001010 

  y = 110110 

  x + y =  1000000 

  x | y = 111110 

  偏差产生的原因是倒数第二位，x+y=0 x|y=1 且倒数第一位加法没有进位 

  结论：**x在二进制取1的位上，y不能做出改变，只能取0**

  ----方法----

  有了上述结论，可以进一步推出只要在x取0的地方，y可以做出改变

  例如

  x = 10010010011

  y = 00000000(0)00  k = 0

  y = 00000000(1)00  k = 1

  y = 0000000(1)(0)00 k = 2

  y = 0000000(1)(1)00 k = 3

  y = 00000(1)0(0)(0)00 k = 4

  y = 00000(1)0(0)(1)00 k = 5

  ...

  注意观察括号里的数，为x取0的比特位，而如果把括号里的数连起来看，正好等于k。

  得出结论，**把k表示成二进制数，填入x取0的比特位，x取1的比特位保持为0，得到y**。 

  ---代码说明---

  思路有了，接着就是代码，显然用位操作是最合适的方式。 

  循环的思想是每次取得k的最低一位，填入到低位开始，x中比特位为0的位置上。 

  所以用while来判断k是否大于0，若是，说明k还未完全填完 

  循环体内，需要找到x当前可以填的位置，我们用bitNum来从右往左扫描x的每一位 



#### 代码:

```golang

```

#### 代码效率：

<p class="note note-primary"; style="font-size:22px">
   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>
   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户
</p>