---
title: go和java和c++接口的区别
excerpt: 面试自我介绍
categories: 后端面试
banner_img: /img/壁纸.jpg
---

依赖倒转原则：高层模块不应该依赖于低层模块，二者都应该依赖于抽象，接口就是高层模块和底层模块的中间层，用于降低耦合性。

接口的作用：	

1、降低类间的耦合性

2、提高并行开发的风险

java需要显示实现接口，就是需要写implement XXX，Golang是隐式实现，经典的鸭子理论，长的像鸭子，叫起来像鸭子，就是鸭子，举个例子是sort.Sort函数，只要是实现这个的interface里面的函数的类传进去就能调用他。

​	golang接口可以作为接近范型来使用，可以作为参数传入，java不行



C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 "= 0" 来指定的。例如：

class Shape

{

   public:

​      // 纯虚函数

​      virtual double getArea() = 0;

   private:

​      string name;      // 名称

};



设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。

派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。

C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。

C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 `itab` 中的 `fun` 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 `itab` 中的 `fun` 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 `itab`， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。
