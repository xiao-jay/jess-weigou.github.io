---
title: 进程线程和协程的特性和区别
excerpt: 所在模块：操作系统
tags: [操作系统]
categories: 后端面试
banner_img: /img/壁纸.jpg
---

## 进程

**进程是操作系统分配资源的最小单位**

​	一个进程中有多个线程，一个线程里面可以有多个协程，因为进程是最大的了，进程切换需要的开销很大，但是进程挂了，其他进程因为保护机制会不受影响，但是这个进程里面的线程协程也都会挂掉。

### 进程间通信的方式

1、管道，有名管道和无名管道

2、共享内存

3、信号量

4、消息队列

5、socket（不同设备间的进程通信）

## 线程

**线程是操作系统所能调度执行的最小单位**

计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程，线程是cpu调度分配的最小单位

### 线程间的通信方式

因为线程是共享内存的，所以通信的时候只需要加锁防止访问冲突就行

##### 锁机制：包括互斥锁、条件变量、读写锁

互斥锁提供了以排他方式防止数据结构被并发修改的方法。 
读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 
条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

### 线程的几种状态

**1、新建状态(New)**：新创建了一个线程对象。

**2、就绪状态(Runnable)**：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权，

  即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。

**3、运行状态(Running)**：就绪状态的线程获取了CPU，执行程序代码。

**4、阻塞状态(Blocked)**：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

  阻塞的情况分三种：

①.等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，

  必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，

②.同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。

③.其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时，

  或者I/O处理完毕时，线程重新转入就绪状态。

**5、死亡状态(Dead)**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。



### 什么是线程死锁？

**概念：**线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行

#### 死锁产生的原因

- 系统资源不足
- 进程推进的顺便不合适
- 资源分配不当

#### 产生死锁的条件

- **互斥条件：**进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放
- **请求和保持条件：**一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。
- **不剥夺条件：**任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用
- **循环等待条件：**当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。

#### 处理死锁的方法

破坏产生死锁的必要条件，增加系统资源，改变合理的进程推进顺序，改善资源分配方式

## 协程

**协程是用户态的轻量级线程，操作系统所不能开辟的，但是可以由程序控制**

### 协程的优势

1、极高的执行效率，因为子程序切换不是线程切换，而是程序自身切换，没有线程切换开销效率高。

2、不需要多线程的锁机制，因为只有一个线程不存在同时写变量冲突。



### 为什么协程切换代价比线程低

协程切换流程：

1、保存当前寄存器信息

2、选择下一个要执行的协程

3、恢复寄存器上下文

线程切换流程：

1、软中断

2、保存寄存器信息到内核堆栈、

3、选择下一个要执行的线程

4、恢复上下文

5、返回用户堆栈

需要保存的寄存器信息大小不同，线程需要把寄存器保存到内核堆栈，并且 返回用户堆栈

协程无多线程锁机制，因为一个协程运行就一个线程。

协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

**协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行**。

协程的特点在于是一个线程执行

极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；

不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

#### go语言内的协程

goroutine 非常的**轻量**，初始分配只有 2KB，当栈空间不够用时，会自动扩容。同时，自身存储了执行 stack 信息，用于在调度时能恢复上下文信息。

而线程比较重，一般初始大小有几 MB(不同系统分配不同)，线程是由操作系统调度，是操作系统的调度基本单位。而 golang 实现了自己的调度机制，goroutine 是它的调度基本单位。
