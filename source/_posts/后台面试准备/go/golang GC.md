---
title: golang GC
excerpt: 所在模块：golang
tags: [golang]
categories: 后端面试
banner_img: /img/壁纸.jpg
---

# Golang 的垃圾回收

## Golang1.0 标记清除算法

串行的标记清除算法，会导致长时间stw（stop the world）时间，造成资源浪费。

## Golang 1.5三色标记法

Go的垃圾收集的整个过程可以分成标记准备、标记、标记终止和清除四个不同阶段

​	Golang 使用三色标记法，开始每个事件都是白色，扫描到一个进程，标记为灰色，就把他丢入队列，每次从队列取出来一个，从这个事件的开始遍历这个事件引出的其他事件，然后把这个事件标记成黑色，有bfs那味，不会重新遍历黑色的事件，直到灰色事件队列没事件了，清除白色事件。

### 写屏障

因为程序与标记是并发运行的，可能这个事件已经是黑色的还会引出事件，这个时候新事件还是白色，会被清除，这个时候加入写屏障，约定在清扫开始前黑色事件不引出其他事件



想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：

- 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
- 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径

#### 插入写屏障

Dijkstra 在 1978 年提出了插入写屏障，通过如下所示的写屏障，用户程序和垃圾收集器可以在交替工作的情况下保证程序执行的正确性：

```go
writePointer(slot, ptr):
    shade(ptr)
    *slot = ptr
```



上述插入写屏障的伪代码非常好理解，每当执行类似 `*slot = ptr` 的表达式时，我们会执行上述写屏障通过 `shade` 函数尝试改变指针的颜色。如果 `ptr` 指针是白色的，那么该函数会将该对象设置成灰色，其他情况则保持不变。

![dijkstra-insert-write-barrier](https://img.draveness.me/2020-03-16-15843705141840-dijkstra-insert-write-barrier.png)

**图 7-29 Dijkstra 插入写屏障**

假设我们在应用程序中使用 Dijkstra 提出的插入写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：

1. 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；
2. 用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色；
3. 垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；

Dijkstra 的插入写屏障是一种相对保守的屏障技术，它会将**有存活可能的对象都标记成灰色**以满足强三色不变性。在如上所示的垃圾收集过程中，实际上不再存活的 B 对象最后没有被回收；而如果我们在第二和第三步之间将指向 C 对象的指针改回指向 B，垃圾收集器仍然认为 C 对象是存活的，这些被错误标记的垃圾对象只有在下一个循环才会被回收。

插入式的 Dijkstra 写屏障虽然实现非常简单并且也能保证强三色不变性，但是它也有明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之间做出权衡。



#### 删除写屏障 

Yuasa 在 1990 年的论文 Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它会保证开启写屏障时堆上所有对象的可达，所以也被称作快照垃圾收集（Snapshot GC）[10](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:10)：

> This guarantees that no objects will become unreachable to the garbage collector traversal all objects which are live at the beginning of garbage collection will be reached even if the pointers to them are overwritten.

该算法会使用如下所示的写屏障保证增量或者并发执行垃圾收集时程序的正确性：

```go
writePointer(slot, ptr)
    shade(*slot)
    *slot = ptr
```



上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。

![yuasa-delete-write-barrier](https://img.draveness.me/2021-01-02-16095599123266-yuasa-delete-write-barrier.png)

**图 7-29 Yuasa 删除写屏障**

假设我们在应用程序中使用 Yuasa 提出的删除写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：

1. 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；
2. 用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；
3. **用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色**；
4. 垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；

GC触发条件：

1、长时间（2分钟）没GC，就GC一次

2、内存分配到一定比例，或者堆内存占用比上次增加了100%

3、手动



#### 标记好之后是怎么回收内存的

​	标记完之后会扫描堆栈中每一个对象，如果不是黑色就把对象清空，并且用链表把每一个空闲空间链接起来。
