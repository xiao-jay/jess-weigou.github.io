---
title: 切片（1.18版本的golang已经改变之前的分配方式）
---

### 1.18版本golang slice切片扩容代码

```
newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		const threshold = 256
		if old.cap < threshold {
			newcap = doublecap
		} else {
			// Check 0 < newcap to detect overflow
			// and prevent an infinite loop.
			for 0 < newcap && newcap < cap {
				// Transition from growing 2x for small slices
				// to growing 1.25x for large slices. This formula
				// gives a smooth-ish transition between the two.
				newcap += (newcap + 3*threshold) / 4
			}
			// Set newcap to the requested cap when
			// the newcap calculation overflowed.
			if newcap <= 0 {
				newcap = cap
			}
		}
	}
```

明显看到不再是1024之后再每次增加百分之25了，

#### 1、切片扩容流程

如果超过容量，会重新扩一个内存，创建新的数组，并把指针指向这个数组，容量如果不超过1024会阔一倍，如果容量超过1024扩容量会每次增加25%。

```
package main

import (
    "fmt"
)

func main() {
    a := []int{}
    for i := 0; i < 33; i++ {
        a = append(a, i)
        fmt.Print(cap(a), " ")
    }
}
```

结果：

```
1 2 4 4 8 8 8 8 16 16 16 16 16 16 16 16 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 64 
```

#### 2、切片和数组区别

- 切片是可以扩容的，数组定好之后就不能扩容，大小固定

- ```
  var` `x[3]int = [3]int{1,2,3}
  var` `y[3]int = x
  fmt.Println(x,y)
  y[0]=999
  fmt.Println(x,y)　
  ```

结果

```
[1 2 3] [1 2 3]
[1 2 3] [999 2 3]
```





```
var x[]int = []int{1,2,3}
var y[]int = x
fmt.Println(x,y)
y[0]=999
fmt.Println(x,y)　
```

结果

```
[1 2 3] [1 2 3]
[999 2 3] [999 2 3]
```

结论：切片赋值是指针赋值，不是简单的数复制，子改变了父也会改变。

#### 3、make默认值和append

```
func main() {
	s := make([]int, 5)
	s = append(s, 1, 2, 3)
	fmt.Println(s)
}
```

```
[0 0 0 0 0 1 2 3]
```

解析：

产生5个空int类型，之后插入1，2，3

