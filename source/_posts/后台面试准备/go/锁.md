---
title: golang Mutex
excerpt: 所在模块：golang
tags: [golang]
categories: 后端面试
banner_img: /img/壁纸.jpg
---

**我们先来看怎么实现一个最简单的互斥锁，在开始之前可以先想一想，如果是你，你会怎么设计呢？**

**你可能会想到，可以通过一个 flag 变量，标记当前的锁是否被某个 goroutine 持有。如果这个 flag 的值是 1，就代表锁已经被持有，那么其它竞争的 goroutine 只能等待；如果这个 flag 的值是 0，就可以通过 CAS（compare-and-swap，或者 compare-and-set）将这个 flag 设置为 1，标识锁被当前的这个 goroutine 持有了。**

**整个逻辑很简单，但事实上早期的 Mutex 就是这么设计的，不过在看源码之前我们需要先了解一下什么是 CAS，它非常重要。**

#### CAS 是什么

**假设有一个块内存，里面存储的值是 a，但是现在想将其变成 a + b，这个时候需要经历哪几步呢？**

- `将存储的值读取出来，得到 a`
- `将 a 和 b 进行加法运算，得到 a + b`
- `再将计算后的新值 a + b 写回到原来的内存中，也就是将原来的值 a 给更新掉`

**单线程的话是没有任何问题的，但如果是多个线程同时操作这块内存呢？显然可能会出问题。因此需要通过 CAS 解决这一点，首先它会将内存中原本的值备份一份，运算之后会比较此时内存的值和备份的值，如果一致才进行更新，如果不一致则什么也不做。比如一开始内存的值是 a，备份一份，然后计算完毕之后发现内存的值变成了 a1，前后不一致，说明其它线程已经将这块内存的值给修改了，那么此时就不会再更新了；如果一致，说明没有别的线程修改这个内存的数据，那么此时才会更新。**

> **所以 CAS 的名字很直观，就是先比较、然后再决定是否更新（设置），并且整体是原子性的。**

**CAS 是实现互斥锁和并发原语的基础，我们有必要掌握它。**



## sync.Mutex

这是sync包的互斥锁，加了之后不需要其他goroutine读取，只允许这个读取

加锁是原语操作

当goutine超过1ms因为锁请求不到资源的时候，会变成饥饿模式，下次允许优先获得锁。

## sync.RWMutex

这个sync包的读写锁，加了之后运行其他goroutine读，不允许其他进程写







参考文档：https://www.cnblogs.com/traditional/p/11894550.html
