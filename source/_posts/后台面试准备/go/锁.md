---
title: golang Mutex
excerpt: 所在模块：golang
tags: [golang]
categories: 后端面试
banner_img: /img/壁纸.jpg
---

**我们先来看怎么实现一个最简单的互斥锁，在开始之前可以先想一想，如果是你，你会怎么设计呢？**

**你可能会想到，可以通过一个 flag 变量，标记当前的锁是否被某个 goroutine 持有。如果这个 flag 的值是 1，就代表锁已经被持有，那么其它竞争的 goroutine 只能等待；如果这个 flag 的值是 0，就可以通过 CAS（compare-and-swap，或者 compare-and-set）将这个 flag 设置为 1，标识锁被当前的这个 goroutine 持有了。**

**整个逻辑很简单，但事实上早期的 Mutex 就是这么设计的，不过在看源码之前我们需要先了解一下什么是 CAS，它非常重要。**

#### CAS 是什么

**假设有一个块内存，里面存储的值是 a，但是现在想将其变成 a + b，这个时候需要经历哪几步呢？**

- `将存储的值读取出来，得到 a`
- `将 a 和 b 进行加法运算，得到 a + b`
- `再将计算后的新值 a + b 写回到原来的内存中，也就是将原来的值 a 给更新掉`

**单线程的话是没有任何问题的，但如果是多个线程同时操作这块内存呢？显然可能会出问题。因此需要通过 CAS 解决这一点，首先它会将内存中原本的值备份一份，运算之后会比较此时内存的值和备份的值，如果一致才进行更新，如果不一致则什么也不做。比如一开始内存的值是 a，备份一份，然后计算完毕之后发现内存的值变成了 a1，前后不一致，说明其它线程已经将这块内存的值给修改了，那么此时就不会再更新了；如果一致，说明没有别的线程修改这个内存的数据，那么此时才会更新。**

> **所以 CAS 的名字很直观，就是先比较、然后再决定是否更新（设置），并且整体是原子性的。**

**CAS 是实现互斥锁和并发原语的基础，我们有必要掌握它。**







## sync.Mutex

这是sync包的互斥锁，加了之后不需要其他goroutine读取，只允许这个读取

加锁是原语操作

当goutine超过1ms因为锁请求不到资源的时候，会变成饥饿模式，下次允许优先获得锁。

下面是最简单的mutex实现方式

```
// CAS 操作，当时还没有抽象出 atomic 包
func cas(val *int32, old, new int32) bool
func semacquire(*int32)
func semrelease(*int32)

// 互斥锁的结构，包含两个字段
type Mutex struct {
    key int32  // 锁是否被持有的标识
    sema int32 // 信号量专用，用以阻塞和唤醒 goroutine
}

// 保证成功在 val 上增加 delta 的值
func xadd(val *int32, delta int32) (new int32) {
    for {
        v := *val
        if cas(val, v, v+delta) {
            return v + delta
        }
    }
    panic("unreached")
}

// 请求锁
func (m *Mutex) Lock() {
    if xadd(&m.key, 1) == 1 { // 标识加 1，如果等于 1，成功获取到锁
        return
    }
    semacquire(&m.sema) // 否则阻塞等待
}

// 释放锁
func (m *Mutex) Unlock() {
    if xadd(&m.key, -1) == 0 { // 将标识减去 1，如果等于 0，则没有其它等待者
        return
    }
    semrelease(&m.sema) // 唤醒其它阻塞的 goroutine
}

```







## Mutex 常有错误

### 1、lock和unlock没有成对出现

```
package main

import (
    "sync"
    "time"
)

func main() {
    var m sync.Mutex

    go func() {
        m.Lock()
    }()
    // 确保子协程内部的代码先执行，简单 sleep 一下
    time.Sleep(100)
    m.Lock()
}

```



**此时会引发 panic：fatal error: all goroutines are asleep - deadlock，因为子协程已经获取锁了，而主协程也在获取锁，所以主协程会阻塞在 m.Lock() 这一步。然后当子协程执行完毕之后，就只剩下主协程，而主协程如果想往下走，那么必须有子协程进行 Unlock。但是现在没有子协程了，所以主协程想往下走是不可能的，因此就死锁了。**

**如果是缺少 Lock，那么就会对一个未加锁的 Mutex 进行 Unlock，此时会引发 panic。**



#### Go runtime 是如何检测到死锁的

也很简单，Go 只是去检查整个程序(所有的 Goroutines)是否都已经停止了，如果是，那么就是发生了灾难，Deadlock；很显然，上面这个例子只有一个 Main Goroutine，而它将会永远被阻塞，因此，Go runtime 检测到，整个程序已经被阻塞停止了，因此抛出 Panic Deadlock 异常！

### 2、拷贝了一个mutex

**一般出现这种情况，都是在将 Mutex 作为函数参数传递的时候没有传递指针，而是直接把值本身传递了。而我们说 Go 只有值传递，不管传值还是传指针，都是拷贝一份。如果直接传 Mutex 本身，那么会拷贝一份，两者不是同一个 Mutex 了。**

### 





## sync.RWMutex



### 实现原理

**WMutex 是很常见的并发原语，很多编程语言的库都提供了类似的并发类型。RWMutex 一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现，Go 的 RWMutex 就是基于 Mutex 实现的。**

**而基于对读和写操作的优先级，读写锁的设计和实现也分成三类。**

**Read-preferring：读优先，当读锁和写锁都可以获取时优先获取读锁。该设计可以提供很高的并发性，但是在竞争激烈的情况下可能会导致写饥饿。这是因为如果有大量的读，这种设计会导致只有在所有的读锁都释放了，写锁才可能被获取到。**

**Write-preferring：写优先，当读锁和写锁都可以获取时优先获取写锁。当然，如果有一些 goroutine 已经获取了读锁，那么获取写锁的 goroutine 也必须要等待已经存在的读锁都被释放之后才可以获取。所以写优先级设计中的优先权是针对新来的读请求而言的，这种设计主要避免了写锁的饥饿问题。**

**不指定优先级：这种设计比较简单，不区分读锁和写锁的优先级，某些场景下这种不指定优先级的设计反而更有效。因为第一类优先级会导致写饥饿，第二类优先级可能会导致读饥饿，这种不指定优先级的访问不再区分读写，大家都是同一个优先级，有时反而解决了饥饿的问题。**

**Go 标准库 sync 中的 RWMutex 设计是 Write-preferring 方案，下面来分看一下底层结构。**

**RWMutex 包含一个 Mutex，以及四个辅助字段 writerSem、readerSem、readerCount 和 readerWait：**

```
type RWMutex struct {
    // 获取写锁的 goroutine 称之为 writer，获取读锁的 goroutine 称之为 reader
    w           Mutex  // 互斥锁，通过互斥锁实现写锁的互斥
    writerSem   uint32 // writer 信号量
    readerSem   uint32 // reader 信号量
    readerCount int32  // reader 的数量
    readWait    int32  // writer 想要成功获取到写锁需要释放的读锁的数量，因为写锁要等到已存在的读锁释放之后才能获取
                       // 假设 writer 在获取写锁时，发现有 3 个 reader 获取到了读锁，那么 readWait 就是 3
}

const rwmutexMaxReaders = 1 << 30  // reader 的最大数量

```



### 总结

**在开发过程中，一开始考虑共享资源并发访问问题的时候，我们就会想到互斥锁 Mutex。因为刚开始的时候，我们还并不太了解并发的情况，所以就会使用最简单的同步原语来解决问题。等到系统成熟，真正到了需要性能优化的时候，我们就能静下心来分析并发场景的可能性，这个时候我们就要考虑是否可以将 Mutex 修改为 RWMutex，来压榨系统的性能。**

**当然，如果一开始你的场景就非常明确了，比如我就要实现一个线程安全的 map，那么一开始你就可以考虑使用读写锁。正如之前说的，如果你能意识到你要解决的问题是使用 Mutex 时的效率问题、并且读多写少，那么你直接就可以毫不犹豫地选择 RWMutex，不用考虑其它选择。但是在使用 RWMutex 时，最需要注意的一点就是尽量避免重入，重入带来的死锁非常隐蔽，而且难以诊断。**







## Context

### cancel实现原理

**以上四个方法中常用的就是 Done 了，如果 Context 取消的时候，我们就可以得到一个关闭的 chan，关闭的 chan 是可以读取的；所以只要可以读取的时候，就意味着收到 Context 取消的信号了，那么 Context 监视的所有 goroutine 都会接收到信号。以下是这个方法的经典用法：**

```
package main
 
import (
    "context"
    "fmt"
    "time"
)
 
func goroutine1(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            //等待退出的信号
            fmt.Println("收到取消通知，我要退出啦，使命已经结束")
            return
        default:
            //什么也不做，为了select不阻塞
        }
        
        // todo: 努力工作
        func() {
            time.Sleep(time.Second * 3)
            fmt.Println("bob，别傻愣着")
        }()
    }
}
 
func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go goroutine1(ctx)
    time.Sleep(time.Second * 9)
    fmt.Println("结束啦~~~~，通知goroutine退出")
    cancel()
    // 可能要忙其他的事情
    for {}
    /*
    	bob，别傻愣着
    	bob，别傻愣着
    	结束啦~~~~，通知goroutine退出
    	bob，别傻愣着
    	收到取消通知，我要退出啦，使命已经结束
    */
}

```



参考文档：https://www.cnblogs.com/traditional/p/11894550.html
