---
title: 数据库事务和隔离级别
excerpt: 所在模块：数据库
tags: [数据库]
categories: 后端面试
banner_img: /img/壁纸.jpg
---

**数据库事务的定义：**一个或多个数据库操作

### 事务的四大特性

**A atom 原子性**  事务执行是原子，一个事务中所有操作，要么全部完成，要么全部不完成，不会结束在中间的环节。

**C Consistency 一致性**	在事务开始和事务开始后，数据库的完整性约束没被破坏完整性约束：主键的约束没有变，数据库中不能输入不符合约束的值。

**I	isolation 隔离性**	多个并发事务相互独立互不影响，多个用户的并发事务访问同一个数据库，一个用户的事务应该被隔离起来不被干扰。

**D durability 持久性**	事务处理后对数据的修改是永久的

### Mysql 事务是如何实现的
**原子性：**通过undo log实现的。每条数据变更都伴随一条undo log日志的生成，当系统发生错误或执行回滚根据undo log做逆向操作。
**持久性：**通过redo log实现的。redo log记录了数据的修改日志。数据持久化到磁盘，先是储存到缓冲池里，然后缓冲池中的数据定期同步到磁盘中，如果系统宕机，可能会丢失数据，系统重启后会读取redo log恢复数据。
**隔离性：**mysql数据库通过MVCC + next-key机制实现了隔离性
**一致性：**以上3大特性，保障了事务的一致性



#### mysql四种隔离级别

1、读未提交

如果一个事物已经开始写数据，则另外一个事物则不允许同时进行写操作，但是允许读数据，会出现脏读。

2、读已提交

未提交的写事务禁止其他事物访问，可避免脏读

3、可重复读(数据库默认隔离级别)

sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。

​	可避免脏读，不可重复读

4、串行化

​	可避免脏读、不可重复读和幻读

| 隔离界别                   | 脏读     | 不可重复读 | 幻读     |
| -------------------------- | -------- | ---------- | -------- |
| READ UNCOMMITTED：读未提交 | 可能发生 | 可能发生   | 可能发生 |
| READ COMMITTED：读已提交   | 解决     | 可能发生   | 可能发生 |
| REPEATABLE READ：可重复读  | 解决     | 解决       | 可能发生 |
| SERIALIZABLE：可串行化     | 解决     | 解决       | 解决     |

#### 不考虑隔离级别会发生的事情

1、脏读

一个事务在处理数据时读到别的未提交事务的数据，然后这个数据回滚了

2、不可重复读

数据库中的某个数据，在一次事务中多次查询得到的数据不一致，因为另一个事务修改并且提交了

3、幻读

在一次事务里面，多次查询之后，查询的结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做 幻行但是不可重复读是一个数据，幻读是一批数据整体，解决不可重复读的办法**是行锁**，解决幻读的办法是**锁表**。

是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。



### 数据库三大范式

- **第一范式**

  一列不能有多个值

- **第二范式**，属性完全依赖于主键 [ 消除部分子函数依赖 ]

  **非主属性完全依赖于主关键字**

  (学号, 课程名称) → (姓名, 年龄, 成绩, 学分)

  这个数据库表不满足第二范式，因为存在如下决定关系： 

  (课程名称) → (学分)

  (学号) → (姓名, 年龄)

  即存在组合关键字中的字段决定非关键字的情况。

- **第三范式** 属性不依赖于其它非主属性 [ **消除传递依赖** ]

​	(学号) → (所在学院) → (学院地点, 学院电话) 这样是不符合的，得分成两个表

​	**学生：(学号, 姓名, 年龄, 所在学院)；**

​	**学院：(学院, 地点, 电话)；**



