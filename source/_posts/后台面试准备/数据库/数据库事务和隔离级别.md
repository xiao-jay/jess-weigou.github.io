---
title: 数据库事务和隔离级别
excerpt: 所在模块：数据库
tags: [数据库]
categories: 后端面试
banner_img: /img/壁纸.jpg
---

**数据库事务的定义：**一个或多个数据库操作

### 事务的四大特性

**A atom 原子性**  事务执行是原子，一个事务中所有操作，要么全部完成，要么全部不完成，不会结束在中间的环节。

**C Consistency 一致性**	在事务开始和事务开始后，数据库的完整性约束没被破坏完整性约束：主键的约束没有变，数据库中不能输入不符合约束的值。

**I	isolation 隔离性**	多个并发事务相互独立互不影响，多个用户的并发事务访问同一个数据库，一个用户的事务应该被隔离起来不被干扰。

**D durability 持久性**	事务处理后对数据的修改是永久的

### Mysql 事务是如何实现的
**原子性：**通过undo log实现的。每条数据变更都伴随一条undo log日志的生成，当系统发生错误或执行回滚根据undo log做逆向操作
**持久性：**通过redo log实现的。redo log记录了数据的修改日志。数据持久化到磁盘，先是储存到缓冲池里，然后缓冲池中的数据定期同步到磁盘中，如果系统宕机，可能会丢失数据，系统重启后会读取redo log恢复数据
**隔离性：**mysql数据库通过MVCC + next-key机制实现了隔离性
**一致性：**以上3大特性，保障了事务的一致性

### **redo log与binlog的区别**

我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：

（1）作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。

（2）层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。

（3）内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。

（4）写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：

前面曾提到：当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。
除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。

#### mysql四种隔离级别

1、读未提交

如果一个事物已经开始写数据，则另外一个事物则不允许同时进行写操作，但是允许读数据，会出现脏读。

2、读已提交

未提交的写事务禁止其他事物访问，可避免脏读

3、可重复读(数据库默认隔离级别)

sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。

​	可避免脏读，不可重复读

4、串行化

​	可避免脏读、不可重复读和幻读

| 隔离界别                   | 脏读     | 不可重复读 | 幻读     |
| -------------------------- | -------- | ---------- | -------- |
| READ UNCOMMITTED：读未提交 | 可能发生 | 可能发生   | 可能发生 |
| READ COMMITTED：读已提交   | 解决     | 可能发生   | 可能发生 |
| REPEATABLE READ：可重复读  | 解决     | 解决       | 可能发生 |
| SERIALIZABLE：可串行化     | 解决     | 解决       | 解决     |

#### 不考虑隔离级别会发生的事情

1、脏读

一个事务在处理数据时读到别的未提交事务的数据，然后这个数据回滚了

2、不可重复读

数据库中的某个数据，在一次事务中多次查询得到的数据不一致，因为另一个事务修改并且提交了

3、幻读

在一次事务里面，多次查询之后，查询的结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做 幻行但是不可重复读是一个数据，幻读是一批数据整体，解决不可重复读的办法**是行锁**，解决幻读的办法是**锁表**。



### 数据库三大范式

- **第一范式**

  一列不能有多个值

- **第二范式**，属性完全依赖于主键 [ 消除部分子函数依赖 ]

  **非主属性完全依赖于主关键字**

  (学号, 课程名称) → (姓名, 年龄, 成绩, 学分)

  这个数据库表不满足第二范式，因为存在如下决定关系： 

  (课程名称) → (学分)

  (学号) → (姓名, 年龄)

  即存在组合关键字中的字段决定非关键字的情况。

- **第三范式** 属性不依赖于其它非主属性 [ **消除传递依赖** ]

​	(学号) → (所在学院) → (学院地点, 学院电话) 这样是不符合的，得分成两个表

​	**学生：(学号, 姓名, 年龄, 所在学院)；**

​	**学院：(学院, 地点, 电话)；**



