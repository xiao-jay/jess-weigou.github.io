---
title: mysql索引
---

索引底层数据结构是B+数

单例索引：一个索引只能包含一个列，一个表可以有多个单例索引

组合索引：一个组合索引包含两个或以上的列，原理简单，在a，b，c字段上创建索引，索引记录会首先安装A排序，A一样照B排序，B一样照C排序。



![](D:\Users\David\Desktop\mystroy\themes\fluid\source\img\联合索引.png)

聚簇索引：数据存储和索引放一块，b+树叶子节点存放的是数据表的行记录，可以理解成将数据存储和索引放到了一块,这是主键索引，因为InnoDB数据文件本身要按主键聚集，所以InnoDB要求必须有主键，如果没有就自动生成一个隐含的字段作为主键

![](D:\Users\David\Desktop\mystroy\themes\fluid\source\img\innode主键索引.png)

为什么mysql表要有一个自增的id主键，因为mysql索引用b+数，得是一个递增的，因为如果不递增增加数据的话得裂表影响效率，而且不建议使用太长的字段作为主键。

非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。

聚簇索引优点：

- 数据访问更快，因为聚簇索引将数据放在同一个B+树中，所以比非聚簇索引快
- 聚簇索引对于主键的排序查找和范围查找速度非常快

缺点：

-  插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将出现页分裂，严重影响性能，我们一般会定义一个自增的ID作为主键
- 更新主键的代价很高
- 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

### 1、一级索引

索引和数据存储在一起，都存储在同一个B+tree中的叶子节点。一般主键索引都是一级索引。

### 2、二级索引

二级索引树的叶子节点存储的是主键而不是数据。也就是说，在找到索引后，得到对应的主键，再回到一级索引中找主键对应的数据记录。

### 3、一级索引和二级索引的关系：回表

一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引，这叫做“回表”。

### 4、索引建立原则
（1）最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

（2）=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，
mysql的查询优化器会帮你优化成索引可以识别的形式

（3）尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，
比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，
那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，
一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录

（4）索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，
原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，
显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);

（5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可