---
title: mysql索引
excerpt: 所在模块：数据库
tags: [数据库]
categories: 后端面试
banner_img: /img/壁纸.jpg
---

对于各种树的介绍和异同可以看这篇文章[B树、B+树、红黑树、AVL树](http://www.mystorys.xyz/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/)

索引底层数据结构是B+数

**单例索引：**一个索引只能包含一个列，一个表可以有多个单例索引

**组合索引：**一个组合索引包含两个或以上的列，原理简单，在a，b，c字段上创建索引，索引记录会首先安装A排序，A一样照B排序，B一样照C排序。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0e0abqd14j203205xq30.jpg)

**聚簇索引：**数据存储和索引放一块，b+树叶子节点存放的是数据表的行记录，可以理解成将数据存储和索引放到了一块,这是主键索引，因为InnoDB数据文件本身要按主键聚集，所以InnoDB要求必须有主键，如果没有就自动生成一个隐含的字段作为主键

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0e0bs4mxzj20dw060aaa.jpg)

为什么mysql表要有一个自增的id主键，因为mysql索引用b+数，得是一个递增的，因为如果不递增增加数据的话得裂表影响效率，而且不建议使用太长的字段作为主键。

**非聚簇索引：**数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。

聚簇索引优点：

- 数据访问更快，因为聚簇索引将数据放在同一个B+树中，所以比非聚簇索引快
- 聚簇索引对于主键的排序查找和范围查找速度非常快

缺点：

-  插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将出现页分裂，严重影响性能，我们一般会定义一个自增的ID作为主键
- 更新主键的代价很高
- 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

#### 1、一级索引

索引和数据存储在一起，都存储在同一个B+tree中的叶子节点。一般主键索引都是一级索引。

#### 2、二级索引

二级索引树的叶子节点存储的是主键而不是数据。也就是说，在找到索引后，得到对应的主键，再回到一级索引中找主键对应的数据记录。

#### 3、一级索引和二级索引的关系：回表

一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引，这叫做“回表”。

#### 4、索引建立原则

（1）最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的。
如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

（2）=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，
mysql的查询优化器会帮你优化成索引可以识别的形式

（3）尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，
比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，
那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，
一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录

（4）索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，
原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，
显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);

（5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可

#### 5、可能索引失效的原因

和索引建立原则类似

- 范围查询，>,<,!=,or会导致索引失效,like '%liu' 百分号在前也会导致索引失效
  - 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，把c>3放到最后。

- 使用select * 类似的语句可能会导致不用索引，优化器可能会选择TABLE ACCESS FULL
- 单键值的b树索引列上存在null值，导致COUNT(*)不能走索引
- 索引列上有函数运算，导致不走索引

- 建立组合索引，但查询谓词并未使用组合索引的第一列，此处有一个INDEX SKIP SCAN概念