---
title: 三次握手，四次挥手
---

#### 三次握手

大值理解：tcp为了确认传输数据的安全，第一次发送特殊tcp报文段给客户，客户第二次回复特殊的tcp报文段给服务器，第三次服务器发送要发送的数据给客户。

![](https://img2018.cnblogs.com/blog/1344250/201904/1344250-20190402114137828-2119548758.png)

- 第一次客户端发送SYN=1和初始化的序列号seq x给服务器请求连接连接（ SYN：同步标志）
- 第二次服务器回复ACK=1，ack=x+1,seq=y是发送数据的第一个字符的数据编号，SYN为1 代表收到消息并且也请求连接
- 第三次用户回复ACK=1，ack为y+1，sep为x+1的tcp报文，连接完毕可以传输数据

ACK代表确认（acknowledge character）

序列号seq就是这个报文段中的第一个字节的数据编号

#### 2、四次挥手

![](https://img2018.cnblogs.com/blog/1344250/201904/1344250-20190402114059390-716421818.png)

- 用户和服务器其中两个都可以终止连接，假设用户想取消连接了，先给服务器发送一个FIN置为1,seq为u的报文

- 服务器收到之后，会立马回复一个ACK为1，ack为u+1，seq为v的报文，ack会自动回复上一个报文加一的seq数据，表示收到。

- 隔了一个close_wait时间回复一个FIN置为1，ACK置为1的报文，seq为w，ack为u+1表示同意，为什么要等待一段时间，是因为要询问上层的软件是否同意关闭，服务器不发FIN代表自己可以收到消息但是客户不会发消息了

- 最后用户回复ACK为1，seq为u+1,ack为w+1的报文，结束连接。

  

#### 问题

1、 为什么三次握手和四次挥手？，而不是两次握手

三次握手是得把ACK和SYN都发送给对方，三次握手才能保证双方都接收到消息，第一次是喂，用户：我要连接，服务器：好，我收到了，用户：我收到你的收到了，如果是两次握手那服务器不知道客户收到没有。四次握手是没必要，已经有很大概率链接连接成功了，而且四次握手需要更多的网络资源。

四次挥手是ack和fin分开发送，原因就是要确认上层应用同意断开，不然会发生数据丢失

2、为什么客户端最后还要等待2MSL？

确实服务器收到了ACK=1，如果没收到可以再发，通知上层应用连接要关闭了。

3、**ISN代表什么？意义何在？**

发送方的字节数据编号的原点，isn代表双方连接的钥匙，钥匙要对上孔

4、**ISN是固定不变的吗？**

动态随机

5、**ISN为何要动态随机？**

防止被第三方猜到，从而被第三方仿造的RST报文的reset。

6、**三次握手的第一次可以携带数据吗？为何？**对方难道不可以将数据缓存下来，等握手成功再提交给应用程序？

**不可以，三次握手还没有完成。**，因为如果带大量1k字节数据的话服务器要开辟大量缓存来处理，容易使服务器拒绝访问，这是洪泛攻击

7、**第三次可以携带数据吗？为何？**

可以，能够发送第三次代表第二次报文已经接收到了，伪装的ip接收不到第二次报文，所以第三次发送的时候是安全的。

**8、如果输入的端口不存在会怎么办**

握手不能进行，会出现超时未响应的错误。

**9、为什么断开连接却需要四次呢？**

1、确保数据能够完整传输。
2、当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。